95d2d4424deaebe03857e03824cde5bd
'use strict';

Object.defineProperty(exports, '__esModule', {
  value: true
});
var jsxRuntime = require('react/jsx-runtime');
var React = require('react');
var motionUtils = require('motion-utils');
var motionDom = require('motion-dom');
function _interopNamespaceDefault(e) {
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () {
            return e[k];
          }
        });
      }
    });
  }
  n.default = e;
  return Object.freeze(n);
}
var React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
const LayoutGroupContext = React.createContext({});
function isAnimationControls(v) {
  return v !== null && typeof v === "object" && typeof v.start === "function";
}
const isKeyframesTarget = v => {
  return Array.isArray(v);
};
function shallowCompare(next, prev) {
  if (!Array.isArray(prev)) return false;
  const prevLength = prev.length;
  if (prevLength !== next.length) return false;
  for (let i = 0; i < prevLength; i++) {
    if (prev[i] !== next[i]) return false;
  }
  return true;
}

/**
 * Decides if the supplied variable is variant label
 */
function isVariantLabel(v) {
  return typeof v === "string" || Array.isArray(v);
}
function getValueState(visualElement) {
  const state = [{}, {}];
  visualElement === null || visualElement === void 0 ? void 0 : visualElement.values.forEach((value, key) => {
    state[0][key] = value.get();
    state[1][key] = value.getVelocity();
  });
  return state;
}
function resolveVariantFromProps(props, definition, custom, visualElement) {
  /**
   * If the variant definition is a function, resolve.
   */
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
  }
  /**
   * If the variant definition is a variant label, or
   * the function returned a variant label, resolve.
   */
  if (typeof definition === "string") {
    definition = props.variants && props.variants[definition];
  }
  /**
   * At this point we've resolved both functions and variant labels,
   * but the resolved variant label might itself have been a function.
   * If so, resolve. This can only have returned a valid target object.
   */
  if (typeof definition === "function") {
    const [current, velocity] = getValueState(visualElement);
    definition = definition(custom !== undefined ? custom : props.custom, current, velocity);
  }
  return definition;
}
function resolveVariant(visualElement, definition, custom) {
  const props = visualElement.getProps();
  return resolveVariantFromProps(props, definition, custom !== undefined ? custom : props.custom, visualElement);
}
const variantPriorityOrder = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"];
const variantProps = ["initial", ...variantPriorityOrder];
const MotionGlobalConfig = {
  skipAnimations: false,
  useManualTiming: false
};
function createRenderStep(runNextFrame) {
  /**
   * We create and reuse two queues, one to queue jobs for the current frame
   * and one for the next. We reuse to avoid triggering GC after x frames.
   */
  let thisFrame = new Set();
  let nextFrame = new Set();
  /**
   * Track whether we're currently processing jobs in this step. This way
   * we can decide whether to schedule new jobs for this frame or next.
   */
  let isProcessing = false;
  let flushNextFrame = false;
  /**
   * A set of processes which were marked keepAlive when scheduled.
   */
  const toKeepAlive = new WeakSet();
  let latestFrameData = {
    delta: 0.0,
    timestamp: 0.0,
    isProcessing: false
  };
  function triggerCallback(callback) {
    if (toKeepAlive.has(callback)) {
      step.schedule(callback);
      runNextFrame();
    }
    callback(latestFrameData);
  }
  const step = {
    /**
     * Schedule a process to run on the next frame.
     */
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing;
      const queue = addToCurrentFrame ? thisFrame : nextFrame;
      if (keepAlive) toKeepAlive.add(callback);
      if (!queue.has(callback)) queue.add(callback);
      return callback;
    },
    /**
     * Cancel the provided callback from running on the next frame.
     */
    cancel: callback => {
      nextFrame.delete(callback);
      toKeepAlive.delete(callback);
    },
    /**
     * Execute all schedule callbacks.
     */
    process: frameData => {
      latestFrameData = frameData;
      /**
       * If we're already processing we've probably been triggered by a flushSync
       * inside an existing process. Instead of executing, mark flushNextFrame
       * as true and ensure we flush the following frame at the end of this one.
       */
      if (isProcessing) {
        flushNextFrame = true;
        return;
      }
      isProcessing = true;
      [thisFrame, nextFrame] = [nextFrame, thisFrame];
      // Execute this frame
      thisFrame.forEach(triggerCallback);
      // Clear the frame so no callbacks remain. This is to avoid
      // memory leaks should this render step not run for a while.
      thisFrame.clear();
      isProcessing = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step.process(frameData);
      }
    }
  };
  return step;
}
const stepsOrder = ["read",
// Read
"resolveKeyframes",
// Write/Read/Write/Read
"update",
// Compute
"preRender",
// Compute
"render",
// Write
"postRender" // Compute
];
const maxElapsed$1 = 40;
function createRenderBatcher(scheduleNextBatch, allowKeepAlive) {
  let runNextFrame = false;
  let useDefaultElapsed = true;
  const state = {
    delta: 0.0,
    timestamp: 0.0,
    isProcessing: false
  };
  const flagRunNextFrame = () => runNextFrame = true;
  const steps = stepsOrder.reduce((acc, key) => {
    acc[key] = createRenderStep(flagRunNextFrame);
    return acc;
  }, {});
  const {
    read,
    resolveKeyframes,
    update,
    preRender,
    render,
    postRender
  } = steps;
  const processBatch = () => {
    const timestamp = MotionGlobalConfig.useManualTiming ? state.timestamp : performance.now();
    runNextFrame = false;
    state.delta = useDefaultElapsed ? 1000 / 60 : Math.max(Math.min(timestamp - state.timestamp, maxElapsed$1), 1);
    state.timestamp = timestamp;
    state.isProcessing = true;
    // Unrolled render loop for better per-frame performance
    read.process(state);
    resolveKeyframes.process(state);
    update.process(state);
    preRender.process(state);
    render.process(state);
    postRender.process(state);
    state.isProcessing = false;
    if (runNextFrame && allowKeepAlive) {
      useDefaultElapsed = false;
      scheduleNextBatch(processBatch);
    }
  };
  const wake = () => {
    runNextFrame = true;
    useDefaultElapsed = true;
    if (!state.isProcessing) {
      scheduleNextBatch(processBatch);
    }
  };
  const schedule = stepsOrder.reduce((acc, key) => {
    const step = steps[key];
    acc[key] = (process, keepAlive = false, immediate = false) => {
      if (!runNextFrame) wake();
      return step.schedule(process, keepAlive, immediate);
    };
    return acc;
  }, {});
  const cancel = process => {
    for (let i = 0; i < stepsOrder.length; i++) {
      steps[stepsOrder[i]].cancel(process);
    }
  };
  return {
    schedule,
    cancel,
    state,
    steps
  };
}
const {
  schedule: frame,
  cancel: cancelFrame,
  state: frameData,
  steps: frameSteps
} = createRenderBatcher(typeof requestAnimationFrame !== "undefined" ? requestAnimationFrame : motionUtils.noop, true);

/**
 * Generate a list of every possible transform key.
 */
const transformPropOrder = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"];
/**
 * A quick lookup for transform props.
 */
const transformProps = new Set(transformPropOrder);
const positionalKeys = new Set(["width", "height", "top", "left", "right", "bottom", ...transformPropOrder]);
const isCustomValue = v => {
  return Boolean(v && typeof v === "object" && v.mix && v.toValue);
};
const resolveFinalValueInKeyframes = v => {
  // TODO maybe throw if v.length - 1 is placeholder token?
  return isKeyframesTarget(v) ? v[v.length - 1] || 0 : v;
};
let now;
function clearTime() {
  now = undefined;
}
/**
 * An eventloop-synchronous alternative to performance.now().
 *
 * Ensures that time measurements remain consistent within a synchronous context.
 * Usually calling performance.now() twice within the same synchronous context
 * will return different values which isn't useful for animations when we're usually
 * trying to sync animations to the same frame.
 */
const time = {
  now: () => {
    if (now === undefined) {
      time.set(frameData.isProcessing || MotionGlobalConfig.useManualTiming ? frameData.timestamp : performance.now());
    }
    return now;
  },
  set: newTime => {
    now = newTime;
    queueMicrotask(clearTime);
  }
};
function addUniqueItem(arr, item) {
  if (arr.indexOf(item) === -1) arr.push(item);
}
function removeItem(arr, item) {
  const index = arr.indexOf(item);
  if (index > -1) arr.splice(index, 1);
}
// Adapted from array-move
function moveItem([...arr], fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    const endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    const [item] = arr.splice(fromIndex, 1);
    arr.splice(endIndex, 0, item);
  }
  return arr;
}
class SubscriptionManager {
  constructor() {
    this.subscriptions = [];
  }
  add(handler) {
    addUniqueItem(this.subscriptions, handler);
    return () => removeItem(this.subscriptions, handler);
  }
  notify(a, b, c) {
    const numSubscriptions = this.subscriptions.length;
    if (!numSubscriptions) return;
    if (numSubscriptions === 1) {
      /**
       * If there's only a single handler we can just call it without invoking a loop.
       */
      this.subscriptions[0](a, b, c);
    } else {
      for (let i = 0; i < numSubscriptions; i++) {
        /**
         * Check whether the handler exists before firing as it's possible
         * the subscriptions were modified during this loop running.
         */
        const handler = this.subscriptions[i];
        handler && handler(a, b, c);
      }
    }
  }
  getSize() {
    return this.subscriptions.length;
  }
  clear() {
    this.subscriptions.length = 0;
  }
}

/*
  Convert velocity into velocity per second

  @param [number]: Unit per frame
  @param [number]: Frame duration in ms
*/
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1000 / frameDuration) : 0;
}
const warned = new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message)) return;
  console.warn(message);
  if (element) console.warn(element);
  warned.add(message);
}

/**
 * Maximum time between the value of two frames, beyond which we
 * assume the velocity has since been 0.
 */
const MAX_VELOCITY_DELTA = 30;
const isFloat = value => {
  return !isNaN(parseFloat(value));
};
const collectMotionValues = {
  current: undefined
};
/**
 * `MotionValue` is used to track the state and velocity of motion values.
 *
 * @public
 */
class MotionValue {
  /**
   * @param init - The initiating value
   * @param config - Optional configuration options
   *
   * -  `transformer`: A function to transform incoming values with.
   *
   * @internal
   */
  constructor(init, options = {}) {
    /**
     * This will be replaced by the build step with the latest version number.
     * When MotionValues are provided to motion components, warn if versions are mixed.
     */
    this.version = "11.18.2";
    /**
     * Tracks whether this value can output a velocity. Currently this is only true
     * if the value is numerical, but we might be able to widen the scope here and support
     * other value types.
     *
     * @internal
     */
    this.canTrackVelocity = null;
    /**
     * An object containing a SubscriptionManager for each active event.
     */
    this.events = {};
    this.updateAndNotify = (v, render = true) => {
      const currentTime = time.now();
      /**
       * If we're updating the value during another frame or eventloop
       * than the previous frame, then the we set the previous frame value
       * to current.
       */
      if (this.updatedAt !== currentTime) {
        this.setPrevFrameValue();
      }
      this.prev = this.current;
      this.setCurrent(v);
      // Update update subscribers
      if (this.current !== this.prev && this.events.change) {
        this.events.change.notify(this.current);
      }
      // Update render subscribers
      if (render && this.events.renderRequest) {
        this.events.renderRequest.notify(this.current);
      }
    };
    this.hasAnimated = false;
    this.setCurrent(init);
    this.owner = options.owner;
  }
  setCurrent(current) {
    this.current = current;
    this.updatedAt = time.now();
    if (this.canTrackVelocity === null && current !== undefined) {
      this.canTrackVelocity = isFloat(this.current);
    }
  }
  setPrevFrameValue(prevFrameValue = this.current) {
    this.prevFrameValue = prevFrameValue;
    this.prevUpdatedAt = this.updatedAt;
  }
  /**
   * Adds a function that will be notified when the `MotionValue` is updated.
   *
   * It returns a function that, when called, will cancel the subscription.
   *
   * When calling `onChange` inside a React component, it should be wrapped with the
   * `useEffect` hook. As it returns an unsubscribe function, this should be returned
   * from the `useEffect` function to ensure you don't add duplicate subscribers..
   *
   * ```jsx
   * export const MyComponent = () => {
   *   const x = useMotionValue(0)
   *   const y = useMotionValue(0)
   *   const opacity = useMotionValue(1)
   *
   *   useEffect(() => {
   *     function updateOpacity() {
   *       const maxXY = Math.max(x.get(), y.get())
   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])
   *       opacity.set(newOpacity)
   *     }
   *
   *     const unsubscribeX = x.on("change", updateOpacity)
   *     const unsubscribeY = y.on("change", updateOpacity)
   *
   *     return () => {
   *       unsubscribeX()
   *       unsubscribeY()
   *     }
   *   }, [])
   *
   *   return <motion.div style={{ x }} />
   * }
   * ```
   *
   * @param subscriber - A function that receives the latest value.
   * @returns A function that, when called, will cancel this subscription.
   *
   * @deprecated
   */
  onChange(subscription) {
    if (process.env.NODE_ENV !== "production") {
      warnOnce(false, `value.onChange(callback) is deprecated. Switch to value.on("change", callback).`);
    }
    return this.on("change", subscription);
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    const unsubscribe = this.events[eventName].add(callback);
    if (eventName === "change") {
      return () => {
        unsubscribe();
        /**
         * If we have no more change listeners by the start
         * of the next frame, stop active animations.
         */
        frame.read(() => {
          if (!this.events.change.getSize()) {
            this.stop();
          }
        });
      };
    }
    return unsubscribe;
  }
  clearListeners() {
    for (const eventManagers in this.events) {
      this.events[eventManagers].clear();
    }
  }
  /**
   * Attaches a passive effect to the `MotionValue`.
   *
   * @internal
   */
  attach(passiveEffect, stopPassiveEffect) {
    this.passiveEffect = passiveEffect;
    this.stopPassiveEffect = stopPassiveEffect;
  }
  /**
   * Sets the state of the `MotionValue`.
   *
   * @remarks
   *
   * ```jsx
   * const x = useMotionValue(0)
   * x.set(10)
   * ```
   *
   * @param latest - Latest value to set.
   * @param render - Whether to notify render subscribers. Defaults to `true`
   *
   * @public
   */
  set(v, render = true) {
    if (!render || !this.passiveEffect) {
      this.updateAndNotify(v, render);
    } else {
      this.passiveEffect(v, this.updateAndNotify);
    }
  }
  setWithVelocity(prev, current, delta) {
    this.set(current);
    this.prev = undefined;
    this.prevFrameValue = prev;
    this.prevUpdatedAt = this.updatedAt - delta;
  }
  /**
   * Set the state of the `MotionValue`, stopping any active animations,
   * effects, and resets velocity to `0`.
   */
  jump(v, endAnimation = true) {
    this.updateAndNotify(v);
    this.prev = v;
    this.prevUpdatedAt = this.prevFrameValue = undefined;
    endAnimation && this.stop();
    if (this.stopPassiveEffect) this.stopPassiveEffect();
  }
  /**
   * Returns the latest state of `MotionValue`
   *
   * @returns - The latest state of `MotionValue`
   *
   * @public
   */
  get() {
    if (collectMotionValues.current) {
      collectMotionValues.current.push(this);
    }
    return this.current;
  }
  /**
   * @public
   */
  getPrevious() {
    return this.prev;
  }
  /**
   * Returns the latest velocity of `MotionValue`
   *
   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.
   *
   * @public
   */
  getVelocity() {
    const currentTime = time.now();
    if (!this.canTrackVelocity || this.prevFrameValue === undefined || currentTime - this.updatedAt > MAX_VELOCITY_DELTA) {
      return 0;
    }
    const delta = Math.min(this.updatedAt - this.prevUpdatedAt, MAX_VELOCITY_DELTA);
    // Casts because of parseFloat's poor typing
    return velocityPerSecond(parseFloat(this.current) - parseFloat(this.prevFrameValue), delta);
  }
  /**
   * Registers a new animation to control this `MotionValue`. Only one
   * animation can drive a `MotionValue` at one time.
   *
   * ```jsx
   * value.start()
   * ```
   *
   * @param animation - A function that starts the provided animation
   *
   * @internal
   */
  start(startAnimation) {
    this.stop();
    return new Promise(resolve => {
      this.hasAnimated = true;
      this.animation = startAnimation(resolve);
      if (this.events.animationStart) {
        this.events.animationStart.notify();
      }
    }).then(() => {
      if (this.events.animationComplete) {
        this.events.animationComplete.notify();
      }
      this.clearAnimation();
    });
  }
  /**
   * Stop the currently active animation.
   *
   * @public
   */
  stop() {
    if (this.animation) {
      this.animation.stop();
      if (this.events.animationCancel) {
        this.events.animationCancel.notify();
      }
    }
    this.clearAnimation();
  }
  /**
   * Returns `true` if this value is currently animating.
   *
   * @public
   */
  isAnimating() {
    return !!this.animation;
  }
  clearAnimation() {
    delete this.animation;
  }
  /**
   * Destroy and clean up subscribers to this `MotionValue`.
   *
   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically
   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually
   * created a `MotionValue` via the `motionValue` function.
   *
   * @public
   */
  destroy() {
    this.clearListeners();
    this.stop();
    if (this.stopPassiveEffect) {
      this.stopPassiveEffect();
    }
  }
}
function motionValue(init, options) {
  return new MotionValue(init, options);
}

/**
 * Set VisualElement's MotionValue, creating a new MotionValue for it if
 * it doesn't exist.
 */
function setMotionValue(visualElement, key, value) {
  if (visualElement.hasValue(key)) {
    visualElement.getValue(key).set(value);
  } else {
    visualElement.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement, definition) {
  const resolved = resolveVariant(visualElement, definition);
  let {
    transitionEnd = {},
    transition = {},
    ...target
  } = resolved || {};
  target = {
    ...target,
    ...transitionEnd
  };
  for (const key in target) {
    const value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement, key, value);
  }
}
const isMotionValue = value => Boolean(value && value.getVelocity);
function isWillChangeMotionValue(value) {
  return Boolean(isMotionValue(value) && value.add);
}
function addValueToWillChange(visualElement, key) {
  const willChange = visualElement.getValue("willChange");
  /**
   * It could be that a user has set willChange to a regular MotionValue,
   * in which case we can't add the value to it.
   */
  if (isWillChangeMotionValue(willChange)) {
    return willChange.add(key);
  }
}

/**
 * Convert camelCase to dash-case properties.
 */
const camelToDash = str => str.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase();
const optimizedAppearDataId = "framerAppearId";
const optimizedAppearDataAttribute = "data-" + camelToDash(optimizedAppearDataId);
function getOptimisedAppearId(visualElement) {
  return visualElement.props[optimizedAppearDataAttribute];
}
const instantAnimationState = {
  current: false
};

/*
  Bezier function generator
  This has been modified from Gaëtan Renaudeau's BezierEasing
  https://github.com/gre/bezier-easing/blob/master/src/index.js
  https://github.com/gre/bezier-easing/blob/master/LICENSE
  
  I've removed the newtonRaphsonIterate algo because in benchmarking it
  wasn't noticiably faster than binarySubdivision, indeed removing it
  usually improved times, depending on the curve.
  I also removed the lookup table, as for the added bundle size and loop we're
  only cutting ~4 or so subdivision iterations. I bumped the max iterations up
  to 12 to compensate and this still tended to be faster for no perceivable
  loss in accuracy.
  Usage
    const easeOut = cubicBezier(.17,.67,.83,.67);
    const x = easeOut(0.5); // returns 0.627...
*/
// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
const calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;
const subdivisionPrecision = 0.0000001;
const subdivisionMaxIterations = 12;
function binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {
  let currentX;
  let currentT;
  let i = 0;
  do {
    currentT = lowerBound + (upperBound - lowerBound) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - x;
    if (currentX > 0.0) {
      upperBound = currentT;
    } else {
      lowerBound = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i < subdivisionMaxIterations);
  return currentT;
}
function cubicBezier(mX1, mY1, mX2, mY2) {
  // If this is a linear gradient, return linear easing
  if (mX1 === mY1 && mX2 === mY2) return motionUtils.noop;
  const getTForX = aX => binarySubdivide(aX, 0, 1, mX1, mX2);
  // If animation is at start/end, return t without easing
  return t => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);
}

// Accepts an easing function and returns a new one that outputs mirrored values for
// the second half of the animation. Turns easeIn into easeInOut.
const mirrorEasing = easing => p => p <= 0.5 ? easing(2 * p) / 2 : (2 - easing(2 * (1 - p))) / 2;

// Accepts an easing function and returns a new one that outputs reversed values.
// Turns easeIn into easeOut.
const reverseEasing = easing => p => 1 - easing(1 - p);
const backOut = /*@__PURE__*/cubicBezier(0.33, 1.53, 0.69, 0.99);
const backIn = /*@__PURE__*/reverseEasing(backOut);
const backInOut = /*@__PURE__*/mirrorEasing(backIn);
const anticipate = p => (p *= 2) < 1 ? 0.5 * backIn(p) : 0.5 * (2 - Math.pow(2, -10 * (p - 1)));
const circIn = p => 1 - Math.sin(Math.acos(p));
const circOut = reverseEasing(circIn);
const circInOut = mirrorEasing(circIn);

/**
 * Check if the value is a zero value string like "0px" or "0%"
 */
const isZeroValueString = v => /^0[^.\s]+$/u.test(v);
function isNone(value) {
  if (typeof value === "number") {
    return value === 0;
  } else if (value !== null) {
    return value === "none" || value === "0" || isZeroValueString(value);
  } else {
    return true;
  }
}
const clamp = (min, max, v) => {
  if (v > max) return max;
  if (v < min) return min;
  return v;
};
const number = {
  test: v => typeof v === "number",
  parse: parseFloat,
  transform: v => v
};
const alpha = {
  ...number,
  transform: v => clamp(0, 1, v)
};
const scale = {
  ...number,
  default: 1
};

// If this number is a decimal, make it just five decimal places
// to avoid exponents
const sanitize = v => Math.round(v * 100000) / 100000;
const floatRegex = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;
function isNullish(v) {
  return v == null;
}
const singleColorRegex = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu;

/**
 * Returns true if the provided string is a color, ie rgba(0,0,0,0) or #000,
 * but false if a number or multiple colors
 */
const isColorString = (type, testProp) => v => {
  return Boolean(typeof v === "string" && singleColorRegex.test(v) && v.startsWith(type) || testProp && !isNullish(v) && Object.prototype.hasOwnProperty.call(v, testProp));
};
const splitColor = (aName, bName, cName) => v => {
  if (typeof v !== "string") return v;
  const [a, b, c, alpha] = v.match(floatRegex);
  return {
    [aName]: parseFloat(a),
    [bName]: parseFloat(b),
    [cName]: parseFloat(c),
    alpha: alpha !== undefined ? parseFloat(alpha) : 1
  };
};
const clampRgbUnit = v => clamp(0, 255, v);
const rgbUnit = {
  ...number,
  transform: v => Math.round(clampRgbUnit(v))
};
const rgba = {
  test: /*@__PURE__*/isColorString("rgb", "red"),
  parse: /*@__PURE__*/splitColor("red", "green", "blue"),
  transform: ({
    red,
    green,
    blue,
    alpha: alpha$1 = 1
  }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};
function parseHex(v) {
  let r = "";
  let g = "";
  let b = "";
  let a = "";
  // If we have 6 characters, ie #FF0000
  if (v.length > 5) {
    r = v.substring(1, 3);
    g = v.substring(3, 5);
    b = v.substring(5, 7);
    a = v.substring(7, 9);
    // Or we have 3 characters, ie #F00
  } else {
    r = v.substring(1, 2);
    g = v.substring(2, 3);
    b = v.substring(3, 4);
    a = v.substring(4, 5);
    r += r;
    g += g;
    b += b;
    a += a;
  }
  return {
    red: parseInt(r, 16),
    green: parseInt(g, 16),
    blue: parseInt(b, 16),
    alpha: a ? parseInt(a, 16) / 255 : 1
  };
}
const hex = {
  test: /*@__PURE__*/isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};
const createUnitType = unit => ({
  test: v => typeof v === "string" && v.endsWith(unit) && v.split(" ").length === 1,
  parse: parseFloat,
  transform: v => `${v}${unit}`
});
const degrees = /*@__PURE__*/createUnitType("deg");
const percent = /*@__PURE__*/createUnitType("%");
const px = /*@__PURE__*/createUnitType("px");
const vh = /*@__PURE__*/createUnitType("vh");
const vw = /*@__PURE__*/createUnitType("vw");
const progressPercentage = {
  ...percent,
  parse: v => percent.parse(v) / 100,
  transform: v => percent.transform(v * 100)
};
const hsla = {
  test: /*@__PURE__*/isColorString("hsl", "hue"),
  parse: /*@__PURE__*/splitColor("hue", "saturation", "lightness"),
  transform: ({
    hue,
    saturation,
    lightness,
    alpha: alpha$1 = 1
  }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};
const color = {
  test: v => rgba.test(v) || hex.test(v) || hsla.test(v),
  parse: v => {
    if (rgba.test(v)) {
      return rgba.parse(v);
    } else if (hsla.test(v)) {
      return hsla.parse(v);
    } else {
      return hex.parse(v);
    }
  },
  transform: v => {
    return typeof v === "string" ? v : v.hasOwnProperty("red") ? rgba.transform(v) : hsla.transform(v);
  }
};
const colorRegex = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;
function test(v) {
  var _a, _b;
  return isNaN(v) && typeof v === "string" && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;
}
const NUMBER_TOKEN = "number";
const COLOR_TOKEN = "color";
const VAR_TOKEN = "var";
const VAR_FUNCTION_TOKEN = "var(";
const SPLIT_TOKEN = "${}";
// this regex consists of the `singleCssVariableRegex|rgbHSLValueRegex|digitRegex`
const complexRegex = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;
function analyseComplexValue(value) {
  const originalValue = value.toString();
  const values = [];
  const indexes = {
    color: [],
    number: [],
    var: []
  };
  const types = [];
  let i = 0;
  const tokenised = originalValue.replace(complexRegex, parsedValue => {
    if (color.test(parsedValue)) {
      indexes.color.push(i);
      types.push(COLOR_TOKEN);
      values.push(color.parse(parsedValue));
    } else if (parsedValue.startsWith(VAR_FUNCTION_TOKEN)) {
      indexes.var.push(i);
      types.push(VAR_TOKEN);
      values.push(parsedValue);
    } else {
      indexes.number.push(i);
      types.push(NUMBER_TOKEN);
      values.push(parseFloat(parsedValue));
    }
    ++i;
    return SPLIT_TOKEN;
  });
  const split = tokenised.split(SPLIT_TOKEN);
  return {
    values,
    split,
    indexes,
    types
  };
}
function parseComplexValue(v) {
  return analyseComplexValue(v).values;
}
function createTransformer(source) {
  const {
    split,
    types
  } = analyseComplexValue(source);
  const numSections = split.length;
  return v => {
    let output = "";
    for (let i = 0; i < numSections; i++) {
      output += split[i];
      if (v[i] !== undefined) {
        const type = types[i];
        if (type === NUMBER_TOKEN) {
          output += sanitize(v[i]);
        } else if (type === COLOR_TOKEN) {
          output += color.transform(v[i]);
        } else {
          output += v[i];
        }
      }
    }
    return output;
  };
}
const convertNumbersToZero = v => typeof v === "number" ? 0 : v;
function getAnimatableNone$1(v) {
  const parsed = parseComplexValue(v);
  const transformer = createTransformer(v);
  return transformer(parsed.map(convertNumbersToZero));
}
const complex = {
  test,
  parse: parseComplexValue,
  createTransformer,
  getAnimatableNone: getAnimatableNone$1
};

/**
 * Properties that should default to 1 or 100%
 */
const maxDefaults = new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v) {
  const [name, value] = v.slice(0, -1).split("(");
  if (name === "drop-shadow") return v;
  const [number] = value.match(floatRegex) || [];
  if (!number) return v;
  const unit = value.replace(number, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number !== value) defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
const functionRegex = /\b([a-z-]*)\(.*?\)/gu;
const filter = {
  ...complex,
  getAnimatableNone: v => {
    const functions = v.match(functionRegex);
    return functions ? functions.map(applyDefaultFilter).join(" ") : v;
  }
};
const browserNumberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Misc
  backgroundPositionX: px,
  backgroundPositionY: px
};
const transformValueTypes = {
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px
};
const int = {
  ...number,
  transform: Math.round
};
const numberValueTypes = {
  ...browserNumberValueTypes,
  ...transformValueTypes,
  zIndex: int,
  size: px,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

/**
 * A map of default value types for common values
 */
const defaultValueTypes = {
  ...numberValueTypes,
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
};
/**
 * Gets the default ValueType for the provided value key
 */
const getDefaultValueType = key => defaultValueTypes[key];
function getAnimatableNone(key, value) {
  let defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter) defaultValueType = complex;
  // If value is not recognised as animatable, ie "none", create an animatable version origin based on the target
  return defaultValueType.getAnimatableNone ? defaultValueType.getAnimatableNone(value) : undefined;
}

/**
 * If we encounter keyframes like "none" or "0" and we also have keyframes like
 * "#fff" or "200px 200px" we want to find a keyframe to serve as a template for
 * the "none" keyframes. In this case "#fff" or "200px 200px" - then these get turned into
 * zero equivalents, i.e. "#fff0" or "0px 0px".
 */
const invalidTemplates = new Set(["auto", "none", "0"]);
function makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name) {
  let i = 0;
  let animatableTemplate = undefined;
  while (i < unresolvedKeyframes.length && !animatableTemplate) {
    const keyframe = unresolvedKeyframes[i];
    if (typeof keyframe === "string" && !invalidTemplates.has(keyframe) && analyseComplexValue(keyframe).values.length) {
      animatableTemplate = unresolvedKeyframes[i];
    }
    i++;
  }
  if (animatableTemplate && name) {
    for (const noneIndex of noneKeyframeIndexes) {
      unresolvedKeyframes[noneIndex] = getAnimatableNone(name, animatableTemplate);
    }
  }
}
const isNumOrPxType = v => v === number || v === px;
const getPosFromMatrix = (matrix, pos) => parseFloat(matrix.split(", ")[pos]);
const getTranslateFromMatrix = (pos2, pos3) => (_bbox, {
  transform
}) => {
  if (transform === "none" || !transform) return 0;
  const matrix3d = transform.match(/^matrix3d\((.+)\)$/u);
  if (matrix3d) {
    return getPosFromMatrix(matrix3d[1], pos3);
  } else {
    const matrix = transform.match(/^matrix\((.+)\)$/u);
    if (matrix) {
      return getPosFromMatrix(matrix[1], pos2);
    } else {
      return 0;
    }
  }
};
const transformKeys = new Set(["x", "y", "z"]);
const nonTranslationalTransformKeys = transformPropOrder.filter(key => !transformKeys.has(key));
function removeNonTranslationalTransform(visualElement) {
  const removedTransforms = [];
  nonTranslationalTransformKeys.forEach(key => {
    const value = visualElement.getValue(key);
    if (value !== undefined) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  return removedTransforms;
}
const positionalValues = {
  // Dimensions
  width: ({
    x
  }, {
    paddingLeft = "0",
    paddingRight = "0"
  }) => x.max - x.min - parseFloat(paddingLeft) - parseFloat(paddingRight),
  height: ({
    y
  }, {
    paddingTop = "0",
    paddingBottom = "0"
  }) => y.max - y.min - parseFloat(paddingTop) - parseFloat(paddingBottom),
  top: (_bbox, {
    top
  }) => parseFloat(top),
  left: (_bbox, {
    left
  }) => parseFloat(left),
  bottom: ({
    y
  }, {
    top
  }) => parseFloat(top) + (y.max - y.min),
  right: ({
    x
  }, {
    left
  }) => parseFloat(left) + (x.max - x.min),
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
// Alias translate longform names
positionalValues.translateX = positionalValues.x;
positionalValues.translateY = positionalValues.y;
const toResolve = new Set();
let isScheduled = false;
let anyNeedsMeasurement = false;
function measureAllKeyframes() {
  if (anyNeedsMeasurement) {
    const resolversToMeasure = Array.from(toResolve).filter(resolver => resolver.needsMeasurement);
    const elementsToMeasure = new Set(resolversToMeasure.map(resolver => resolver.element));
    const transformsToRestore = new Map();
    /**
     * Write pass
     * If we're measuring elements we want to remove bounding box-changing transforms.
     */
    elementsToMeasure.forEach(element => {
      const removedTransforms = removeNonTranslationalTransform(element);
      if (!removedTransforms.length) return;
      transformsToRestore.set(element, removedTransforms);
      element.render();
    });
    // Read
    resolversToMeasure.forEach(resolver => resolver.measureInitialState());
    // Write
    elementsToMeasure.forEach(element => {
      element.render();
      const restore = transformsToRestore.get(element);
      if (restore) {
        restore.forEach(([key, value]) => {
          var _a;
          (_a = element.getValue(key)) === null || _a === void 0 ? void 0 : _a.set(value);
        });
      }
    });
    // Read
    resolversToMeasure.forEach(resolver => resolver.measureEndState());
    // Write
    resolversToMeasure.forEach(resolver => {
      if (resolver.suspendedScrollY !== undefined) {
        window.scrollTo(0, resolver.suspendedScrollY);
      }
    });
  }
  anyNeedsMeasurement = false;
  isScheduled = false;
  toResolve.forEach(resolver => resolver.complete());
  toResolve.clear();
}
function readAllKeyframes() {
  toResolve.forEach(resolver => {
    resolver.readKeyframes();
    if (resolver.needsMeasurement) {
      anyNeedsMeasurement = true;
    }
  });
}
function flushKeyframeResolvers() {
  readAllKeyframes();
  measureAllKeyframes();
}
class KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue, element, isAsync = false) {
    /**
     * Track whether this resolver has completed. Once complete, it never
     * needs to attempt keyframe resolution again.
     */
    this.isComplete = false;
    /**
     * Track whether this resolver is async. If it is, it'll be added to the
     * resolver queue and flushed in the next frame. Resolvers that aren't going
     * to trigger read/write thrashing don't need to be async.
     */
    this.isAsync = false;
    /**
     * Track whether this resolver needs to perform a measurement
     * to resolve its keyframes.
     */
    this.needsMeasurement = false;
    /**
     * Track whether this resolver is currently scheduled to resolve
     * to allow it to be cancelled and resumed externally.
     */
    this.isScheduled = false;
    this.unresolvedKeyframes = [...unresolvedKeyframes];
    this.onComplete = onComplete;
    this.name = name;
    this.motionValue = motionValue;
    this.element = element;
    this.isAsync = isAsync;
  }
  scheduleResolve() {
    this.isScheduled = true;
    if (this.isAsync) {
      toResolve.add(this);
      if (!isScheduled) {
        isScheduled = true;
        frame.read(readAllKeyframes);
        frame.resolveKeyframes(measureAllKeyframes);
      }
    } else {
      this.readKeyframes();
      this.complete();
    }
  }
  readKeyframes() {
    const {
      unresolvedKeyframes,
      name,
      element,
      motionValue
    } = this;
    /**
     * If a keyframe is null, we hydrate it either by reading it from
     * the instance, or propagating from previous keyframes.
     */
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (unresolvedKeyframes[i] === null) {
        /**
         * If the first keyframe is null, we need to find its value by sampling the element
         */
        if (i === 0) {
          const currentValue = motionValue === null || motionValue === void 0 ? void 0 : motionValue.get();
          const finalKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
          if (currentValue !== undefined) {
            unresolvedKeyframes[0] = currentValue;
          } else if (element && name) {
            const valueAsRead = element.readValue(name, finalKeyframe);
            if (valueAsRead !== undefined && valueAsRead !== null) {
              unresolvedKeyframes[0] = valueAsRead;
            }
          }
          if (unresolvedKeyframes[0] === undefined) {
            unresolvedKeyframes[0] = finalKeyframe;
          }
          if (motionValue && currentValue === undefined) {
            motionValue.set(unresolvedKeyframes[0]);
          }
        } else {
          unresolvedKeyframes[i] = unresolvedKeyframes[i - 1];
        }
      }
    }
  }
  setFinalKeyframe() {}
  measureInitialState() {}
  renderEndStyles() {}
  measureEndState() {}
  complete() {
    this.isComplete = true;
    this.onComplete(this.unresolvedKeyframes, this.finalKeyframe);
    toResolve.delete(this);
  }
  cancel() {
    if (!this.isComplete) {
      this.isScheduled = false;
      toResolve.delete(this);
    }
  }
  resume() {
    if (!this.isComplete) this.scheduleResolve();
  }
}

/**
 * Check if value is a numerical string, ie a string that is purely a number eg "100" or "-100.1"
 */
const isNumericalString = v => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(v);
const checkStringStartsWith = token => key => typeof key === "string" && key.startsWith(token);
const isCSSVariableName = /*@__PURE__*/checkStringStartsWith("--");
const startsAsVariableToken = /*@__PURE__*/checkStringStartsWith("var(--");
const isCSSVariableToken = value => {
  const startsWithToken = startsAsVariableToken(value);
  if (!startsWithToken) return false;
  // Ensure any comments are stripped from the value as this can harm performance of the regex.
  return singleCssVariableRegex.test(value.split("/*")[0].trim());
};
const singleCssVariableRegex = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu;

/**
 * Parse Framer's special CSS variable format into a CSS token and a fallback.
 *
 * ```
 * `var(--foo, #fff)` => [`--foo`, '#fff']
 * ```
 *
 * @param current
 */
const splitCSSVariableRegex =
// eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words
/^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;
function parseCSSVariable(current) {
  const match = splitCSSVariableRegex.exec(current);
  if (!match) return [,];
  const [, token1, token2, fallback] = match;
  return [`--${token1 !== null && token1 !== void 0 ? token1 : token2}`, fallback];
}
const maxDepth = 4;
function getVariableValue(current, element, depth = 1) {
  motionUtils.invariant(depth <= maxDepth, `Max CSS variable fallback depth detected in property "${current}". This may indicate a circular fallback dependency.`);
  const [token, fallback] = parseCSSVariable(current);
  // No CSS variable detected
  if (!token) return;
  // Attempt to read this CSS variable off the element
  const resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    const trimmed = resolved.trim();
    return isNumericalString(trimmed) ? parseFloat(trimmed) : trimmed;
  }
  return isCSSVariableToken(fallback) ? getVariableValue(fallback, element, depth + 1) : fallback;
}

/**
 * Tests a provided value against a ValueType
 */
const testValueType = v => type => type.test(v);

/**
 * ValueType for "auto"
 */
const auto = {
  test: v => v === "auto",
  parse: v => v
};

/**
 * A list of value types commonly used for dimensions
 */
const dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
/**
 * Tests a dimensional value against the list of dimension ValueTypes
 */
const findDimensionValueType = v => dimensionValueTypes.find(testValueType(v));
class DOMKeyframesResolver extends KeyframeResolver {
  constructor(unresolvedKeyframes, onComplete, name, motionValue, element) {
    super(unresolvedKeyframes, onComplete, name, motionValue, element, true);
  }
  readKeyframes() {
    const {
      unresolvedKeyframes,
      element,
      name
    } = this;
    if (!element || !element.current) return;
    super.readKeyframes();
    /**
     * If any keyframe is a CSS variable, we need to find its value by sampling the element
     */
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      let keyframe = unresolvedKeyframes[i];
      if (typeof keyframe === "string") {
        keyframe = keyframe.trim();
        if (isCSSVariableToken(keyframe)) {
          const resolved = getVariableValue(keyframe, element.current);
          if (resolved !== undefined) {
            unresolvedKeyframes[i] = resolved;
          }
          if (i === unresolvedKeyframes.length - 1) {
            this.finalKeyframe = keyframe;
          }
        }
      }
    }
    /**
     * Resolve "none" values. We do this potentially twice - once before and once after measuring keyframes.
     * This could be seen as inefficient but it's a trade-off to avoid measurements in more situations, which
     * have a far bigger performance impact.
     */
    this.resolveNoneKeyframes();
    /**
     * Check to see if unit type has changed. If so schedule jobs that will
     * temporarily set styles to the destination keyframes.
     * Skip if we have more than two keyframes or this isn't a positional value.
     * TODO: We can throw if there are multiple keyframes and the value type changes.
     */
    if (!positionalKeys.has(name) || unresolvedKeyframes.length !== 2) {
      return;
    }
    const [origin, target] = unresolvedKeyframes;
    const originType = findDimensionValueType(origin);
    const targetType = findDimensionValueType(target);
    /**
     * Either we don't recognise these value types or we can animate between them.
     */
    if (originType === targetType) return;
    /**
     * If both values are numbers or pixels, we can animate between them by
     * converting them to numbers.
     */
    if (isNumOrPxType(originType) && isNumOrPxType(targetType)) {
      for (let i = 0; i < unresolvedKeyframes.length; i++) {
        const value = unresolvedKeyframes[i];
        if (typeof value === "string") {
          unresolvedKeyframes[i] = parseFloat(value);
        }
      }
    } else {
      /**
       * Else, the only way to resolve this is by measuring the element.
       */
      this.needsMeasurement = true;
    }
  }
  resolveNoneKeyframes() {
    const {
      unresolvedKeyframes,
      name
    } = this;
    const noneKeyframeIndexes = [];
    for (let i = 0; i < unresolvedKeyframes.length; i++) {
      if (isNone(unresolvedKeyframes[i])) {
        noneKeyframeIndexes.push(i);
      }
    }
    if (noneKeyframeIndexes.length) {
      makeNoneKeyframesAnimatable(unresolvedKeyframes, noneKeyframeIndexes, name);
    }
  }
  measureInitialState() {
    const {
      element,
      unresolvedKeyframes,
      name
    } = this;
    if (!element || !element.current) return;
    if (name === "height") {
      this.suspendedScrollY = window.pageYOffset;
    }
    this.measuredOrigin = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    unresolvedKeyframes[0] = this.measuredOrigin;
    // Set final key frame to measure after next render
    const measureKeyframe = unresolvedKeyframes[unresolvedKeyframes.length - 1];
    if (measureKeyframe !== undefined) {
      element.getValue(name, measureKeyframe).jump(measureKeyframe, false);
    }
  }
  measureEndState() {
    var _a;
    const {
      element,
      name,
      unresolvedKeyframes
    } = this;
    if (!element || !element.current) return;
    const value = element.getValue(name);
    value && value.jump(this.measuredOrigin, false);
    const finalKeyframeIndex = unresolvedKeyframes.length - 1;
    const finalKeyframe = unresolvedKeyframes[finalKeyframeIndex];
    unresolvedKeyframes[finalKeyframeIndex] = positionalValues[name](element.measureViewportBox(), window.getComputedStyle(element.current));
    if (finalKeyframe !== null && this.finalKeyframe === undefined) {
      this.finalKeyframe = finalKeyframe;
    }
    // If we removed transform values, reapply them before the next render
    if ((_a = this.removedTransforms) === null || _a === void 0 ? void 0 : _a.length) {
      this.removedTransforms.forEach(([unsetTransformName, unsetTransformValue]) => {
        element.getValue(unsetTransformName).set(unsetTransformValue);
      });
    }
    this.resolveNoneKeyframes();
  }
}

/**
 * Check if a value is animatable. Examples:
 *
 * ✅: 100, "100px", "#fff"
 * ❌: "block", "url(2.jpg)"
 * @param value
 *
 * @internal
 */
const isAnimatable = (value, name) => {
  // If the list of keys tat might be non-animatable grows, replace with Set
  if (name === "zIndex") return false;
  // If it's a number or a keyframes array, we can animate it. We might at some point
  // need to do a deep isAnimatable check of keyframes, or let Popmotion handle this,
  // but for now lets leave it like this for performance reasons
  if (typeof value === "number" || Array.isArray(value)) return true;
  if (typeof value === "string" && (
  // It's animatable if we have a string
  complex.test(value) || value === "0") &&
  // And it contains numbers and/or colors
  !value.startsWith("url(") // Unless it starts with "url("
  ) {
    return true;
  }
  return false;
};
function hasKeyframesChanged(keyframes) {
  const current = keyframes[0];
  if (keyframes.length === 1) return true;
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i] !== current) return true;
  }
}
function canAnimate(keyframes, name, type, velocity) {
  /**
   * Check if we're able to animate between the start and end keyframes,
   * and throw a warning if we're attempting to animate between one that's
   * animatable and another that isn't.
   */
  const originKeyframe = keyframes[0];
  if (originKeyframe === null) return false;
  /**
   * These aren't traditionally animatable but we do support them.
   * In future we could look into making this more generic or replacing
   * this function with mix() === mixImmediate
   */
  if (name === "display" || name === "visibility") return true;
  const targetKeyframe = keyframes[keyframes.length - 1];
  const isOriginAnimatable = isAnimatable(originKeyframe, name);
  const isTargetAnimatable = isAnimatable(targetKeyframe, name);
  motionUtils.warning(isOriginAnimatable === isTargetAnimatable, `You are trying to animate ${name} from "${originKeyframe}" to "${targetKeyframe}". ${originKeyframe} is not an animatable value - to enable this animation set ${originKeyframe} to a value animatable to ${targetKeyframe} via the \`style\` property.`);
  // Always skip if any of these are true
  if (!isOriginAnimatable || !isTargetAnimatable) {
    return false;
  }
  return hasKeyframesChanged(keyframes) || (type === "spring" || motionDom.isGenerator(type)) && velocity;
}
const isNotNull = value => value !== null;
function getFinalKeyframe(keyframes, {
  repeat,
  repeatType = "loop"
}, finalKeyframe) {
  const resolvedKeyframes = keyframes.filter(isNotNull);
  const index = repeat && repeatType !== "loop" && repeat % 2 === 1 ? 0 : resolvedKeyframes.length - 1;
  return !index || finalKeyframe === undefined ? resolvedKeyframes[index] : finalKeyframe;
}

/**
 * Maximum time allowed between an animation being created and it being
 * resolved for us to use the latter as the start time.
 *
 * This is to ensure that while we prefer to "start" an animation as soon
 * as it's triggered, we also want to avoid a visual jump if there's a big delay
 * between these two moments.
 */
const MAX_RESOLVE_DELAY = 40;
class BaseAnimation {
  constructor({
    autoplay = true,
    delay = 0,
    type = "keyframes",
    repeat = 0,
    repeatDelay = 0,
    repeatType = "loop",
    ...options
  }) {
    // Track whether the animation has been stopped. Stopped animations won't restart.
    this.isStopped = false;
    this.hasAttemptedResolve = false;
    this.createdAt = time.now();
    this.options = {
      autoplay,
      delay,
      type,
      repeat,
      repeatDelay,
      repeatType,
      ...options
    };
    this.updateFinishedPromise();
  }
  /**
   * This method uses the createdAt and resolvedAt to calculate the
   * animation startTime. *Ideally*, we would use the createdAt time as t=0
   * as the following frame would then be the first frame of the animation in
   * progress, which would feel snappier.
   *
   * However, if there's a delay (main thread work) between the creation of
   * the animation and the first commited frame, we prefer to use resolvedAt
   * to avoid a sudden jump into the animation.
   */
  calcStartTime() {
    if (!this.resolvedAt) return this.createdAt;
    return this.resolvedAt - this.createdAt > MAX_RESOLVE_DELAY ? this.resolvedAt : this.createdAt;
  }
  /**
   * A getter for resolved data. If keyframes are not yet resolved, accessing
   * this.resolved will synchronously flush all pending keyframe resolvers.
   * This is a deoptimisation, but at its worst still batches read/writes.
   */
  get resolved() {
    if (!this._resolved && !this.hasAttemptedResolve) {
      flushKeyframeResolvers();
    }
    return this._resolved;
  }
  /**
   * A method to be called when the keyframes resolver completes. This method
   * will check if its possible to run the animation and, if not, skip it.
   * Otherwise, it will call initPlayback on the implementing class.
   */
  onKeyframesResolved(keyframes, finalKeyframe) {
    this.resolvedAt = time.now();
    this.hasAttemptedResolve = true;
    const {
      name,
      type,
      velocity,
      delay,
      onComplete,
      onUpdate,
      isGenerator
    } = this.options;
    /**
     * If we can't animate this value with the resolved keyframes
     * then we should complete it immediately.
     */
    if (!isGenerator && !canAnimate(keyframes, name, type, velocity)) {
      // Finish immediately
      if (instantAnimationState.current || !delay) {
        onUpdate && onUpdate(getFinalKeyframe(keyframes, this.options, finalKeyframe));
        onComplete && onComplete();
        this.resolveFinishedPromise();
        return;
      }
      // Finish after a delay
      else {
        this.options.duration = 0;
      }
    }
    const resolvedAnimation = this.initPlayback(keyframes, finalKeyframe);
    if (resolvedAnimation === false) return;
    this._resolved = {
      keyframes,
      finalKeyframe,
      ...resolvedAnimation
    };
    this.onPostResolved();
  }
  onPostResolved() {}
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  flatten() {
    this.options.type = "keyframes";
    this.options.ease = "linear";
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise(resolve => {
      this.resolveFinishedPromise = resolve;
    });
  }
}

/*
  Value in range from progress

  Given a lower limit and an upper limit, we return the value within
  that range as expressed by progress (usually a number from 0 to 1)

  So progress = 0.5 would change

  from -------- to

  to

  from ---- to

  E.g. from = 10, to = 20, progress = 0.5 => 15

  @param [number]: Lower limit of range
  @param [number]: Upper limit of range
  @param [number]: The progress between lower and upper limits expressed 0-1
  @return [number]: Value as calculated from progress within range (not limited within range)
*/
const mixNumber$1 = (from, to, progress) => {
  return from + (to - from) * progress;
};

// Adapted from https://gist.github.com/mjackson/5311256
function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function hslaToRgba({
  hue,
  saturation,
  lightness,
  alpha
}) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p = 2 * lightness - q;
    red = hueToRgb(p, q, hue + 1 / 3);
    green = hueToRgb(p, q, hue);
    blue = hueToRgb(p, q, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha
  };
}
function mixImmediate(a, b) {
  return p => p > 0 ? b : a;
}

// Linear color space blending
// Explained https://www.youtube.com/watch?v=LKnqECcg6Gw
// Demonstrated http://codepen.io/osublake/pen/xGVVaN
const mixLinearColor = (from, to, v) => {
  const fromExpo = from * from;
  const expo = v * (to * to - fromExpo) + fromExpo;
  return expo < 0 ? 0 : Math.sqrt(expo);
};
const colorTypes = [hex, rgba, hsla];
const getColorType = v => colorTypes.find(type => type.test(v));
function asRGBA(color) {
  const type = getColorType(color);
  motionUtils.warning(Boolean(type), `'${color}' is not an animatable color. Use the equivalent color code instead.`);
  if (!Boolean(type)) return false;
  let model = type.parse(color);
  if (type === hsla) {
    // TODO Remove this cast - needed since Motion's stricter typing
    model = hslaToRgba(model);
  }
  return model;
}
const mixColor = (from, to) => {
  const fromRGBA = asRGBA(from);
  const toRGBA = asRGBA(to);
  if (!fromRGBA || !toRGBA) {
    return mixImmediate(from, to);
  }
  const blended = {
    ...fromRGBA
  };
  return v => {
    blended.red = mixLinearColor(fromRGBA.red, toRGBA.red, v);
    blended.green = mixLinearColor(fromRGBA.green, toRGBA.green, v);
    blended.blue = mixLinearColor(fromRGBA.blue, toRGBA.blue, v);
    blended.alpha = mixNumber$1(fromRGBA.alpha, toRGBA.alpha, v);
    return rgba.transform(blended);
  };
};

/**
 * Pipe
 * Compose other transformers to run linearily
 * pipe(min(20), max(40))
 * @param  {...functions} transformers
 * @return {function}
 */
const combineFunctions = (a, b) => v => b(a(v));
const pipe = (...transformers) => transformers.reduce(combineFunctions);
const invisibleValues = new Set(["none", "hidden"]);
/**
 * Returns a function that, when provided a progress value between 0 and 1,
 * will return the "none" or "hidden" string only when the progress is that of
 * the origin or target.
 */
function mixVisibility(origin, target) {
  if (invisibleValues.has(origin)) {
    return p => p <= 0 ? origin : target;
  } else {
    return p => p >= 1 ? target : origin;
  }
}
function mixNumber(a, b) {
  return p => mixNumber$1(a, b, p);
}
function getMixer$1(a) {
  if (typeof a === "number") {
    return mixNumber;
  } else if (typeof a === "string") {
    return isCSSVariableToken(a) ? mixImmediate : color.test(a) ? mixColor : mixComplex;
  } else if (Array.isArray(a)) {
    return mixArray;
  } else if (typeof a === "object") {
    return color.test(a) ? mixColor : mixObject;
  }
  return mixImmediate;
}
function mixArray(a, b) {
  const output = [...a];
  const numValues = output.length;
  const blendValue = a.map((v, i) => getMixer$1(v)(v, b[i]));
  return p => {
    for (let i = 0; i < numValues; i++) {
      output[i] = blendValue[i](p);
    }
    return output;
  };
}
function mixObject(a, b) {
  const output = {
    ...a,
    ...b
  };
  const blendValue = {};
  for (const key in output) {
    if (a[key] !== undefined && b[key] !== undefined) {
      blendValue[key] = getMixer$1(a[key])(a[key], b[key]);
    }
  }
  return v => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v);
    }
    return output;
  };
}
function matchOrder(origin, target) {
  var _a;
  const orderedOrigin = [];
  const pointers = {
    color: 0,
    var: 0,
    number: 0
  };
  for (let i = 0; i < target.values.length; i++) {
    const type = target.types[i];
    const originIndex = origin.indexes[type][pointers[type]];
    const originValue = (_a = origin.values[originIndex]) !== null && _a !== void 0 ? _a : 0;
    orderedOrigin[i] = originValue;
    pointers[type]++;
  }
  return orderedOrigin;
}
const mixComplex = (origin, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyseComplexValue(origin);
  const targetStats = analyseComplexValue(target);
  const canInterpolate = originStats.indexes.var.length === targetStats.indexes.var.length && originStats.indexes.color.length === targetStats.indexes.color.length && originStats.indexes.number.length >= targetStats.indexes.number.length;
  if (canInterpolate) {
    if (invisibleValues.has(origin) && !targetStats.values.length || invisibleValues.has(target) && !originStats.values.length) {
      return mixVisibility(origin, target);
    }
    return pipe(mixArray(matchOrder(originStats, targetStats), targetStats.values), template);
  } else {
    motionUtils.warning(true, `Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return mixImmediate(origin, target);
  }
};
function mix(from, to, p) {
  if (typeof from === "number" && typeof to === "number" && typeof p === "number") {
    return mixNumber$1(from, to, p);
  }
  const mixer = getMixer$1(from);
  return mixer(from, to);
}
const velocitySampleDuration = 5; // ms
function calcGeneratorVelocity(resolveValue, t, current) {
  const prevT = Math.max(t - velocitySampleDuration, 0);
  return velocityPerSecond(current - resolveValue(prevT), t - prevT);
}
const springDefaults = {
  // Default spring physics
  stiffness: 100,
  damping: 10,
  mass: 1.0,
  velocity: 0.0,
  // Default duration/bounce-based options
  duration: 800,
  // in ms
  bounce: 0.3,
  visualDuration: 0.3,
  // in seconds
  // Rest thresholds
  restSpeed: {
    granular: 0.01,
    default: 2
  },
  restDelta: {
    granular: 0.005,
    default: 0.5
  },
  // Limits
  minDuration: 0.01,
  // in seconds
  maxDuration: 10.0,
  // in seconds
  minDamping: 0.05,
  maxDamping: 1
};
const safeMin = 0.001;
function findSpring({
  duration = springDefaults.duration,
  bounce = springDefaults.bounce,
  velocity = springDefaults.velocity,
  mass = springDefaults.mass
}) {
  let envelope;
  let derivative;
  motionUtils.warning(duration <= motionUtils.secondsToMilliseconds(springDefaults.maxDuration), "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  /**
   * Restrict dampingRatio and duration to within acceptable ranges.
   */
  dampingRatio = clamp(springDefaults.minDamping, springDefaults.maxDamping, dampingRatio);
  duration = clamp(springDefaults.minDuration, springDefaults.maxDuration, motionUtils.millisecondsToSeconds(duration));
  if (dampingRatio < 1) {
    /**
     * Underdamped spring
     */
    envelope = undampedFreq => {
      const exponentialDecay = undampedFreq * dampingRatio;
      const delta = exponentialDecay * duration;
      const a = exponentialDecay - velocity;
      const b = calcAngularFreq(undampedFreq, dampingRatio);
      const c = Math.exp(-delta);
      return safeMin - a / b * c;
    };
    derivative = undampedFreq => {
      const exponentialDecay = undampedFreq * dampingRatio;
      const delta = exponentialDecay * duration;
      const d = delta * velocity + velocity;
      const e = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq, 2) * duration;
      const f = Math.exp(-delta);
      const g = calcAngularFreq(Math.pow(undampedFreq, 2), dampingRatio);
      const factor = -envelope(undampedFreq) + safeMin > 0 ? -1 : 1;
      return factor * ((d - e) * f) / g;
    };
  } else {
    /**
     * Critically-damped spring
     */
    envelope = undampedFreq => {
      const a = Math.exp(-undampedFreq * duration);
      const b = (undampedFreq - velocity) * duration + 1;
      return -safeMin + a * b;
    };
    derivative = undampedFreq => {
      const a = Math.exp(-undampedFreq * duration);
      const b = (velocity - undampedFreq) * (duration * duration);
      return a * b;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = motionUtils.secondsToMilliseconds(duration);
  if (isNaN(undampedFreq)) {
    return {
      stiffness: springDefaults.stiffness,
      damping: springDefaults.damping,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
const rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i = 1; i < rootIterations; i++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}
const durationKeys = ["duration", "bounce"];
const physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some(key => options[key] !== undefined);
}
function getSpringOptions(options) {
  let springOptions = {
    velocity: springDefaults.velocity,
    stiffness: springDefaults.stiffness,
    damping: springDefaults.damping,
    mass: springDefaults.mass,
    isResolvedFromDuration: false,
    ...options
  };
  // stiffness/damping/mass overrides duration/bounce
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    if (options.visualDuration) {
      const visualDuration = options.visualDuration;
      const root = 2 * Math.PI / (visualDuration * 1.2);
      const stiffness = root * root;
      const damping = 2 * clamp(0.05, 1, 1 - (options.bounce || 0)) * Math.sqrt(stiffness);
      springOptions = {
        ...springOptions,
        mass: springDefaults.mass,
        stiffness,
        damping
      };
    } else {
      const derived = findSpring(options);
      springOptions = {
        ...springOptions,
        ...derived,
        mass: springDefaults.mass
      };
      springOptions.isResolvedFromDuration = true;
    }
  }
  return springOptions;
}
function spring(optionsOrVisualDuration = springDefaults.visualDuration, bounce = springDefaults.bounce) {
  const options = typeof optionsOrVisualDuration !== "object" ? {
    visualDuration: optionsOrVisualDuration,
    keyframes: [0, 1],
    bounce
  } : optionsOrVisualDuration;
  let {
    restSpeed,
    restDelta
  } = options;
  const origin = options.keyframes[0];
  const target = options.keyframes[options.keyframes.length - 1];
  /**
   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
   * to reduce GC during animation.
   */
  const state = {
    done: false,
    value: origin
  };
  const {
    stiffness,
    damping,
    mass,
    duration,
    velocity,
    isResolvedFromDuration
  } = getSpringOptions({
    ...options,
    velocity: -motionUtils.millisecondsToSeconds(options.velocity || 0)
  });
  const initialVelocity = velocity || 0.0;
  const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
  const initialDelta = target - origin;
  const undampedAngularFreq = motionUtils.millisecondsToSeconds(Math.sqrt(stiffness / mass));
  /**
   * If we're working on a granular scale, use smaller defaults for determining
   * when the spring is finished.
   *
   * These defaults have been selected emprically based on what strikes a good
   * ratio between feeling good and finishing as soon as changes are imperceptible.
   */
  const isGranularScale = Math.abs(initialDelta) < 5;
  restSpeed || (restSpeed = isGranularScale ? springDefaults.restSpeed.granular : springDefaults.restSpeed.default);
  restDelta || (restDelta = isGranularScale ? springDefaults.restDelta.granular : springDefaults.restDelta.default);
  let resolveSpring;
  if (dampingRatio < 1) {
    const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
    // Underdamped spring
    resolveSpring = t => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t) + initialDelta * Math.cos(angularFreq * t));
    };
  } else if (dampingRatio === 1) {
    // Critically damped spring
    resolveSpring = t => target - Math.exp(-undampedAngularFreq * t) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t);
  } else {
    // Overdamped spring
    const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
    resolveSpring = t => {
      const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t);
      // When performing sinh or cosh values can hit Infinity so we cap them here
      const freqForT = Math.min(dampedAngularFreq * t, 300);
      return target - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
    };
  }
  const generator = {
    calculatedDuration: isResolvedFromDuration ? duration || null : null,
    next: t => {
      const current = resolveSpring(t);
      if (!isResolvedFromDuration) {
        let currentVelocity = 0.0;
        /**
         * We only need to calculate velocity for under-damped springs
         * as over- and critically-damped springs can't overshoot, so
         * checking only for displacement is enough.
         */
        if (dampingRatio < 1) {
          currentVelocity = t === 0 ? motionUtils.secondsToMilliseconds(initialVelocity) : calcGeneratorVelocity(resolveSpring, t, current);
        }
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(target - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t >= duration;
      }
      state.value = state.done ? target : current;
      return state;
    },
    toString: () => {
      const calculatedDuration = Math.min(motionDom.calcGeneratorDuration(generator), motionDom.maxGeneratorDuration);
      const easing = motionDom.generateLinearEasing(progress => generator.next(calculatedDuration * progress).value, calculatedDuration, 30);
      return calculatedDuration + "ms " + easing;
    }
  };
  return generator;
}
function inertia({
  keyframes,
  velocity = 0.0,
  power = 0.8,
  timeConstant = 325,
  bounceDamping = 10,
  bounceStiffness = 500,
  modifyTarget,
  min,
  max,
  restDelta = 0.5,
  restSpeed
}) {
  const origin = keyframes[0];
  const state = {
    done: false,
    value: origin
  };
  const isOutOfBounds = v => min !== undefined && v < min || max !== undefined && v > max;
  const nearestBoundary = v => {
    if (min === undefined) return max;
    if (max === undefined) return min;
    return Math.abs(min - v) < Math.abs(max - v) ? min : max;
  };
  let amplitude = power * velocity;
  const ideal = origin + amplitude;
  const target = modifyTarget === undefined ? ideal : modifyTarget(ideal);
  /**
   * If the target has changed we need to re-calculate the amplitude, otherwise
   * the animation will start from the wrong position.
   */
  if (target !== ideal) amplitude = target - origin;
  const calcDelta = t => -amplitude * Math.exp(-t / timeConstant);
  const calcLatest = t => target + calcDelta(t);
  const applyFriction = t => {
    const delta = calcDelta(t);
    const latest = calcLatest(t);
    state.done = Math.abs(delta) <= restDelta;
    state.value = state.done ? target : latest;
  };
  /**
   * Ideally this would resolve for t in a stateless way, we could
   * do that by always precalculating the animation but as we know
   * this will be done anyway we can assume that spring will
   * be discovered during that.
   */
  let timeReachedBoundary;
  let spring$1;
  const checkCatchBoundary = t => {
    if (!isOutOfBounds(state.value)) return;
    timeReachedBoundary = t;
    spring$1 = spring({
      keyframes: [state.value, nearestBoundary(state.value)],
      velocity: calcGeneratorVelocity(calcLatest, t, state.value),
      // TODO: This should be passing * 1000
      damping: bounceDamping,
      stiffness: bounceStiffness,
      restDelta,
      restSpeed
    });
  };
  checkCatchBoundary(0);
  return {
    calculatedDuration: null,
    next: t => {
      /**
       * We need to resolve the friction to figure out if we need a
       * spring but we don't want to do this twice per frame. So here
       * we flag if we updated for this frame and later if we did
       * we can skip doing it again.
       */
      let hasUpdatedFrame = false;
      if (!spring$1 && timeReachedBoundary === undefined) {
        hasUpdatedFrame = true;
        applyFriction(t);
        checkCatchBoundary(t);
      }
      /**
       * If we have a spring and the provided t is beyond the moment the friction
       * animation crossed the min/max boundary, use the spring.
       */
      if (timeReachedBoundary !== undefined && t >= timeReachedBoundary) {
        return spring$1.next(t - timeReachedBoundary);
      } else {
        !hasUpdatedFrame && applyFriction(t);
        return state;
      }
    }
  };
}
const easeIn = /*@__PURE__*/cubicBezier(0.42, 0, 1, 1);
const easeOut = /*@__PURE__*/cubicBezier(0, 0, 0.58, 1);
const easeInOut = /*@__PURE__*/cubicBezier(0.42, 0, 0.58, 1);
const isEasingArray = ease => {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};
const easingLookup = {
  linear: motionUtils.noop,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate
};
const easingDefinitionToFunction = definition => {
  if (motionDom.isBezierDefinition(definition)) {
    // If cubic bezier definition, create bezier curve
    motionUtils.invariant(definition.length === 4, `Cubic bezier arrays must contain four numerical values.`);
    const [x1, y1, x2, y2] = definition;
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    // Else lookup from table
    motionUtils.invariant(easingLookup[definition] !== undefined, `Invalid easing type '${definition}'`);
    return easingLookup[definition];
  }
  return definition;
};
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || mix;
  const numMixers = output.length - 1;
  for (let i = 0; i < numMixers; i++) {
    let mixer = mixerFactory(output[i], output[i + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i] || motionUtils.noop : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
/**
 * Create a function that maps from a numerical input array to a generic output array.
 *
 * Accepts:
 *   - Numbers
 *   - Colors (hex, hsl, hsla, rgb, rgba)
 *   - Complex (combinations of one or more numbers or strings)
 *
 * ```jsx
 * const mixColor = interpolate([0, 1], ['#fff', '#000'])
 *
 * mixColor(0.5) // 'rgba(128, 128, 128, 1)'
 * ```
 *
 * TODO Revist this approach once we've moved to data models for values,
 * probably not needed to pregenerate mixer functions.
 *
 * @public
 */
function interpolate(input, output, {
  clamp: isClamp = true,
  ease,
  mixer
} = {}) {
  const inputLength = input.length;
  motionUtils.invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  /**
   * If we're only provided a single input, we can just make a function
   * that returns the output.
   */
  if (inputLength === 1) return () => output[0];
  if (inputLength === 2 && output[0] === output[1]) return () => output[1];
  const isZeroDeltaRange = input[0] === input[1];
  // If input runs highest -> lowest, reverse both arrays
  if (input[0] > input[inputLength - 1]) {
    input = [...input].reverse();
    output = [...output].reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const numMixers = mixers.length;
  const interpolator = v => {
    if (isZeroDeltaRange && v < input[0]) return output[0];
    let i = 0;
    if (numMixers > 1) {
      for (; i < input.length - 2; i++) {
        if (v < input[i + 1]) break;
      }
    }
    const progressInRange = motionUtils.progress(input[i], input[i + 1], v);
    return mixers[i](progressInRange);
  };
  return isClamp ? v => interpolator(clamp(input[0], input[inputLength - 1], v)) : interpolator;
}
function fillOffset(offset, remaining) {
  const min = offset[offset.length - 1];
  for (let i = 1; i <= remaining; i++) {
    const offsetProgress = motionUtils.progress(0, remaining, i);
    offset.push(mixNumber$1(min, 1, offsetProgress));
  }
}
function defaultOffset$1(arr) {
  const offset = [0];
  fillOffset(offset, arr.length - 1);
  return offset;
}
function convertOffsetToTimes(offset, duration) {
  return offset.map(o => o * duration);
}
function defaultEasing$1(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function keyframes({
  duration = 300,
  keyframes: keyframeValues,
  times,
  ease = "easeInOut"
}) {
  /**
   * Easing functions can be externally defined as strings. Here we convert them
   * into actual functions.
   */
  const easingFunctions = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  /**
   * This is the Iterator-spec return value. We ensure it's mutable rather than using a generator
   * to reduce GC during animation.
   */
  const state = {
    done: false,
    value: keyframeValues[0]
  };
  /**
   * Create a times array based on the provided 0-1 offsets
   */
  const absoluteTimes = convertOffsetToTimes(
  // Only use the provided offsets if they're the correct length
  // TODO Maybe we should warn here if there's a length mismatch
  times && times.length === keyframeValues.length ? times : defaultOffset$1(keyframeValues), duration);
  const mapTimeToKeyframe = interpolate(absoluteTimes, keyframeValues, {
    ease: Array.isArray(easingFunctions) ? easingFunctions : defaultEasing$1(keyframeValues, easingFunctions)
  });
  return {
    calculatedDuration: duration,
    next: t => {
      state.value = mapTimeToKeyframe(t);
      state.done = t >= duration;
      return state;
    }
  };
}
const frameloopDriver = update => {
  const passTimestamp = ({
    timestamp
  }) => update(timestamp);
  return {
    start: () => frame.update(passTimestamp, true),
    stop: () => cancelFrame(passTimestamp),
    /**
     * If we're processing this frame we can use the
     * framelocked timestamp to keep things in sync.
     */
    now: () => frameData.isProcessing ? frameData.timestamp : time.now()
  };
};
const generators = {
  decay: inertia,
  inertia,
  tween: keyframes,
  keyframes: keyframes,
  spring
};
const percentToProgress = percent => percent / 100;
/**
 * Animation that runs on the main thread. Designed to be WAAPI-spec in the subset of
 * features we expose publically. Mostly the compatibility is to ensure visual identity
 * between both WAAPI and main thread animations.
 */
class MainThreadAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    /**
     * The time at which the animation was paused.
     */
    this.holdTime = null;
    /**
     * The time at which the animation was cancelled.
     */
    this.cancelTime = null;
    /**
     * The current time of the animation.
     */
    this.currentTime = 0;
    /**
     * Playback speed as a factor. 0 would be stopped, -1 reverse and 2 double speed.
     */
    this.playbackSpeed = 1;
    /**
     * The state of the animation to apply when the animation is resolved. This
     * allows calls to the public API to control the animation before it is resolved,
     * without us having to resolve it first.
     */
    this.pendingPlayState = "running";
    /**
     * The time at which the animation was started.
     */
    this.startTime = null;
    this.state = "idle";
    /**
     * This method is bound to the instance to fix a pattern where
     * animation.stop is returned as a reference from a useEffect.
     */
    this.stop = () => {
      this.resolver.cancel();
      this.isStopped = true;
      if (this.state === "idle") return;
      this.teardown();
      const {
        onStop
      } = this.options;
      onStop && onStop();
    };
    const {
      name,
      motionValue,
      element,
      keyframes
    } = this.options;
    const KeyframeResolver$1 = (element === null || element === void 0 ? void 0 : element.KeyframeResolver) || KeyframeResolver;
    const onResolved = (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe);
    this.resolver = new KeyframeResolver$1(keyframes, onResolved, name, motionValue, element);
    this.resolver.scheduleResolve();
  }
  flatten() {
    super.flatten();
    // If we've already resolved the animation, re-initialise it
    if (this._resolved) {
      Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes));
    }
  }
  initPlayback(keyframes$1) {
    const {
      type = "keyframes",
      repeat = 0,
      repeatDelay = 0,
      repeatType,
      velocity = 0
    } = this.options;
    const generatorFactory = motionDom.isGenerator(type) ? type : generators[type] || keyframes;
    /**
     * If our generator doesn't support mixing numbers, we need to replace keyframes with
     * [0, 100] and then make a function that maps that to the actual keyframes.
     *
     * 100 is chosen instead of 1 as it works nicer with spring animations.
     */
    let mapPercentToKeyframes;
    let mirroredGenerator;
    if (generatorFactory !== keyframes && typeof keyframes$1[0] !== "number") {
      if (process.env.NODE_ENV !== "production") {
        motionUtils.invariant(keyframes$1.length === 2, `Only two keyframes currently supported with spring and inertia animations. Trying to animate ${keyframes$1}`);
      }
      mapPercentToKeyframes = pipe(percentToProgress, mix(keyframes$1[0], keyframes$1[1]));
      keyframes$1 = [0, 100];
    }
    const generator = generatorFactory({
      ...this.options,
      keyframes: keyframes$1
    });
    /**
     * If we have a mirror repeat type we need to create a second generator that outputs the
     * mirrored (not reversed) animation and later ping pong between the two generators.
     */
    if (repeatType === "mirror") {
      mirroredGenerator = generatorFactory({
        ...this.options,
        keyframes: [...keyframes$1].reverse(),
        velocity: -velocity
      });
    }
    /**
     * If duration is undefined and we have repeat options,
     * we need to calculate a duration from the generator.
     *
     * We set it to the generator itself to cache the duration.
     * Any timeline resolver will need to have already precalculated
     * the duration by this step.
     */
    if (generator.calculatedDuration === null) {
      generator.calculatedDuration = motionDom.calcGeneratorDuration(generator);
    }
    const {
      calculatedDuration
    } = generator;
    const resolvedDuration = calculatedDuration + repeatDelay;
    const totalDuration = resolvedDuration * (repeat + 1) - repeatDelay;
    return {
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      calculatedDuration,
      resolvedDuration,
      totalDuration
    };
  }
  onPostResolved() {
    const {
      autoplay = true
    } = this.options;
    this.play();
    if (this.pendingPlayState === "paused" || !autoplay) {
      this.pause();
    } else {
      this.state = this.pendingPlayState;
    }
  }
  tick(timestamp, sample = false) {
    const {
      resolved
    } = this;
    // If the animations has failed to resolve, return the final keyframe.
    if (!resolved) {
      const {
        keyframes
      } = this.options;
      return {
        done: true,
        value: keyframes[keyframes.length - 1]
      };
    }
    const {
      finalKeyframe,
      generator,
      mirroredGenerator,
      mapPercentToKeyframes,
      keyframes,
      calculatedDuration,
      totalDuration,
      resolvedDuration
    } = resolved;
    if (this.startTime === null) return generator.next(0);
    const {
      delay,
      repeat,
      repeatType,
      repeatDelay,
      onUpdate
    } = this.options;
    /**
     * requestAnimationFrame timestamps can come through as lower than
     * the startTime as set by performance.now(). Here we prevent this,
     * though in the future it could be possible to make setting startTime
     * a pending operation that gets resolved here.
     */
    if (this.speed > 0) {
      this.startTime = Math.min(this.startTime, timestamp);
    } else if (this.speed < 0) {
      this.startTime = Math.min(timestamp - totalDuration / this.speed, this.startTime);
    }
    // Update currentTime
    if (sample) {
      this.currentTime = timestamp;
    } else if (this.holdTime !== null) {
      this.currentTime = this.holdTime;
    } else {
      // Rounding the time because floating point arithmetic is not always accurate, e.g. 3000.367 - 1000.367 =
      // 2000.0000000000002. This is a problem when we are comparing the currentTime with the duration, for
      // example.
      this.currentTime = Math.round(timestamp - this.startTime) * this.speed;
    }
    // Rebase on delay
    const timeWithoutDelay = this.currentTime - delay * (this.speed >= 0 ? 1 : -1);
    const isInDelayPhase = this.speed >= 0 ? timeWithoutDelay < 0 : timeWithoutDelay > totalDuration;
    this.currentTime = Math.max(timeWithoutDelay, 0);
    // If this animation has finished, set the current time  to the total duration.
    if (this.state === "finished" && this.holdTime === null) {
      this.currentTime = totalDuration;
    }
    let elapsed = this.currentTime;
    let frameGenerator = generator;
    if (repeat) {
      /**
       * Get the current progress (0-1) of the animation. If t is >
       * than duration we'll get values like 2.5 (midway through the
       * third iteration)
       */
      const progress = Math.min(this.currentTime, totalDuration) / resolvedDuration;
      /**
       * Get the current iteration (0 indexed). For instance the floor of
       * 2.5 is 2.
       */
      let currentIteration = Math.floor(progress);
      /**
       * Get the current progress of the iteration by taking the remainder
       * so 2.5 is 0.5 through iteration 2
       */
      let iterationProgress = progress % 1.0;
      /**
       * If iteration progress is 1 we count that as the end
       * of the previous iteration.
       */
      if (!iterationProgress && progress >= 1) {
        iterationProgress = 1;
      }
      iterationProgress === 1 && currentIteration--;
      currentIteration = Math.min(currentIteration, repeat + 1);
      /**
       * Reverse progress if we're not running in "normal" direction
       */
      const isOddIteration = Boolean(currentIteration % 2);
      if (isOddIteration) {
        if (repeatType === "reverse") {
          iterationProgress = 1 - iterationProgress;
          if (repeatDelay) {
            iterationProgress -= repeatDelay / resolvedDuration;
          }
        } else if (repeatType === "mirror") {
          frameGenerator = mirroredGenerator;
        }
      }
      elapsed = clamp(0, 1, iterationProgress) * resolvedDuration;
    }
    /**
     * If we're in negative time, set state as the initial keyframe.
     * This prevents delay: x, duration: 0 animations from finishing
     * instantly.
     */
    const state = isInDelayPhase ? {
      done: false,
      value: keyframes[0]
    } : frameGenerator.next(elapsed);
    if (mapPercentToKeyframes) {
      state.value = mapPercentToKeyframes(state.value);
    }
    let {
      done
    } = state;
    if (!isInDelayPhase && calculatedDuration !== null) {
      done = this.speed >= 0 ? this.currentTime >= totalDuration : this.currentTime <= 0;
    }
    const isAnimationFinished = this.holdTime === null && (this.state === "finished" || this.state === "running" && done);
    if (isAnimationFinished && finalKeyframe !== undefined) {
      state.value = getFinalKeyframe(keyframes, this.options, finalKeyframe);
    }
    if (onUpdate) {
      onUpdate(state.value);
    }
    if (isAnimationFinished) {
      this.finish();
    }
    return state;
  }
  get duration() {
    const {
      resolved
    } = this;
    return resolved ? motionUtils.millisecondsToSeconds(resolved.calculatedDuration) : 0;
  }
  get time() {
    return motionUtils.millisecondsToSeconds(this.currentTime);
  }
  set time(newTime) {
    newTime = motionUtils.secondsToMilliseconds(newTime);
    this.currentTime = newTime;
    if (this.holdTime !== null || this.speed === 0) {
      this.holdTime = newTime;
    } else if (this.driver) {
      this.startTime = this.driver.now() - newTime / this.speed;
    }
  }
  get speed() {
    return this.playbackSpeed;
  }
  set speed(newSpeed) {
    const hasChanged = this.playbackSpeed !== newSpeed;
    this.playbackSpeed = newSpeed;
    if (hasChanged) {
      this.time = motionUtils.millisecondsToSeconds(this.currentTime);
    }
  }
  play() {
    if (!this.resolver.isScheduled) {
      this.resolver.resume();
    }
    if (!this._resolved) {
      this.pendingPlayState = "running";
      return;
    }
    if (this.isStopped) return;
    const {
      driver = frameloopDriver,
      onPlay,
      startTime
    } = this.options;
    if (!this.driver) {
      this.driver = driver(timestamp => this.tick(timestamp));
    }
    onPlay && onPlay();
    const now = this.driver.now();
    if (this.holdTime !== null) {
      this.startTime = now - this.holdTime;
    } else if (!this.startTime) {
      this.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    } else if (this.state === "finished") {
      this.startTime = now;
    }
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    this.cancelTime = this.startTime;
    this.holdTime = null;
    /**
     * Set playState to running only after we've used it in
     * the previous logic.
     */
    this.state = "running";
    this.driver.start();
  }
  pause() {
    var _a;
    if (!this._resolved) {
      this.pendingPlayState = "paused";
      return;
    }
    this.state = "paused";
    this.holdTime = (_a = this.currentTime) !== null && _a !== void 0 ? _a : 0;
  }
  complete() {
    if (this.state !== "running") {
      this.play();
    }
    this.pendingPlayState = this.state = "finished";
    this.holdTime = null;
  }
  finish() {
    this.teardown();
    this.state = "finished";
    const {
      onComplete
    } = this.options;
    onComplete && onComplete();
  }
  cancel() {
    if (this.cancelTime !== null) {
      this.tick(this.cancelTime);
    }
    this.teardown();
    this.updateFinishedPromise();
  }
  teardown() {
    this.state = "idle";
    this.stopDriver();
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    this.startTime = this.cancelTime = null;
    this.resolver.cancel();
  }
  stopDriver() {
    if (!this.driver) return;
    this.driver.stop();
    this.driver = undefined;
  }
  sample(time) {
    this.startTime = 0;
    return this.tick(time, true);
  }
}
// Legacy interface
function animateValue(options) {
  return new MainThreadAnimation(options);
}

/**
 * A list of values that can be hardware-accelerated.
 */
const acceleratedValues = new Set(["opacity", "clipPath", "filter", "transform"
// TODO: Can be accelerated but currently disabled until https://issues.chromium.org/issues/41491098 is resolved
// or until we implement support for linear() easing.
// "background-color"
]);
function startWaapiAnimation(element, valueName, keyframes, {
  delay = 0,
  duration = 300,
  repeat = 0,
  repeatType = "loop",
  ease = "easeInOut",
  times
} = {}) {
  const keyframeOptions = {
    [valueName]: keyframes
  };
  if (times) keyframeOptions.offset = times;
  const easing = motionDom.mapEasingToNativeEasing(ease, duration);
  /**
   * If this is an easing array, apply to keyframes, not animation as a whole
   */
  if (Array.isArray(easing)) keyframeOptions.easing = easing;
  return element.animate(keyframeOptions, {
    delay,
    duration,
    easing: !Array.isArray(easing) ? easing : "linear",
    fill: "both",
    iterations: repeat + 1,
    direction: repeatType === "reverse" ? "alternate" : "normal"
  });
}
const supportsWaapi = /*@__PURE__*/motionUtils.memo(() => Object.hasOwnProperty.call(Element.prototype, "animate"));

/**
 * 10ms is chosen here as it strikes a balance between smooth
 * results (more than one keyframe per frame at 60fps) and
 * keyframe quantity.
 */
const sampleDelta = 10; //ms
/**
 * Implement a practical max duration for keyframe generation
 * to prevent infinite loops
 */
const maxDuration = 20000;
/**
 * Check if an animation can run natively via WAAPI or requires pregenerated keyframes.
 * WAAPI doesn't support spring or function easings so we run these as JS animation before
 * handing off.
 */
function requiresPregeneratedKeyframes(options) {
  return motionDom.isGenerator(options.type) || options.type === "spring" || !motionDom.isWaapiSupportedEasing(options.ease);
}
function pregenerateKeyframes(keyframes, options) {
  /**
   * Create a main-thread animation to pregenerate keyframes.
   * We sample this at regular intervals to generate keyframes that we then
   * linearly interpolate between.
   */
  const sampleAnimation = new MainThreadAnimation({
    ...options,
    keyframes,
    repeat: 0,
    delay: 0,
    isGenerator: true
  });
  let state = {
    done: false,
    value: keyframes[0]
  };
  const pregeneratedKeyframes = [];
  /**
   * Bail after 20 seconds of pre-generated keyframes as it's likely
   * we're heading for an infinite loop.
   */
  let t = 0;
  while (!state.done && t < maxDuration) {
    state = sampleAnimation.sample(t);
    pregeneratedKeyframes.push(state.value);
    t += sampleDelta;
  }
  return {
    times: undefined,
    keyframes: pregeneratedKeyframes,
    duration: t - sampleDelta,
    ease: "linear"
  };
}
const unsupportedEasingFunctions = {
  anticipate,
  backInOut,
  circInOut
};
function isUnsupportedEase(key) {
  return key in unsupportedEasingFunctions;
}
class AcceleratedAnimation extends BaseAnimation {
  constructor(options) {
    super(options);
    const {
      name,
      motionValue,
      element,
      keyframes
    } = this.options;
    this.resolver = new DOMKeyframesResolver(keyframes, (resolvedKeyframes, finalKeyframe) => this.onKeyframesResolved(resolvedKeyframes, finalKeyframe), name, motionValue, element);
    this.resolver.scheduleResolve();
  }
  initPlayback(keyframes, finalKeyframe) {
    let {
      duration = 300,
      times,
      ease,
      type,
      motionValue,
      name,
      startTime
    } = this.options;
    /**
     * If element has since been unmounted, return false to indicate
     * the animation failed to initialised.
     */
    if (!motionValue.owner || !motionValue.owner.current) {
      return false;
    }
    /**
     * If the user has provided an easing function name that isn't supported
     * by WAAPI (like "anticipate"), we need to provide the corressponding
     * function. This will later get converted to a linear() easing function.
     */
    if (typeof ease === "string" && motionDom.supportsLinearEasing() && isUnsupportedEase(ease)) {
      ease = unsupportedEasingFunctions[ease];
    }
    /**
     * If this animation needs pre-generated keyframes then generate.
     */
    if (requiresPregeneratedKeyframes(this.options)) {
      const {
        onComplete,
        onUpdate,
        motionValue,
        element,
        ...options
      } = this.options;
      const pregeneratedAnimation = pregenerateKeyframes(keyframes, options);
      keyframes = pregeneratedAnimation.keyframes;
      // If this is a very short animation, ensure we have
      // at least two keyframes to animate between as older browsers
      // can't animate between a single keyframe.
      if (keyframes.length === 1) {
        keyframes[1] = keyframes[0];
      }
      duration = pregeneratedAnimation.duration;
      times = pregeneratedAnimation.times;
      ease = pregeneratedAnimation.ease;
      type = "keyframes";
    }
    const animation = startWaapiAnimation(motionValue.owner.current, name, keyframes, {
      ...this.options,
      duration,
      times,
      ease
    });
    // Override the browser calculated startTime with one synchronised to other JS
    // and WAAPI animations starting this event loop.
    animation.startTime = startTime !== null && startTime !== void 0 ? startTime : this.calcStartTime();
    if (this.pendingTimeline) {
      motionDom.attachTimeline(animation, this.pendingTimeline);
      this.pendingTimeline = undefined;
    } else {
      /**
       * Prefer the `onfinish` prop as it's more widely supported than
       * the `finished` promise.
       *
       * Here, we synchronously set the provided MotionValue to the end
       * keyframe. If we didn't, when the WAAPI animation is finished it would
       * be removed from the element which would then revert to its old styles.
       */
      animation.onfinish = () => {
        const {
          onComplete
        } = this.options;
        motionValue.set(getFinalKeyframe(keyframes, this.options, finalKeyframe));
        onComplete && onComplete();
        this.cancel();
        this.resolveFinishedPromise();
      };
    }
    return {
      animation,
      duration,
      times,
      type,
      ease,
      keyframes: keyframes
    };
  }
  get duration() {
    const {
      resolved
    } = this;
    if (!resolved) return 0;
    const {
      duration
    } = resolved;
    return motionUtils.millisecondsToSeconds(duration);
  }
  get time() {
    const {
      resolved
    } = this;
    if (!resolved) return 0;
    const {
      animation
    } = resolved;
    return motionUtils.millisecondsToSeconds(animation.currentTime || 0);
  }
  set time(newTime) {
    const {
      resolved
    } = this;
    if (!resolved) return;
    const {
      animation
    } = resolved;
    animation.currentTime = motionUtils.secondsToMilliseconds(newTime);
  }
  get speed() {
    const {
      resolved
    } = this;
    if (!resolved) return 1;
    const {
      animation
    } = resolved;
    return animation.playbackRate;
  }
  set speed(newSpeed) {
    const {
      resolved
    } = this;
    if (!resolved) return;
    const {
      animation
    } = resolved;
    animation.playbackRate = newSpeed;
  }
  get state() {
    const {
      resolved
    } = this;
    if (!resolved) return "idle";
    const {
      animation
    } = resolved;
    return animation.playState;
  }
  get startTime() {
    const {
      resolved
    } = this;
    if (!resolved) return null;
    const {
      animation
    } = resolved;
    // Coerce to number as TypeScript incorrectly types this
    // as CSSNumberish
    return animation.startTime;
  }
  /**
   * Replace the default DocumentTimeline with another AnimationTimeline.
   * Currently used for scroll animations.
   */
  attachTimeline(timeline) {
    if (!this._resolved) {
      this.pendingTimeline = timeline;
    } else {
      const {
        resolved
      } = this;
      if (!resolved) return motionUtils.noop;
      const {
        animation
      } = resolved;
      motionDom.attachTimeline(animation, timeline);
    }
    return motionUtils.noop;
  }
  play() {
    if (this.isStopped) return;
    const {
      resolved
    } = this;
    if (!resolved) return;
    const {
      animation
    } = resolved;
    if (animation.playState === "finished") {
      this.updateFinishedPromise();
    }
    animation.play();
  }
  pause() {
    const {
      resolved
    } = this;
    if (!resolved) return;
    const {
      animation
    } = resolved;
    animation.pause();
  }
  stop() {
    this.resolver.cancel();
    this.isStopped = true;
    if (this.state === "idle") return;
    this.resolveFinishedPromise();
    this.updateFinishedPromise();
    const {
      resolved
    } = this;
    if (!resolved) return;
    const {
      animation,
      keyframes,
      duration,
      type,
      ease,
      times
    } = resolved;
    if (animation.playState === "idle" || animation.playState === "finished") {
      return;
    }
    /**
     * WAAPI doesn't natively have any interruption capabilities.
     *
     * Rather than read commited styles back out of the DOM, we can
     * create a renderless JS animation and sample it twice to calculate
     * its current value, "previous" value, and therefore allow
     * Motion to calculate velocity for any subsequent animation.
     */
    if (this.time) {
      const {
        motionValue,
        onUpdate,
        onComplete,
        element,
        ...options
      } = this.options;
      const sampleAnimation = new MainThreadAnimation({
        ...options,
        keyframes,
        duration,
        type,
        ease,
        times,
        isGenerator: true
      });
      const sampleTime = motionUtils.secondsToMilliseconds(this.time);
      motionValue.setWithVelocity(sampleAnimation.sample(sampleTime - sampleDelta).value, sampleAnimation.sample(sampleTime).value, sampleDelta);
    }
    const {
      onStop
    } = this.options;
    onStop && onStop();
    this.cancel();
  }
  complete() {
    const {
      resolved
    } = this;
    if (!resolved) return;
    resolved.animation.finish();
  }
  cancel() {
    const {
      resolved
    } = this;
    if (!resolved) return;
    resolved.animation.cancel();
  }
  static supports(options) {
    const {
      motionValue,
      name,
      repeatDelay,
      repeatType,
      damping,
      type
    } = options;
    if (!motionValue || !motionValue.owner || !(motionValue.owner.current instanceof HTMLElement)) {
      return false;
    }
    const {
      onUpdate,
      transformTemplate
    } = motionValue.owner.getProps();
    return supportsWaapi() && name && acceleratedValues.has(name) &&
    /**
     * If we're outputting values to onUpdate then we can't use WAAPI as there's
     * no way to read the value from WAAPI every frame.
     */
    !onUpdate && !transformTemplate && !repeatDelay && repeatType !== "mirror" && damping !== 0 && type !== "inertia";
  }
}
const underDampedSpring = {
  type: "spring",
  stiffness: 500,
  damping: 25,
  restSpeed: 10
};
const criticallyDampedSpring = target => ({
  type: "spring",
  stiffness: 550,
  damping: target === 0 ? 2 * Math.sqrt(550) : 30,
  restSpeed: 10
});
const keyframesTransition = {
  type: "keyframes",
  duration: 0.8
};
/**
 * Default easing curve is a slightly shallower version of
 * the default browser easing curve.
 */
const ease = {
  type: "keyframes",
  ease: [0.25, 0.1, 0.35, 1],
  duration: 0.3
};
const getDefaultTransition = (valueKey, {
  keyframes
}) => {
  if (keyframes.length > 2) {
    return keyframesTransition;
  } else if (transformProps.has(valueKey)) {
    return valueKey.startsWith("scale") ? criticallyDampedSpring(keyframes[1]) : underDampedSpring;
  }
  return ease;
};

/**
 * Decide whether a transition is defined on a given Transition.
 * This filters out orchestration options and returns true
 * if any options are left.
 */
function isTransitionDefined({
  when,
  delay: _delay,
  delayChildren,
  staggerChildren,
  staggerDirection,
  repeat,
  repeatType,
  repeatDelay,
  from,
  elapsed,
  ...transition
}) {
  return !!Object.keys(transition).length;
}
const animateMotionValue = (name, value, target, transition = {}, element, isHandoff) => onComplete => {
  const valueTransition = motionDom.getValueTransition(transition, name) || {};
  /**
   * Most transition values are currently completely overwritten by value-specific
   * transitions. In the future it'd be nicer to blend these transitions. But for now
   * delay actually does inherit from the root transition if not value-specific.
   */
  const delay = valueTransition.delay || transition.delay || 0;
  /**
   * Elapsed isn't a public transition option but can be passed through from
   * optimized appear effects in milliseconds.
   */
  let {
    elapsed = 0
  } = transition;
  elapsed = elapsed - motionUtils.secondsToMilliseconds(delay);
  let options = {
    keyframes: Array.isArray(target) ? target : [null, target],
    ease: "easeOut",
    velocity: value.getVelocity(),
    ...valueTransition,
    delay: -elapsed,
    onUpdate: v => {
      value.set(v);
      valueTransition.onUpdate && valueTransition.onUpdate(v);
    },
    onComplete: () => {
      onComplete();
      valueTransition.onComplete && valueTransition.onComplete();
    },
    name,
    motionValue: value,
    element: isHandoff ? undefined : element
  };
  /**
   * If there's no transition defined for this value, we can generate
   * unqiue transition settings for this value.
   */
  if (!isTransitionDefined(valueTransition)) {
    options = {
      ...options,
      ...getDefaultTransition(name, options)
    };
  }
  /**
   * Both WAAPI and our internal animation functions use durations
   * as defined by milliseconds, while our external API defines them
   * as seconds.
   */
  if (options.duration) {
    options.duration = motionUtils.secondsToMilliseconds(options.duration);
  }
  if (options.repeatDelay) {
    options.repeatDelay = motionUtils.secondsToMilliseconds(options.repeatDelay);
  }
  if (options.from !== undefined) {
    options.keyframes[0] = options.from;
  }
  let shouldSkip = false;
  if (options.type === false || options.duration === 0 && !options.repeatDelay) {
    options.duration = 0;
    if (options.delay === 0) {
      shouldSkip = true;
    }
  }
  if (instantAnimationState.current || MotionGlobalConfig.skipAnimations) {
    shouldSkip = true;
    options.duration = 0;
    options.delay = 0;
  }
  /**
   * If we can or must skip creating the animation, and apply only
   * the final keyframe, do so. We also check once keyframes are resolved but
   * this early check prevents the need to create an animation at all.
   */
  if (shouldSkip && !isHandoff && value.get() !== undefined) {
    const finalKeyframe = getFinalKeyframe(options.keyframes, valueTransition);
    if (finalKeyframe !== undefined) {
      frame.update(() => {
        options.onUpdate(finalKeyframe);
        options.onComplete();
      });
      // We still want to return some animation controls here rather
      // than returning undefined
      return new motionDom.GroupPlaybackControls([]);
    }
  }
  /**
   * Animate via WAAPI if possible. If this is a handoff animation, the optimised animation will be running via
   * WAAPI. Therefore, this animation must be JS to ensure it runs "under" the
   * optimised animation.
   */
  if (!isHandoff && AcceleratedAnimation.supports(options)) {
    return new AcceleratedAnimation(options);
  } else {
    return new MainThreadAnimation(options);
  }
};

/**
 * Decide whether we should block this animation. Previously, we achieved this
 * just by checking whether the key was listed in protectedKeys, but this
 * posed problems if an animation was triggered by afterChildren and protectedKeys
 * had been set to true in the meantime.
 */
function shouldBlockAnimation({
  protectedKeys,
  needsAnimating
}, key) {
  const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}
function animateTarget(visualElement, targetAndTransition, {
  delay = 0,
  transitionOverride,
  type
} = {}) {
  var _a;
  let {
    transition = visualElement.getDefaultTransition(),
    transitionEnd,
    ...target
  } = targetAndTransition;
  if (transitionOverride) transition = transitionOverride;
  const animations = [];
  const animationTypeState = type && visualElement.animationState && visualElement.animationState.getState()[type];
  for (const key in target) {
    const value = visualElement.getValue(key, (_a = visualElement.latestValues[key]) !== null && _a !== void 0 ? _a : null);
    const valueTarget = target[key];
    if (valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    const valueTransition = {
      delay,
      ...motionDom.getValueTransition(transition || {}, key)
    };
    /**
     * If this is the first time a value is being animated, check
     * to see if we're handling off from an existing animation.
     */
    let isHandoff = false;
    if (window.MotionHandoffAnimation) {
      const appearId = getOptimisedAppearId(visualElement);
      if (appearId) {
        const startTime = window.MotionHandoffAnimation(appearId, key, frame);
        if (startTime !== null) {
          valueTransition.startTime = startTime;
          isHandoff = true;
        }
      }
    }
    addValueToWillChange(visualElement, key);
    value.start(animateMotionValue(key, value, valueTarget, visualElement.shouldReduceMotion && positionalKeys.has(key) ? {
      type: false
    } : valueTransition, visualElement, isHandoff));
    const animation = value.animation;
    if (animation) {
      animations.push(animation);
    }
  }
  if (transitionEnd) {
    Promise.all(animations).then(() => {
      frame.update(() => {
        transitionEnd && setTarget(visualElement, transitionEnd);
      });
    });
  }
  return animations;
}
function animateVariant(visualElement, variant, options = {}) {
  var _a;
  const resolved = resolveVariant(visualElement, variant, options.type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);
  let {
    transition = visualElement.getDefaultTransition() || {}
  } = resolved || {};
  if (options.transitionOverride) {
    transition = options.transitionOverride;
  }
  /**
   * If we have a variant, create a callback that runs it as an animation.
   * Otherwise, we resolve a Promise immediately for a composable no-op.
   */
  const getAnimation = resolved ? () => Promise.all(animateTarget(visualElement, resolved, options)) : () => Promise.resolve();
  /**
   * If we have children, create a callback that runs all their animations.
   * Otherwise, we resolve a Promise immediately for a composable no-op.
   */
  const getChildAnimations = visualElement.variantChildren && visualElement.variantChildren.size ? (forwardDelay = 0) => {
    const {
      delayChildren = 0,
      staggerChildren,
      staggerDirection
    } = transition;
    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : () => Promise.resolve();
  /**
   * If the transition explicitly defines a "when" option, we need to resolve either
   * this animation or all children animations before playing the other.
   */
  const {
    when
  } = transition;
  if (when) {
    const [first, last] = when === "beforeChildren" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation];
    return first().then(() => last());
  } else {
    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);
  }
}
function animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {
  const animations = [];
  const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;
  const generateStaggerDuration = staggerDirection === 1 ? (i = 0) => i * staggerChildren : (i = 0) => maxStaggerDuration - i * staggerChildren;
  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach((child, i) => {
    child.notify("AnimationStart", variant);
    animations.push(animateVariant(child, variant, {
      ...options,
      delay: delayChildren + generateStaggerDuration(i)
    }).then(() => child.notify("AnimationComplete", variant)));
  });
  return Promise.all(animations);
}
function sortByTreeOrder(a, b) {
  return a.sortNodePosition(b);
}
function animateVisualElement(visualElement, definition, options = {}) {
  visualElement.notify("AnimationStart", definition);
  let animation;
  if (Array.isArray(definition)) {
    const animations = definition.map(variant => animateVariant(visualElement, variant, options));
    animation = Promise.all(animations);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement, definition, options);
  } else {
    const resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement, definition, options.custom) : definition;
    animation = Promise.all(animateTarget(visualElement, resolvedDefinition, options));
  }
  return animation.then(() => {
    visualElement.notify("AnimationComplete", definition);
  });
}
const numVariantProps = variantProps.length;
function getVariantContext(visualElement) {
  if (!visualElement) return undefined;
  if (!visualElement.isControllingVariants) {
    const context = visualElement.parent ? getVariantContext(visualElement.parent) || {} : {};
    if (visualElement.props.initial !== undefined) {
      context.initial = visualElement.props.initial;
    }
    return context;
  }
  const context = {};
  for (let i = 0; i < numVariantProps; i++) {
    const name = variantProps[i];
    const prop = visualElement.props[name];
    if (isVariantLabel(prop) || prop === false) {
      context[name] = prop;
    }
  }
  return context;
}
const reversePriorityOrder = [...variantPriorityOrder].reverse();
const numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement) {
  return animations => Promise.all(animations.map(({
    animation,
    options
  }) => animateVisualElement(visualElement, animation, options)));
}
function createAnimationState(visualElement) {
  let animate = animateList(visualElement);
  let state = createState();
  let isInitialRender = true;
  /**
   * This function will be used to reduce the animation definitions for
   * each active animation type into an object of resolved values for it.
   */
  const buildResolvedTypeValues = type => (acc, definition) => {
    var _a;
    const resolved = resolveVariant(visualElement, definition, type === "exit" ? (_a = visualElement.presenceContext) === null || _a === void 0 ? void 0 : _a.custom : undefined);
    if (resolved) {
      const {
        transition,
        transitionEnd,
        ...target
      } = resolved;
      acc = {
        ...acc,
        ...target,
        ...transitionEnd
      };
    }
    return acc;
  };
  /**
   * This just allows us to inject mocked animation functions
   * @internal
   */
  function setAnimateFunction(makeAnimator) {
    animate = makeAnimator(visualElement);
  }
  /**
   * When we receive new props, we need to:
   * 1. Create a list of protected keys for each type. This is a directory of
   *    value keys that are currently being "handled" by types of a higher priority
   *    so that whenever an animation is played of a given type, these values are
   *    protected from being animated.
   * 2. Determine if an animation type needs animating.
   * 3. Determine if any values have been removed from a type and figure out
   *    what to animate those to.
   */
  function animateChanges(changedActiveType) {
    const {
      props
    } = visualElement;
    const context = getVariantContext(visualElement.parent) || {};
    /**
     * A list of animations that we'll build into as we iterate through the animation
     * types. This will get executed at the end of the function.
     */
    const animations = [];
    /**
     * Keep track of which values have been removed. Then, as we hit lower priority
     * animation types, we can check if they contain removed values and animate to that.
     */
    const removedKeys = new Set();
    /**
     * A dictionary of all encountered keys. This is an object to let us build into and
     * copy it without iteration. Each time we hit an animation type we set its protected
     * keys - the keys its not allowed to animate - to the latest version of this object.
     */
    let encounteredKeys = {};
    /**
     * If a variant has been removed at a given index, and this component is controlling
     * variant animations, we want to ensure lower-priority variants are forced to animate.
     */
    let removedVariantIndex = Infinity;
    /**
     * Iterate through all animation types in reverse priority order. For each, we want to
     * detect which values it's handling and whether or not they've changed (and therefore
     * need to be animated). If any values have been removed, we want to detect those in
     * lower priority props and flag for animation.
     */
    for (let i = 0; i < numAnimationTypes; i++) {
      const type = reversePriorityOrder[i];
      const typeState = state[type];
      const prop = props[type] !== undefined ? props[type] : context[type];
      const propIsVariant = isVariantLabel(prop);
      /**
       * If this type has *just* changed isActive status, set activeDelta
       * to that status. Otherwise set to null.
       */
      const activeDelta = type === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false) removedVariantIndex = i;
      /**
       * If this prop is an inherited variant, rather than been set directly on the
       * component itself, we want to make sure we allow the parent to trigger animations.
       *
       * TODO: Can probably change this to a !isControllingVariants check
       */
      let isInherited = prop === context[type] && prop !== props[type] && propIsVariant;
      /**
       *
       */
      if (isInherited && isInitialRender && visualElement.manuallyAnimateOnMount) {
        isInherited = false;
      }
      /**
       * Set all encountered keys so far as the protected keys for this type. This will
       * be any key that has been animated or otherwise handled by active, higher-priortiy types.
       */
      typeState.protectedKeys = {
        ...encounteredKeys
      };
      // Check if we can skip analysing this prop early
      if (
      // If it isn't active and hasn't *just* been set as inactive
      !typeState.isActive && activeDelta === null ||
      // If we didn't and don't have any defined prop for this animation type
      !prop && !typeState.prevProp ||
      // Or if the prop doesn't define an animation
      isAnimationControls(prop) || typeof prop === "boolean") {
        continue;
      }
      /**
       * As we go look through the values defined on this type, if we detect
       * a changed value or a value that was removed in a higher priority, we set
       * this to true and add this prop to the animation list.
       */
      const variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      let shouldAnimateType = variantDidChange ||
      // If we're making this variant active, we want to always make it active
      type === changedActiveType && typeState.isActive && !isInherited && propIsVariant ||
      // If we removed a higher-priority variant (i is in reverse order)
      i > removedVariantIndex && propIsVariant;
      let handledRemovedValues = false;
      /**
       * As animations can be set as variant lists, variants or target objects, we
       * coerce everything to an array if it isn't one already
       */
      const definitionList = Array.isArray(prop) ? prop : [prop];
      /**
       * Build an object of all the resolved values. We'll use this in the subsequent
       * animateChanges calls to determine whether a value has changed.
       */
      let resolvedValues = definitionList.reduce(buildResolvedTypeValues(type), {});
      if (activeDelta === false) resolvedValues = {};
      /**
       * Now we need to loop through all the keys in the prev prop and this prop,
       * and decide:
       * 1. If the value has changed, and needs animating
       * 2. If it has been removed, and needs adding to the removedKeys set
       * 3. If it has been removed in a higher priority type and needs animating
       * 4. If it hasn't been removed in a higher priority but hasn't changed, and
       *    needs adding to the type's protectedKeys list.
       */
      const {
        prevResolvedValues = {}
      } = typeState;
      const allKeys = {
        ...prevResolvedValues,
        ...resolvedValues
      };
      const markToAnimate = key => {
        shouldAnimateType = true;
        if (removedKeys.has(key)) {
          handledRemovedValues = true;
          removedKeys.delete(key);
        }
        typeState.needsAnimating[key] = true;
        const motionValue = visualElement.getValue(key);
        if (motionValue) motionValue.liveStyle = false;
      };
      for (const key in allKeys) {
        const next = resolvedValues[key];
        const prev = prevResolvedValues[key];
        // If we've already handled this we can just skip ahead
        if (encounteredKeys.hasOwnProperty(key)) continue;
        /**
         * If the value has changed, we probably want to animate it.
         */
        let valueHasChanged = false;
        if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
          valueHasChanged = !shallowCompare(next, prev);
        } else {
          valueHasChanged = next !== prev;
        }
        if (valueHasChanged) {
          if (next !== undefined && next !== null) {
            // If next is defined and doesn't equal prev, it needs animating
            markToAnimate(key);
          } else {
            // If it's undefined, it's been removed.
            removedKeys.add(key);
          }
        } else if (next !== undefined && removedKeys.has(key)) {
          /**
           * If next hasn't changed and it isn't undefined, we want to check if it's
           * been removed by a higher priority
           */
          markToAnimate(key);
        } else {
          /**
           * If it hasn't changed, we add it to the list of protected values
           * to ensure it doesn't get animated.
           */
          typeState.protectedKeys[key] = true;
        }
      }
      /**
       * Update the typeState so next time animateChanges is called we can compare the
       * latest prop and resolvedValues to these.
       */
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      /**
       *
       */
      if (typeState.isActive) {
        encounteredKeys = {
          ...encounteredKeys,
          ...resolvedValues
        };
      }
      if (isInitialRender && visualElement.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      /**
       * If this is an inherited prop we want to skip this animation
       * unless the inherited variants haven't changed on this render.
       */
      const willAnimateViaParent = isInherited && variantDidChange;
      const needsAnimating = !willAnimateViaParent || handledRemovedValues;
      if (shouldAnimateType && needsAnimating) {
        animations.push(...definitionList.map(animation => ({
          animation: animation,
          options: {
            type
          }
        })));
      }
    }
    /**
     * If there are some removed value that haven't been dealt with,
     * we need to create a new animation that falls back either to the value
     * defined in the style prop, or the last read value.
     */
    if (removedKeys.size) {
      const fallbackAnimation = {};
      removedKeys.forEach(key => {
        const fallbackTarget = visualElement.getBaseTarget(key);
        const motionValue = visualElement.getValue(key);
        if (motionValue) motionValue.liveStyle = true;
        // @ts-expect-error - @mattgperry to figure if we should do something here
        fallbackAnimation[key] = fallbackTarget !== null && fallbackTarget !== void 0 ? fallbackTarget : null;
      });
      animations.push({
        animation: fallbackAnimation
      });
    }
    let shouldAnimate = Boolean(animations.length);
    if (isInitialRender && (props.initial === false || props.initial === props.animate) && !visualElement.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate(animations) : Promise.resolve();
  }
  /**
   * Change whether a certain animation type is active.
   */
  function setActive(type, isActive) {
    var _a;
    // If the active state hasn't changed, we can safely do nothing here
    if (state[type].isActive === isActive) return Promise.resolve();
    // Propagate active change to children
    (_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.forEach(child => {
      var _a;
      return (_a = child.animationState) === null || _a === void 0 ? void 0 : _a.setActive(type, isActive);
    });
    state[type].isActive = isActive;
    const animations = animateChanges(type);
    for (const key in state) {
      state[key].protectedKeys = {};
    }
    return animations;
  }
  return {
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: () => state,
    reset: () => {
      state = createState();
      isInitialRender = true;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (Array.isArray(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive = false) {
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  return {
    animate: createTypeState(true),
    whileInView: createTypeState(),
    whileHover: createTypeState(),
    whileTap: createTypeState(),
    whileDrag: createTypeState(),
    whileFocus: createTypeState(),
    exit: createTypeState()
  };
}
class Feature {
  constructor(node) {
    this.isMounted = false;
    this.node = node;
  }
  update() {}
}
class AnimationFeature extends Feature {
  /**
   * We dynamically generate the AnimationState manager as it contains a reference
   * to the underlying animation library. We only want to load that if we load this,
   * so people can optionally code split it out using the `m` component.
   */
  constructor(node) {
    super(node);
    node.animationState || (node.animationState = createAnimationState(node));
  }
  updateAnimationControlsSubscription() {
    const {
      animate
    } = this.node.getProps();
    if (isAnimationControls(animate)) {
      this.unmountControls = animate.subscribe(this.node);
    }
  }
  /**
   * Subscribe any provided AnimationControls to the component's VisualElement
   */
  mount() {
    this.updateAnimationControlsSubscription();
  }
  update() {
    const {
      animate
    } = this.node.getProps();
    const {
      animate: prevAnimate
    } = this.node.prevProps || {};
    if (animate !== prevAnimate) {
      this.updateAnimationControlsSubscription();
    }
  }
  unmount() {
    var _a;
    this.node.animationState.reset();
    (_a = this.unmountControls) === null || _a === void 0 ? void 0 : _a.call(this);
  }
}
let id$2 = 0;
class ExitAnimationFeature extends Feature {
  constructor() {
    super(...arguments);
    this.id = id$2++;
  }
  update() {
    if (!this.node.presenceContext) return;
    const {
      isPresent,
      onExitComplete
    } = this.node.presenceContext;
    const {
      isPresent: prevIsPresent
    } = this.node.prevPresenceContext || {};
    if (!this.node.animationState || isPresent === prevIsPresent) {
      return;
    }
    const exitAnimation = this.node.animationState.setActive("exit", !isPresent);
    if (onExitComplete && !isPresent) {
      exitAnimation.then(() => onExitComplete(this.id));
    }
  }
  mount() {
    const {
      register
    } = this.node.presenceContext || {};
    if (register) {
      this.unmount = register(this.id);
    }
  }
  unmount() {}
}
const animations = {
  animation: {
    Feature: AnimationFeature
  },
  exit: {
    Feature: ExitAnimationFeature
  }
};
const MotionContext = React.createContext({});
const createAxisDelta = () => ({
  translate: 0,
  scale: 1,
  origin: 0,
  originPoint: 0
});
const createDelta = () => ({
  x: createAxisDelta(),
  y: createAxisDelta()
});
const createAxis = () => ({
  min: 0,
  max: 0
});
const createBox = () => ({
  x: createAxis(),
  y: createAxis()
});
const SCALE_PRECISION = 0.0001;
const SCALE_MIN = 1 - SCALE_PRECISION;
const SCALE_MAX = 1 + SCALE_PRECISION;
const TRANSLATE_PRECISION = 0.01;
const TRANSLATE_MIN = 0 - TRANSLATE_PRECISION;
const TRANSLATE_MAX = 0 + TRANSLATE_PRECISION;
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  return Math.abs(value - target) <= maxDistance;
}
function calcAxisDelta(delta, source, target, origin = 0.5) {
  delta.origin = origin;
  delta.originPoint = mixNumber$1(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  delta.translate = mixNumber$1(target.min, target.max, delta.origin) - delta.originPoint;
  if (delta.scale >= SCALE_MIN && delta.scale <= SCALE_MAX || isNaN(delta.scale)) {
    delta.scale = 1.0;
  }
  if (delta.translate >= TRANSLATE_MIN && delta.translate <= TRANSLATE_MAX || isNaN(delta.translate)) {
    delta.translate = 0.0;
  }
}
function calcBoxDelta(delta, source, target, origin) {
  calcAxisDelta(delta.x, source.x, target.x, origin ? origin.originX : undefined);
  calcAxisDelta(delta.y, source.y, target.y, origin ? origin.originY : undefined);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}

/**
 * A list of all valid MotionProps.
 *
 * @privateRemarks
 * This doesn't throw if a `MotionProp` name is missing - it should.
 */
const validMotionProps = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);
/**
 * Check whether a prop name is a valid `MotionProp` key.
 *
 * @param key - Name of the property to check
 * @returns `true` is key is a valid `MotionProp`.
 *
 * @public
 */
function isValidMotionProp(key) {
  return key.startsWith("while") || key.startsWith("drag") && key !== "draggable" || key.startsWith("layout") || key.startsWith("onTap") || key.startsWith("onPan") || key.startsWith("onLayout") || validMotionProps.has(key);
}
let shouldForward = key => !isValidMotionProp(key);
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp) return;
  // Explicitly filter our events
  shouldForward = key => key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
}
/**
 * Emotion and Styled Components both allow users to pass through arbitrary props to their components
 * to dynamically generate CSS. They both use the `@emotion/is-prop-valid` package to determine which
 * of these should be passed to the underlying DOM node.
 *
 * However, when styling a Motion component `styled(motion.div)`, both packages pass through *all* props
 * as it's seen as an arbitrary component rather than a DOM node. Motion only allows arbitrary props
 * passed through the `custom` prop so it doesn't *need* the payload or computational overhead of
 * `@emotion/is-prop-valid`, however to fix this problem we need to use it.
 *
 * By making it an optionalDependency we can offer this functionality only in the situations where it's
 * actually required.
 */
try {
  /**
   * We attempt to import this package but require won't be defined in esm environments, in that case
   * isPropValid will have to be provided via `MotionContext`. In a 6.0.0 this should probably be removed
   * in favour of explicit injection.
   */
  loadExternalIsValidProp(require("@emotion/is-prop-valid").default);
} catch (_a) {
  // We don't need to actually do anything here - the fallback is the existing `isPropValid`.
}
function filterProps(props, isDom, forwardMotionProps) {
  const filteredProps = {};
  for (const key in props) {
    /**
     * values is considered a valid prop by Emotion, so if it's present
     * this will be rendered out to the DOM unless explicitly filtered.
     *
     * We check the type as it could be used with the `feColorMatrix`
     * element, which we support.
     */
    if (key === "values" && typeof props.values === "object") continue;
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) ||
    // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

/**
 * @public
 */
const PresenceContext = React.createContext(null);
function isControllingVariants(props) {
  return isAnimationControls(props.animate) || variantProps.some(name => isVariantLabel(props[name]));
}
function isVariantNode(props) {
  return Boolean(isControllingVariants(props) || props.variants);
}

/**
 * Creates a constant value over the lifecycle of a component.
 *
 * Even if `useMemo` is provided an empty array as its final argument, it doesn't offer
 * a guarantee that it won't re-run for performance reasons later on. By using `useConstant`
 * you can ensure that initialisers don't execute twice or more.
 */
function useConstant(init) {
  const ref = React.useRef(null);
  if (ref.current === null) {
    ref.current = init();
  }
  return ref.current;
}

/**
 * If the provided value is a MotionValue, this returns the actual value, otherwise just the value itself
 *
 * TODO: Remove and move to library
 */
function resolveMotionValue(value) {
  const unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}
function makeState({
  scrapeMotionValuesFromProps,
  createRenderState,
  onUpdate
}, props, context, presenceContext) {
  const state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps),
    renderState: createRenderState()
  };
  if (onUpdate) {
    /**
     * onMount works without the VisualElement because it could be
     * called before the VisualElement payload has been hydrated.
     * (e.g. if someone is using m components <m.circle />)
     */
    state.onMount = instance => onUpdate({
      props,
      current: instance,
      ...state
    });
    state.onUpdate = visualElement => onUpdate(visualElement);
  }
  return state;
}
const makeUseVisualState = config => (props, isStatic) => {
  const context = React.useContext(MotionContext);
  const presenceContext = React.useContext(PresenceContext);
  const make = () => makeState(config, props, context, presenceContext);
  return isStatic ? make() : useConstant(make);
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  const values = {};
  const motionValues = scrapeMotionValues(props, {});
  for (const key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  let {
    initial,
    animate
  } = props;
  const isControllingVariants$1 = isControllingVariants(props);
  const isVariantNode$1 = isVariantNode(props);
  if (context && isVariantNode$1 && !isControllingVariants$1 && props.inherit !== false) {
    if (initial === undefined) initial = context.initial;
    if (animate === undefined) animate = context.animate;
  }
  let isInitialAnimationBlocked = presenceContext ? presenceContext.initial === false : false;
  isInitialAnimationBlocked = isInitialAnimationBlocked || initial === false;
  const variantToSet = isInitialAnimationBlocked ? animate : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    const list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    for (let i = 0; i < list.length; i++) {
      const resolved = resolveVariantFromProps(props, list[i]);
      if (resolved) {
        const {
          transitionEnd,
          transition,
          ...target
        } = resolved;
        for (const key in target) {
          let valueTarget = target[key];
          if (Array.isArray(valueTarget)) {
            /**
             * Take final keyframe if the initial animation is blocked because
             * we want to initialise at the end of that blocked animation.
             */
            const index = isInitialAnimationBlocked ? valueTarget.length - 1 : 0;
            valueTarget = valueTarget[index];
          }
          if (valueTarget !== null) {
            values[key] = valueTarget;
          }
        }
        for (const key in transitionEnd) {
          values[key] = transitionEnd[key];
        }
      }
    }
  }
  return values;
}
function addDomEvent(target, eventName, handler, options = {
  passive: true
}) {
  target.addEventListener(eventName, handler, options);
  return () => target.removeEventListener(eventName, handler);
}
function extractEventInfo(event) {
  return {
    point: {
      x: event.pageX,
      y: event.pageY
    }
  };
}
const addPointerInfo = handler => {
  return event => motionDom.isPrimaryPointer(event) && handler(event, extractEventInfo(event));
};
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, eventName, addPointerInfo(handler), options);
}
const isBrowser = typeof window !== "undefined";
function useUnmountEffect(callback) {
  return React.useEffect(() => () => callback(), []);
}
const useIsomorphicLayoutEffect = isBrowser ? React.useLayoutEffect : React.useEffect;
function useIsMounted() {
  const isMounted = React.useRef(false);
  useIsomorphicLayoutEffect(() => {
    isMounted.current = true;
    return () => {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}
function useForceUpdate() {
  const isMounted = useIsMounted();
  const [forcedRenderCount, setForcedRenderCount] = React.useState(0);
  const forceRender = React.useCallback(() => {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  /**
   * Defer this to the end of the next animation frame in case there are multiple
   * synchronous calls.
   */
  const deferredForceRender = React.useCallback(() => frame.postRender(forceRender), [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}

/**
 * @public
 */
const MotionConfigContext = React.createContext({
  transformPagePoint: p => p,
  isStatic: false,
  reducedMotion: "never"
});

/**
 * Measurement functionality has to be within a separate component
 * to leverage snapshot lifecycle.
 */
class PopChildMeasure extends React__namespace.Component {
  getSnapshotBeforeUpdate(prevProps) {
    const element = this.props.childRef.current;
    if (element && prevProps.isPresent && !this.props.isPresent) {
      const size = this.props.sizeRef.current;
      size.height = element.offsetHeight || 0;
      size.width = element.offsetWidth || 0;
      size.top = element.offsetTop;
      size.left = element.offsetLeft;
    }
    return null;
  }
  /**
   * Required with getSnapshotBeforeUpdate to stop React complaining.
   */
  componentDidUpdate() {}
  render() {
    return this.props.children;
  }
}
function PopChild({
  children,
  isPresent
}) {
  const id = React.useId();
  const ref = React.useRef(null);
  const size = React.useRef({
    width: 0,
    height: 0,
    top: 0,
    left: 0
  });
  const {
    nonce
  } = React.useContext(MotionConfigContext);
  /**
   * We create and inject a style block so we can apply this explicit
   * sizing in a non-destructive manner by just deleting the style block.
   *
   * We can't apply size via render as the measurement happens
   * in getSnapshotBeforeUpdate (post-render), likewise if we apply the
   * styles directly on the DOM node, we might be overwriting
   * styles set via the style prop.
   */
  React.useInsertionEffect(() => {
    const {
      width,
      height,
      top,
      left
    } = size.current;
    if (isPresent || !ref.current || !width || !height) return;
    ref.current.dataset.motionPopId = id;
    const style = document.createElement("style");
    if (nonce) style.nonce = nonce;
    document.head.appendChild(style);
    if (style.sheet) {
      style.sheet.insertRule(`
          [data-motion-pop-id="${id}"] {
            position: absolute !important;
            width: ${width}px !important;
            height: ${height}px !important;
            top: ${top}px !important;
            left: ${left}px !important;
          }
        `);
    }
    return () => {
      document.head.removeChild(style);
    };
  }, [isPresent]);
  return jsxRuntime.jsx(PopChildMeasure, {
    isPresent: isPresent,
    childRef: ref,
    sizeRef: size,
    children: React__namespace.cloneElement(children, {
      ref
    })
  });
}
const PresenceChild = ({
  children,
  initial,
  isPresent,
  onExitComplete,
  custom,
  presenceAffectsLayout,
  mode
}) => {
  const presenceChildren = useConstant(newChildrenMap);
  const id = React.useId();
  const memoizedOnExitComplete = React.useCallback(childId => {
    presenceChildren.set(childId, true);
    for (const isComplete of presenceChildren.values()) {
      if (!isComplete) return; // can stop searching when any is incomplete
    }
    onExitComplete && onExitComplete();
  }, [presenceChildren, onExitComplete]);
  const context = React.useMemo(() => ({
    id,
    initial,
    isPresent,
    custom,
    onExitComplete: memoizedOnExitComplete,
    register: childId => {
      presenceChildren.set(childId, false);
      return () => presenceChildren.delete(childId);
    }
  }),
  /**
   * If the presence of a child affects the layout of the components around it,
   * we want to make a new context value to ensure they get re-rendered
   * so they can detect that layout change.
   */
  presenceAffectsLayout ? [Math.random(), memoizedOnExitComplete] : [isPresent, memoizedOnExitComplete]);
  React.useMemo(() => {
    presenceChildren.forEach((_, key) => presenceChildren.set(key, false));
  }, [isPresent]);
  /**
   * If there's no `motion` components to fire exit animations, we want to remove this
   * component immediately.
   */
  React__namespace.useEffect(() => {
    !isPresent && !presenceChildren.size && onExitComplete && onExitComplete();
  }, [isPresent]);
  if (mode === "popLayout") {
    children = jsxRuntime.jsx(PopChild, {
      isPresent: isPresent,
      children: children
    });
  }
  return jsxRuntime.jsx(PresenceContext.Provider, {
    value: context,
    children: children
  });
};
function newChildrenMap() {
  return new Map();
}

/**
 * When a component is the child of `AnimatePresence`, it can use `usePresence`
 * to access information about whether it's still present in the React tree.
 *
 * ```jsx
 * import { usePresence } from "framer-motion"
 *
 * export const Component = () => {
 *   const [isPresent, safeToRemove] = usePresence()
 *
 *   useEffect(() => {
 *     !isPresent && setTimeout(safeToRemove, 1000)
 *   }, [isPresent])
 *
 *   return <div />
 * }
 * ```
 *
 * If `isPresent` is `false`, it means that a component has been removed the tree, but
 * `AnimatePresence` won't really remove it until `safeToRemove` has been called.
 *
 * @public
 */
function usePresence(subscribe = true) {
  const context = React.useContext(PresenceContext);
  if (context === null) return [true, null];
  const {
    isPresent,
    onExitComplete,
    register
  } = context;
  // It's safe to call the following hooks conditionally (after an early return) because the context will always
  // either be null or non-null for the lifespan of the component.
  const id = React.useId();
  React.useEffect(() => {
    if (subscribe) register(id);
  }, [subscribe]);
  const safeToRemove = React.useCallback(() => subscribe && onExitComplete && onExitComplete(id), [id, onExitComplete, subscribe]);
  return !isPresent && onExitComplete ? [false, safeToRemove] : [true];
}
/**
 * Similar to `usePresence`, except `useIsPresent` simply returns whether or not the component is present.
 * There is no `safeToRemove` function.
 *
 * ```jsx
 * import { useIsPresent } from "framer-motion"
 *
 * export const Component = () => {
 *   const isPresent = useIsPresent()
 *
 *   useEffect(() => {
 *     !isPresent && console.log("I've been removed!")
 *   }, [isPresent])
 *
 *   return <div />
 * }
 * ```
 *
 * @public
 */
function useIsPresent() {
  return isPresent(React.useContext(PresenceContext));
}
function isPresent(context) {
  return context === null ? true : context.isPresent;
}
const getChildKey = child => child.key || "";
function onlyElements(children) {
  const filtered = [];
  // We use forEach here instead of map as map mutates the component key by preprending `.$`
  React.Children.forEach(children, child => {
    if (React.isValidElement(child)) filtered.push(child);
  });
  return filtered;
}

/**
 * `AnimatePresence` enables the animation of components that have been removed from the tree.
 *
 * When adding/removing more than a single child, every child **must** be given a unique `key` prop.
 *
 * Any `motion` components that have an `exit` property defined will animate out when removed from
 * the tree.
 *
 * ```jsx
 * import { motion, AnimatePresence } from 'framer-motion'
 *
 * export const Items = ({ items }) => (
 *   <AnimatePresence>
 *     {items.map(item => (
 *       <motion.div
 *         key={item.id}
 *         initial={{ opacity: 0 }}
 *         animate={{ opacity: 1 }}
 *         exit={{ opacity: 0 }}
 *       />
 *     ))}
 *   </AnimatePresence>
 * )
 * ```
 *
 * You can sequence exit animations throughout a tree using variants.
 *
 * If a child contains multiple `motion` components with `exit` props, it will only unmount the child
 * once all `motion` components have finished animating out. Likewise, any components using
 * `usePresence` all need to call `safeToRemove`.
 *
 * @public
 */
const AnimatePresence = ({
  children,
  custom,
  initial = true,
  onExitComplete,
  presenceAffectsLayout = true,
  mode = "sync",
  propagate = false
}) => {
  const [isParentPresent, safeToRemove] = usePresence(propagate);
  /**
   * Filter any children that aren't ReactElements. We can only track components
   * between renders with a props.key.
   */
  const presentChildren = React.useMemo(() => onlyElements(children), [children]);
  /**
   * Track the keys of the currently rendered children. This is used to
   * determine which children are exiting.
   */
  const presentKeys = propagate && !isParentPresent ? [] : presentChildren.map(getChildKey);
  /**
   * If `initial={false}` we only want to pass this to components in the first render.
   */
  const isInitialRender = React.useRef(true);
  /**
   * A ref containing the currently present children. When all exit animations
   * are complete, we use this to re-render the component with the latest children
   * *committed* rather than the latest children *rendered*.
   */
  const pendingPresentChildren = React.useRef(presentChildren);
  /**
   * Track which exiting children have finished animating out.
   */
  const exitComplete = useConstant(() => new Map());
  /**
   * Save children to render as React state. To ensure this component is concurrent-safe,
   * we check for exiting children via an effect.
   */
  const [diffedChildren, setDiffedChildren] = React.useState(presentChildren);
  const [renderedChildren, setRenderedChildren] = React.useState(presentChildren);
  useIsomorphicLayoutEffect(() => {
    isInitialRender.current = false;
    pendingPresentChildren.current = presentChildren;
    /**
     * Update complete status of exiting children.
     */
    for (let i = 0; i < renderedChildren.length; i++) {
      const key = getChildKey(renderedChildren[i]);
      if (!presentKeys.includes(key)) {
        if (exitComplete.get(key) !== true) {
          exitComplete.set(key, false);
        }
      } else {
        exitComplete.delete(key);
      }
    }
  }, [renderedChildren, presentKeys.length, presentKeys.join("-")]);
  const exitingChildren = [];
  if (presentChildren !== diffedChildren) {
    let nextChildren = [...presentChildren];
    /**
     * Loop through all the currently rendered components and decide which
     * are exiting.
     */
    for (let i = 0; i < renderedChildren.length; i++) {
      const child = renderedChildren[i];
      const key = getChildKey(child);
      if (!presentKeys.includes(key)) {
        nextChildren.splice(i, 0, child);
        exitingChildren.push(child);
      }
    }
    /**
     * If we're in "wait" mode, and we have exiting children, we want to
     * only render these until they've all exited.
     */
    if (mode === "wait" && exitingChildren.length) {
      nextChildren = exitingChildren;
    }
    setRenderedChildren(onlyElements(nextChildren));
    setDiffedChildren(presentChildren);
    /**
     * Early return to ensure once we've set state with the latest diffed
     * children, we can immediately re-render.
     */
    return;
  }
  if (process.env.NODE_ENV !== "production" && mode === "wait" && renderedChildren.length > 1) {
    console.warn(`You're attempting to animate multiple children within AnimatePresence, but its mode is set to "wait". This will lead to odd visual behaviour.`);
  }
  /**
   * If we've been provided a forceRender function by the LayoutGroupContext,
   * we can use it to force a re-render amongst all surrounding components once
   * all components have finished animating out.
   */
  const {
    forceRender
  } = React.useContext(LayoutGroupContext);
  return jsxRuntime.jsx(jsxRuntime.Fragment, {
    children: renderedChildren.map(child => {
      const key = getChildKey(child);
      const isPresent = propagate && !isParentPresent ? false : presentChildren === renderedChildren || presentKeys.includes(key);
      const onExit = () => {
        if (exitComplete.has(key)) {
          exitComplete.set(key, true);
        } else {
          return;
        }
        let isEveryExitComplete = true;
        exitComplete.forEach(isExitComplete => {
          if (!isExitComplete) isEveryExitComplete = false;
        });
        if (isEveryExitComplete) {
          forceRender === null || forceRender === void 0 ? void 0 : forceRender();
          setRenderedChildren(pendingPresentChildren.current);
          propagate && (safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove());
          onExitComplete && onExitComplete();
        }
      };
      return jsxRuntime.jsx(PresenceChild, {
        isPresent: isPresent,
        initial: !isInitialRender.current || initial ? undefined : false,
        custom: isPresent ? undefined : custom,
        presenceAffectsLayout: presenceAffectsLayout,
        mode: mode,
        onExitComplete: isPresent ? undefined : onExit,
        children: child
      }, key);
    })
  });
};

/**
 * Note: Still used by components generated by old versions of Framer
 *
 * @deprecated
 */
const DeprecatedLayoutGroupContext = React.createContext(null);
function animateSingleValue(value, keyframes, options) {
  const motionValue$1 = isMotionValue(value) ? value : motionValue(value);
  motionValue$1.start(animateMotionValue("", motionValue$1, keyframes, options));
  return motionValue$1.animation;
}
const wrap = (min, max, v) => {
  const rangeSize = max - min;
  return ((v - min) % rangeSize + rangeSize) % rangeSize + min;
};
function getEasingForSegment(easing, i) {
  return isEasingArray(easing) ? easing[wrap(0, easing.length, i)] : easing;
}
function isDOMKeyframes(keyframes) {
  return typeof keyframes === "object" && !Array.isArray(keyframes);
}
function resolveSubjects(subject, keyframes, scope, selectorCache) {
  if (typeof subject === "string" && isDOMKeyframes(keyframes)) {
    return motionDom.resolveElements(subject, scope, selectorCache);
  } else if (subject instanceof NodeList) {
    return Array.from(subject);
  } else if (Array.isArray(subject)) {
    return subject;
  } else {
    return [subject];
  }
}
function calculateRepeatDuration(duration, repeat, _repeatDelay) {
  return duration * (repeat + 1);
}

/**
 * Given a absolute or relative time definition and current/prev time state of the sequence,
 * calculate an absolute time for the next keyframes.
 */
function calcNextTime(current, next, prev, labels) {
  var _a;
  if (typeof next === "number") {
    return next;
  } else if (next.startsWith("-") || next.startsWith("+")) {
    return Math.max(0, current + parseFloat(next));
  } else if (next === "<") {
    return prev;
  } else {
    return (_a = labels.get(next)) !== null && _a !== void 0 ? _a : current;
  }
}
function eraseKeyframes(sequence, startTime, endTime) {
  for (let i = 0; i < sequence.length; i++) {
    const keyframe = sequence[i];
    if (keyframe.at > startTime && keyframe.at < endTime) {
      removeItem(sequence, keyframe);
      // If we remove this item we have to push the pointer back one
      i--;
    }
  }
}
function addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {
  /**
   * Erase every existing value between currentTime and targetTime,
   * this will essentially splice this timeline into any currently
   * defined ones.
   */
  eraseKeyframes(sequence, startTime, endTime);
  for (let i = 0; i < keyframes.length; i++) {
    sequence.push({
      value: keyframes[i],
      at: mixNumber$1(startTime, endTime, offset[i]),
      easing: getEasingForSegment(easing, i)
    });
  }
}

/**
 * Take an array of times that represent repeated keyframes. For instance
 * if we have original times of [0, 0.5, 1] then our repeated times will
 * be [0, 0.5, 1, 1, 1.5, 2]. Loop over the times and scale them back
 * down to a 0-1 scale.
 */
function normalizeTimes(times, repeat) {
  for (let i = 0; i < times.length; i++) {
    times[i] = times[i] / (repeat + 1);
  }
}
function compareByTime(a, b) {
  if (a.at === b.at) {
    if (a.value === null) return 1;
    if (b.value === null) return -1;
    return 0;
  } else {
    return a.at - b.at;
  }
}
const defaultSegmentEasing = "easeInOut";
const MAX_REPEAT = 20;
function createAnimationsFromSequence(sequence, {
  defaultTransition = {},
  ...sequenceTransition
} = {}, scope, generators) {
  const defaultDuration = defaultTransition.duration || 0.3;
  const animationDefinitions = new Map();
  const sequences = new Map();
  const elementCache = {};
  const timeLabels = new Map();
  let prevTime = 0;
  let currentTime = 0;
  let totalDuration = 0;
  /**
   * Build the timeline by mapping over the sequence array and converting
   * the definitions into keyframes and offsets with absolute time values.
   * These will later get converted into relative offsets in a second pass.
   */
  for (let i = 0; i < sequence.length; i++) {
    const segment = sequence[i];
    /**
     * If this is a timeline label, mark it and skip the rest of this iteration.
     */
    if (typeof segment === "string") {
      timeLabels.set(segment, currentTime);
      continue;
    } else if (!Array.isArray(segment)) {
      timeLabels.set(segment.name, calcNextTime(currentTime, segment.at, prevTime, timeLabels));
      continue;
    }
    let [subject, keyframes, transition = {}] = segment;
    /**
     * If a relative or absolute time value has been specified we need to resolve
     * it in relation to the currentTime.
     */
    if (transition.at !== undefined) {
      currentTime = calcNextTime(currentTime, transition.at, prevTime, timeLabels);
    }
    /**
     * Keep track of the maximum duration in this definition. This will be
     * applied to currentTime once the definition has been parsed.
     */
    let maxDuration = 0;
    const resolveValueSequence = (valueKeyframes, valueTransition, valueSequence, elementIndex = 0, numSubjects = 0) => {
      const valueKeyframesAsList = keyframesAsList(valueKeyframes);
      const {
        delay = 0,
        times = defaultOffset$1(valueKeyframesAsList),
        type = "keyframes",
        repeat,
        repeatType,
        repeatDelay = 0,
        ...remainingTransition
      } = valueTransition;
      let {
        ease = defaultTransition.ease || "easeOut",
        duration
      } = valueTransition;
      /**
       * Resolve stagger() if defined.
       */
      const calculatedDelay = typeof delay === "function" ? delay(elementIndex, numSubjects) : delay;
      /**
       * If this animation should and can use a spring, generate a spring easing function.
       */
      const numKeyframes = valueKeyframesAsList.length;
      const createGenerator = motionDom.isGenerator(type) ? type : generators === null || generators === void 0 ? void 0 : generators[type];
      if (numKeyframes <= 2 && createGenerator) {
        /**
         * As we're creating an easing function from a spring,
         * ideally we want to generate it using the real distance
         * between the two keyframes. However this isn't always
         * possible - in these situations we use 0-100.
         */
        let absoluteDelta = 100;
        if (numKeyframes === 2 && isNumberKeyframesArray(valueKeyframesAsList)) {
          const delta = valueKeyframesAsList[1] - valueKeyframesAsList[0];
          absoluteDelta = Math.abs(delta);
        }
        const springTransition = {
          ...remainingTransition
        };
        if (duration !== undefined) {
          springTransition.duration = motionUtils.secondsToMilliseconds(duration);
        }
        const springEasing = motionDom.createGeneratorEasing(springTransition, absoluteDelta, createGenerator);
        ease = springEasing.ease;
        duration = springEasing.duration;
      }
      duration !== null && duration !== void 0 ? duration : duration = defaultDuration;
      const startTime = currentTime + calculatedDelay;
      /**
       * If there's only one time offset of 0, fill in a second with length 1
       */
      if (times.length === 1 && times[0] === 0) {
        times[1] = 1;
      }
      /**
       * Fill out if offset if fewer offsets than keyframes
       */
      const remainder = times.length - valueKeyframesAsList.length;
      remainder > 0 && fillOffset(times, remainder);
      /**
       * If only one value has been set, ie [1], push a null to the start of
       * the keyframe array. This will let us mark a keyframe at this point
       * that will later be hydrated with the previous value.
       */
      valueKeyframesAsList.length === 1 && valueKeyframesAsList.unshift(null);
      /**
       * Handle repeat options
       */
      if (repeat) {
        motionUtils.invariant(repeat < MAX_REPEAT, "Repeat count too high, must be less than 20");
        duration = calculateRepeatDuration(duration, repeat);
        const originalKeyframes = [...valueKeyframesAsList];
        const originalTimes = [...times];
        ease = Array.isArray(ease) ? [...ease] : [ease];
        const originalEase = [...ease];
        for (let repeatIndex = 0; repeatIndex < repeat; repeatIndex++) {
          valueKeyframesAsList.push(...originalKeyframes);
          for (let keyframeIndex = 0; keyframeIndex < originalKeyframes.length; keyframeIndex++) {
            times.push(originalTimes[keyframeIndex] + (repeatIndex + 1));
            ease.push(keyframeIndex === 0 ? "linear" : getEasingForSegment(originalEase, keyframeIndex - 1));
          }
        }
        normalizeTimes(times, repeat);
      }
      const targetTime = startTime + duration;
      /**
       * Add keyframes, mapping offsets to absolute time.
       */
      addKeyframes(valueSequence, valueKeyframesAsList, ease, times, startTime, targetTime);
      maxDuration = Math.max(calculatedDelay + duration, maxDuration);
      totalDuration = Math.max(targetTime, totalDuration);
    };
    if (isMotionValue(subject)) {
      const subjectSequence = getSubjectSequence(subject, sequences);
      resolveValueSequence(keyframes, transition, getValueSequence("default", subjectSequence));
    } else {
      const subjects = resolveSubjects(subject, keyframes, scope, elementCache);
      const numSubjects = subjects.length;
      /**
       * For every element in this segment, process the defined values.
       */
      for (let subjectIndex = 0; subjectIndex < numSubjects; subjectIndex++) {
        /**
         * Cast necessary, but we know these are of this type
         */
        keyframes = keyframes;
        transition = transition;
        const thisSubject = subjects[subjectIndex];
        const subjectSequence = getSubjectSequence(thisSubject, sequences);
        for (const key in keyframes) {
          resolveValueSequence(keyframes[key], getValueTransition(transition, key), getValueSequence(key, subjectSequence), subjectIndex, numSubjects);
        }
      }
    }
    prevTime = currentTime;
    currentTime += maxDuration;
  }
  /**
   * For every element and value combination create a new animation.
   */
  sequences.forEach((valueSequences, element) => {
    for (const key in valueSequences) {
      const valueSequence = valueSequences[key];
      /**
       * Arrange all the keyframes in ascending time order.
       */
      valueSequence.sort(compareByTime);
      const keyframes = [];
      const valueOffset = [];
      const valueEasing = [];
      /**
       * For each keyframe, translate absolute times into
       * relative offsets based on the total duration of the timeline.
       */
      for (let i = 0; i < valueSequence.length; i++) {
        const {
          at,
          value,
          easing
        } = valueSequence[i];
        keyframes.push(value);
        valueOffset.push(motionUtils.progress(0, totalDuration, at));
        valueEasing.push(easing || "easeOut");
      }
      /**
       * If the first keyframe doesn't land on offset: 0
       * provide one by duplicating the initial keyframe. This ensures
       * it snaps to the first keyframe when the animation starts.
       */
      if (valueOffset[0] !== 0) {
        valueOffset.unshift(0);
        keyframes.unshift(keyframes[0]);
        valueEasing.unshift(defaultSegmentEasing);
      }
      /**
       * If the last keyframe doesn't land on offset: 1
       * provide one with a null wildcard value. This will ensure it
       * stays static until the end of the animation.
       */
      if (valueOffset[valueOffset.length - 1] !== 1) {
        valueOffset.push(1);
        keyframes.push(null);
      }
      if (!animationDefinitions.has(element)) {
        animationDefinitions.set(element, {
          keyframes: {},
          transition: {}
        });
      }
      const definition = animationDefinitions.get(element);
      definition.keyframes[key] = keyframes;
      definition.transition[key] = {
        ...defaultTransition,
        duration: totalDuration,
        ease: valueEasing,
        times: valueOffset,
        ...sequenceTransition
      };
    }
  });
  return animationDefinitions;
}
function getSubjectSequence(subject, sequences) {
  !sequences.has(subject) && sequences.set(subject, {});
  return sequences.get(subject);
}
function getValueSequence(name, sequences) {
  if (!sequences[name]) sequences[name] = [];
  return sequences[name];
}
function keyframesAsList(keyframes) {
  return Array.isArray(keyframes) ? keyframes : [keyframes];
}
function getValueTransition(transition, key) {
  return transition && transition[key] ? {
    ...transition,
    ...transition[key]
  } : {
    ...transition
  };
}
const isNumber = keyframe => typeof keyframe === "number";
const isNumberKeyframesArray = keyframes => keyframes.every(isNumber);
const visualElementStore = new WeakMap();
function isSVGElement(element) {
  return element instanceof SVGElement && element.tagName !== "svg";
}
const featureProps = {
  animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
  exit: ["exit"],
  drag: ["drag", "dragControls"],
  focus: ["whileFocus"],
  hover: ["whileHover", "onHoverStart", "onHoverEnd"],
  tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
  pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
  inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
  layout: ["layout", "layoutId"]
};
const featureDefinitions = {};
for (const key in featureProps) {
  featureDefinitions[key] = {
    isEnabled: props => featureProps[key].some(name => !!props[name])
  };
}

// Does this device prefer reduced motion? Returns `null` server-side.
const prefersReducedMotion = {
  current: null
};
const hasReducedMotionListener = {
  current: false
};
function initPrefersReducedMotion() {
  hasReducedMotionListener.current = true;
  if (!isBrowser) return;
  if (window.matchMedia) {
    const motionMediaQuery = window.matchMedia("(prefers-reduced-motion)");
    const setReducedMotionPreferences = () => prefersReducedMotion.current = motionMediaQuery.matches;
    motionMediaQuery.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}

/**
 * A list of all ValueTypes
 */
const valueTypes = [...dimensionValueTypes, color, complex];
/**
 * Tests a value against the list of ValueTypes
 */
const findValueType = v => valueTypes.find(testValueType(v));
function updateMotionValuesFromProps(element, next, prev) {
  for (const key in next) {
    const nextValue = next[key];
    const prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      /**
       * If this is a motion value found in props or style, we want to add it
       * to our visual element's motion value map.
       */
      element.addValue(key, nextValue);
      /**
       * Check the version of the incoming motion value with this version
       * and warn against mismatches.
       */
      if (process.env.NODE_ENV === "development") {
        warnOnce(nextValue.version === "11.18.2", `Attempting to mix Motion versions ${nextValue.version} with 11.18.2 may not work as expected.`);
      }
    } else if (isMotionValue(prevValue)) {
      /**
       * If we're swapping from a motion value to a static value,
       * create a new motion value from that
       */
      element.addValue(key, motionValue(nextValue, {
        owner: element
      }));
    } else if (prevValue !== nextValue) {
      /**
       * If this is a flat value that has changed, update the motion value
       * or create one if it doesn't exist. We only want to do this if we're
       * not handling the value with our animation state.
       */
      if (element.hasValue(key)) {
        const existingValue = element.getValue(key);
        if (existingValue.liveStyle === true) {
          existingValue.jump(nextValue);
        } else if (!existingValue.hasAnimated) {
          existingValue.set(nextValue);
        }
      } else {
        const latestValue = element.getStaticValue(key);
        element.addValue(key, motionValue(latestValue !== undefined ? latestValue : nextValue, {
          owner: element
        }));
      }
    }
  }
  // Handle removed values
  for (const key in prev) {
    if (next[key] === undefined) element.removeValue(key);
  }
  return next;
}
const propEventHandlers = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
/**
 * A VisualElement is an imperative abstraction around UI elements such as
 * HTMLElement, SVGElement, Three.Object3D etc.
 */
class VisualElement {
  /**
   * This method takes React props and returns found MotionValues. For example, HTML
   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.
   *
   * This isn't an abstract method as it needs calling in the constructor, but it is
   * intended to be one.
   */
  scrapeMotionValuesFromProps(_props, _prevProps, _visualElement) {
    return {};
  }
  constructor({
    parent,
    props,
    presenceContext,
    reducedMotionConfig,
    blockInitialAnimation,
    visualState
  }, options = {}) {
    /**
     * A reference to the current underlying Instance, e.g. a HTMLElement
     * or Three.Mesh etc.
     */
    this.current = null;
    /**
     * A set containing references to this VisualElement's children.
     */
    this.children = new Set();
    /**
     * Determine what role this visual element should take in the variant tree.
     */
    this.isVariantNode = false;
    this.isControllingVariants = false;
    /**
     * Decides whether this VisualElement should animate in reduced motion
     * mode.
     *
     * TODO: This is currently set on every individual VisualElement but feels
     * like it could be set globally.
     */
    this.shouldReduceMotion = null;
    /**
     * A map of all motion values attached to this visual element. Motion
     * values are source of truth for any given animated value. A motion
     * value might be provided externally by the component via props.
     */
    this.values = new Map();
    this.KeyframeResolver = KeyframeResolver;
    /**
     * Cleanup functions for active features (hover/tap/exit etc)
     */
    this.features = {};
    /**
     * A map of every subscription that binds the provided or generated
     * motion values onChange listeners to this visual element.
     */
    this.valueSubscriptions = new Map();
    /**
     * A reference to the previously-provided motion values as returned
     * from scrapeMotionValuesFromProps. We use the keys in here to determine
     * if any motion values need to be removed after props are updated.
     */
    this.prevMotionValues = {};
    /**
     * An object containing a SubscriptionManager for each active event.
     */
    this.events = {};
    /**
     * An object containing an unsubscribe function for each prop event subscription.
     * For example, every "Update" event can have multiple subscribers via
     * VisualElement.on(), but only one of those can be defined via the onUpdate prop.
     */
    this.propEventSubscriptions = {};
    this.notifyUpdate = () => this.notify("Update", this.latestValues);
    this.render = () => {
      if (!this.current) return;
      this.triggerBuild();
      this.renderInstance(this.current, this.renderState, this.props.style, this.projection);
    };
    this.renderScheduledAt = 0.0;
    this.scheduleRender = () => {
      const now = time.now();
      if (this.renderScheduledAt < now) {
        this.renderScheduledAt = now;
        frame.render(this.render, false, true);
      }
    };
    const {
      latestValues,
      renderState,
      onUpdate
    } = visualState;
    this.onUpdate = onUpdate;
    this.latestValues = latestValues;
    this.baseTarget = {
      ...latestValues
    };
    this.initialValues = props.initial ? {
      ...latestValues
    } : {};
    this.renderState = renderState;
    this.parent = parent;
    this.props = props;
    this.presenceContext = presenceContext;
    this.depth = parent ? parent.depth + 1 : 0;
    this.reducedMotionConfig = reducedMotionConfig;
    this.options = options;
    this.blockInitialAnimation = Boolean(blockInitialAnimation);
    this.isControllingVariants = isControllingVariants(props);
    this.isVariantNode = isVariantNode(props);
    if (this.isVariantNode) {
      this.variantChildren = new Set();
    }
    this.manuallyAnimateOnMount = Boolean(parent && parent.current);
    /**
     * Any motion values that are provided to the element when created
     * aren't yet bound to the element, as this would technically be impure.
     * However, we iterate through the motion values and set them to the
     * initial values for this component.
     *
     * TODO: This is impure and we should look at changing this to run on mount.
     * Doing so will break some tests but this isn't necessarily a breaking change,
     * more a reflection of the test.
     */
    const {
      willChange,
      ...initialMotionValues
    } = this.scrapeMotionValuesFromProps(props, {}, this);
    for (const key in initialMotionValues) {
      const value = initialMotionValues[key];
      if (latestValues[key] !== undefined && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
  }
  mount(instance) {
    this.current = instance;
    visualElementStore.set(instance, this);
    if (this.projection && !this.projection.instance) {
      this.projection.mount(instance);
    }
    if (this.parent && this.isVariantNode && !this.isControllingVariants) {
      this.removeFromVariantTree = this.parent.addVariantChild(this);
    }
    this.values.forEach((value, key) => this.bindToMotionValue(key, value));
    if (!hasReducedMotionListener.current) {
      initPrefersReducedMotion();
    }
    this.shouldReduceMotion = this.reducedMotionConfig === "never" ? false : this.reducedMotionConfig === "always" ? true : prefersReducedMotion.current;
    if (process.env.NODE_ENV !== "production") {
      warnOnce(this.shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
    }
    if (this.parent) this.parent.children.add(this);
    this.update(this.props, this.presenceContext);
  }
  unmount() {
    visualElementStore.delete(this.current);
    this.projection && this.projection.unmount();
    cancelFrame(this.notifyUpdate);
    cancelFrame(this.render);
    this.valueSubscriptions.forEach(remove => remove());
    this.valueSubscriptions.clear();
    this.removeFromVariantTree && this.removeFromVariantTree();
    this.parent && this.parent.children.delete(this);
    for (const key in this.events) {
      this.events[key].clear();
    }
    for (const key in this.features) {
      const feature = this.features[key];
      if (feature) {
        feature.unmount();
        feature.isMounted = false;
      }
    }
    this.current = null;
  }
  bindToMotionValue(key, value) {
    if (this.valueSubscriptions.has(key)) {
      this.valueSubscriptions.get(key)();
    }
    const valueIsTransform = transformProps.has(key);
    const removeOnChange = value.on("change", latestValue => {
      this.latestValues[key] = latestValue;
      this.props.onUpdate && frame.preRender(this.notifyUpdate);
      if (valueIsTransform && this.projection) {
        this.projection.isTransformDirty = true;
      }
    });
    const removeOnRenderRequest = value.on("renderRequest", this.scheduleRender);
    let removeSyncCheck;
    if (window.MotionCheckAppearSync) {
      removeSyncCheck = window.MotionCheckAppearSync(this, key, value);
    }
    this.valueSubscriptions.set(key, () => {
      removeOnChange();
      removeOnRenderRequest();
      if (removeSyncCheck) removeSyncCheck();
      if (value.owner) value.stop();
    });
  }
  sortNodePosition(other) {
    /**
     * If these nodes aren't even of the same type we can't compare their depth.
     */
    if (!this.current || !this.sortInstanceNodePosition || this.type !== other.type) {
      return 0;
    }
    return this.sortInstanceNodePosition(this.current, other.current);
  }
  updateFeatures() {
    let key = "animation";
    for (key in featureDefinitions) {
      const featureDefinition = featureDefinitions[key];
      if (!featureDefinition) continue;
      const {
        isEnabled,
        Feature: FeatureConstructor
      } = featureDefinition;
      /**
       * If this feature is enabled but not active, make a new instance.
       */
      if (!this.features[key] && FeatureConstructor && isEnabled(this.props)) {
        this.features[key] = new FeatureConstructor(this);
      }
      /**
       * If we have a feature, mount or update it.
       */
      if (this.features[key]) {
        const feature = this.features[key];
        if (feature.isMounted) {
          feature.update();
        } else {
          feature.mount();
          feature.isMounted = true;
        }
      }
    }
  }
  triggerBuild() {
    this.build(this.renderState, this.latestValues, this.props);
  }
  /**
   * Measure the current viewport box with or without transforms.
   * Only measures axis-aligned boxes, rotate and skew must be manually
   * removed with a re-render to work.
   */
  measureViewportBox() {
    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : createBox();
  }
  getStaticValue(key) {
    return this.latestValues[key];
  }
  setStaticValue(key, value) {
    this.latestValues[key] = value;
  }
  /**
   * Update the provided props. Ensure any newly-added motion values are
   * added to our map, old ones removed, and listeners updated.
   */
  update(props, presenceContext) {
    if (props.transformTemplate || this.props.transformTemplate) {
      this.scheduleRender();
    }
    this.prevProps = this.props;
    this.props = props;
    this.prevPresenceContext = this.presenceContext;
    this.presenceContext = presenceContext;
    /**
     * Update prop event handlers ie onAnimationStart, onAnimationComplete
     */
    for (let i = 0; i < propEventHandlers.length; i++) {
      const key = propEventHandlers[i];
      if (this.propEventSubscriptions[key]) {
        this.propEventSubscriptions[key]();
        delete this.propEventSubscriptions[key];
      }
      const listenerName = "on" + key;
      const listener = props[listenerName];
      if (listener) {
        this.propEventSubscriptions[key] = this.on(key, listener);
      }
    }
    this.prevMotionValues = updateMotionValuesFromProps(this, this.scrapeMotionValuesFromProps(props, this.prevProps, this), this.prevMotionValues);
    if (this.handleChildMotionValue) {
      this.handleChildMotionValue();
    }
    this.onUpdate && this.onUpdate(this);
  }
  getProps() {
    return this.props;
  }
  /**
   * Returns the variant definition with a given name.
   */
  getVariant(name) {
    return this.props.variants ? this.props.variants[name] : undefined;
  }
  /**
   * Returns the defined default transition on this component.
   */
  getDefaultTransition() {
    return this.props.transition;
  }
  getTransformPagePoint() {
    return this.props.transformPagePoint;
  }
  getClosestVariantNode() {
    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : undefined;
  }
  /**
   * Add a child visual element to our set of children.
   */
  addVariantChild(child) {
    const closestVariantNode = this.getClosestVariantNode();
    if (closestVariantNode) {
      closestVariantNode.variantChildren && closestVariantNode.variantChildren.add(child);
      return () => closestVariantNode.variantChildren.delete(child);
    }
  }
  /**
   * Add a motion value and bind it to this visual element.
   */
  addValue(key, value) {
    // Remove existing value if it exists
    const existingValue = this.values.get(key);
    if (value !== existingValue) {
      if (existingValue) this.removeValue(key);
      this.bindToMotionValue(key, value);
      this.values.set(key, value);
      this.latestValues[key] = value.get();
    }
  }
  /**
   * Remove a motion value and unbind any active subscriptions.
   */
  removeValue(key) {
    this.values.delete(key);
    const unsubscribe = this.valueSubscriptions.get(key);
    if (unsubscribe) {
      unsubscribe();
      this.valueSubscriptions.delete(key);
    }
    delete this.latestValues[key];
    this.removeValueFromRenderState(key, this.renderState);
  }
  /**
   * Check whether we have a motion value for this key
   */
  hasValue(key) {
    return this.values.has(key);
  }
  getValue(key, defaultValue) {
    if (this.props.values && this.props.values[key]) {
      return this.props.values[key];
    }
    let value = this.values.get(key);
    if (value === undefined && defaultValue !== undefined) {
      value = motionValue(defaultValue === null ? undefined : defaultValue, {
        owner: this
      });
      this.addValue(key, value);
    }
    return value;
  }
  /**
   * If we're trying to animate to a previously unencountered value,
   * we need to check for it in our state and as a last resort read it
   * directly from the instance (which might have performance implications).
   */
  readValue(key, target) {
    var _a;
    let value = this.latestValues[key] !== undefined || !this.current ? this.latestValues[key] : (_a = this.getBaseTargetFromProps(this.props, key)) !== null && _a !== void 0 ? _a : this.readValueFromInstance(this.current, key, this.options);
    if (value !== undefined && value !== null) {
      if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
        // If this is a number read as a string, ie "0" or "200", convert it to a number
        value = parseFloat(value);
      } else if (!findValueType(value) && complex.test(target)) {
        value = getAnimatableNone(key, target);
      }
      this.setBaseTarget(key, isMotionValue(value) ? value.get() : value);
    }
    return isMotionValue(value) ? value.get() : value;
  }
  /**
   * Set the base target to later animate back to. This is currently
   * only hydrated on creation and when we first read a value.
   */
  setBaseTarget(key, value) {
    this.baseTarget[key] = value;
  }
  /**
   * Find the base target for a value thats been removed from all animation
   * props.
   */
  getBaseTarget(key) {
    var _a;
    const {
      initial
    } = this.props;
    let valueFromInitial;
    if (typeof initial === "string" || typeof initial === "object") {
      const variant = resolveVariantFromProps(this.props, initial, (_a = this.presenceContext) === null || _a === void 0 ? void 0 : _a.custom);
      if (variant) {
        valueFromInitial = variant[key];
      }
    }
    /**
     * If this value still exists in the current initial variant, read that.
     */
    if (initial && valueFromInitial !== undefined) {
      return valueFromInitial;
    }
    /**
     * Alternatively, if this VisualElement config has defined a getBaseTarget
     * so we can read the value from an alternative source, try that.
     */
    const target = this.getBaseTargetFromProps(this.props, key);
    if (target !== undefined && !isMotionValue(target)) return target;
    /**
     * If the value was initially defined on initial, but it doesn't any more,
     * return undefined. Otherwise return the value as initially read from the DOM.
     */
    return this.initialValues[key] !== undefined && valueFromInitial === undefined ? undefined : this.baseTarget[key];
  }
  on(eventName, callback) {
    if (!this.events[eventName]) {
      this.events[eventName] = new SubscriptionManager();
    }
    return this.events[eventName].add(callback);
  }
  notify(eventName, ...args) {
    if (this.events[eventName]) {
      this.events[eventName].notify(...args);
    }
  }
}
class DOMVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.KeyframeResolver = DOMKeyframesResolver;
  }
  sortInstanceNodePosition(a, b) {
    /**
     * compareDocumentPosition returns a bitmask, by using the bitwise &
     * we're returning true if 2 in that bitmask is set to true. 2 is set
     * to true if b preceeds a.
     */
    return a.compareDocumentPosition(b) & 2 ? 1 : -1;
  }
  getBaseTargetFromProps(props, key) {
    return props.style ? props.style[key] : undefined;
  }
  removeValueFromRenderState(key, {
    vars,
    style
  }) {
    delete vars[key];
    delete style[key];
  }
  handleChildMotionValue() {
    if (this.childSubscription) {
      this.childSubscription();
      delete this.childSubscription;
    }
    const {
      children
    } = this.props;
    if (isMotionValue(children)) {
      this.childSubscription = children.on("change", latest => {
        if (this.current) {
          this.current.textContent = `${latest}`;
        }
      });
    }
  }
}

/**
 * Provided a value and a ValueType, returns the value as that value type.
 */
const getValueAsType = (value, type) => {
  return type && typeof value === "number" ? type.transform(value) : value;
};
const translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
const numTransforms = transformPropOrder.length;
/**
 * Build a CSS transform style from individual x/y/scale etc properties.
 *
 * This outputs with a default order of transforms/scales/rotations, this can be customised by
 * providing a transformTemplate function.
 */
function buildTransform(latestValues, transform, transformTemplate) {
  // The transform string we're going to build into.
  let transformString = "";
  let transformIsDefault = true;
  /**
   * Loop over all possible transforms in order, adding the ones that
   * are present to the transform string.
   */
  for (let i = 0; i < numTransforms; i++) {
    const key = transformPropOrder[i];
    const value = latestValues[key];
    if (value === undefined) continue;
    let valueIsDefault = true;
    if (typeof value === "number") {
      valueIsDefault = value === (key.startsWith("scale") ? 1 : 0);
    } else {
      valueIsDefault = parseFloat(value) === 0;
    }
    if (!valueIsDefault || transformTemplate) {
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (!valueIsDefault) {
        transformIsDefault = false;
        const transformName = translateAlias[key] || key;
        transformString += `${transformName}(${valueAsType}) `;
      }
      if (transformTemplate) {
        transform[key] = valueAsType;
      }
    }
  }
  transformString = transformString.trim();
  // If we have a custom `transform` template, pass our transform values and
  // generated transformString to that before returning
  if (transformTemplate) {
    transformString = transformTemplate(transform, transformIsDefault ? "" : transformString);
  } else if (transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildHTMLStyles(state, latestValues, transformTemplate) {
  const {
    style,
    vars,
    transformOrigin
  } = state;
  // Track whether we encounter any transform or transformOrigin values.
  let hasTransform = false;
  let hasTransformOrigin = false;
  /**
   * Loop over all our latest animated values and decide whether to handle them
   * as a style or CSS variable.
   *
   * Transforms and transform origins are kept separately for further processing.
   */
  for (const key in latestValues) {
    const value = latestValues[key];
    if (transformProps.has(key)) {
      // If this is a transform, flag to enable further transform processing
      hasTransform = true;
      continue;
    } else if (isCSSVariableName(key)) {
      vars[key] = value;
      continue;
    } else {
      // Convert the value to its default value type, ie 0 -> "0px"
      const valueAsType = getValueAsType(value, numberValueTypes[key]);
      if (key.startsWith("origin")) {
        // If this is a transform origin, flag and enable further transform-origin processing
        hasTransformOrigin = true;
        transformOrigin[key] = valueAsType;
      } else {
        style[key] = valueAsType;
      }
    }
  }
  if (!latestValues.transform) {
    if (hasTransform || transformTemplate) {
      style.transform = buildTransform(latestValues, state.transform, transformTemplate);
    } else if (style.transform) {
      /**
       * If we have previously created a transform but currently don't have any,
       * reset transform style to none.
       */
      style.transform = "none";
    }
  }
  /**
   * Build a transformOrigin style. Uses the same defaults as the browser for
   * undefined origins.
   */
  if (hasTransformOrigin) {
    const {
      originX = "50%",
      originY = "50%",
      originZ = 0
    } = transformOrigin;
    style.transformOrigin = `${originX} ${originY} ${originZ}`;
  }
}
const dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
const camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
/**
 * Build SVG path properties. Uses the path's measured length to convert
 * our custom pathLength, pathSpacing and pathOffset into stroke-dashoffset
 * and stroke-dasharray attributes.
 *
 * This function is mutative to reduce per-frame GC.
 */
function buildSVGPath(attrs, length, spacing = 1, offset = 0, useDashCase = true) {
  // Normalise path length by setting SVG attribute pathLength to 1
  attrs.pathLength = 1;
  // We use dash case when setting attributes directly to the DOM node and camel case
  // when defining props on a React component.
  const keys = useDashCase ? dashKeys : camelKeys;
  // Build the dash offset
  attrs[keys.offset] = px.transform(-offset);
  // Build the dash array
  const pathLength = px.transform(length);
  const pathSpacing = px.transform(spacing);
  attrs[keys.array] = `${pathLength} ${pathSpacing}`;
}
function calcOrigin$1(origin, offset, size) {
  return typeof origin === "string" ? origin : px.transform(offset + size * origin);
}
/**
 * The SVG transform origin defaults are different to CSS and is less intuitive,
 * so we use the measured dimensions of the SVG to reconcile these.
 */
function calcSVGTransformOrigin(dimensions, originX, originY) {
  const pxOriginX = calcOrigin$1(originX, dimensions.x, dimensions.width);
  const pxOriginY = calcOrigin$1(originY, dimensions.y, dimensions.height);
  return `${pxOriginX} ${pxOriginY}`;
}

/**
 * Build SVG visual attrbutes, like cx and style.transform
 */
function buildSVGAttrs(state, {
  attrX,
  attrY,
  attrScale,
  originX,
  originY,
  pathLength,
  pathSpacing = 1,
  pathOffset = 0,
  // This is object creation, which we try to avoid per-frame.
  ...latest
}, isSVGTag, transformTemplate) {
  buildHTMLStyles(state, latest, transformTemplate);
  /**
   * For svg tags we just want to make sure viewBox is animatable and treat all the styles
   * as normal HTML tags.
   */
  if (isSVGTag) {
    if (state.style.viewBox) {
      state.attrs.viewBox = state.style.viewBox;
    }
    return;
  }
  state.attrs = state.style;
  state.style = {};
  const {
    attrs,
    style,
    dimensions
  } = state;
  /**
   * However, we apply transforms as CSS transforms. So if we detect a transform we take it from attrs
   * and copy it into style.
   */
  if (attrs.transform) {
    if (dimensions) style.transform = attrs.transform;
    delete attrs.transform;
  }
  // Parse transformOrigin
  if (dimensions && (originX !== undefined || originY !== undefined || style.transform)) {
    style.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== undefined ? originX : 0.5, originY !== undefined ? originY : 0.5);
  }
  // Render attrX/attrY/attrScale as attributes
  if (attrX !== undefined) attrs.x = attrX;
  if (attrY !== undefined) attrs.y = attrY;
  if (attrScale !== undefined) attrs.scale = attrScale;
  // Build SVG path if one has been defined
  if (pathLength !== undefined) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

/**
 * A set of attribute names that are always read/written as camel case.
 */
const camelCaseAttributes = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);
const isSVGTag = tag => typeof tag === "string" && tag.toLowerCase() === "svg";
function renderHTML(element, {
  style,
  vars
}, styleProp, projection) {
  Object.assign(element.style, style, projection && projection.getProjectionStyles(styleProp));
  // Loop over any CSS variables and assign those.
  for (const key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, undefined, projection);
  for (const key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}
const scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}
function isForcedMotionValue(key, {
  layout,
  layoutId
}) {
  return transformProps.has(key) || key.startsWith("origin") || (layout || layoutId !== undefined) && (!!scaleCorrectors[key] || key === "opacity");
}
function scrapeMotionValuesFromProps$1(props, prevProps, visualElement) {
  var _a;
  const {
    style
  } = props;
  const newValues = {};
  for (const key in style) {
    if (isMotionValue(style[key]) || prevProps.style && isMotionValue(prevProps.style[key]) || isForcedMotionValue(key, props) || ((_a = visualElement === null || visualElement === void 0 ? void 0 : visualElement.getValue(key)) === null || _a === void 0 ? void 0 : _a.liveStyle) !== undefined) {
      newValues[key] = style[key];
    }
  }
  return newValues;
}
function scrapeMotionValuesFromProps(props, prevProps, visualElement) {
  const newValues = scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  for (const key in props) {
    if (isMotionValue(props[key]) || isMotionValue(prevProps[key])) {
      const targetKey = transformPropOrder.indexOf(key) !== -1 ? "attr" + key.charAt(0).toUpperCase() + key.substring(1) : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}
class SVGVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "svg";
    this.isSVGTag = false;
    this.measureInstanceViewportBox = createBox;
  }
  getBaseTargetFromProps(props, key) {
    return props[key];
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    }
    key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
    return instance.getAttribute(key);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps(props, prevProps, visualElement);
  }
  build(renderState, latestValues, props) {
    buildSVGAttrs(renderState, latestValues, this.isSVGTag, props.transformTemplate);
  }
  renderInstance(instance, renderState, styleProp, projection) {
    renderSVG(instance, renderState, styleProp, projection);
  }
  mount(instance) {
    this.isSVGTag = isSVGTag(instance.tagName);
    super.mount(instance);
  }
}

/**
 * Bounding boxes tend to be defined as top, left, right, bottom. For various operations
 * it's easier to consider each axis individually. This function returns a bounding box
 * as a map of single-axis min/max values.
 */
function convertBoundingBoxToBox({
  top,
  left,
  right,
  bottom
}) {
  return {
    x: {
      min: left,
      max: right
    },
    y: {
      min: top,
      max: bottom
    }
  };
}
function convertBoxToBoundingBox({
  x,
  y
}) {
  return {
    top: y.min,
    right: x.max,
    bottom: y.max,
    left: x.min
  };
}
/**
 * Applies a TransformPoint function to a bounding box. TransformPoint is usually a function
 * provided by Framer to allow measured points to be corrected for device scaling. This is used
 * when measuring DOM elements and DOM event points.
 */
function transformBoxPoints(point, transformPoint) {
  if (!transformPoint) return point;
  const topLeft = transformPoint({
    x: point.left,
    y: point.top
  });
  const bottomRight = transformPoint({
    x: point.right,
    y: point.bottom
  });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}
function isIdentityScale(scale) {
  return scale === undefined || scale === 1;
}
function hasScale({
  scale,
  scaleX,
  scaleY
}) {
  return !isIdentityScale(scale) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || has2DTranslate(values) || values.z || values.rotate || values.rotateX || values.rotateY || values.skewX || values.skewY;
}
function has2DTranslate(values) {
  return is2DTranslate(values.x) || is2DTranslate(values.y);
}
function is2DTranslate(value) {
  return value && value !== "0%";
}

/**
 * Scales a point based on a factor and an originPoint
 */
function scalePoint(point, scale, originPoint) {
  const distanceFromOrigin = point - originPoint;
  const scaled = scale * distanceFromOrigin;
  return originPoint + scaled;
}
/**
 * Applies a translate/scale delta to a point
 */
function applyPointDelta(point, translate, scale, originPoint, boxScale) {
  if (boxScale !== undefined) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale, originPoint) + translate;
}
/**
 * Applies a translate/scale delta to an axis
 */
function applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {
  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Applies a translate/scale delta to a box
 */
function applyBoxDelta(box, {
  x,
  y
}) {
  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);
  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);
}
const TREE_SCALE_SNAP_MIN = 0.999999999999;
const TREE_SCALE_SNAP_MAX = 1.0000000000001;
/**
 * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms
 * in a tree upon our box before then calculating how to project it into our desired viewport-relative box
 *
 * This is the final nested loop within updateLayoutDelta for future refactoring
 */
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {
  const treeLength = treePath.length;
  if (!treeLength) return;
  // Reset the treeScale
  treeScale.x = treeScale.y = 1;
  let node;
  let delta;
  for (let i = 0; i < treeLength; i++) {
    node = treePath[i];
    delta = node.projectionDelta;
    /**
     * TODO: Prefer to remove this, but currently we have motion components with
     * display: contents in Framer.
     */
    const {
      visualElement
    } = node.options;
    if (visualElement && visualElement.props.style && visualElement.props.style.display === "contents") {
      continue;
    }
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, {
        x: -node.scroll.offset.x,
        y: -node.scroll.offset.y
      });
    }
    if (delta) {
      // Incoporate each ancestor's scale into a culmulative treeScale for this component
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      // Apply each ancestor's calculated delta into this component's recorded layout box
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
  /**
   * Snap tree scale back to 1 if it's within a non-perceivable threshold.
   * This will help reduce useless scales getting rendered.
   */
  if (treeScale.x < TREE_SCALE_SNAP_MAX && treeScale.x > TREE_SCALE_SNAP_MIN) {
    treeScale.x = 1.0;
  }
  if (treeScale.y < TREE_SCALE_SNAP_MAX && treeScale.y > TREE_SCALE_SNAP_MIN) {
    treeScale.y = 1.0;
  }
}
function translateAxis(axis, distance) {
  axis.min = axis.min + distance;
  axis.max = axis.max + distance;
}
/**
 * Apply a transform to an axis from the latest resolved motion values.
 * This function basically acts as a bridge between a flat motion value map
 * and applyAxisDelta
 */
function transformAxis(axis, axisTranslate, axisScale, boxScale, axisOrigin = 0.5) {
  const originPoint = mixNumber$1(axis.min, axis.max, axisOrigin);
  // Apply the axis delta to the final axis
  applyAxisDelta(axis, axisTranslate, axisScale, originPoint, boxScale);
}
/**
 * Apply a transform to a box from the latest resolved motion values.
 */
function transformBox(box, transform) {
  transformAxis(box.x, transform.x, transform.scaleX, transform.scale, transform.originX);
  transformAxis(box.y, transform.y, transform.scaleY, transform.scale, transform.originY);
}
function measureViewportBox(instance, transformPoint) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint));
}
function measurePageBox(element, rootProjectionNode, transformPagePoint) {
  const viewportBox = measureViewportBox(element, transformPagePoint);
  const {
    scroll
  } = rootProjectionNode;
  if (scroll) {
    translateAxis(viewportBox.x, scroll.offset.x);
    translateAxis(viewportBox.y, scroll.offset.y);
  }
  return viewportBox;
}
function getComputedStyle$1(element) {
  return window.getComputedStyle(element);
}
class HTMLVisualElement extends DOMVisualElement {
  constructor() {
    super(...arguments);
    this.type = "html";
    this.renderInstance = renderHTML;
  }
  readValueFromInstance(instance, key) {
    if (transformProps.has(key)) {
      const defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      const computedStyle = getComputedStyle$1(instance);
      const value = (isCSSVariableName(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
      return typeof value === "string" ? value.trim() : value;
    }
  }
  measureInstanceViewportBox(instance, {
    transformPagePoint
  }) {
    return measureViewportBox(instance, transformPagePoint);
  }
  build(renderState, latestValues, props) {
    buildHTMLStyles(renderState, latestValues, props.transformTemplate);
  }
  scrapeMotionValuesFromProps(props, prevProps, visualElement) {
    return scrapeMotionValuesFromProps$1(props, prevProps, visualElement);
  }
}
function isObjectKey(key, object) {
  return key in object;
}
class ObjectVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.type = "object";
  }
  readValueFromInstance(instance, key) {
    if (isObjectKey(key, instance)) {
      const value = instance[key];
      if (typeof value === "string" || typeof value === "number") {
        return value;
      }
    }
    return undefined;
  }
  getBaseTargetFromProps() {
    return undefined;
  }
  removeValueFromRenderState(key, renderState) {
    delete renderState.output[key];
  }
  measureInstanceViewportBox() {
    return createBox();
  }
  build(renderState, latestValues) {
    Object.assign(renderState.output, latestValues);
  }
  renderInstance(instance, {
    output
  }) {
    Object.assign(instance, output);
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
function createDOMVisualElement(element) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        transform: {},
        transformOrigin: {},
        style: {},
        vars: {},
        attrs: {}
      },
      latestValues: {}
    }
  };
  const node = isSVGElement(element) ? new SVGVisualElement(options) : new HTMLVisualElement(options);
  node.mount(element);
  visualElementStore.set(element, node);
}
function createObjectVisualElement(subject) {
  const options = {
    presenceContext: null,
    props: {},
    visualState: {
      renderState: {
        output: {}
      },
      latestValues: {}
    }
  };
  const node = new ObjectVisualElement(options);
  node.mount(subject);
  visualElementStore.set(subject, node);
}
function isSingleValue(subject, keyframes) {
  return isMotionValue(subject) || typeof subject === "number" || typeof subject === "string" && !isDOMKeyframes(keyframes);
}
/**
 * Implementation
 */
function animateSubject(subject, keyframes, options, scope) {
  const animations = [];
  if (isSingleValue(subject, keyframes)) {
    animations.push(animateSingleValue(subject, isDOMKeyframes(keyframes) ? keyframes.default || keyframes : keyframes, options ? options.default || options : options));
  } else {
    const subjects = resolveSubjects(subject, keyframes, scope);
    const numSubjects = subjects.length;
    motionUtils.invariant(Boolean(numSubjects), "No valid elements provided.");
    for (let i = 0; i < numSubjects; i++) {
      const thisSubject = subjects[i];
      const createVisualElement = thisSubject instanceof Element ? createDOMVisualElement : createObjectVisualElement;
      if (!visualElementStore.has(thisSubject)) {
        createVisualElement(thisSubject);
      }
      const visualElement = visualElementStore.get(thisSubject);
      const transition = {
        ...options
      };
      /**
       * Resolve stagger function if provided.
       */
      if ("delay" in transition && typeof transition.delay === "function") {
        transition.delay = transition.delay(i, numSubjects);
      }
      animations.push(...animateTarget(visualElement, {
        ...keyframes,
        transition
      }, {}));
    }
  }
  return animations;
}
function animateSequence(sequence, options, scope) {
  const animations = [];
  const animationDefinitions = createAnimationsFromSequence(sequence, options, scope, {
    spring
  });
  animationDefinitions.forEach(({
    keyframes,
    transition
  }, subject) => {
    animations.push(...animateSubject(subject, keyframes, transition));
  });
  return animations;
}
function isSequence(value) {
  return Array.isArray(value) && value.some(Array.isArray);
}
/**
 * Creates an animation function that is optionally scoped
 * to a specific element.
 */
function createScopedAnimate(scope) {
  /**
   * Implementation
   */
  function scopedAnimate(subjectOrSequence, optionsOrKeyframes, options) {
    let animations = [];
    if (isSequence(subjectOrSequence)) {
      animations = animateSequence(subjectOrSequence, optionsOrKeyframes, scope);
    } else {
      animations = animateSubject(subjectOrSequence, optionsOrKeyframes, options, scope);
    }
    const animation = new motionDom.GroupPlaybackControls(animations);
    if (scope) {
      scope.animations.push(animation);
    }
    return animation;
  }
  return scopedAnimate;
}
const animate = createScopedAnimate();
function setCSSVar(element, name, value) {
  element.style.setProperty(`--${name}`, value);
}
function setStyle(element, name, value) {
  element.style[name] = value;
}
const supportsPartialKeyframes = /*@__PURE__*/motionUtils.memo(() => {
  try {
    document.createElement("div").animate({
      opacity: [1]
    });
  } catch (e) {
    return false;
  }
  return true;
});
const state = new WeakMap();
function hydrateKeyframes(valueName, keyframes, read) {
  for (let i = 0; i < keyframes.length; i++) {
    if (keyframes[i] === null) {
      keyframes[i] = i === 0 ? read() : keyframes[i - 1];
    }
    if (typeof keyframes[i] === "number" && browserNumberValueTypes[valueName]) {
      keyframes[i] = browserNumberValueTypes[valueName].transform(keyframes[i]);
    }
  }
  if (!supportsPartialKeyframes() && keyframes.length < 2) {
    keyframes.unshift(read());
  }
}
const defaultEasing = "easeOut";
function getElementAnimationState(element) {
  const animationState = state.get(element) || new Map();
  state.set(element, animationState);
  return state.get(element);
}
class NativeAnimation extends motionDom.NativeAnimationControls {
  constructor(element, valueName, valueKeyframes, options) {
    const isCSSVar = valueName.startsWith("--");
    motionUtils.invariant(typeof options.type !== "string", `animateMini doesn't support "type" as a string. Did you mean to import { spring } from "framer-motion"?`);
    const existingAnimation = getElementAnimationState(element).get(valueName);
    existingAnimation && existingAnimation.stop();
    const readInitialKeyframe = () => {
      return valueName.startsWith("--") ? element.style.getPropertyValue(valueName) : window.getComputedStyle(element)[valueName];
    };
    if (!Array.isArray(valueKeyframes)) {
      valueKeyframes = [valueKeyframes];
    }
    hydrateKeyframes(valueName, valueKeyframes, readInitialKeyframe);
    // TODO: Replace this with toString()?
    if (motionDom.isGenerator(options.type)) {
      const generatorOptions = motionDom.createGeneratorEasing(options, 100, options.type);
      options.ease = motionDom.supportsLinearEasing() ? generatorOptions.ease : defaultEasing;
      options.duration = motionUtils.secondsToMilliseconds(generatorOptions.duration);
      options.type = "keyframes";
    } else {
      options.ease = options.ease || defaultEasing;
    }
    const onFinish = () => {
      this.setValue(element, valueName, getFinalKeyframe(valueKeyframes, options));
      this.cancel();
      this.resolveFinishedPromise();
    };
    const init = () => {
      this.setValue = isCSSVar ? setCSSVar : setStyle;
      this.options = options;
      this.updateFinishedPromise();
      this.removeAnimation = () => {
        const elementState = state.get(element);
        elementState && elementState.delete(valueName);
      };
    };
    if (!supportsWaapi()) {
      super();
      init();
      onFinish();
    } else {
      super(startWaapiAnimation(element, valueName, valueKeyframes, options));
      init();
      if (options.autoplay === false) {
        this.animation.pause();
      }
      this.animation.onfinish = onFinish;
      getElementAnimationState(element).set(valueName, this);
    }
  }
  /**
   * Allows the returned animation to be awaited or promise-chained. Currently
   * resolves when the animation finishes at all but in a future update could/should
   * reject if its cancels.
   */
  then(resolve, reject) {
    return this.currentFinishedPromise.then(resolve, reject);
  }
  updateFinishedPromise() {
    this.currentFinishedPromise = new Promise(resolve => {
      this.resolveFinishedPromise = resolve;
    });
  }
  play() {
    if (this.state === "finished") {
      this.updateFinishedPromise();
    }
    super.play();
  }
  cancel() {
    this.removeAnimation();
    super.cancel();
  }
}
function animateElements(elementOrSelector, keyframes, options, scope) {
  const elements = motionDom.resolveElements(elementOrSelector, scope);
  const numElements = elements.length;
  motionUtils.invariant(Boolean(numElements), "No valid element provided.");
  const animations = [];
  for (let i = 0; i < numElements; i++) {
    const element = elements[i];
    const elementTransition = {
      ...options
    };
    /**
     * Resolve stagger function if provided.
     */
    if (typeof elementTransition.delay === "function") {
      elementTransition.delay = elementTransition.delay(i, numElements);
    }
    for (const valueName in keyframes) {
      const valueKeyframes = keyframes[valueName];
      const valueOptions = {
        ...motionDom.getValueTransition(elementTransition, valueName)
      };
      valueOptions.duration = valueOptions.duration ? motionUtils.secondsToMilliseconds(valueOptions.duration) : valueOptions.duration;
      valueOptions.delay = motionUtils.secondsToMilliseconds(valueOptions.delay || 0);
      animations.push(new NativeAnimation(element, valueName, valueKeyframes, valueOptions));
    }
  }
  return animations;
}
const createScopedWaapiAnimate = scope => {
  function scopedAnimate(elementOrSelector, keyframes, options) {
    return new motionDom.GroupPlaybackControls(animateElements(elementOrSelector, keyframes, options, scope));
  }
  return scopedAnimate;
};
const animateMini = /*@__PURE__*/createScopedWaapiAnimate();
function observeTimeline(update, timeline) {
  let prevProgress;
  const onFrame = () => {
    const {
      currentTime
    } = timeline;
    const percentage = currentTime === null ? 0 : currentTime.value;
    const progress = percentage / 100;
    if (prevProgress !== progress) {
      update(progress);
    }
    prevProgress = progress;
  };
  frame.update(onFrame, true);
  return () => cancelFrame(onFrame);
}
const resizeHandlers = new WeakMap();
let observer;
function getElementSize(target, borderBoxSize) {
  if (borderBoxSize) {
    const {
      inlineSize,
      blockSize
    } = borderBoxSize[0];
    return {
      width: inlineSize,
      height: blockSize
    };
  } else if (target instanceof SVGElement && "getBBox" in target) {
    return target.getBBox();
  } else {
    return {
      width: target.offsetWidth,
      height: target.offsetHeight
    };
  }
}
function notifyTarget({
  target,
  contentRect,
  borderBoxSize
}) {
  var _a;
  (_a = resizeHandlers.get(target)) === null || _a === void 0 ? void 0 : _a.forEach(handler => {
    handler({
      target,
      contentSize: contentRect,
      get size() {
        return getElementSize(target, borderBoxSize);
      }
    });
  });
}
function notifyAll(entries) {
  entries.forEach(notifyTarget);
}
function createResizeObserver() {
  if (typeof ResizeObserver === "undefined") return;
  observer = new ResizeObserver(notifyAll);
}
function resizeElement(target, handler) {
  if (!observer) createResizeObserver();
  const elements = motionDom.resolveElements(target);
  elements.forEach(element => {
    let elementHandlers = resizeHandlers.get(element);
    if (!elementHandlers) {
      elementHandlers = new Set();
      resizeHandlers.set(element, elementHandlers);
    }
    elementHandlers.add(handler);
    observer === null || observer === void 0 ? void 0 : observer.observe(element);
  });
  return () => {
    elements.forEach(element => {
      const elementHandlers = resizeHandlers.get(element);
      elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.delete(handler);
      if (!(elementHandlers === null || elementHandlers === void 0 ? void 0 : elementHandlers.size)) {
        observer === null || observer === void 0 ? void 0 : observer.unobserve(element);
      }
    });
  };
}
const windowCallbacks = new Set();
let windowResizeHandler;
function createWindowResizeHandler() {
  windowResizeHandler = () => {
    const size = {
      width: window.innerWidth,
      height: window.innerHeight
    };
    const info = {
      target: window,
      size,
      contentSize: size
    };
    windowCallbacks.forEach(callback => callback(info));
  };
  window.addEventListener("resize", windowResizeHandler);
}
function resizeWindow(callback) {
  windowCallbacks.add(callback);
  if (!windowResizeHandler) createWindowResizeHandler();
  return () => {
    windowCallbacks.delete(callback);
    if (!windowCallbacks.size && windowResizeHandler) {
      windowResizeHandler = undefined;
    }
  };
}
function resize(a, b) {
  return typeof a === "function" ? resizeWindow(a) : resizeElement(a, b);
}

/**
 * A time in milliseconds, beyond which we consider the scroll velocity to be 0.
 */
const maxElapsed = 50;
const createAxisInfo = () => ({
  current: 0,
  offset: [],
  progress: 0,
  scrollLength: 0,
  targetOffset: 0,
  targetLength: 0,
  containerLength: 0,
  velocity: 0
});
const createScrollInfo = () => ({
  time: 0,
  x: createAxisInfo(),
  y: createAxisInfo()
});
const keys = {
  x: {
    length: "Width",
    position: "Left"
  },
  y: {
    length: "Height",
    position: "Top"
  }
};
function updateAxisInfo(element, axisName, info, time) {
  const axis = info[axisName];
  const {
    length,
    position
  } = keys[axisName];
  const prev = axis.current;
  const prevTime = info.time;
  axis.current = element[`scroll${position}`];
  axis.scrollLength = element[`scroll${length}`] - element[`client${length}`];
  axis.offset.length = 0;
  axis.offset[0] = 0;
  axis.offset[1] = axis.scrollLength;
  axis.progress = motionUtils.progress(0, axis.scrollLength, axis.current);
  const elapsed = time - prevTime;
  axis.velocity = elapsed > maxElapsed ? 0 : velocityPerSecond(axis.current - prev, elapsed);
}
function updateScrollInfo(element, info, time) {
  updateAxisInfo(element, "x", info, time);
  updateAxisInfo(element, "y", info, time);
  info.time = time;
}
function calcInset(element, container) {
  const inset = {
    x: 0,
    y: 0
  };
  let current = element;
  while (current && current !== container) {
    if (current instanceof HTMLElement) {
      inset.x += current.offsetLeft;
      inset.y += current.offsetTop;
      current = current.offsetParent;
    } else if (current.tagName === "svg") {
      /**
       * This isn't an ideal approach to measuring the offset of <svg /> tags.
       * It would be preferable, given they behave like HTMLElements in most ways
       * to use offsetLeft/Top. But these don't exist on <svg />. Likewise we
       * can't use .getBBox() like most SVG elements as these provide the offset
       * relative to the SVG itself, which for <svg /> is usually 0x0.
       */
      const svgBoundingBox = current.getBoundingClientRect();
      current = current.parentElement;
      const parentBoundingBox = current.getBoundingClientRect();
      inset.x += svgBoundingBox.left - parentBoundingBox.left;
      inset.y += svgBoundingBox.top - parentBoundingBox.top;
    } else if (current instanceof SVGGraphicsElement) {
      const {
        x,
        y
      } = current.getBBox();
      inset.x += x;
      inset.y += y;
      let svg = null;
      let parent = current.parentNode;
      while (!svg) {
        if (parent.tagName === "svg") {
          svg = parent;
        }
        parent = current.parentNode;
      }
      current = svg;
    } else {
      break;
    }
  }
  return inset;
}
const namedEdges = {
  start: 0,
  center: 0.5,
  end: 1
};
function resolveEdge(edge, length, inset = 0) {
  let delta = 0;
  /**
   * If we have this edge defined as a preset, replace the definition
   * with the numerical value.
   */
  if (edge in namedEdges) {
    edge = namedEdges[edge];
  }
  /**
   * Handle unit values
   */
  if (typeof edge === "string") {
    const asNumber = parseFloat(edge);
    if (edge.endsWith("px")) {
      delta = asNumber;
    } else if (edge.endsWith("%")) {
      edge = asNumber / 100;
    } else if (edge.endsWith("vw")) {
      delta = asNumber / 100 * document.documentElement.clientWidth;
    } else if (edge.endsWith("vh")) {
      delta = asNumber / 100 * document.documentElement.clientHeight;
    } else {
      edge = asNumber;
    }
  }
  /**
   * If the edge is defined as a number, handle as a progress value.
   */
  if (typeof edge === "number") {
    delta = length * edge;
  }
  return inset + delta;
}
const defaultOffset = [0, 0];
function resolveOffset(offset, containerLength, targetLength, targetInset) {
  let offsetDefinition = Array.isArray(offset) ? offset : defaultOffset;
  let targetPoint = 0;
  let containerPoint = 0;
  if (typeof offset === "number") {
    /**
     * If we're provided offset: [0, 0.5, 1] then each number x should become
     * [x, x], so we default to the behaviour of mapping 0 => 0 of both target
     * and container etc.
     */
    offsetDefinition = [offset, offset];
  } else if (typeof offset === "string") {
    offset = offset.trim();
    if (offset.includes(" ")) {
      offsetDefinition = offset.split(" ");
    } else {
      /**
       * If we're provided a definition like "100px" then we want to apply
       * that only to the top of the target point, leaving the container at 0.
       * Whereas a named offset like "end" should be applied to both.
       */
      offsetDefinition = [offset, namedEdges[offset] ? offset : `0`];
    }
  }
  targetPoint = resolveEdge(offsetDefinition[0], targetLength, targetInset);
  containerPoint = resolveEdge(offsetDefinition[1], containerLength);
  return targetPoint - containerPoint;
}
const ScrollOffset = {
  Enter: [[0, 1], [1, 1]],
  Exit: [[0, 0], [1, 0]],
  Any: [[1, 0], [0, 1]],
  All: [[0, 0], [1, 1]]
};
const point = {
  x: 0,
  y: 0
};
function getTargetSize(target) {
  return "getBBox" in target && target.tagName !== "svg" ? target.getBBox() : {
    width: target.clientWidth,
    height: target.clientHeight
  };
}
function resolveOffsets(container, info, options) {
  const {
    offset: offsetDefinition = ScrollOffset.All
  } = options;
  const {
    target = container,
    axis = "y"
  } = options;
  const lengthLabel = axis === "y" ? "height" : "width";
  const inset = target !== container ? calcInset(target, container) : point;
  /**
   * Measure the target and container. If they're the same thing then we
   * use the container's scrollWidth/Height as the target, from there
   * all other calculations can remain the same.
   */
  const targetSize = target === container ? {
    width: container.scrollWidth,
    height: container.scrollHeight
  } : getTargetSize(target);
  const containerSize = {
    width: container.clientWidth,
    height: container.clientHeight
  };
  /**
   * Reset the length of the resolved offset array rather than creating a new one.
   * TODO: More reusable data structures for targetSize/containerSize would also be good.
   */
  info[axis].offset.length = 0;
  /**
   * Populate the offset array by resolving the user's offset definition into
   * a list of pixel scroll offets.
   */
  let hasChanged = !info[axis].interpolate;
  const numOffsets = offsetDefinition.length;
  for (let i = 0; i < numOffsets; i++) {
    const offset = resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset[axis]);
    if (!hasChanged && offset !== info[axis].interpolatorOffsets[i]) {
      hasChanged = true;
    }
    info[axis].offset[i] = offset;
  }
  /**
   * If the pixel scroll offsets have changed, create a new interpolator function
   * to map scroll value into a progress.
   */
  if (hasChanged) {
    info[axis].interpolate = interpolate(info[axis].offset, defaultOffset$1(offsetDefinition), {
      clamp: false
    });
    info[axis].interpolatorOffsets = [...info[axis].offset];
  }
  info[axis].progress = clamp(0, 1, info[axis].interpolate(info[axis].current));
}
function measure(container, target = container, info) {
  /**
   * Find inset of target within scrollable container
   */
  info.x.targetOffset = 0;
  info.y.targetOffset = 0;
  if (target !== container) {
    let node = target;
    while (node && node !== container) {
      info.x.targetOffset += node.offsetLeft;
      info.y.targetOffset += node.offsetTop;
      node = node.offsetParent;
    }
  }
  info.x.targetLength = target === container ? target.scrollWidth : target.clientWidth;
  info.y.targetLength = target === container ? target.scrollHeight : target.clientHeight;
  info.x.containerLength = container.clientWidth;
  info.y.containerLength = container.clientHeight;
  /**
   * In development mode ensure scroll containers aren't position: static as this makes
   * it difficult to measure their relative positions.
   */
  if (process.env.NODE_ENV !== "production") {
    if (container && target && target !== container) {
      warnOnce(getComputedStyle(container).position !== "static", "Please ensure that the container has a non-static position, like 'relative', 'fixed', or 'absolute' to ensure scroll offset is calculated correctly.");
    }
  }
}
function createOnScrollHandler(element, onScroll, info, options = {}) {
  return {
    measure: () => measure(element, options.target, info),
    update: time => {
      updateScrollInfo(element, info, time);
      if (options.offset || options.target) {
        resolveOffsets(element, info, options);
      }
    },
    notify: () => onScroll(info)
  };
}
const scrollListeners = new WeakMap();
const resizeListeners = new WeakMap();
const onScrollHandlers = new WeakMap();
const getEventTarget = element => element === document.documentElement ? window : element;
function scrollInfo(onScroll, {
  container = document.documentElement,
  ...options
} = {}) {
  let containerHandlers = onScrollHandlers.get(container);
  /**
   * Get the onScroll handlers for this container.
   * If one isn't found, create a new one.
   */
  if (!containerHandlers) {
    containerHandlers = new Set();
    onScrollHandlers.set(container, containerHandlers);
  }
  /**
   * Create a new onScroll handler for the provided callback.
   */
  const info = createScrollInfo();
  const containerHandler = createOnScrollHandler(container, onScroll, info, options);
  containerHandlers.add(containerHandler);
  /**
   * Check if there's a scroll event listener for this container.
   * If not, create one.
   */
  if (!scrollListeners.has(container)) {
    const measureAll = () => {
      for (const handler of containerHandlers) handler.measure();
    };
    const updateAll = () => {
      for (const handler of containerHandlers) {
        handler.update(frameData.timestamp);
      }
    };
    const notifyAll = () => {
      for (const handler of containerHandlers) handler.notify();
    };
    const listener = () => {
      frame.read(measureAll, false, true);
      frame.read(updateAll, false, true);
      frame.update(notifyAll, false, true);
    };
    scrollListeners.set(container, listener);
    const target = getEventTarget(container);
    window.addEventListener("resize", listener, {
      passive: true
    });
    if (container !== document.documentElement) {
      resizeListeners.set(container, resize(container, listener));
    }
    target.addEventListener("scroll", listener, {
      passive: true
    });
  }
  const listener = scrollListeners.get(container);
  frame.read(listener, false, true);
  return () => {
    var _a;
    cancelFrame(listener);
    /**
     * Check if we even have any handlers for this container.
     */
    const currentHandlers = onScrollHandlers.get(container);
    if (!currentHandlers) return;
    currentHandlers.delete(containerHandler);
    if (currentHandlers.size) return;
    /**
     * If no more handlers, remove the scroll listener too.
     */
    const scrollListener = scrollListeners.get(container);
    scrollListeners.delete(container);
    if (scrollListener) {
      getEventTarget(container).removeEventListener("scroll", scrollListener);
      (_a = resizeListeners.get(container)) === null || _a === void 0 ? void 0 : _a();
      window.removeEventListener("resize", scrollListener);
    }
  };
}
function scrollTimelineFallback({
  source,
  container,
  axis = "y"
}) {
  // Support legacy source argument. Deprecate later.
  if (source) container = source;
  // ScrollTimeline records progress as a percentage CSSUnitValue
  const currentTime = {
    value: 0
  };
  const cancel = scrollInfo(info => {
    currentTime.value = info[axis].progress * 100;
  }, {
    container,
    axis
  });
  return {
    currentTime,
    cancel
  };
}
const timelineCache = new Map();
function getTimeline({
  source,
  container = document.documentElement,
  axis = "y"
} = {}) {
  // Support legacy source argument. Deprecate later.
  if (source) container = source;
  if (!timelineCache.has(container)) {
    timelineCache.set(container, {});
  }
  const elementCache = timelineCache.get(container);
  if (!elementCache[axis]) {
    elementCache[axis] = motionDom.supportsScrollTimeline() ? new ScrollTimeline({
      source: container,
      axis
    }) : scrollTimelineFallback({
      source: container,
      axis
    });
  }
  return elementCache[axis];
}
/**
 * If the onScroll function has two arguments, it's expecting
 * more specific information about the scroll from scrollInfo.
 */
function isOnScrollWithInfo(onScroll) {
  return onScroll.length === 2;
}
/**
 * Currently, we only support element tracking with `scrollInfo`, though in
 * the future we can also offer ViewTimeline support.
 */
function needsElementTracking(options) {
  return options && (options.target || options.offset);
}
function scrollFunction(onScroll, options) {
  if (isOnScrollWithInfo(onScroll) || needsElementTracking(options)) {
    return scrollInfo(info => {
      onScroll(info[options.axis].progress, info);
    }, options);
  } else {
    return observeTimeline(onScroll, getTimeline(options));
  }
}
function scrollAnimation(animation, options) {
  animation.flatten();
  if (needsElementTracking(options)) {
    animation.pause();
    return scrollInfo(info => {
      animation.time = animation.duration * info[options.axis].progress;
    }, options);
  } else {
    const timeline = getTimeline(options);
    if (animation.attachTimeline) {
      return animation.attachTimeline(timeline, valueAnimation => {
        valueAnimation.pause();
        return observeTimeline(progress => {
          valueAnimation.time = valueAnimation.duration * progress;
        }, timeline);
      });
    } else {
      return motionUtils.noop;
    }
  }
}
function scroll(onScroll, {
  axis = "y",
  ...options
} = {}) {
  const optionsWithDefaults = {
    axis,
    ...options
  };
  return typeof onScroll === "function" ? scrollFunction(onScroll, optionsWithDefaults) : scrollAnimation(onScroll, optionsWithDefaults);
}
const thresholds = {
  some: 0,
  all: 1
};
function inView(elementOrSelector, onStart, {
  root,
  margin: rootMargin,
  amount = "some"
} = {}) {
  const elements = motionDom.resolveElements(elementOrSelector);
  const activeIntersections = new WeakMap();
  const onIntersectionChange = entries => {
    entries.forEach(entry => {
      const onEnd = activeIntersections.get(entry.target);
      /**
       * If there's no change to the intersection, we don't need to
       * do anything here.
       */
      if (entry.isIntersecting === Boolean(onEnd)) return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (typeof newOnEnd === "function") {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer.unobserve(entry.target);
        }
      } else if (typeof onEnd === "function") {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  };
  const observer = new IntersectionObserver(onIntersectionChange, {
    root,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach(element => observer.observe(element));
  return () => observer.disconnect();
}
function steps(numSteps, direction = "end") {
  return progress => {
    progress = direction === "end" ? Math.min(progress, 0.999) : Math.max(progress, 0.001);
    const expanded = progress * numSteps;
    const rounded = direction === "end" ? Math.floor(expanded) : Math.ceil(expanded);
    return clamp(0, 1, rounded / numSteps);
  };
}
function getOriginIndex(from, total) {
  if (from === "first") {
    return 0;
  } else {
    const lastIndex = total - 1;
    return from === "last" ? lastIndex : lastIndex / 2;
  }
}
function stagger(duration = 0.1, {
  startDelay = 0,
  from = 0,
  ease
} = {}) {
  return (i, total) => {
    const fromIndex = typeof from === "number" ? from : getOriginIndex(from, total);
    const distance = Math.abs(fromIndex - i);
    let delay = duration * distance;
    if (ease) {
      const maxDelay = total * duration;
      const easingFunction = easingDefinitionToFunction(ease);
      delay = easingFunction(delay / maxDelay) * maxDelay;
    }
    return startDelay + delay;
  };
}

/**
 * Timeout defined in ms
 */
function delay(callback, timeout) {
  const start = time.now();
  const checkElapsed = ({
    timestamp
  }) => {
    const elapsed = timestamp - start;
    if (elapsed >= timeout) {
      cancelFrame(checkElapsed);
      callback(elapsed - timeout);
    }
  };
  frame.read(checkElapsed, true);
  return () => cancelFrame(checkElapsed);
}
const distance = (a, b) => Math.abs(a - b);
function distance2D(a, b) {
  // Multi-dimensional
  const xDelta = distance(a.x, b.x);
  const yDelta = distance(a.y, b.y);
  return Math.sqrt(xDelta ** 2 + yDelta ** 2);
}
const isCustomValueType = v => {
  return v && typeof v === "object" && v.mix;
};
const getMixer = v => isCustomValueType(v) ? v.mix : undefined;
function transform(...args) {
  const useImmediate = !Array.isArray(args[0]);
  const argOffset = useImmediate ? 0 : -1;
  const inputValue = args[0 + argOffset];
  const inputRange = args[1 + argOffset];
  const outputRange = args[2 + argOffset];
  const options = args[3 + argOffset];
  const interpolator = interpolate(inputRange, outputRange, {
    mixer: getMixer(outputRange[0]),
    ...options
  });
  return useImmediate ? interpolator(inputValue) : interpolator;
}

/**
 * @deprecated
 *
 * Import as `frame` instead.
 */
const sync = frame;
/**
 * @deprecated
 *
 * Use cancelFrame(callback) instead.
 */
const cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = process => cancelFrame(process);
  return acc;
}, {});
const {
  schedule: microtask,
  cancel: cancelMicrotask
} = createRenderBatcher(queueMicrotask, false);
const compareByDepth = (a, b) => a.depth - b.depth;
class FlatTree {
  constructor() {
    this.children = [];
    this.isDirty = false;
  }
  add(child) {
    addUniqueItem(this.children, child);
    this.isDirty = true;
  }
  remove(child) {
    removeItem(this.children, child);
    this.isDirty = true;
  }
  forEach(callback) {
    this.isDirty && this.children.sort(compareByDepth);
    this.isDirty = false;
    this.children.forEach(callback);
  }
}
const borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
const numBorders = borders.length;
const asNumber = value => typeof value === "string" ? parseFloat(value) : value;
const isPx = value => typeof value === "number" || px.test(value);
function mixValues(target, follow, lead, progress, shouldCrossfadeOpacity, isOnlyMember) {
  if (shouldCrossfadeOpacity) {
    target.opacity = mixNumber$1(0,
    // TODO Reinstate this if only child
    lead.opacity !== undefined ? lead.opacity : 1, easeCrossfadeIn(progress));
    target.opacityExit = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, 0, easeCrossfadeOut(progress));
  } else if (isOnlyMember) {
    target.opacity = mixNumber$1(follow.opacity !== undefined ? follow.opacity : 1, lead.opacity !== undefined ? lead.opacity : 1, progress);
  }
  /**
   * Mix border radius
   */
  for (let i = 0; i < numBorders; i++) {
    const borderLabel = `border${borders[i]}Radius`;
    let followRadius = getRadius(follow, borderLabel);
    let leadRadius = getRadius(lead, borderLabel);
    if (followRadius === undefined && leadRadius === undefined) continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    const canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mixNumber$1(asNumber(followRadius), asNumber(leadRadius), progress), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  /**
   * Mix rotation
   */
  if (follow.rotate || lead.rotate) {
    target.rotate = mixNumber$1(follow.rotate || 0, lead.rotate || 0, progress);
  }
}
function getRadius(values, radiusName) {
  return values[radiusName] !== undefined ? values[radiusName] : values.borderRadius;
}
// /**
//  * We only want to mix the background color if there's a follow element
//  * that we're not crossfading opacity between. For instance with switch
//  * AnimateSharedLayout animations, this helps the illusion of a continuous
//  * element being animated but also cuts down on the number of paints triggered
//  * for elements where opacity is doing that work for us.
//  */
// if (
//     !hasFollowElement &&
//     latestLeadValues.backgroundColor &&
//     latestFollowValues.backgroundColor
// ) {
//     /**
//      * This isn't ideal performance-wise as mixColor is creating a new function every frame.
//      * We could probably create a mixer that runs at the start of the animation but
//      * the idea behind the crossfader is that it runs dynamically between two potentially
//      * changing targets (ie opacity or borderRadius may be animating independently via variants)
//      */
//     leadState.backgroundColor = followState.backgroundColor = mixColor(
//         latestFollowValues.backgroundColor as string,
//         latestLeadValues.backgroundColor as string
//     )(p)
// }
const easeCrossfadeIn = /*@__PURE__*/compress(0, 0.5, circOut);
const easeCrossfadeOut = /*@__PURE__*/compress(0.5, 0.95, motionUtils.noop);
function compress(min, max, easing) {
  return p => {
    // Could replace ifs with clamp
    if (p < min) return 0;
    if (p > max) return 1;
    return easing(motionUtils.progress(min, max, p));
  };
}

/**
 * Reset an axis to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
/**
 * Reset a box to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}
/**
 * Reset a delta to the provided origin box.
 *
 * This is a mutative operation.
 */
function copyAxisDeltaInto(delta, originDelta) {
  delta.translate = originDelta.translate;
  delta.scale = originDelta.scale;
  delta.originPoint = originDelta.originPoint;
  delta.origin = originDelta.origin;
}

/**
 * Remove a delta from a point. This is essentially the steps of applyPointDelta in reverse
 */
function removePointDelta(point, translate, scale, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale, originPoint);
  if (boxScale !== undefined) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
/**
 * Remove a delta from an axis. This is essentially the steps of applyAxisDelta in reverse
 */
function removeAxisDelta(axis, translate = 0, scale = 1, origin = 0.5, boxScale, originAxis = axis, sourceAxis = axis) {
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    const relativeProgress = mixNumber$1(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number") return;
  let originPoint = mixNumber$1(originAxis.min, originAxis.max, origin);
  if (axis === originAxis) originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale, originPoint, boxScale);
}
/**
 * Remove a transforms from an axis. This is essentially the steps of applyAxisTransforms in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeAxisTransforms(axis, transforms, [key, scaleKey, originKey], origin, sourceAxis) {
  removeAxisDelta(axis, transforms[key], transforms[scaleKey], transforms[originKey], transforms.scale, origin, sourceAxis);
}
/**
 * The names of the motion values we want to apply as translation, scale and origin.
 */
const xKeys = ["x", "scaleX", "originX"];
const yKeys = ["y", "scaleY", "originY"];
/**
 * Remove a transforms from an box. This is essentially the steps of applyAxisBox in reverse
 * and acts as a bridge between motion values and removeAxisDelta
 */
function removeBoxTransforms(box, transforms, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms, xKeys, originBox ? originBox.x : undefined, sourceBox ? sourceBox.x : undefined);
  removeAxisTransforms(box.y, transforms, yKeys, originBox ? originBox.y : undefined, sourceBox ? sourceBox.y : undefined);
}
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function axisEquals(a, b) {
  return a.min === b.min && a.max === b.max;
}
function boxEquals(a, b) {
  return axisEquals(a.x, b.x) && axisEquals(a.y, b.y);
}
function axisEqualsRounded(a, b) {
  return Math.round(a.min) === Math.round(b.min) && Math.round(a.max) === Math.round(b.max);
}
function boxEqualsRounded(a, b) {
  return axisEqualsRounded(a.x, b.x) && axisEqualsRounded(a.y, b.y);
}
function aspectRatio(box) {
  return calcLength(box.x) / calcLength(box.y);
}
function axisDeltaEquals(a, b) {
  return a.translate === b.translate && a.scale === b.scale && a.originPoint === b.originPoint;
}
class NodeStack {
  constructor() {
    this.members = [];
  }
  add(node) {
    addUniqueItem(this.members, node);
    node.scheduleRender();
  }
  remove(node) {
    removeItem(this.members, node);
    if (node === this.prevLead) {
      this.prevLead = undefined;
    }
    if (node === this.lead) {
      const prevLead = this.members[this.members.length - 1];
      if (prevLead) {
        this.promote(prevLead);
      }
    }
  }
  relegate(node) {
    const indexOfNode = this.members.findIndex(member => node === member);
    if (indexOfNode === 0) return false;
    /**
     * Find the next projection node that is present
     */
    let prevLead;
    for (let i = indexOfNode; i >= 0; i--) {
      const member = this.members[i];
      if (member.isPresent !== false) {
        prevLead = member;
        break;
      }
    }
    if (prevLead) {
      this.promote(prevLead);
      return true;
    } else {
      return false;
    }
  }
  promote(node, preserveFollowOpacity) {
    const prevLead = this.lead;
    if (node === prevLead) return;
    this.prevLead = prevLead;
    this.lead = node;
    node.show();
    if (prevLead) {
      prevLead.instance && prevLead.scheduleRender();
      node.scheduleRender();
      node.resumeFrom = prevLead;
      if (preserveFollowOpacity) {
        node.resumeFrom.preserveOpacity = true;
      }
      if (prevLead.snapshot) {
        node.snapshot = prevLead.snapshot;
        node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
      }
      if (node.root && node.root.isUpdating) {
        node.isLayoutDirty = true;
      }
      const {
        crossfade
      } = node.options;
      if (crossfade === false) {
        prevLead.hide();
      }
      /**
       * TODO:
       *   - Test border radius when previous node was deleted
       *   - boxShadow mixing
       *   - Shared between element A in scrolled container and element B (scroll stays the same or changes)
       *   - Shared between element A in transformed container and element B (transform stays the same or changes)
       *   - Shared between element A in scrolled page and element B (scroll stays the same or changes)
       * ---
       *   - Crossfade opacity of root nodes
       *   - layoutId changes after animation
       *   - layoutId changes mid animation
       */
    }
  }
  exitAnimationComplete() {
    this.members.forEach(node => {
      const {
        options,
        resumingFrom
      } = node;
      options.onExitComplete && options.onExitComplete();
      if (resumingFrom) {
        resumingFrom.options.onExitComplete && resumingFrom.options.onExitComplete();
      }
    });
  }
  scheduleRender() {
    this.members.forEach(node => {
      node.instance && node.scheduleRender(false);
    });
  }
  /**
   * Clear any leads that have been removed this render to prevent them from being
   * used in future animations and to prevent memory leaks
   */
  removeLeadSnapshot() {
    if (this.lead && this.lead.snapshot) {
      this.lead.snapshot = undefined;
    }
  }
}
function buildProjectionTransform(delta, treeScale, latestTransform) {
  let transform = "";
  /**
   * The translations we use to calculate are always relative to the viewport coordinate space.
   * But when we apply scales, we also scale the coordinate space of an element and its children.
   * For instance if we have a treeScale (the culmination of all parent scales) of 0.5 and we need
   * to move an element 100 pixels, we actually need to move it 200 in within that scaled space.
   */
  const xTranslate = delta.x.translate / treeScale.x;
  const yTranslate = delta.y.translate / treeScale.y;
  const zTranslate = (latestTransform === null || latestTransform === void 0 ? void 0 : latestTransform.z) || 0;
  if (xTranslate || yTranslate || zTranslate) {
    transform = `translate3d(${xTranslate}px, ${yTranslate}px, ${zTranslate}px) `;
  }
  /**
   * Apply scale correction for the tree transform.
   * This will apply scale to the screen-orientated axes.
   */
  if (treeScale.x !== 1 || treeScale.y !== 1) {
    transform += `scale(${1 / treeScale.x}, ${1 / treeScale.y}) `;
  }
  if (latestTransform) {
    const {
      transformPerspective,
      rotate,
      rotateX,
      rotateY,
      skewX,
      skewY
    } = latestTransform;
    if (transformPerspective) transform = `perspective(${transformPerspective}px) ${transform}`;
    if (rotate) transform += `rotate(${rotate}deg) `;
    if (rotateX) transform += `rotateX(${rotateX}deg) `;
    if (rotateY) transform += `rotateY(${rotateY}deg) `;
    if (skewX) transform += `skewX(${skewX}deg) `;
    if (skewY) transform += `skewY(${skewY}deg) `;
  }
  /**
   * Apply scale to match the size of the element to the size we want it.
   * This will apply scale to the element-orientated axes.
   */
  const elementScaleX = delta.x.scale * treeScale.x;
  const elementScaleY = delta.y.scale * treeScale.y;
  if (elementScaleX !== 1 || elementScaleY !== 1) {
    transform += `scale(${elementScaleX}, ${elementScaleY})`;
  }
  return transform || "none";
}
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

/**
 * This should only ever be modified on the client otherwise it'll
 * persist through server requests. If we need instanced states we
 * could lazy-init via root.
 */
const globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};
const metrics = {
  type: "projectionFrame",
  totalNodes: 0,
  resolvedTargetDeltas: 0,
  recalculatedProjection: 0
};
const isDebug = typeof window !== "undefined" && window.MotionDebug !== undefined;
const transformAxes = ["", "X", "Y", "Z"];
const hiddenVisibility = {
  visibility: "hidden"
};
/**
 * We use 1000 as the animation target as 0-1000 maps better to pixels than 0-1
 * which has a noticeable difference in spring animations
 */
const animationTarget = 1000;
let id$1 = 0;
function resetDistortingTransform(key, visualElement, values, sharedAnimationValues) {
  const {
    latestValues
  } = visualElement;
  // Record the distorting transform and then temporarily set it to 0
  if (latestValues[key]) {
    values[key] = latestValues[key];
    visualElement.setStaticValue(key, 0);
    if (sharedAnimationValues) {
      sharedAnimationValues[key] = 0;
    }
  }
}
function cancelTreeOptimisedTransformAnimations(projectionNode) {
  projectionNode.hasCheckedOptimisedAppear = true;
  if (projectionNode.root === projectionNode) return;
  const {
    visualElement
  } = projectionNode.options;
  if (!visualElement) return;
  const appearId = getOptimisedAppearId(visualElement);
  if (window.MotionHasOptimisedAnimation(appearId, "transform")) {
    const {
      layout,
      layoutId
    } = projectionNode.options;
    window.MotionCancelOptimisedAnimation(appearId, "transform", frame, !(layout || layoutId));
  }
  const {
    parent
  } = projectionNode;
  if (parent && !parent.hasCheckedOptimisedAppear) {
    cancelTreeOptimisedTransformAnimations(parent);
  }
}
function createProjectionNode$1({
  attachResizeListener,
  defaultParent,
  measureScroll,
  checkIsScrollRoot,
  resetTransform
}) {
  return class ProjectionNode {
    constructor(latestValues = {}, parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent()) {
      /**
       * A unique ID generated for every projection node.
       */
      this.id = id$1++;
      /**
       * An id that represents a unique session instigated by startUpdate.
       */
      this.animationId = 0;
      /**
       * A Set containing all this component's children. This is used to iterate
       * through the children.
       *
       * TODO: This could be faster to iterate as a flat array stored on the root node.
       */
      this.children = new Set();
      /**
       * Options for the node. We use this to configure what kind of layout animations
       * we should perform (if any).
       */
      this.options = {};
      /**
       * We use this to detect when its safe to shut down part of a projection tree.
       * We have to keep projecting children for scale correction and relative projection
       * until all their parents stop performing layout animations.
       */
      this.isTreeAnimating = false;
      this.isAnimationBlocked = false;
      /**
       * Flag to true if we think this layout has been changed. We can't always know this,
       * currently we set it to true every time a component renders, or if it has a layoutDependency
       * if that has changed between renders. Additionally, components can be grouped by LayoutGroup
       * and if one node is dirtied, they all are.
       */
      this.isLayoutDirty = false;
      /**
       * Flag to true if we think the projection calculations for this node needs
       * recalculating as a result of an updated transform or layout animation.
       */
      this.isProjectionDirty = false;
      /**
       * Flag to true if the layout *or* transform has changed. This then gets propagated
       * throughout the projection tree, forcing any element below to recalculate on the next frame.
       */
      this.isSharedProjectionDirty = false;
      /**
       * Flag transform dirty. This gets propagated throughout the whole tree but is only
       * respected by shared nodes.
       */
      this.isTransformDirty = false;
      /**
       * Block layout updates for instant layout transitions throughout the tree.
       */
      this.updateManuallyBlocked = false;
      this.updateBlockedByResize = false;
      /**
       * Set to true between the start of the first `willUpdate` call and the end of the `didUpdate`
       * call.
       */
      this.isUpdating = false;
      /**
       * If this is an SVG element we currently disable projection transforms
       */
      this.isSVG = false;
      /**
       * Flag to true (during promotion) if a node doing an instant layout transition needs to reset
       * its projection styles.
       */
      this.needsReset = false;
      /**
       * Flags whether this node should have its transform reset prior to measuring.
       */
      this.shouldResetTransform = false;
      /**
       * Store whether this node has been checked for optimised appear animations. As
       * effects fire bottom-up, and we want to look up the tree for appear animations,
       * this makes sure we only check each path once, stopping at nodes that
       * have already been checked.
       */
      this.hasCheckedOptimisedAppear = false;
      /**
       * An object representing the calculated contextual/accumulated/tree scale.
       * This will be used to scale calculcated projection transforms, as these are
       * calculated in screen-space but need to be scaled for elements to layoutly
       * make it to their calculated destinations.
       *
       * TODO: Lazy-init
       */
      this.treeScale = {
        x: 1,
        y: 1
      };
      /**
       *
       */
      this.eventHandlers = new Map();
      this.hasTreeAnimated = false;
      // Note: Currently only running on root node
      this.updateScheduled = false;
      this.scheduleUpdate = () => this.update();
      this.projectionUpdateScheduled = false;
      this.checkUpdateFailed = () => {
        if (this.isUpdating) {
          this.isUpdating = false;
          this.clearAllSnapshots();
        }
      };
      /**
       * This is a multi-step process as shared nodes might be of different depths. Nodes
       * are sorted by depth order, so we need to resolve the entire tree before moving to
       * the next step.
       */
      this.updateProjection = () => {
        this.projectionUpdateScheduled = false;
        /**
         * Reset debug counts. Manually resetting rather than creating a new
         * object each frame.
         */
        if (isDebug) {
          metrics.totalNodes = metrics.resolvedTargetDeltas = metrics.recalculatedProjection = 0;
        }
        this.nodes.forEach(propagateDirtyNodes);
        this.nodes.forEach(resolveTargetDelta);
        this.nodes.forEach(calcProjection);
        this.nodes.forEach(cleanDirtyNodes);
        if (isDebug) {
          window.MotionDebug.record(metrics);
        }
      };
      /**
       * Frame calculations
       */
      this.resolvedRelativeTargetAt = 0.0;
      this.hasProjected = false;
      this.isVisible = true;
      this.animationProgress = 0;
      /**
       * Shared layout
       */
      // TODO Only running on root node
      this.sharedNodes = new Map();
      this.latestValues = latestValues;
      this.root = parent ? parent.root || parent : this;
      this.path = parent ? [...parent.path, parent] : [];
      this.parent = parent;
      this.depth = parent ? parent.depth + 1 : 0;
      for (let i = 0; i < this.path.length; i++) {
        this.path[i].shouldResetTransform = true;
      }
      if (this.root === this) this.nodes = new FlatTree();
    }
    addEventListener(name, handler) {
      if (!this.eventHandlers.has(name)) {
        this.eventHandlers.set(name, new SubscriptionManager());
      }
      return this.eventHandlers.get(name).add(handler);
    }
    notifyListeners(name, ...args) {
      const subscriptionManager = this.eventHandlers.get(name);
      subscriptionManager && subscriptionManager.notify(...args);
    }
    hasListeners(name) {
      return this.eventHandlers.has(name);
    }
    /**
     * Lifecycles
     */
    mount(instance, isLayoutDirty = this.root.hasTreeAnimated) {
      if (this.instance) return;
      this.isSVG = isSVGElement(instance);
      this.instance = instance;
      const {
        layoutId,
        layout,
        visualElement
      } = this.options;
      if (visualElement && !visualElement.current) {
        visualElement.mount(instance);
      }
      this.root.nodes.add(this);
      this.parent && this.parent.children.add(this);
      if (isLayoutDirty && (layout || layoutId)) {
        this.isLayoutDirty = true;
      }
      if (attachResizeListener) {
        let cancelDelay;
        const resizeUnblockUpdate = () => this.root.updateBlockedByResize = false;
        attachResizeListener(instance, () => {
          this.root.updateBlockedByResize = true;
          cancelDelay && cancelDelay();
          cancelDelay = delay(resizeUnblockUpdate, 250);
          if (globalProjectionState.hasAnimatedSinceResize) {
            globalProjectionState.hasAnimatedSinceResize = false;
            this.nodes.forEach(finishAnimation);
          }
        });
      }
      if (layoutId) {
        this.root.registerSharedNode(layoutId, this);
      }
      // Only register the handler if it requires layout animation
      if (this.options.animate !== false && visualElement && (layoutId || layout)) {
        this.addEventListener("didUpdate", ({
          delta,
          hasLayoutChanged,
          hasRelativeTargetChanged,
          layout: newLayout
        }) => {
          if (this.isTreeAnimationBlocked()) {
            this.target = undefined;
            this.relativeTarget = undefined;
            return;
          }
          // TODO: Check here if an animation exists
          const layoutTransition = this.options.transition || visualElement.getDefaultTransition() || defaultLayoutTransition;
          const {
            onLayoutAnimationStart,
            onLayoutAnimationComplete
          } = visualElement.getProps();
          /**
           * The target layout of the element might stay the same,
           * but its position relative to its parent has changed.
           */
          const targetChanged = !this.targetLayout || !boxEqualsRounded(this.targetLayout, newLayout) || hasRelativeTargetChanged;
          /**
           * If the layout hasn't seemed to have changed, it might be that the
           * element is visually in the same place in the document but its position
           * relative to its parent has indeed changed. So here we check for that.
           */
          const hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
          if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !this.currentAnimation)) {
            if (this.resumeFrom) {
              this.resumingFrom = this.resumeFrom;
              this.resumingFrom.resumingFrom = undefined;
            }
            this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
            const animationOptions = {
              ...motionDom.getValueTransition(layoutTransition, "layout"),
              onPlay: onLayoutAnimationStart,
              onComplete: onLayoutAnimationComplete
            };
            if (visualElement.shouldReduceMotion || this.options.layoutRoot) {
              animationOptions.delay = 0;
              animationOptions.type = false;
            }
            this.startAnimation(animationOptions);
          } else {
            /**
             * If the layout hasn't changed and we have an animation that hasn't started yet,
             * finish it immediately. Otherwise it will be animating from a location
             * that was probably never commited to screen and look like a jumpy box.
             */
            if (!hasLayoutChanged) {
              finishAnimation(this);
            }
            if (this.isLead() && this.options.onExitComplete) {
              this.options.onExitComplete();
            }
          }
          this.targetLayout = newLayout;
        });
      }
    }
    unmount() {
      this.options.layoutId && this.willUpdate();
      this.root.nodes.remove(this);
      const stack = this.getStack();
      stack && stack.remove(this);
      this.parent && this.parent.children.delete(this);
      this.instance = undefined;
      cancelFrame(this.updateProjection);
    }
    // only on the root
    blockUpdate() {
      this.updateManuallyBlocked = true;
    }
    unblockUpdate() {
      this.updateManuallyBlocked = false;
    }
    isUpdateBlocked() {
      return this.updateManuallyBlocked || this.updateBlockedByResize;
    }
    isTreeAnimationBlocked() {
      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || false;
    }
    // Note: currently only running on root node
    startUpdate() {
      if (this.isUpdateBlocked()) return;
      this.isUpdating = true;
      this.nodes && this.nodes.forEach(resetSkewAndRotation);
      this.animationId++;
    }
    getTransformTemplate() {
      const {
        visualElement
      } = this.options;
      return visualElement && visualElement.getProps().transformTemplate;
    }
    willUpdate(shouldNotifyListeners = true) {
      this.root.hasTreeAnimated = true;
      if (this.root.isUpdateBlocked()) {
        this.options.onExitComplete && this.options.onExitComplete();
        return;
      }
      /**
       * If we're running optimised appear animations then these must be
       * cancelled before measuring the DOM. This is so we can measure
       * the true layout of the element rather than the WAAPI animation
       * which will be unaffected by the resetSkewAndRotate step.
       *
       * Note: This is a DOM write. Worst case scenario is this is sandwiched
       * between other snapshot reads which will cause unnecessary style recalculations.
       * This has to happen here though, as we don't yet know which nodes will need
       * snapshots in startUpdate(), but we only want to cancel optimised animations
       * if a layout animation measurement is actually going to be affected by them.
       */
      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear) {
        cancelTreeOptimisedTransformAnimations(this);
      }
      !this.root.isUpdating && this.root.startUpdate();
      if (this.isLayoutDirty) return;
      this.isLayoutDirty = true;
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        node.shouldResetTransform = true;
        node.updateScroll("snapshot");
        if (node.options.layoutRoot) {
          node.willUpdate(false);
        }
      }
      const {
        layoutId,
        layout
      } = this.options;
      if (layoutId === undefined && !layout) return;
      const transformTemplate = this.getTransformTemplate();
      this.prevTransformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : undefined;
      this.updateSnapshot();
      shouldNotifyListeners && this.notifyListeners("willUpdate");
    }
    update() {
      this.updateScheduled = false;
      const updateWasBlocked = this.isUpdateBlocked();
      // When doing an instant transition, we skip the layout update,
      // but should still clean up the measurements so that the next
      // snapshot could be taken correctly.
      if (updateWasBlocked) {
        this.unblockUpdate();
        this.clearAllSnapshots();
        this.nodes.forEach(clearMeasurements);
        return;
      }
      if (!this.isUpdating) {
        this.nodes.forEach(clearIsLayoutDirty);
      }
      this.isUpdating = false;
      /**
       * Write
       */
      this.nodes.forEach(resetTransformStyle);
      /**
       * Read ==================
       */
      // Update layout measurements of updated children
      this.nodes.forEach(updateLayout);
      /**
       * Write
       */
      // Notify listeners that the layout is updated
      this.nodes.forEach(notifyLayoutUpdate);
      this.clearAllSnapshots();
      /**
       * Manually flush any pending updates. Ideally
       * we could leave this to the following requestAnimationFrame but this seems
       * to leave a flash of incorrectly styled content.
       */
      const now = time.now();
      frameData.delta = clamp(0, 1000 / 60, now - frameData.timestamp);
      frameData.timestamp = now;
      frameData.isProcessing = true;
      frameSteps.update.process(frameData);
      frameSteps.preRender.process(frameData);
      frameSteps.render.process(frameData);
      frameData.isProcessing = false;
    }
    didUpdate() {
      if (!this.updateScheduled) {
        this.updateScheduled = true;
        microtask.read(this.scheduleUpdate);
      }
    }
    clearAllSnapshots() {
      this.nodes.forEach(clearSnapshot);
      this.sharedNodes.forEach(removeLeadSnapshots);
    }
    scheduleUpdateProjection() {
      if (!this.projectionUpdateScheduled) {
        this.projectionUpdateScheduled = true;
        frame.preRender(this.updateProjection, false, true);
      }
    }
    scheduleCheckAfterUnmount() {
      /**
       * If the unmounting node is in a layoutGroup and did trigger a willUpdate,
       * we manually call didUpdate to give a chance to the siblings to animate.
       * Otherwise, cleanup all snapshots to prevents future nodes from reusing them.
       */
      frame.postRender(() => {
        if (this.isLayoutDirty) {
          this.root.didUpdate();
        } else {
          this.root.checkUpdateFailed();
        }
      });
    }
    /**
     * Update measurements
     */
    updateSnapshot() {
      if (this.snapshot || !this.instance) return;
      this.snapshot = this.measure();
    }
    updateLayout() {
      if (!this.instance) return;
      // TODO: Incorporate into a forwarded scroll offset
      this.updateScroll();
      if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
        return;
      }
      /**
       * When a node is mounted, it simply resumes from the prevLead's
       * snapshot instead of taking a new one, but the ancestors scroll
       * might have updated while the prevLead is unmounted. We need to
       * update the scroll again to make sure the layout we measure is
       * up to date.
       */
      if (this.resumeFrom && !this.resumeFrom.instance) {
        for (let i = 0; i < this.path.length; i++) {
          const node = this.path[i];
          node.updateScroll();
        }
      }
      const prevLayout = this.layout;
      this.layout = this.measure(false);
      this.layoutCorrected = createBox();
      this.isLayoutDirty = false;
      this.projectionDelta = undefined;
      this.notifyListeners("measure", this.layout.layoutBox);
      const {
        visualElement
      } = this.options;
      visualElement && visualElement.notify("LayoutMeasure", this.layout.layoutBox, prevLayout ? prevLayout.layoutBox : undefined);
    }
    updateScroll(phase = "measure") {
      let needsMeasurement = Boolean(this.options.layoutScroll && this.instance);
      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === phase) {
        needsMeasurement = false;
      }
      if (needsMeasurement) {
        const isRoot = checkIsScrollRoot(this.instance);
        this.scroll = {
          animationId: this.root.animationId,
          phase,
          isRoot,
          offset: measureScroll(this.instance),
          wasRoot: this.scroll ? this.scroll.isRoot : isRoot
        };
      }
    }
    resetTransform() {
      if (!resetTransform) return;
      const isResetRequested = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout;
      const hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
      const transformTemplate = this.getTransformTemplate();
      const transformTemplateValue = transformTemplate ? transformTemplate(this.latestValues, "") : undefined;
      const transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
      if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
        resetTransform(this.instance, transformTemplateValue);
        this.shouldResetTransform = false;
        this.scheduleRender();
      }
    }
    measure(removeTransform = true) {
      const pageBox = this.measurePageBox();
      let layoutBox = this.removeElementScroll(pageBox);
      /**
       * Measurements taken during the pre-render stage
       * still have transforms applied so we remove them
       * via calculation.
       */
      if (removeTransform) {
        layoutBox = this.removeTransform(layoutBox);
      }
      roundBox(layoutBox);
      return {
        animationId: this.root.animationId,
        measuredBox: pageBox,
        layoutBox,
        latestValues: {},
        source: this.id
      };
    }
    measurePageBox() {
      var _a;
      const {
        visualElement
      } = this.options;
      if (!visualElement) return createBox();
      const box = visualElement.measureViewportBox();
      const wasInScrollRoot = ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) || this.path.some(checkNodeWasScrollRoot);
      if (!wasInScrollRoot) {
        // Remove viewport scroll to give page-relative coordinates
        const {
          scroll
        } = this.root;
        if (scroll) {
          translateAxis(box.x, scroll.offset.x);
          translateAxis(box.y, scroll.offset.y);
        }
      }
      return box;
    }
    removeElementScroll(box) {
      var _a;
      const boxWithoutScroll = createBox();
      copyBoxInto(boxWithoutScroll, box);
      if ((_a = this.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot) {
        return boxWithoutScroll;
      }
      /**
       * Performance TODO: Keep a cumulative scroll offset down the tree
       * rather than loop back up the path.
       */
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        const {
          scroll,
          options
        } = node;
        if (node !== this.root && scroll && options.layoutScroll) {
          /**
           * If this is a new scroll root, we want to remove all previous scrolls
           * from the viewport box.
           */
          if (scroll.wasRoot) {
            copyBoxInto(boxWithoutScroll, box);
          }
          translateAxis(boxWithoutScroll.x, scroll.offset.x);
          translateAxis(boxWithoutScroll.y, scroll.offset.y);
        }
      }
      return boxWithoutScroll;
    }
    applyTransform(box, transformOnly = false) {
      const withTransforms = createBox();
      copyBoxInto(withTransforms, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
          transformBox(withTransforms, {
            x: -node.scroll.offset.x,
            y: -node.scroll.offset.y
          });
        }
        if (!hasTransform(node.latestValues)) continue;
        transformBox(withTransforms, node.latestValues);
      }
      if (hasTransform(this.latestValues)) {
        transformBox(withTransforms, this.latestValues);
      }
      return withTransforms;
    }
    removeTransform(box) {
      const boxWithoutTransform = createBox();
      copyBoxInto(boxWithoutTransform, box);
      for (let i = 0; i < this.path.length; i++) {
        const node = this.path[i];
        if (!node.instance) continue;
        if (!hasTransform(node.latestValues)) continue;
        hasScale(node.latestValues) && node.updateSnapshot();
        const sourceBox = createBox();
        const nodeBox = node.measurePageBox();
        copyBoxInto(sourceBox, nodeBox);
        removeBoxTransforms(boxWithoutTransform, node.latestValues, node.snapshot ? node.snapshot.layoutBox : undefined, sourceBox);
      }
      if (hasTransform(this.latestValues)) {
        removeBoxTransforms(boxWithoutTransform, this.latestValues);
      }
      return boxWithoutTransform;
    }
    setTargetDelta(delta) {
      this.targetDelta = delta;
      this.root.scheduleUpdateProjection();
      this.isProjectionDirty = true;
    }
    setOptions(options) {
      this.options = {
        ...this.options,
        ...options,
        crossfade: options.crossfade !== undefined ? options.crossfade : true
      };
    }
    clearMeasurements() {
      this.scroll = undefined;
      this.layout = undefined;
      this.snapshot = undefined;
      this.prevTransformTemplateValue = undefined;
      this.targetDelta = undefined;
      this.target = undefined;
      this.isLayoutDirty = false;
    }
    forceRelativeParentToResolveTarget() {
      if (!this.relativeParent) return;
      /**
       * If the parent target isn't up-to-date, force it to update.
       * This is an unfortunate de-optimisation as it means any updating relative
       * projection will cause all the relative parents to recalculate back
       * up the tree.
       */
      if (this.relativeParent.resolvedRelativeTargetAt !== frameData.timestamp) {
        this.relativeParent.resolveTargetDelta(true);
      }
    }
    resolveTargetDelta(forceRecalculation = false) {
      var _a;
      /**
       * Once the dirty status of nodes has been spread through the tree, we also
       * need to check if we have a shared node of a different depth that has itself
       * been dirtied.
       */
      const lead = this.getLead();
      this.isProjectionDirty || (this.isProjectionDirty = lead.isProjectionDirty);
      this.isTransformDirty || (this.isTransformDirty = lead.isTransformDirty);
      this.isSharedProjectionDirty || (this.isSharedProjectionDirty = lead.isSharedProjectionDirty);
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      /**
       * We don't use transform for this step of processing so we don't
       * need to check whether any nodes have changed transform.
       */
      const canSkip = !(forceRecalculation || isShared && this.isSharedProjectionDirty || this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty) || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize);
      if (canSkip) return;
      const {
        layout,
        layoutId
      } = this.options;
      /**
       * If we have no layout, we can't perform projection, so early return
       */
      if (!this.layout || !(layout || layoutId)) return;
      this.resolvedRelativeTargetAt = frameData.timestamp;
      /**
       * If we don't have a targetDelta but do have a layout, we can attempt to resolve
       * a relativeParent. This will allow a component to perform scale correction
       * even if no animation has started.
       */
      if (!this.targetDelta && !this.relativeTarget) {
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && relativeParent.layout && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.layout.layoutBox, relativeParent.layout.layoutBox);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = undefined;
        }
      }
      /**
       * If we have no relative target or no target delta our target isn't valid
       * for this frame.
       */
      if (!this.relativeTarget && !this.targetDelta) return;
      /**
       * Lazy-init target data structure
       */
      if (!this.target) {
        this.target = createBox();
        this.targetWithTransforms = createBox();
      }
      /**
       * If we've got a relative box for this component, resolve it into a target relative to the parent.
       */
      if (this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target) {
        this.forceRelativeParentToResolveTarget();
        calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        /**
         * If we've only got a targetDelta, resolve it into a target
         */
      } else if (this.targetDelta) {
        if (Boolean(this.resumingFrom)) {
          // TODO: This is creating a new object every frame
          this.target = this.applyTransform(this.layout.layoutBox);
        } else {
          copyBoxInto(this.target, this.layout.layoutBox);
        }
        applyBoxDelta(this.target, this.targetDelta);
      } else {
        /**
         * If no target, use own layout as target
         */
        copyBoxInto(this.target, this.layout.layoutBox);
      }
      /**
       * If we've been told to attempt to resolve a relative target, do so.
       */
      if (this.attemptToResolveRelativeTarget) {
        this.attemptToResolveRelativeTarget = false;
        const relativeParent = this.getClosestProjectingParent();
        if (relativeParent && Boolean(relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !relativeParent.options.layoutScroll && relativeParent.target && this.animationProgress !== 1) {
          this.relativeParent = relativeParent;
          this.forceRelativeParentToResolveTarget();
          this.relativeTarget = createBox();
          this.relativeTargetOrigin = createBox();
          calcRelativePosition(this.relativeTargetOrigin, this.target, relativeParent.target);
          copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
        } else {
          this.relativeParent = this.relativeTarget = undefined;
        }
      }
      /**
       * Increase debug counter for resolved target deltas
       */
      if (isDebug) {
        metrics.resolvedTargetDeltas++;
      }
    }
    getClosestProjectingParent() {
      if (!this.parent || hasScale(this.parent.latestValues) || has2DTranslate(this.parent.latestValues)) {
        return undefined;
      }
      if (this.parent.isProjecting()) {
        return this.parent;
      } else {
        return this.parent.getClosestProjectingParent();
      }
    }
    isProjecting() {
      return Boolean((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);
    }
    calcProjection() {
      var _a;
      const lead = this.getLead();
      const isShared = Boolean(this.resumingFrom) || this !== lead;
      let canSkip = true;
      /**
       * If this is a normal layout animation and neither this node nor its nearest projecting
       * is dirty then we can't skip.
       */
      if (this.isProjectionDirty || ((_a = this.parent) === null || _a === void 0 ? void 0 : _a.isProjectionDirty)) {
        canSkip = false;
      }
      /**
       * If this is a shared layout animation and this node's shared projection is dirty then
       * we can't skip.
       */
      if (isShared && (this.isSharedProjectionDirty || this.isTransformDirty)) {
        canSkip = false;
      }
      /**
       * If we have resolved the target this frame we must recalculate the
       * projection to ensure it visually represents the internal calculations.
       */
      if (this.resolvedRelativeTargetAt === frameData.timestamp) {
        canSkip = false;
      }
      if (canSkip) return;
      const {
        layout,
        layoutId
      } = this.options;
      /**
       * If this section of the tree isn't animating we can
       * delete our target sources for the following frame.
       */
      this.isTreeAnimating = Boolean(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation);
      if (!this.isTreeAnimating) {
        this.targetDelta = this.relativeTarget = undefined;
      }
      if (!this.layout || !(layout || layoutId)) return;
      /**
       * Reset the corrected box with the latest values from box, as we're then going
       * to perform mutative operations on it.
       */
      copyBoxInto(this.layoutCorrected, this.layout.layoutBox);
      /**
       * Record previous tree scales before updating.
       */
      const prevTreeScaleX = this.treeScale.x;
      const prevTreeScaleY = this.treeScale.y;
      /**
       * Apply all the parent deltas to this box to produce the corrected box. This
       * is the layout box, as it will appear on screen as a result of the transforms of its parents.
       */
      applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, isShared);
      /**
       * If this layer needs to perform scale correction but doesn't have a target,
       * use the layout as the target.
       */
      if (lead.layout && !lead.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1)) {
        lead.target = lead.layout.layoutBox;
        lead.targetWithTransforms = createBox();
      }
      const {
        target
      } = lead;
      if (!target) {
        /**
         * If we don't have a target to project into, but we were previously
         * projecting, we want to remove the stored transform and schedule
         * a render to ensure the elements reflect the removed transform.
         */
        if (this.prevProjectionDelta) {
          this.createProjectionDeltas();
          this.scheduleRender();
        }
        return;
      }
      if (!this.projectionDelta || !this.prevProjectionDelta) {
        this.createProjectionDeltas();
      } else {
        copyAxisDeltaInto(this.prevProjectionDelta.x, this.projectionDelta.x);
        copyAxisDeltaInto(this.prevProjectionDelta.y, this.projectionDelta.y);
      }
      /**
       * Update the delta between the corrected box and the target box before user-set transforms were applied.
       * This will allow us to calculate the corrected borderRadius and boxShadow to compensate
       * for our layout reprojection, but still allow them to be scaled correctly by the user.
       * It might be that to simplify this we may want to accept that user-set scale is also corrected
       * and we wouldn't have to keep and calc both deltas, OR we could support a user setting
       * to allow people to choose whether these styles are corrected based on just the
       * layout reprojection or the final bounding box.
       */
      calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
      if (this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY || !axisDeltaEquals(this.projectionDelta.x, this.prevProjectionDelta.x) || !axisDeltaEquals(this.projectionDelta.y, this.prevProjectionDelta.y)) {
        this.hasProjected = true;
        this.scheduleRender();
        this.notifyListeners("projectionUpdate", target);
      }
      /**
       * Increase debug counter for recalculated projections
       */
      if (isDebug) {
        metrics.recalculatedProjection++;
      }
    }
    hide() {
      this.isVisible = false;
      // TODO: Schedule render
    }
    show() {
      this.isVisible = true;
      // TODO: Schedule render
    }
    scheduleRender(notifyAll = true) {
      var _a;
      (_a = this.options.visualElement) === null || _a === void 0 ? void 0 : _a.scheduleRender();
      if (notifyAll) {
        const stack = this.getStack();
        stack && stack.scheduleRender();
      }
      if (this.resumingFrom && !this.resumingFrom.instance) {
        this.resumingFrom = undefined;
      }
    }
    createProjectionDeltas() {
      this.prevProjectionDelta = createDelta();
      this.projectionDelta = createDelta();
      this.projectionDeltaWithTransform = createDelta();
    }
    setAnimationOrigin(delta, hasOnlyRelativeTargetChanged = false) {
      const snapshot = this.snapshot;
      const snapshotLatestValues = snapshot ? snapshot.latestValues : {};
      const mixedValues = {
        ...this.latestValues
      };
      const targetDelta = createDelta();
      if (!this.relativeParent || !this.relativeParent.options.layoutRoot) {
        this.relativeTarget = this.relativeTargetOrigin = undefined;
      }
      this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
      const relativeLayout = createBox();
      const snapshotSource = snapshot ? snapshot.source : undefined;
      const layoutSource = this.layout ? this.layout.source : undefined;
      const isSharedLayoutAnimation = snapshotSource !== layoutSource;
      const stack = this.getStack();
      const isOnlyMember = !stack || stack.members.length <= 1;
      const shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
      this.animationProgress = 0;
      let prevRelativeTarget;
      this.mixTargetDelta = latest => {
        const progress = latest / 1000;
        mixAxisDelta(targetDelta.x, delta.x, progress);
        mixAxisDelta(targetDelta.y, delta.y, progress);
        this.setTargetDelta(targetDelta);
        if (this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout) {
          calcRelativePosition(relativeLayout, this.layout.layoutBox, this.relativeParent.layout.layoutBox);
          mixBox(this.relativeTarget, this.relativeTargetOrigin, relativeLayout, progress);
          /**
           * If this is an unchanged relative target we can consider the
           * projection not dirty.
           */
          if (prevRelativeTarget && boxEquals(this.relativeTarget, prevRelativeTarget)) {
            this.isProjectionDirty = false;
          }
          if (!prevRelativeTarget) prevRelativeTarget = createBox();
          copyBoxInto(prevRelativeTarget, this.relativeTarget);
        }
        if (isSharedLayoutAnimation) {
          this.animationValues = mixedValues;
          mixValues(mixedValues, snapshotLatestValues, this.latestValues, progress, shouldCrossfadeOpacity, isOnlyMember);
        }
        this.root.scheduleUpdateProjection();
        this.scheduleRender();
        this.animationProgress = progress;
      };
      this.mixTargetDelta(this.options.layoutRoot ? 1000 : 0);
    }
    startAnimation(options) {
      this.notifyListeners("animationStart");
      this.currentAnimation && this.currentAnimation.stop();
      if (this.resumingFrom && this.resumingFrom.currentAnimation) {
        this.resumingFrom.currentAnimation.stop();
      }
      if (this.pendingAnimation) {
        cancelFrame(this.pendingAnimation);
        this.pendingAnimation = undefined;
      }
      /**
       * Start the animation in the next frame to have a frame with progress 0,
       * where the target is the same as when the animation started, so we can
       * calculate the relative positions correctly for instant transitions.
       */
      this.pendingAnimation = frame.update(() => {
        globalProjectionState.hasAnimatedSinceResize = true;
        this.currentAnimation = animateSingleValue(0, animationTarget, {
          ...options,
          onUpdate: latest => {
            this.mixTargetDelta(latest);
            options.onUpdate && options.onUpdate(latest);
          },
          onComplete: () => {
            options.onComplete && options.onComplete();
            this.completeAnimation();
          }
        });
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = this.currentAnimation;
        }
        this.pendingAnimation = undefined;
      });
    }
    completeAnimation() {
      if (this.resumingFrom) {
        this.resumingFrom.currentAnimation = undefined;
        this.resumingFrom.preserveOpacity = undefined;
      }
      const stack = this.getStack();
      stack && stack.exitAnimationComplete();
      this.resumingFrom = this.currentAnimation = this.animationValues = undefined;
      this.notifyListeners("animationComplete");
    }
    finishAnimation() {
      if (this.currentAnimation) {
        this.mixTargetDelta && this.mixTargetDelta(animationTarget);
        this.currentAnimation.stop();
      }
      this.completeAnimation();
    }
    applyTransformsToTarget() {
      const lead = this.getLead();
      let {
        targetWithTransforms,
        target,
        layout,
        latestValues
      } = lead;
      if (!targetWithTransforms || !target || !layout) return;
      /**
       * If we're only animating position, and this element isn't the lead element,
       * then instead of projecting into the lead box we instead want to calculate
       * a new target that aligns the two boxes but maintains the layout shape.
       */
      if (this !== lead && this.layout && layout && shouldAnimatePositionOnly(this.options.animationType, this.layout.layoutBox, layout.layoutBox)) {
        target = this.target || createBox();
        const xLength = calcLength(this.layout.layoutBox.x);
        target.x.min = lead.target.x.min;
        target.x.max = target.x.min + xLength;
        const yLength = calcLength(this.layout.layoutBox.y);
        target.y.min = lead.target.y.min;
        target.y.max = target.y.min + yLength;
      }
      copyBoxInto(targetWithTransforms, target);
      /**
       * Apply the latest user-set transforms to the targetBox to produce the targetBoxFinal.
       * This is the final box that we will then project into by calculating a transform delta and
       * applying it to the corrected box.
       */
      transformBox(targetWithTransforms, latestValues);
      /**
       * Update the delta between the corrected box and the final target box, after
       * user-set transforms are applied to it. This will be used by the renderer to
       * create a transform style that will reproject the element from its layout layout
       * into the desired bounding box.
       */
      calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
    }
    registerSharedNode(layoutId, node) {
      if (!this.sharedNodes.has(layoutId)) {
        this.sharedNodes.set(layoutId, new NodeStack());
      }
      const stack = this.sharedNodes.get(layoutId);
      stack.add(node);
      const config = node.options.initialPromotionConfig;
      node.promote({
        transition: config ? config.transition : undefined,
        preserveFollowOpacity: config && config.shouldPreserveFollowOpacity ? config.shouldPreserveFollowOpacity(node) : undefined
      });
    }
    isLead() {
      const stack = this.getStack();
      return stack ? stack.lead === this : true;
    }
    getLead() {
      var _a;
      const {
        layoutId
      } = this.options;
      return layoutId ? ((_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.lead) || this : this;
    }
    getPrevLead() {
      var _a;
      const {
        layoutId
      } = this.options;
      return layoutId ? (_a = this.getStack()) === null || _a === void 0 ? void 0 : _a.prevLead : undefined;
    }
    getStack() {
      const {
        layoutId
      } = this.options;
      if (layoutId) return this.root.sharedNodes.get(layoutId);
    }
    promote({
      needsReset,
      transition,
      preserveFollowOpacity
    } = {}) {
      const stack = this.getStack();
      if (stack) stack.promote(this, preserveFollowOpacity);
      if (needsReset) {
        this.projectionDelta = undefined;
        this.needsReset = true;
      }
      if (transition) this.setOptions({
        transition
      });
    }
    relegate() {
      const stack = this.getStack();
      if (stack) {
        return stack.relegate(this);
      } else {
        return false;
      }
    }
    resetSkewAndRotation() {
      const {
        visualElement
      } = this.options;
      if (!visualElement) return;
      // If there's no detected skew or rotation values, we can early return without a forced render.
      let hasDistortingTransform = false;
      /**
       * An unrolled check for rotation values. Most elements don't have any rotation and
       * skipping the nested loop and new object creation is 50% faster.
       */
      const {
        latestValues
      } = visualElement;
      if (latestValues.z || latestValues.rotate || latestValues.rotateX || latestValues.rotateY || latestValues.rotateZ || latestValues.skewX || latestValues.skewY) {
        hasDistortingTransform = true;
      }
      // If there's no distorting values, we don't need to do any more.
      if (!hasDistortingTransform) return;
      const resetValues = {};
      if (latestValues.z) {
        resetDistortingTransform("z", visualElement, resetValues, this.animationValues);
      }
      // Check the skew and rotate value of all axes and reset to 0
      for (let i = 0; i < transformAxes.length; i++) {
        resetDistortingTransform(`rotate${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
        resetDistortingTransform(`skew${transformAxes[i]}`, visualElement, resetValues, this.animationValues);
      }
      // Force a render of this element to apply the transform with all skews and rotations
      // set to 0.
      visualElement.render();
      // Put back all the values we reset
      for (const key in resetValues) {
        visualElement.setStaticValue(key, resetValues[key]);
        if (this.animationValues) {
          this.animationValues[key] = resetValues[key];
        }
      }
      // Schedule a render for the next frame. This ensures we won't visually
      // see the element with the reset rotate value applied.
      visualElement.scheduleRender();
    }
    getProjectionStyles(styleProp) {
      var _a, _b;
      if (!this.instance || this.isSVG) return undefined;
      if (!this.isVisible) {
        return hiddenVisibility;
      }
      const styles = {
        visibility: ""
      };
      const transformTemplate = this.getTransformTemplate();
      if (this.needsReset) {
        this.needsReset = false;
        styles.opacity = "";
        styles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        styles.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
        return styles;
      }
      const lead = this.getLead();
      if (!this.projectionDelta || !this.layout || !lead.target) {
        const emptyStyles = {};
        if (this.options.layoutId) {
          emptyStyles.opacity = this.latestValues.opacity !== undefined ? this.latestValues.opacity : 1;
          emptyStyles.pointerEvents = resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "";
        }
        if (this.hasProjected && !hasTransform(this.latestValues)) {
          emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
          this.hasProjected = false;
        }
        return emptyStyles;
      }
      const valuesToRender = lead.animationValues || lead.latestValues;
      this.applyTransformsToTarget();
      styles.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
      if (transformTemplate) {
        styles.transform = transformTemplate(valuesToRender, styles.transform);
      }
      const {
        x,
        y
      } = this.projectionDelta;
      styles.transformOrigin = `${x.origin * 100}% ${y.origin * 100}% 0`;
      if (lead.animationValues) {
        /**
         * If the lead component is animating, assign this either the entering/leaving
         * opacity
         */
        styles.opacity = lead === this ? (_b = (_a = valuesToRender.opacity) !== null && _a !== void 0 ? _a : this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
      } else {
        /**
         * Or we're not animating at all, set the lead component to its layout
         * opacity and other components to hidden.
         */
        styles.opacity = lead === this ? valuesToRender.opacity !== undefined ? valuesToRender.opacity : "" : valuesToRender.opacityExit !== undefined ? valuesToRender.opacityExit : 0;
      }
      /**
       * Apply scale correction
       */
      for (const key in scaleCorrectors) {
        if (valuesToRender[key] === undefined) continue;
        const {
          correct,
          applyTo
        } = scaleCorrectors[key];
        /**
         * Only apply scale correction to the value if we have an
         * active projection transform. Otherwise these values become
         * vulnerable to distortion if the element changes size without
         * a corresponding layout animation.
         */
        const corrected = styles.transform === "none" ? valuesToRender[key] : correct(valuesToRender[key], lead);
        if (applyTo) {
          const num = applyTo.length;
          for (let i = 0; i < num; i++) {
            styles[applyTo[i]] = corrected;
          }
        } else {
          styles[key] = corrected;
        }
      }
      /**
       * Disable pointer events on follow components. This is to ensure
       * that if a follow component covers a lead component it doesn't block
       * pointer events on the lead.
       */
      if (this.options.layoutId) {
        styles.pointerEvents = lead === this ? resolveMotionValue(styleProp === null || styleProp === void 0 ? void 0 : styleProp.pointerEvents) || "" : "none";
      }
      return styles;
    }
    clearSnapshot() {
      this.resumeFrom = this.snapshot = undefined;
    }
    // Only run on root
    resetTree() {
      this.root.nodes.forEach(node => {
        var _a;
        return (_a = node.currentAnimation) === null || _a === void 0 ? void 0 : _a.stop();
      });
      this.root.nodes.forEach(clearMeasurements);
      this.root.sharedNodes.clear();
    }
  };
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a;
  const snapshot = ((_a = node.resumeFrom) === null || _a === void 0 ? void 0 : _a.snapshot) || node.snapshot;
  if (node.isLead() && node.layout && snapshot && node.hasListeners("didUpdate")) {
    const {
      layoutBox: layout,
      measuredBox: measuredLayout
    } = node.layout;
    const {
      animationType
    } = node.options;
    const isShared = snapshot.source !== node.layout.source;
    // TODO Maybe we want to also resize the layout snapshot so we don't trigger
    // animations for instance if layout="size" and an element has only changed position
    if (animationType === "size") {
      eachAxis(axis => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(axisSnapshot);
        axisSnapshot.min = layout[axis].min;
        axisSnapshot.max = axisSnapshot.min + length;
      });
    } else if (shouldAnimatePositionOnly(animationType, snapshot.layoutBox, layout)) {
      eachAxis(axis => {
        const axisSnapshot = isShared ? snapshot.measuredBox[axis] : snapshot.layoutBox[axis];
        const length = calcLength(layout[axis]);
        axisSnapshot.max = axisSnapshot.min + length;
        /**
         * Ensure relative target gets resized and rerendererd
         */
        if (node.relativeTarget && !node.currentAnimation) {
          node.isProjectionDirty = true;
          node.relativeTarget[axis].max = node.relativeTarget[axis].min + length;
        }
      });
    }
    const layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout, snapshot.layoutBox);
    const visualDelta = createDelta();
    if (isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot.measuredBox);
    } else {
      calcBoxDelta(visualDelta, layout, snapshot.layoutBox);
    }
    const hasLayoutChanged = !isDeltaZero(layoutDelta);
    let hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      const relativeParent = node.getClosestProjectingParent();
      /**
       * If the relativeParent is itself resuming from a different element then
       * the relative snapshot is not relavent
       */
      if (relativeParent && !relativeParent.resumeFrom) {
        const {
          snapshot: parentSnapshot,
          layout: parentLayout
        } = relativeParent;
        if (parentSnapshot && parentLayout) {
          const relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot.layoutBox, parentSnapshot.layoutBox);
          const relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout, parentLayout.layoutBox);
          if (!boxEqualsRounded(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
          if (relativeParent.options.layoutRoot) {
            node.relativeTarget = relativeLayout;
            node.relativeTargetOrigin = relativeSnapshot;
            node.relativeParent = relativeParent;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout,
      snapshot,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    const {
      onExitComplete
    } = node.options;
    onExitComplete && onExitComplete();
  }
  /**
   * Clearing transition
   * TODO: Investigate why this transition is being passed in as {type: false } from Framer
   * and why we need it at all
   */
  node.options.transition = undefined;
}
function propagateDirtyNodes(node) {
  /**
   * Increase debug counter for nodes encountered this frame
   */
  if (isDebug) {
    metrics.totalNodes++;
  }
  if (!node.parent) return;
  /**
   * If this node isn't projecting, propagate isProjectionDirty. It will have
   * no performance impact but it will allow the next child that *is* projecting
   * but *isn't* dirty to just check its parent to see if *any* ancestor needs
   * correcting.
   */
  if (!node.isProjecting()) {
    node.isProjectionDirty = node.parent.isProjectionDirty;
  }
  /**
   * Propagate isSharedProjectionDirty and isTransformDirty
   * throughout the whole tree. A future revision can take another look at
   * this but for safety we still recalcualte shared nodes.
   */
  node.isSharedProjectionDirty || (node.isSharedProjectionDirty = Boolean(node.isProjectionDirty || node.parent.isProjectionDirty || node.parent.isSharedProjectionDirty));
  node.isTransformDirty || (node.isTransformDirty = node.parent.isTransformDirty);
}
function cleanDirtyNodes(node) {
  node.isProjectionDirty = node.isSharedProjectionDirty = node.isTransformDirty = false;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function clearIsLayoutDirty(node) {
  node.isLayoutDirty = false;
}
function resetTransformStyle(node) {
  const {
    visualElement
  } = node.options;
  if (visualElement && visualElement.getProps().onBeforeLayoutMeasure) {
    visualElement.notify("BeforeLayoutMeasure");
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = undefined;
  node.isProjectionDirty = true;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetSkewAndRotation(node) {
  node.resetSkewAndRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p) {
  output.translate = mixNumber$1(delta.translate, 0, p);
  output.scale = mixNumber$1(delta.scale, 1, p);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from, to, p) {
  output.min = mixNumber$1(from.min, to.min, p);
  output.max = mixNumber$1(from.max, to.max, p);
}
function mixBox(output, from, to, p) {
  mixAxis(output.x, from.x, to.x, p);
  mixAxis(output.y, from.y, to.y, p);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== undefined;
}
const defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
const userAgentContains = string => typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(string);
/**
 * Measured bounding boxes must be rounded in Safari and
 * left untouched in Chrome, otherwise non-integer layouts within scaled-up elements
 * can appear to jump.
 */
const roundPoint = userAgentContains("applewebkit/") && !userAgentContains("chrome/") ? Math.round : motionUtils.noop;
function roundAxis(axis) {
  // Round to the nearest .5 pixels to support subpixel layouts
  axis.min = roundPoint(axis.min);
  axis.max = roundPoint(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}
function shouldAnimatePositionOnly(animationType, snapshot, layout) {
  return animationType === "position" || animationType === "preserve-aspect" && !isNear(aspectRatio(snapshot), aspectRatio(layout), 0.2);
}
function checkNodeWasScrollRoot(node) {
  var _a;
  return node !== node.root && ((_a = node.scroll) === null || _a === void 0 ? void 0 : _a.wasRoot);
}
const DocumentProjectionNode = createProjectionNode$1({
  attachResizeListener: (ref, notify) => addDomEvent(ref, "resize", notify),
  measureScroll: () => ({
    x: document.documentElement.scrollLeft || document.body.scrollLeft,
    y: document.documentElement.scrollTop || document.body.scrollTop
  }),
  checkIsScrollRoot: () => true
});
const rootProjectionNode = {
  current: undefined
};
const HTMLProjectionNode = createProjectionNode$1({
  measureScroll: instance => ({
    x: instance.scrollLeft,
    y: instance.scrollTop
  }),
  defaultParent: () => {
    if (!rootProjectionNode.current) {
      const documentNode = new DocumentProjectionNode({});
      documentNode.mount(window);
      documentNode.setOptions({
        layoutScroll: true
      });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: (instance, value) => {
    instance.style.transform = value !== undefined ? value : "none";
  },
  checkIsScrollRoot: instance => Boolean(window.getComputedStyle(instance).position === "fixed")
});
const notify = node => !node.isLayoutDirty && node.willUpdate(false);
function nodeGroup() {
  const nodes = new Set();
  const subscriptions = new WeakMap();
  const dirtyAll = () => nodes.forEach(notify);
  return {
    add: node => {
      nodes.add(node);
      subscriptions.set(node, node.addEventListener("willUpdate", dirtyAll));
    },
    remove: node => {
      nodes.delete(node);
      const unsubscribe = subscriptions.get(node);
      if (unsubscribe) {
        unsubscribe();
        subscriptions.delete(node);
      }
      dirtyAll();
    },
    dirty: dirtyAll
  };
}
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min) return 0;
  return pixels / (axis.max - axis.min) * 100;
}
/**
 * We always correct borderRadius as a percentage rather than pixels to reduce paints.
 * For example, if you are projecting a box that is 100px wide with a 10px borderRadius
 * into a box that is 200px wide with a 20px borderRadius, that is actually a 10%
 * borderRadius in both states. If we animate between the two in pixels that will trigger
 * a paint each time. If we animate between the two in percentage we'll avoid a paint.
 */
const correctBorderRadius = {
  correct: (latest, node) => {
    if (!node.target) return latest;
    /**
     * If latest is a string, if it's a percentage we can return immediately as it's
     * going to be stretched appropriately. Otherwise, if it's a pixel, convert it to a number.
     */
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    /**
     * If latest is a number, it's a pixel value. We use the current viewportBox to calculate that
     * pixel value as a percentage of each axis
     */
    const x = pixelsToPercent(latest, node.target.x);
    const y = pixelsToPercent(latest, node.target.y);
    return `${x}% ${y}%`;
  }
};
const correctBoxShadow = {
  correct: (latest, {
    treeScale,
    projectionDelta
  }) => {
    const original = latest;
    const shadow = complex.parse(latest);
    // TODO: Doesn't support multiple shadows
    if (shadow.length > 5) return original;
    const template = complex.createTransformer(latest);
    const offset = typeof shadow[0] !== "number" ? 1 : 0;
    // Calculate the overall context scale
    const xScale = projectionDelta.x.scale * treeScale.x;
    const yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    /**
     * Ideally we'd correct x and y scales individually, but because blur and
     * spread apply to both we have to take a scale average and apply that instead.
     * We could potentially improve the outcome of this by incorporating the ratio between
     * the two scales.
     */
    const averageScale = mixNumber$1(xScale, yScale, 0.5);
    // Blur
    if (typeof shadow[2 + offset] === "number") shadow[2 + offset] /= averageScale;
    // Spread
    if (typeof shadow[3 + offset] === "number") shadow[3 + offset] /= averageScale;
    return template(shadow);
  }
};
const shouldInheritGroup = inherit => inherit === true;
const shouldInheritId = inherit => shouldInheritGroup(inherit === true) || inherit === "id";
const LayoutGroup = ({
  children,
  id,
  inherit = true
}) => {
  const layoutGroupContext = React.useContext(LayoutGroupContext);
  const deprecatedLayoutGroupContext = React.useContext(DeprecatedLayoutGroupContext);
  const [forceRender, key] = useForceUpdate();
  const context = React.useRef(null);
  const upstreamId = layoutGroupContext.id || deprecatedLayoutGroupContext;
  if (context.current === null) {
    if (shouldInheritId(inherit) && upstreamId) {
      id = id ? upstreamId + "-" + id : upstreamId;
    }
    context.current = {
      id,
      group: shouldInheritGroup(inherit) ? layoutGroupContext.group || nodeGroup() : nodeGroup()
    };
  }
  const memoizedContext = React.useMemo(() => ({
    ...context.current,
    forceRender
  }), [key]);
  return jsxRuntime.jsx(LayoutGroupContext.Provider, {
    value: memoizedContext,
    children: children
  });
};
const LazyContext = React.createContext({
  strict: false
});
function loadFeatures(features) {
  for (const key in features) {
    featureDefinitions[key] = {
      ...featureDefinitions[key],
      ...features[key]
    };
  }
}

/**
 * Used in conjunction with the `m` component to reduce bundle size.
 *
 * `m` is a version of the `motion` component that only loads functionality
 * critical for the initial render.
 *
 * `LazyMotion` can then be used to either synchronously or asynchronously
 * load animation and gesture support.
 *
 * ```jsx
 * // Synchronous loading
 * import { LazyMotion, m, domAnimation } from "framer-motion"
 *
 * function App() {
 *   return (
 *     <LazyMotion features={domAnimation}>
 *       <m.div animate={{ scale: 2 }} />
 *     </LazyMotion>
 *   )
 * }
 *
 * // Asynchronous loading
 * import { LazyMotion, m } from "framer-motion"
 *
 * function App() {
 *   return (
 *     <LazyMotion features={() => import('./path/to/domAnimation')}>
 *       <m.div animate={{ scale: 2 }} />
 *     </LazyMotion>
 *   )
 * }
 * ```
 *
 * @public
 */
function LazyMotion({
  children,
  features,
  strict = false
}) {
  const [, setIsLoaded] = React.useState(!isLazyBundle(features));
  const loadedRenderer = React.useRef(undefined);
  /**
   * If this is a synchronous load, load features immediately
   */
  if (!isLazyBundle(features)) {
    const {
      renderer,
      ...loadedFeatures
    } = features;
    loadedRenderer.current = renderer;
    loadFeatures(loadedFeatures);
  }
  React.useEffect(() => {
    if (isLazyBundle(features)) {
      features().then(({
        renderer,
        ...loadedFeatures
      }) => {
        loadFeatures(loadedFeatures);
        loadedRenderer.current = renderer;
        setIsLoaded(true);
      });
    }
  }, []);
  return jsxRuntime.jsx(LazyContext.Provider, {
    value: {
      renderer: loadedRenderer.current,
      strict
    },
    children: children
  });
}
function isLazyBundle(features) {
  return typeof features === "function";
}

/**
 * `MotionConfig` is used to set configuration options for all children `motion` components.
 *
 * ```jsx
 * import { motion, MotionConfig } from "framer-motion"
 *
 * export function App() {
 *   return (
 *     <MotionConfig transition={{ type: "spring" }}>
 *       <motion.div animate={{ x: 100 }} />
 *     </MotionConfig>
 *   )
 * }
 * ```
 *
 * @public
 */
function MotionConfig({
  children,
  isValidProp,
  ...config
}) {
  isValidProp && loadExternalIsValidProp(isValidProp);
  /**
   * Inherit props from any parent MotionConfig components
   */
  config = {
    ...React.useContext(MotionConfigContext),
    ...config
  };
  /**
   * Don't allow isStatic to change between renders as it affects how many hooks
   * motion components fire.
   */
  config.isStatic = useConstant(() => config.isStatic);
  /**
   * Creating a new config context object will re-render every `motion` component
   * every time it renders. So we only want to create a new one sparingly.
   */
  const context = React.useMemo(() => config, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
  return jsxRuntime.jsx(MotionConfigContext.Provider, {
    value: context,
    children: children
  });
}
const ReorderContext = React.createContext(null);
function createDOMMotionComponentProxy(componentFactory) {
  if (typeof Proxy === "undefined") {
    return componentFactory;
  }
  /**
   * A cache of generated `motion` components, e.g `motion.div`, `motion.input` etc.
   * Rather than generating them anew every render.
   */
  const componentCache = new Map();
  const deprecatedFactoryFunction = (...args) => {
    if (process.env.NODE_ENV !== "production") {
      warnOnce(false, "motion() is deprecated. Use motion.create() instead.");
    }
    return componentFactory(...args);
  };
  return new Proxy(deprecatedFactoryFunction, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: (_target, key) => {
      if (key === "create") return componentFactory;
      /**
       * If this element doesn't exist in the component cache, create it and cache.
       */
      if (!componentCache.has(key)) {
        componentCache.set(key, componentFactory(key));
      }
      return componentCache.get(key);
    }
  });
}

/**
 * @internal
 */
class PanSession {
  constructor(event, handlers, {
    transformPagePoint,
    contextWindow,
    dragSnapToOrigin = false
  } = {}) {
    /**
     * @internal
     */
    this.startEvent = null;
    /**
     * @internal
     */
    this.lastMoveEvent = null;
    /**
     * @internal
     */
    this.lastMoveEventInfo = null;
    /**
     * @internal
     */
    this.handlers = {};
    /**
     * @internal
     */
    this.contextWindow = window;
    this.updatePoint = () => {
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
      const info = getPanInfo(this.lastMoveEventInfo, this.history);
      const isPanStarted = this.startEvent !== null;
      // Only start panning if the offset is larger than 3 pixels. If we make it
      // any larger than this we'll want to reset the pointer history
      // on the first update to avoid visual snapping to the cursoe.
      const isDistancePastThreshold = distance2D(info.offset, {
        x: 0,
        y: 0
      }) >= 3;
      if (!isPanStarted && !isDistancePastThreshold) return;
      const {
        point
      } = info;
      const {
        timestamp
      } = frameData;
      this.history.push({
        ...point,
        timestamp
      });
      const {
        onStart,
        onMove
      } = this.handlers;
      if (!isPanStarted) {
        onStart && onStart(this.lastMoveEvent, info);
        this.startEvent = this.lastMoveEvent;
      }
      onMove && onMove(this.lastMoveEvent, info);
    };
    this.handlePointerMove = (event, info) => {
      this.lastMoveEvent = event;
      this.lastMoveEventInfo = transformPoint(info, this.transformPagePoint);
      // Throttle mouse move event to once per frame
      frame.update(this.updatePoint, true);
    };
    this.handlePointerUp = (event, info) => {
      this.end();
      const {
        onEnd,
        onSessionEnd,
        resumeAnimation
      } = this.handlers;
      if (this.dragSnapToOrigin) resumeAnimation && resumeAnimation();
      if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
      const panInfo = getPanInfo(event.type === "pointercancel" ? this.lastMoveEventInfo : transformPoint(info, this.transformPagePoint), this.history);
      if (this.startEvent && onEnd) {
        onEnd(event, panInfo);
      }
      onSessionEnd && onSessionEnd(event, panInfo);
    };
    // If we have more than one touch, don't start detecting this gesture
    if (!motionDom.isPrimaryPointer(event)) return;
    this.dragSnapToOrigin = dragSnapToOrigin;
    this.handlers = handlers;
    this.transformPagePoint = transformPagePoint;
    this.contextWindow = contextWindow || window;
    const info = extractEventInfo(event);
    const initialInfo = transformPoint(info, this.transformPagePoint);
    const {
      point
    } = initialInfo;
    const {
      timestamp
    } = frameData;
    this.history = [{
      ...point,
      timestamp
    }];
    const {
      onSessionStart
    } = handlers;
    onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
    this.removeListeners = pipe(addPointerEvent(this.contextWindow, "pointermove", this.handlePointerMove), addPointerEvent(this.contextWindow, "pointerup", this.handlePointerUp), addPointerEvent(this.contextWindow, "pointercancel", this.handlePointerUp));
  }
  updateHandlers(handlers) {
    this.handlers = handlers;
  }
  end() {
    this.removeListeners && this.removeListeners();
    cancelFrame(this.updatePoint);
  }
}
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? {
    point: transformPagePoint(info.point)
  } : info;
}
function subtractPoint(a, b) {
  return {
    x: a.x - b.x,
    y: a.y - b.y
  };
}
function getPanInfo({
  point
}, history) {
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity(history, timeDelta) {
  if (history.length < 2) {
    return {
      x: 0,
      y: 0
    };
  }
  let i = history.length - 1;
  let timestampedPoint = null;
  const lastPoint = lastDevicePoint(history);
  while (i >= 0) {
    timestampedPoint = history[i];
    if (lastPoint.timestamp - timestampedPoint.timestamp > motionUtils.secondsToMilliseconds(timeDelta)) {
      break;
    }
    i--;
  }
  if (!timestampedPoint) {
    return {
      x: 0,
      y: 0
    };
  }
  const time = motionUtils.millisecondsToSeconds(lastPoint.timestamp - timestampedPoint.timestamp);
  if (time === 0) {
    return {
      x: 0,
      y: 0
    };
  }
  const currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time,
    y: (lastPoint.y - timestampedPoint.y) / time
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}
function isRefObject(ref) {
  return ref && typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

/**
 * Apply constraints to a point. These constraints are both physical along an
 * axis, and an elastic factor that determines how much to constrain the point
 * by if it does lie outside the defined parameters.
 */
function applyConstraints(point, {
  min,
  max
}, elastic) {
  if (min !== undefined && point < min) {
    // If we have a min point defined, and this is outside of that, constrain
    point = elastic ? mixNumber$1(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== undefined && point > max) {
    // If we have a max point defined, and this is outside of that, constrain
    point = elastic ? mixNumber$1(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
/**
 * Calculate constraints in terms of the viewport when defined relatively to the
 * measured axis. This is measured from the nearest edge, so a max constraint of 200
 * on an axis with a max value of 300 would return a constraint of 500 - axis length
 */
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== undefined ? axis.min + min : undefined,
    max: max !== undefined ? axis.max + max - (axis.max - axis.min) : undefined
  };
}
/**
 * Calculate constraints in terms of the viewport when
 * defined relatively to the measured bounding box.
 */
function calcRelativeConstraints(layoutBox, {
  top,
  left,
  bottom,
  right
}) {
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative axis
 */
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  let min = constraintsAxis.min - layoutAxis.min;
  let max = constraintsAxis.max - layoutAxis.max;
  // If the constraints axis is actually smaller than the layout axis then we can
  // flip the constraints
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    [min, max] = [max, min];
  }
  return {
    min,
    max
  };
}
/**
 * Calculate viewport constraints when defined as another viewport-relative box
 */
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
/**
 * Calculate a transform origin relative to the source axis, between 0-1, that results
 * in an asthetically pleasing scale/transform needed to project from source to target.
 */
function calcOrigin(source, target) {
  let origin = 0.5;
  const sourceLength = calcLength(source);
  const targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin = motionUtils.progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin = motionUtils.progress(source.min, source.max - targetLength, target.min);
  }
  return clamp(0, 1, origin);
}
/**
 * Rebase the calculated viewport constraints relative to the layout.min point.
 */
function rebaseAxisConstraints(layout, constraints) {
  const relativeConstraints = {};
  if (constraints.min !== undefined) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== undefined) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
const defaultElastic = 0.35;
/**
 * Accepts a dragElastic prop and returns resolved elastic values for each axis.
 */
function resolveDragElastic(dragElastic = defaultElastic) {
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  return typeof dragElastic === "number" ? dragElastic : dragElastic[label] || 0;
}

// Fixes https://github.com/motiondivision/motion/issues/2270
const getContextWindow = ({
  current
}) => {
  return current ? current.ownerDocument.defaultView : null;
};
const elementDragControls = new WeakMap();
/**
 *
 */
// let latestPointerEvent: PointerEvent
class VisualElementDragControls {
  constructor(visualElement) {
    this.openDragLock = null;
    this.isDragging = false;
    this.currentDirection = null;
    this.originPoint = {
      x: 0,
      y: 0
    };
    /**
     * The permitted boundaries of travel, in pixels.
     */
    this.constraints = false;
    this.hasMutatedConstraints = false;
    /**
     * The per-axis resolved elastic values.
     */
    this.elastic = createBox();
    this.visualElement = visualElement;
  }
  start(originEvent, {
    snapToCursor = false
  } = {}) {
    /**
     * Don't start dragging if this component is exiting
     */
    const {
      presenceContext
    } = this.visualElement;
    if (presenceContext && presenceContext.isPresent === false) return;
    const onSessionStart = event => {
      const {
        dragSnapToOrigin
      } = this.getProps();
      // Stop or pause any animations on both axis values immediately. This allows the user to throw and catch
      // the component.
      dragSnapToOrigin ? this.pauseAnimation() : this.stopAnimation();
      if (snapToCursor) {
        this.snapToCursor(extractEventInfo(event).point);
      }
    };
    const onStart = (event, info) => {
      // Attempt to grab the global drag gesture lock - maybe make this part of PanSession
      const {
        drag,
        dragPropagation,
        onDragStart
      } = this.getProps();
      if (drag && !dragPropagation) {
        if (this.openDragLock) this.openDragLock();
        this.openDragLock = motionDom.setDragLock(drag);
        // If we don 't have the lock, don't start dragging
        if (!this.openDragLock) return;
      }
      this.isDragging = true;
      this.currentDirection = null;
      this.resolveConstraints();
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = true;
        this.visualElement.projection.target = undefined;
      }
      /**
       * Record gesture origin
       */
      eachAxis(axis => {
        let current = this.getAxisMotionValue(axis).get() || 0;
        /**
         * If the MotionValue is a percentage value convert to px
         */
        if (percent.test(current)) {
          const {
            projection
          } = this.visualElement;
          if (projection && projection.layout) {
            const measuredAxis = projection.layout.layoutBox[axis];
            if (measuredAxis) {
              const length = calcLength(measuredAxis);
              current = length * (parseFloat(current) / 100);
            }
          }
        }
        this.originPoint[axis] = current;
      });
      // Fire onDragStart event
      if (onDragStart) {
        frame.postRender(() => onDragStart(event, info));
      }
      addValueToWillChange(this.visualElement, "transform");
      const {
        animationState
      } = this.visualElement;
      animationState && animationState.setActive("whileDrag", true);
    };
    const onMove = (event, info) => {
      // latestPointerEvent = event
      const {
        dragPropagation,
        dragDirectionLock,
        onDirectionLock,
        onDrag
      } = this.getProps();
      // If we didn't successfully receive the gesture lock, early return.
      if (!dragPropagation && !this.openDragLock) return;
      const {
        offset
      } = info;
      // Attempt to detect drag direction if directionLock is true
      if (dragDirectionLock && this.currentDirection === null) {
        this.currentDirection = getCurrentDirection(offset);
        // If we've successfully set a direction, notify listener
        if (this.currentDirection !== null) {
          onDirectionLock && onDirectionLock(this.currentDirection);
        }
        return;
      }
      // Update each point with the latest position
      this.updateAxis("x", info.point, offset);
      this.updateAxis("y", info.point, offset);
      /**
       * Ideally we would leave the renderer to fire naturally at the end of
       * this frame but if the element is about to change layout as the result
       * of a re-render we want to ensure the browser can read the latest
       * bounding box to ensure the pointer and element don't fall out of sync.
       */
      this.visualElement.render();
      /**
       * This must fire after the render call as it might trigger a state
       * change which itself might trigger a layout update.
       */
      onDrag && onDrag(event, info);
    };
    const onSessionEnd = (event, info) => this.stop(event, info);
    const resumeAnimation = () => eachAxis(axis => {
      var _a;
      return this.getAnimationState(axis) === "paused" && ((_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.play());
    });
    const {
      dragSnapToOrigin
    } = this.getProps();
    this.panSession = new PanSession(originEvent, {
      onSessionStart,
      onStart,
      onMove,
      onSessionEnd,
      resumeAnimation
    }, {
      transformPagePoint: this.visualElement.getTransformPagePoint(),
      dragSnapToOrigin,
      contextWindow: getContextWindow(this.visualElement)
    });
  }
  stop(event, info) {
    const isDragging = this.isDragging;
    this.cancel();
    if (!isDragging) return;
    const {
      velocity
    } = info;
    this.startAnimation(velocity);
    const {
      onDragEnd
    } = this.getProps();
    if (onDragEnd) {
      frame.postRender(() => onDragEnd(event, info));
    }
  }
  cancel() {
    this.isDragging = false;
    const {
      projection,
      animationState
    } = this.visualElement;
    if (projection) {
      projection.isAnimationBlocked = false;
    }
    this.panSession && this.panSession.end();
    this.panSession = undefined;
    const {
      dragPropagation
    } = this.getProps();
    if (!dragPropagation && this.openDragLock) {
      this.openDragLock();
      this.openDragLock = null;
    }
    animationState && animationState.setActive("whileDrag", false);
  }
  updateAxis(axis, _point, offset) {
    const {
      drag
    } = this.getProps();
    // If we're not dragging this axis, do an early return.
    if (!offset || !shouldDrag(axis, drag, this.currentDirection)) return;
    const axisValue = this.getAxisMotionValue(axis);
    let next = this.originPoint[axis] + offset[axis];
    // Apply constraints
    if (this.constraints && this.constraints[axis]) {
      next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
    }
    axisValue.set(next);
  }
  resolveConstraints() {
    var _a;
    const {
      dragConstraints,
      dragElastic
    } = this.getProps();
    const layout = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(false) : (_a = this.visualElement.projection) === null || _a === void 0 ? void 0 : _a.layout;
    const prevConstraints = this.constraints;
    if (dragConstraints && isRefObject(dragConstraints)) {
      if (!this.constraints) {
        this.constraints = this.resolveRefConstraints();
      }
    } else {
      if (dragConstraints && layout) {
        this.constraints = calcRelativeConstraints(layout.layoutBox, dragConstraints);
      } else {
        this.constraints = false;
      }
    }
    this.elastic = resolveDragElastic(dragElastic);
    /**
     * If we're outputting to external MotionValues, we want to rebase the measured constraints
     * from viewport-relative to component-relative.
     */
    if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
      eachAxis(axis => {
        if (this.constraints !== false && this.getAxisMotionValue(axis)) {
          this.constraints[axis] = rebaseAxisConstraints(layout.layoutBox[axis], this.constraints[axis]);
        }
      });
    }
  }
  resolveRefConstraints() {
    const {
      dragConstraints: constraints,
      onMeasureDragConstraints
    } = this.getProps();
    if (!constraints || !isRefObject(constraints)) return false;
    const constraintsElement = constraints.current;
    motionUtils.invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
    const {
      projection
    } = this.visualElement;
    // TODO
    if (!projection || !projection.layout) return false;
    const constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
    let measuredConstraints = calcViewportConstraints(projection.layout.layoutBox, constraintsBox);
    /**
     * If there's an onMeasureDragConstraints listener we call it and
     * if different constraints are returned, set constraints to that
     */
    if (onMeasureDragConstraints) {
      const userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
      this.hasMutatedConstraints = !!userConstraints;
      if (userConstraints) {
        measuredConstraints = convertBoundingBoxToBox(userConstraints);
      }
    }
    return measuredConstraints;
  }
  startAnimation(velocity) {
    const {
      drag,
      dragMomentum,
      dragElastic,
      dragTransition,
      dragSnapToOrigin,
      onDragTransitionEnd
    } = this.getProps();
    const constraints = this.constraints || {};
    const momentumAnimations = eachAxis(axis => {
      if (!shouldDrag(axis, drag, this.currentDirection)) {
        return;
      }
      let transition = constraints && constraints[axis] || {};
      if (dragSnapToOrigin) transition = {
        min: 0,
        max: 0
      };
      /**
       * Overdamp the boundary spring if `dragElastic` is disabled. There's still a frame
       * of spring animations so we should look into adding a disable spring option to `inertia`.
       * We could do something here where we affect the `bounceStiffness` and `bounceDamping`
       * using the value of `dragElastic`.
       */
      const bounceStiffness = dragElastic ? 200 : 1000000;
      const bounceDamping = dragElastic ? 40 : 10000000;
      const inertia = {
        type: "inertia",
        velocity: dragMomentum ? velocity[axis] : 0,
        bounceStiffness,
        bounceDamping,
        timeConstant: 750,
        restDelta: 1,
        restSpeed: 10,
        ...dragTransition,
        ...transition
      };
      // If we're not animating on an externally-provided `MotionValue` we can use the
      // component's animation controls which will handle interactions with whileHover (etc),
      // otherwise we just have to animate the `MotionValue` itself.
      return this.startAxisValueAnimation(axis, inertia);
    });
    // Run all animations and then resolve the new drag constraints.
    return Promise.all(momentumAnimations).then(onDragTransitionEnd);
  }
  startAxisValueAnimation(axis, transition) {
    const axisValue = this.getAxisMotionValue(axis);
    addValueToWillChange(this.visualElement, axis);
    return axisValue.start(animateMotionValue(axis, axisValue, 0, transition, this.visualElement, false));
  }
  stopAnimation() {
    eachAxis(axis => this.getAxisMotionValue(axis).stop());
  }
  pauseAnimation() {
    eachAxis(axis => {
      var _a;
      return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.pause();
    });
  }
  getAnimationState(axis) {
    var _a;
    return (_a = this.getAxisMotionValue(axis).animation) === null || _a === void 0 ? void 0 : _a.state;
  }
  /**
   * Drag works differently depending on which props are provided.
   *
   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.
   * - Otherwise, we apply the delta to the x/y motion values.
   */
  getAxisMotionValue(axis) {
    const dragKey = `_drag${axis.toUpperCase()}`;
    const props = this.visualElement.getProps();
    const externalMotionValue = props[dragKey];
    return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (props.initial ? props.initial[axis] : undefined) || 0);
  }
  snapToCursor(point) {
    eachAxis(axis => {
      const {
        drag
      } = this.getProps();
      // If we're not dragging this axis, do an early return.
      if (!shouldDrag(axis, drag, this.currentDirection)) return;
      const {
        projection
      } = this.visualElement;
      const axisValue = this.getAxisMotionValue(axis);
      if (projection && projection.layout) {
        const {
          min,
          max
        } = projection.layout.layoutBox[axis];
        axisValue.set(point[axis] - mixNumber$1(min, max, 0.5));
      }
    });
  }
  /**
   * When the viewport resizes we want to check if the measured constraints
   * have changed and, if so, reposition the element within those new constraints
   * relative to where it was before the resize.
   */
  scalePositionWithinConstraints() {
    if (!this.visualElement.current) return;
    const {
      drag,
      dragConstraints
    } = this.getProps();
    const {
      projection
    } = this.visualElement;
    if (!isRefObject(dragConstraints) || !projection || !this.constraints) return;
    /**
     * Stop current animations as there can be visual glitching if we try to do
     * this mid-animation
     */
    this.stopAnimation();
    /**
     * Record the relative position of the dragged element relative to the
     * constraints box and save as a progress value.
     */
    const boxProgress = {
      x: 0,
      y: 0
    };
    eachAxis(axis => {
      const axisValue = this.getAxisMotionValue(axis);
      if (axisValue && this.constraints !== false) {
        const latest = axisValue.get();
        boxProgress[axis] = calcOrigin({
          min: latest,
          max: latest
        }, this.constraints[axis]);
      }
    });
    /**
     * Update the layout of this element and resolve the latest drag constraints
     */
    const {
      transformTemplate
    } = this.visualElement.getProps();
    this.visualElement.current.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    projection.root && projection.root.updateScroll();
    projection.updateLayout();
    this.resolveConstraints();
    /**
     * For each axis, calculate the current progress of the layout axis
     * within the new constraints.
     */
    eachAxis(axis => {
      if (!shouldDrag(axis, drag, null)) return;
      /**
       * Calculate a new transform based on the previous box progress
       */
      const axisValue = this.getAxisMotionValue(axis);
      const {
        min,
        max
      } = this.constraints[axis];
      axisValue.set(mixNumber$1(min, max, boxProgress[axis]));
    });
  }
  addListeners() {
    if (!this.visualElement.current) return;
    elementDragControls.set(this.visualElement, this);
    const element = this.visualElement.current;
    /**
     * Attach a pointerdown event listener on this DOM element to initiate drag tracking.
     */
    const stopPointerListener = addPointerEvent(element, "pointerdown", event => {
      const {
        drag,
        dragListener = true
      } = this.getProps();
      drag && dragListener && this.start(event);
    });
    const measureDragConstraints = () => {
      const {
        dragConstraints
      } = this.getProps();
      if (isRefObject(dragConstraints) && dragConstraints.current) {
        this.constraints = this.resolveRefConstraints();
      }
    };
    const {
      projection
    } = this.visualElement;
    const stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
    if (projection && !projection.layout) {
      projection.root && projection.root.updateScroll();
      projection.updateLayout();
    }
    frame.read(measureDragConstraints);
    /**
     * Attach a window resize listener to scale the draggable target within its defined
     * constraints as the window resizes.
     */
    const stopResizeListener = addDomEvent(window, "resize", () => this.scalePositionWithinConstraints());
    /**
     * If the element's layout changes, calculate the delta and apply that to
     * the drag gesture's origin point.
     */
    const stopLayoutUpdateListener = projection.addEventListener("didUpdate", ({
      delta,
      hasLayoutChanged
    }) => {
      if (this.isDragging && hasLayoutChanged) {
        eachAxis(axis => {
          const motionValue = this.getAxisMotionValue(axis);
          if (!motionValue) return;
          this.originPoint[axis] += delta[axis].translate;
          motionValue.set(motionValue.get() + delta[axis].translate);
        });
        this.visualElement.render();
      }
    });
    return () => {
      stopResizeListener();
      stopPointerListener();
      stopMeasureLayoutListener();
      stopLayoutUpdateListener && stopLayoutUpdateListener();
    };
  }
  getProps() {
    const props = this.visualElement.getProps();
    const {
      drag = false,
      dragDirectionLock = false,
      dragPropagation = false,
      dragConstraints = false,
      dragElastic = defaultElastic,
      dragMomentum = true
    } = props;
    return {
      ...props,
      drag,
      dragDirectionLock,
      dragPropagation,
      dragConstraints,
      dragElastic,
      dragMomentum
    };
  }
}
function shouldDrag(direction, drag, currentDirection) {
  return (drag === true || drag === direction) && (currentDirection === null || currentDirection === direction);
}
/**
 * Based on an x/y offset determine the current drag direction. If both axis' offsets are lower
 * than the provided threshold, return `null`.
 *
 * @param offset - The x/y offset from origin.
 * @param lockThreshold - (Optional) - the minimum absolute offset before we can determine a drag direction.
 */
function getCurrentDirection(offset, lockThreshold = 10) {
  let direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}
class DragGesture extends Feature {
  constructor(node) {
    super(node);
    this.removeGroupControls = motionUtils.noop;
    this.removeListeners = motionUtils.noop;
    this.controls = new VisualElementDragControls(node);
  }
  mount() {
    // If we've been provided a DragControls for manual control over the drag gesture,
    // subscribe this component to it on mount.
    const {
      dragControls
    } = this.node.getProps();
    if (dragControls) {
      this.removeGroupControls = dragControls.subscribe(this.controls);
    }
    this.removeListeners = this.controls.addListeners() || motionUtils.noop;
  }
  unmount() {
    this.removeGroupControls();
    this.removeListeners();
  }
}
const asyncHandler = handler => (event, info) => {
  if (handler) {
    frame.postRender(() => handler(event, info));
  }
};
class PanGesture extends Feature {
  constructor() {
    super(...arguments);
    this.removePointerDownListener = motionUtils.noop;
  }
  onPointerDown(pointerDownEvent) {
    this.session = new PanSession(pointerDownEvent, this.createPanHandlers(), {
      transformPagePoint: this.node.getTransformPagePoint(),
      contextWindow: getContextWindow(this.node)
    });
  }
  createPanHandlers() {
    const {
      onPanSessionStart,
      onPanStart,
      onPan,
      onPanEnd
    } = this.node.getProps();
    return {
      onSessionStart: asyncHandler(onPanSessionStart),
      onStart: asyncHandler(onPanStart),
      onMove: onPan,
      onEnd: (event, info) => {
        delete this.session;
        if (onPanEnd) {
          frame.postRender(() => onPanEnd(event, info));
        }
      }
    };
  }
  mount() {
    this.removePointerDownListener = addPointerEvent(this.node.current, "pointerdown", event => this.onPointerDown(event));
  }
  update() {
    this.session && this.session.updateHandlers(this.createPanHandlers());
  }
  unmount() {
    this.removePointerDownListener();
    this.session && this.session.end();
  }
}

/**
 * Internal, exported only for usage in Framer
 */
const SwitchLayoutGroupContext = React.createContext({});
class MeasureLayoutWithContext extends React.Component {
  /**
   * This only mounts projection nodes for components that
   * need measuring, we might want to do it for all components
   * in order to incorporate transforms
   */
  componentDidMount() {
    const {
      visualElement,
      layoutGroup,
      switchLayoutGroup,
      layoutId
    } = this.props;
    const {
      projection
    } = visualElement;
    addScaleCorrector(defaultScaleCorrectors);
    if (projection) {
      if (layoutGroup.group) layoutGroup.group.add(projection);
      if (switchLayoutGroup && switchLayoutGroup.register && layoutId) {
        switchLayoutGroup.register(projection);
      }
      projection.root.didUpdate();
      projection.addEventListener("animationComplete", () => {
        this.safeToRemove();
      });
      projection.setOptions({
        ...projection.options,
        onExitComplete: () => this.safeToRemove()
      });
    }
    globalProjectionState.hasEverUpdated = true;
  }
  getSnapshotBeforeUpdate(prevProps) {
    const {
      layoutDependency,
      visualElement,
      drag,
      isPresent
    } = this.props;
    const projection = visualElement.projection;
    if (!projection) return null;
    /**
     * TODO: We use this data in relegate to determine whether to
     * promote a previous element. There's no guarantee its presence data
     * will have updated by this point - if a bug like this arises it will
     * have to be that we markForRelegation and then find a new lead some other way,
     * perhaps in didUpdate
     */
    projection.isPresent = isPresent;
    if (drag || prevProps.layoutDependency !== layoutDependency || layoutDependency === undefined) {
      projection.willUpdate();
    } else {
      this.safeToRemove();
    }
    if (prevProps.isPresent !== isPresent) {
      if (isPresent) {
        projection.promote();
      } else if (!projection.relegate()) {
        /**
         * If there's another stack member taking over from this one,
         * it's in charge of the exit animation and therefore should
         * be in charge of the safe to remove. Otherwise we call it here.
         */
        frame.postRender(() => {
          const stack = projection.getStack();
          if (!stack || !stack.members.length) {
            this.safeToRemove();
          }
        });
      }
    }
    return null;
  }
  componentDidUpdate() {
    const {
      projection
    } = this.props.visualElement;
    if (projection) {
      projection.root.didUpdate();
      microtask.postRender(() => {
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      });
    }
  }
  componentWillUnmount() {
    const {
      visualElement,
      layoutGroup,
      switchLayoutGroup: promoteContext
    } = this.props;
    const {
      projection
    } = visualElement;
    if (projection) {
      projection.scheduleCheckAfterUnmount();
      if (layoutGroup && layoutGroup.group) layoutGroup.group.remove(projection);
      if (promoteContext && promoteContext.deregister) promoteContext.deregister(projection);
    }
  }
  safeToRemove() {
    const {
      safeToRemove
    } = this.props;
    safeToRemove && safeToRemove();
  }
  render() {
    return null;
  }
}
function MeasureLayout(props) {
  const [isPresent, safeToRemove] = usePresence();
  const layoutGroup = React.useContext(LayoutGroupContext);
  return jsxRuntime.jsx(MeasureLayoutWithContext, {
    ...props,
    layoutGroup: layoutGroup,
    switchLayoutGroup: React.useContext(SwitchLayoutGroupContext),
    isPresent: isPresent,
    safeToRemove: safeToRemove
  });
}
const defaultScaleCorrectors = {
  borderRadius: {
    ...correctBorderRadius,
    applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
  },
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};
const drag = {
  pan: {
    Feature: PanGesture
  },
  drag: {
    Feature: DragGesture,
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function handleHoverEvent(node, event, lifecycle) {
  const {
    props
  } = node;
  if (node.animationState && props.whileHover) {
    node.animationState.setActive("whileHover", lifecycle === "Start");
  }
  const eventName = "onHover" + lifecycle;
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class HoverGesture extends Feature {
  mount() {
    const {
      current
    } = this.node;
    if (!current) return;
    this.unmount = motionDom.hover(current, startEvent => {
      handleHoverEvent(this.node, startEvent, "Start");
      return endEvent => handleHoverEvent(this.node, endEvent, "End");
    });
  }
  unmount() {}
}
class FocusGesture extends Feature {
  constructor() {
    super(...arguments);
    this.isActive = false;
  }
  onFocus() {
    let isFocusVisible = false;
    /**
     * If this element doesn't match focus-visible then don't
     * apply whileHover. But, if matches throws that focus-visible
     * is not a valid selector then in that browser outline styles will be applied
     * to the element by default and we want to match that behaviour with whileFocus.
     */
    try {
      isFocusVisible = this.node.current.matches(":focus-visible");
    } catch (e) {
      isFocusVisible = true;
    }
    if (!isFocusVisible || !this.node.animationState) return;
    this.node.animationState.setActive("whileFocus", true);
    this.isActive = true;
  }
  onBlur() {
    if (!this.isActive || !this.node.animationState) return;
    this.node.animationState.setActive("whileFocus", false);
    this.isActive = false;
  }
  mount() {
    this.unmount = pipe(addDomEvent(this.node.current, "focus", () => this.onFocus()), addDomEvent(this.node.current, "blur", () => this.onBlur()));
  }
  unmount() {}
}
function handlePressEvent(node, event, lifecycle) {
  const {
    props
  } = node;
  if (node.animationState && props.whileTap) {
    node.animationState.setActive("whileTap", lifecycle === "Start");
  }
  const eventName = "onTap" + (lifecycle === "End" ? "" : lifecycle);
  const callback = props[eventName];
  if (callback) {
    frame.postRender(() => callback(event, extractEventInfo(event)));
  }
}
class PressGesture extends Feature {
  mount() {
    const {
      current
    } = this.node;
    if (!current) return;
    this.unmount = motionDom.press(current, startEvent => {
      handlePressEvent(this.node, startEvent, "Start");
      return (endEvent, {
        success
      }) => handlePressEvent(this.node, endEvent, success ? "End" : "Cancel");
    }, {
      useGlobalTarget: this.node.props.globalTapTarget
    });
  }
  unmount() {}
}

/**
 * Map an IntersectionHandler callback to an element. We only ever make one handler for one
 * element, so even though these handlers might all be triggered by different
 * observers, we can keep them in the same map.
 */
const observerCallbacks = new WeakMap();
/**
 * Multiple observers can be created for multiple element/document roots. Each with
 * different settings. So here we store dictionaries of observers to each root,
 * using serialised settings (threshold/margin) as lookup keys.
 */
const observers = new WeakMap();
const fireObserverCallback = entry => {
  const callback = observerCallbacks.get(entry.target);
  callback && callback(entry);
};
const fireAllObserverCallbacks = entries => {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver({
  root,
  ...options
}) {
  const lookupRoot = root || document;
  /**
   * If we don't have an observer lookup map for this root, create one.
   */
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  const rootObservers = observers.get(lookupRoot);
  const key = JSON.stringify(options);
  /**
   * If we don't have an observer for this combination of root and settings,
   * create one.
   */
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, {
      root,
      ...options
    });
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  const rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return () => {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}
const thresholdNames = {
  some: 0,
  all: 1
};
class InViewFeature extends Feature {
  constructor() {
    super(...arguments);
    this.hasEnteredView = false;
    this.isInView = false;
  }
  startObserver() {
    this.unmount();
    const {
      viewport = {}
    } = this.node.getProps();
    const {
      root,
      margin: rootMargin,
      amount = "some",
      once
    } = viewport;
    const options = {
      root: root ? root.current : undefined,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    const onIntersectionUpdate = entry => {
      const {
        isIntersecting
      } = entry;
      /**
       * If there's been no change in the viewport state, early return.
       */
      if (this.isInView === isIntersecting) return;
      this.isInView = isIntersecting;
      /**
       * Handle hasEnteredView. If this is only meant to run once, and
       * element isn't visible, early return. Otherwise set hasEnteredView to true.
       */
      if (once && !isIntersecting && this.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        this.hasEnteredView = true;
      }
      if (this.node.animationState) {
        this.node.animationState.setActive("whileInView", isIntersecting);
      }
      /**
       * Use the latest committed props rather than the ones in scope
       * when this observer is created
       */
      const {
        onViewportEnter,
        onViewportLeave
      } = this.node.getProps();
      const callback = isIntersecting ? onViewportEnter : onViewportLeave;
      callback && callback(entry);
    };
    return observeIntersection(this.node.current, options, onIntersectionUpdate);
  }
  mount() {
    this.startObserver();
  }
  update() {
    if (typeof IntersectionObserver === "undefined") return;
    const {
      props,
      prevProps
    } = this.node;
    const hasOptionsChanged = ["amount", "margin", "root"].some(hasViewportOptionChanged(props, prevProps));
    if (hasOptionsChanged) {
      this.startObserver();
    }
  }
  unmount() {}
}
function hasViewportOptionChanged({
  viewport = {}
}, {
  viewport: prevViewport = {}
} = {}) {
  return name => viewport[name] !== prevViewport[name];
}
const gestureAnimations = {
  inView: {
    Feature: InViewFeature
  },
  tap: {
    Feature: PressGesture
  },
  focus: {
    Feature: FocusGesture
  },
  hover: {
    Feature: HoverGesture
  }
};
const layout = {
  layout: {
    ProjectionNode: HTMLProjectionNode,
    MeasureLayout
  }
};
function getCurrentTreeVariants(props, context) {
  if (isControllingVariants(props)) {
    const {
      initial,
      animate
    } = props;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : undefined,
      animate: isVariantLabel(animate) ? animate : undefined
    };
  }
  return props.inherit !== false ? context : {};
}
function useCreateMotionContext(props) {
  const {
    initial,
    animate
  } = getCurrentTreeVariants(props, React.useContext(MotionContext));
  return React.useMemo(() => ({
    initial,
    animate
  }), [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}
const motionComponentSymbol = Symbol.for("motionComponentSymbol");

/**
 * Creates a ref function that, when called, hydrates the provided
 * external ref and VisualElement.
 */
function useMotionRef(visualState, visualElement, externalRef) {
  return React.useCallback(instance => {
    if (instance) {
      visualState.onMount && visualState.onMount(instance);
    }
    if (visualElement) {
      if (instance) {
        visualElement.mount(instance);
      } else {
        visualElement.unmount();
      }
    }
    if (externalRef) {
      if (typeof externalRef === "function") {
        externalRef(instance);
      } else if (isRefObject(externalRef)) {
        externalRef.current = instance;
      }
    }
  },
  /**
   * Only pass a new ref callback to React if we've received a visual element
   * factory. Otherwise we'll be mounting/remounting every time externalRef
   * or other dependencies change.
   */
  [visualElement]);
}
function useVisualElement(Component, visualState, props, createVisualElement, ProjectionNodeConstructor) {
  var _a, _b;
  const {
    visualElement: parent
  } = React.useContext(MotionContext);
  const lazyContext = React.useContext(LazyContext);
  const presenceContext = React.useContext(PresenceContext);
  const reducedMotionConfig = React.useContext(MotionConfigContext).reducedMotion;
  const visualElementRef = React.useRef(null);
  /**
   * If we haven't preloaded a renderer, check to see if we have one lazy-loaded
   */
  createVisualElement = createVisualElement || lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceContext,
      blockInitialAnimation: presenceContext ? presenceContext.initial === false : false,
      reducedMotionConfig
    });
  }
  const visualElement = visualElementRef.current;
  /**
   * Load Motion gesture and animation features. These are rendered as renderless
   * components so each feature can optionally make use of React lifecycle methods.
   */
  const initialLayoutGroupConfig = React.useContext(SwitchLayoutGroupContext);
  if (visualElement && !visualElement.projection && ProjectionNodeConstructor && (visualElement.type === "html" || visualElement.type === "svg")) {
    createProjectionNode(visualElementRef.current, props, ProjectionNodeConstructor, initialLayoutGroupConfig);
  }
  const isMounted = React.useRef(false);
  React.useInsertionEffect(() => {
    /**
     * Check the component has already mounted before calling
     * `update` unnecessarily. This ensures we skip the initial update.
     */
    if (visualElement && isMounted.current) {
      visualElement.update(props, presenceContext);
    }
  });
  /**
   * Cache this value as we want to know whether HandoffAppearAnimations
   * was present on initial render - it will be deleted after this.
   */
  const optimisedAppearId = props[optimizedAppearDataAttribute];
  const wantsHandoff = React.useRef(Boolean(optimisedAppearId) && !((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId)) && ((_b = window.MotionHasOptimisedAnimation) === null || _b === void 0 ? void 0 : _b.call(window, optimisedAppearId)));
  useIsomorphicLayoutEffect(() => {
    if (!visualElement) return;
    isMounted.current = true;
    window.MotionIsMounted = true;
    visualElement.updateFeatures();
    microtask.render(visualElement.render);
    /**
     * Ideally this function would always run in a useEffect.
     *
     * However, if we have optimised appear animations to handoff from,
     * it needs to happen synchronously to ensure there's no flash of
     * incorrect styles in the event of a hydration error.
     *
     * So if we detect a situtation where optimised appear animations
     * are running, we use useLayoutEffect to trigger animations.
     */
    if (wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
  });
  React.useEffect(() => {
    if (!visualElement) return;
    if (!wantsHandoff.current && visualElement.animationState) {
      visualElement.animationState.animateChanges();
    }
    if (wantsHandoff.current) {
      // This ensures all future calls to animateChanges() in this component will run in useEffect
      queueMicrotask(() => {
        var _a;
        (_a = window.MotionHandoffMarkAsComplete) === null || _a === void 0 ? void 0 : _a.call(window, optimisedAppearId);
      });
      wantsHandoff.current = false;
    }
  });
  return visualElement;
}
function createProjectionNode(visualElement, props, ProjectionNodeConstructor, initialPromotionConfig) {
  const {
    layoutId,
    layout,
    drag,
    dragConstraints,
    layoutScroll,
    layoutRoot
  } = props;
  visualElement.projection = new ProjectionNodeConstructor(visualElement.latestValues, props["data-framer-portal-id"] ? undefined : getClosestProjectingNode(visualElement.parent));
  visualElement.projection.setOptions({
    layoutId,
    layout,
    alwaysMeasureLayout: Boolean(drag) || dragConstraints && isRefObject(dragConstraints),
    visualElement,
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig,
    layoutScroll,
    layoutRoot
  });
}
function getClosestProjectingNode(visualElement) {
  if (!visualElement) return undefined;
  return visualElement.options.allowProjection !== false ? visualElement.projection : getClosestProjectingNode(visualElement.parent);
}

/**
 * Create a `motion` component.
 *
 * This function accepts a Component argument, which can be either a string (ie "div"
 * for `motion.div`), or an actual React component.
 *
 * Alongside this is a config option which provides a way of rendering the provided
 * component "offline", or outside the React render cycle.
 */
function createRendererMotionComponent({
  preloadedFeatures,
  createVisualElement,
  useRender,
  useVisualState,
  Component
}) {
  var _a, _b;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    /**
     * If we need to measure the element we load this functionality in a
     * separate class component in order to gain access to getSnapshotBeforeUpdate.
     */
    let MeasureLayout;
    const configAndProps = {
      ...React.useContext(MotionConfigContext),
      ...props,
      layoutId: useLayoutId(props)
    };
    const {
      isStatic
    } = configAndProps;
    const context = useCreateMotionContext(props);
    const visualState = useVisualState(props, isStatic);
    if (!isStatic && isBrowser) {
      useStrictMode(configAndProps, preloadedFeatures);
      const layoutProjection = getProjectionFunctionality(configAndProps);
      MeasureLayout = layoutProjection.MeasureLayout;
      /**
       * Create a VisualElement for this component. A VisualElement provides a common
       * interface to renderer-specific APIs (ie DOM/Three.js etc) as well as
       * providing a way of rendering to these APIs outside of the React render loop
       * for more performant animations and interactions
       */
      context.visualElement = useVisualElement(Component, visualState, configAndProps, createVisualElement, layoutProjection.ProjectionNode);
    }
    /**
     * The mount order and hierarchy is specific to ensure our element ref
     * is hydrated by the time features fire their effects.
     */
    return jsxRuntime.jsxs(MotionContext.Provider, {
      value: context,
      children: [MeasureLayout && context.visualElement ? jsxRuntime.jsx(MeasureLayout, {
        visualElement: context.visualElement,
        ...configAndProps
      }) : null, useRender(Component, props, useMotionRef(visualState, context.visualElement, externalRef), visualState, isStatic, context.visualElement)]
    });
  }
  MotionComponent.displayName = `motion.${typeof Component === "string" ? Component : `create(${(_b = (_a = Component.displayName) !== null && _a !== void 0 ? _a : Component.name) !== null && _b !== void 0 ? _b : ""})`}`;
  const ForwardRefMotionComponent = React.forwardRef(MotionComponent);
  ForwardRefMotionComponent[motionComponentSymbol] = Component;
  return ForwardRefMotionComponent;
}
function useLayoutId({
  layoutId
}) {
  const layoutGroupId = React.useContext(LayoutGroupContext).id;
  return layoutGroupId && layoutId !== undefined ? layoutGroupId + "-" + layoutId : layoutId;
}
function useStrictMode(configAndProps, preloadedFeatures) {
  const isStrict = React.useContext(LazyContext).strict;
  /**
   * If we're in development mode, check to make sure we're not rendering a motion component
   * as a child of LazyMotion, as this will break the file-size benefits of using it.
   */
  if (process.env.NODE_ENV !== "production" && preloadedFeatures && isStrict) {
    const strictMessage = "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.";
    configAndProps.ignoreStrict ? motionUtils.warning(false, strictMessage) : motionUtils.invariant(false, strictMessage);
  }
}
function getProjectionFunctionality(props) {
  const {
    drag,
    layout
  } = featureDefinitions;
  if (!drag && !layout) return {};
  const combined = {
    ...drag,
    ...layout
  };
  return {
    MeasureLayout: (drag === null || drag === void 0 ? void 0 : drag.isEnabled(props)) || (layout === null || layout === void 0 ? void 0 : layout.isEnabled(props)) ? combined.MeasureLayout : undefined,
    ProjectionNode: combined.ProjectionNode
  };
}

/**
 * We keep these listed separately as we use the lowercase tag names as part
 * of the runtime bundle to detect SVG components
 */
const lowercaseSVGElements = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];
function isSVGComponent(Component) {
  if (
  /**
   * If it's not a string, it's a custom React component. Currently we only support
   * HTML custom React components.
   */
  typeof Component !== "string" ||
  /**
   * If it contains a dash, the element is a custom HTML webcomponent.
   */
  Component.includes("-")) {
    return false;
  } else if (
  /**
   * If it's in our list of lowercase SVG tags, it's an SVG component
   */
  lowercaseSVGElements.indexOf(Component) > -1 ||
  /**
   * If it contains a capital letter, it's an SVG component
   */
  /[A-Z]/u.test(Component)) {
    return true;
  }
  return false;
}
const createHtmlRenderState = () => ({
  style: {},
  transform: {},
  transformOrigin: {},
  vars: {}
});
const createSvgRenderState = () => ({
  ...createHtmlRenderState(),
  attrs: {}
});
function updateSVGDimensions(instance, renderState) {
  try {
    renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
  } catch (e) {
    // Most likely trying to measure an unrendered element under Firefox
    renderState.dimensions = {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    };
  }
}
const layoutProps = ["x", "y", "width", "height", "cx", "cy", "r"];
const svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps,
    createRenderState: createSvgRenderState,
    onUpdate: ({
      props,
      prevProps,
      current,
      renderState,
      latestValues
    }) => {
      if (!current) return;
      let hasTransform = !!props.drag;
      if (!hasTransform) {
        for (const key in latestValues) {
          if (transformProps.has(key)) {
            hasTransform = true;
            break;
          }
        }
      }
      if (!hasTransform) return;
      let needsMeasure = !prevProps;
      if (prevProps) {
        /**
         * Check the layout props for changes, if any are found we need to
         * measure the element again.
         */
        for (let i = 0; i < layoutProps.length; i++) {
          const key = layoutProps[i];
          if (props[key] !== prevProps[key]) {
            needsMeasure = true;
          }
        }
      }
      if (!needsMeasure) return;
      frame.read(() => {
        updateSVGDimensions(current, renderState);
        frame.render(() => {
          buildSVGAttrs(renderState, latestValues, isSVGTag(current.tagName), props.transformTemplate);
          renderSVG(current, renderState);
        });
      });
    }
  })
};
const htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps$1,
    createRenderState: createHtmlRenderState
  })
};
function copyRawValuesOnly(target, source, props) {
  for (const key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues({
  transformTemplate
}, visualState) {
  return React.useMemo(() => {
    const state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, transformTemplate);
    return Object.assign({}, state.vars, state.style);
  }, [visualState]);
}
function useStyle(props, visualState) {
  const styleProp = props.style || {};
  const style = {};
  /**
   * Copy non-Motion Values straight into style
   */
  copyRawValuesOnly(style, styleProp, props);
  Object.assign(style, useInitialMotionValues(props, visualState));
  return style;
}
function useHTMLProps(props, visualState) {
  // The `any` isn't ideal but it is the type of createElement props argument
  const htmlProps = {};
  const style = useStyle(props, visualState);
  if (props.drag && props.dragListener !== false) {
    // Disable the ghost element when a user drags
    htmlProps.draggable = false;
    // Disable text selection
    style.userSelect = style.WebkitUserSelect = style.WebkitTouchCallout = "none";
    // Disable scrolling on the draggable direction
    style.touchAction = props.drag === true ? "none" : `pan-${props.drag === "x" ? "y" : "x"}`;
  }
  if (props.tabIndex === undefined && (props.onTap || props.onTapStart || props.whileTap)) {
    htmlProps.tabIndex = 0;
  }
  htmlProps.style = style;
  return htmlProps;
}
function useSVGProps(props, visualState, _isStatic, Component) {
  const visualProps = React.useMemo(() => {
    const state = createSvgRenderState();
    buildSVGAttrs(state, visualState, isSVGTag(Component), props.transformTemplate);
    return {
      ...state.attrs,
      style: {
        ...state.style
      }
    };
  }, [visualState]);
  if (props.style) {
    const rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = {
      ...rawStyles,
      ...visualProps.style
    };
  }
  return visualProps;
}
function createUseRender(forwardMotionProps = false) {
  const useRender = (Component, props, ref, {
    latestValues
  }, isStatic) => {
    const useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    const visualProps = useVisualProps(props, latestValues, isStatic, Component);
    const filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    const elementProps = Component !== React.Fragment ? {
      ...filteredProps,
      ...visualProps,
      ref
    } : {};
    /**
     * If component has been handed a motion value as its child,
     * memoise its initial value and render that. Subsequent updates
     * will be handled by the onChange handler
     */
    const {
      children
    } = props;
    const renderedChildren = React.useMemo(() => isMotionValue(children) ? children.get() : children, [children]);
    return React.createElement(Component, {
      ...elementProps,
      children: renderedChildren
    });
  };
  return useRender;
}
function createMotionComponentFactory(preloadedFeatures, createVisualElement) {
  return function createMotionComponent(Component, {
    forwardMotionProps
  } = {
    forwardMotionProps: false
  }) {
    const baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
    const config = {
      ...baseConfig,
      preloadedFeatures,
      useRender: createUseRender(forwardMotionProps),
      createVisualElement,
      Component
    };
    return createRendererMotionComponent(config);
  };
}
const createDomVisualElement = (Component, options) => {
  return isSVGComponent(Component) ? new SVGVisualElement(options) : new HTMLVisualElement(options, {
    allowProjection: Component !== React.Fragment
  });
};
const createMotionComponent = /*@__PURE__*/createMotionComponentFactory({
  ...animations,
  ...gestureAnimations,
  ...drag,
  ...layout
}, createDomVisualElement);
const motion = /*@__PURE__*/createDOMMotionComponentProxy(createMotionComponent);
function checkReorder(order, value, offset, velocity) {
  if (!velocity) return order;
  const index = order.findIndex(item => item.value === value);
  if (index === -1) return order;
  const nextOffset = velocity > 0 ? 1 : -1;
  const nextItem = order[index + nextOffset];
  if (!nextItem) return order;
  const item = order[index];
  const nextLayout = nextItem.layout;
  const nextItemCenter = mixNumber$1(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
    return moveItem(order, index, index + nextOffset);
  }
  return order;
}
function ReorderGroupComponent({
  children,
  as = "ul",
  axis = "y",
  onReorder,
  values,
  ...props
}, externalRef) {
  const Component = useConstant(() => motion[as]);
  const order = [];
  const isReordering = React.useRef(false);
  motionUtils.invariant(Boolean(values), "Reorder.Group must be provided a values prop");
  const context = {
    axis,
    registerItem: (value, layout) => {
      // If the entry was already added, update it rather than adding it again
      const idx = order.findIndex(entry => value === entry.value);
      if (idx !== -1) {
        order[idx].layout = layout[axis];
      } else {
        order.push({
          value: value,
          layout: layout[axis]
        });
      }
      order.sort(compareMin);
    },
    updateOrder: (item, offset, velocity) => {
      if (isReordering.current) return;
      const newOrder = checkReorder(order, item, offset, velocity);
      if (order !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter(value => values.indexOf(value) !== -1));
      }
    }
  };
  React.useEffect(() => {
    isReordering.current = false;
  });
  return jsxRuntime.jsx(Component, {
    ...props,
    ref: externalRef,
    ignoreStrict: true,
    children: jsxRuntime.jsx(ReorderContext.Provider, {
      value: context,
      children: children
    })
  });
}
const ReorderGroup = /*@__PURE__*/React.forwardRef(ReorderGroupComponent);
function getValue(item) {
  return item.value;
}
function compareMin(a, b) {
  return a.layout.min - b.layout.min;
}

/**
 * Creates a `MotionValue` to track the state and velocity of a value.
 *
 * Usually, these are created automatically. For advanced use-cases, like use with `useTransform`, you can create `MotionValue`s externally and pass them into the animated component via the `style` prop.
 *
 * ```jsx
 * export const MyComponent = () => {
 *   const scale = useMotionValue(1)
 *
 *   return <motion.div style={{ scale }} />
 * }
 * ```
 *
 * @param initial - The initial state.
 *
 * @public
 */
function useMotionValue(initial) {
  const value = useConstant(() => motionValue(initial));
  /**
   * If this motion value is being used in static mode, like on
   * the Framer canvas, force components to rerender when the motion
   * value is updated.
   */
  const {
    isStatic
  } = React.useContext(MotionConfigContext);
  if (isStatic) {
    const [, setLatest] = React.useState(initial);
    React.useEffect(() => value.on("change", setLatest), []);
  }
  return value;
}
function useCombineMotionValues(values, combineValues) {
  /**
   * Initialise the returned motion value. This remains the same between renders.
   */
  const value = useMotionValue(combineValues());
  /**
   * Create a function that will update the template motion value with the latest values.
   * This is pre-bound so whenever a motion value updates it can schedule its
   * execution in Framesync. If it's already been scheduled it won't be fired twice
   * in a single frame.
   */
  const updateValue = () => value.set(combineValues());
  /**
   * Synchronously update the motion value with the latest values during the render.
   * This ensures that within a React render, the styles applied to the DOM are up-to-date.
   */
  updateValue();
  /**
   * Subscribe to all motion values found within the template. Whenever any of them change,
   * schedule an update.
   */
  useIsomorphicLayoutEffect(() => {
    const scheduleUpdate = () => frame.preRender(updateValue, false, true);
    const subscriptions = values.map(v => v.on("change", scheduleUpdate));
    return () => {
      subscriptions.forEach(unsubscribe => unsubscribe());
      cancelFrame(updateValue);
    };
  });
  return value;
}
function useComputed(compute) {
  /**
   * Open session of collectMotionValues. Any MotionValue that calls get()
   * will be saved into this array.
   */
  collectMotionValues.current = [];
  compute();
  const value = useCombineMotionValues(collectMotionValues.current, compute);
  /**
   * Synchronously close session of collectMotionValues.
   */
  collectMotionValues.current = undefined;
  return value;
}
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  if (typeof input === "function") {
    return useComputed(input);
  }
  const transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], ([latest]) => transformer(latest));
}
function useListTransform(values, transformer) {
  const latest = useConstant(() => []);
  return useCombineMotionValues(values, () => {
    latest.length = 0;
    const numValues = values.length;
    for (let i = 0; i < numValues; i++) {
      latest[i] = values[i].get();
    }
    return transformer(latest);
  });
}
function useDefaultMotionValue(value, defaultValue = 0) {
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
function ReorderItemComponent({
  children,
  style = {},
  value,
  as = "li",
  onDrag,
  layout = true,
  ...props
}, externalRef) {
  const Component = useConstant(() => motion[as]);
  const context = React.useContext(ReorderContext);
  const point = {
    x: useDefaultMotionValue(style.x),
    y: useDefaultMotionValue(style.y)
  };
  const zIndex = useTransform([point.x, point.y], ([latestX, latestY]) => latestX || latestY ? 1 : "unset");
  motionUtils.invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  const {
    axis,
    registerItem,
    updateOrder
  } = context;
  return jsxRuntime.jsx(Component, {
    drag: axis,
    ...props,
    dragSnapToOrigin: true,
    style: {
      ...style,
      x: point.x,
      y: point.y,
      zIndex
    },
    layout: layout,
    onDrag: (event, gesturePoint) => {
      const {
        velocity
      } = gesturePoint;
      velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
      onDrag && onDrag(event, gesturePoint);
    },
    onLayoutMeasure: measured => registerItem(value, measured),
    ref: externalRef,
    ignoreStrict: true,
    children: children
  });
}
const ReorderItem = /*@__PURE__*/React.forwardRef(ReorderItemComponent);
var namespace = /*#__PURE__*/Object.freeze({
  __proto__: null,
  Group: ReorderGroup,
  Item: ReorderItem
});
const createMinimalMotionComponent = /*@__PURE__*/createMotionComponentFactory();
const m = /*@__PURE__*/createDOMMotionComponentProxy(createMinimalMotionComponent);

/**
 * @public
 */
const domAnimation = {
  renderer: createDomVisualElement,
  ...animations,
  ...gestureAnimations
};

/**
 * @public
 */
const domMax = {
  ...domAnimation,
  ...drag,
  ...layout
};

/**
 * @public
 */
const domMin = {
  renderer: createDomVisualElement,
  ...animations
};
function useMotionValueEvent(value, event, callback) {
  /**
   * useInsertionEffect will create subscriptions before any other
   * effects will run. Effects run upwards through the tree so it
   * can be that binding a useLayoutEffect higher up the tree can
   * miss changes from lower down the tree.
   */
  React.useInsertionEffect(() => value.on(event, callback), [value, event, callback]);
}
function refWarning(name, ref) {
  motionUtils.warning(Boolean(!ref || ref.current), `You have defined a ${name} options but the provided ref is not yet hydrated, probably because it's defined higher up the tree. Try calling useScroll() in the same component as the ref, or setting its \`layoutEffect: false\` option.`);
}
const createScrollMotionValues = () => ({
  scrollX: motionValue(0),
  scrollY: motionValue(0),
  scrollXProgress: motionValue(0),
  scrollYProgress: motionValue(0)
});
function useScroll({
  container,
  target,
  layoutEffect = true,
  ...options
} = {}) {
  const values = useConstant(createScrollMotionValues);
  const useLifecycleEffect = layoutEffect ? useIsomorphicLayoutEffect : React.useEffect;
  useLifecycleEffect(() => {
    refWarning("target", target);
    refWarning("container", container);
    return scroll((_progress, {
      x,
      y
    }) => {
      values.scrollX.set(x.current);
      values.scrollXProgress.set(x.progress);
      values.scrollY.set(y.current);
      values.scrollYProgress.set(y.progress);
    }, {
      ...options,
      container: (container === null || container === void 0 ? void 0 : container.current) || undefined,
      target: (target === null || target === void 0 ? void 0 : target.current) || undefined
    });
  }, [container, target, JSON.stringify(options.offset)]);
  return values;
}

/**
 * @deprecated useElementScroll is deprecated. Convert to useScroll({ container: ref })
 */
function useElementScroll(ref) {
  if (process.env.NODE_ENV === "development") {
    warnOnce(false, "useElementScroll is deprecated. Convert to useScroll({ container: ref }).");
  }
  return useScroll({
    container: ref
  });
}

/**
 * @deprecated useViewportScroll is deprecated. Convert to useScroll()
 */
function useViewportScroll() {
  if (process.env.NODE_ENV !== "production") {
    warnOnce(false, "useViewportScroll is deprecated. Convert to useScroll().");
  }
  return useScroll();
}

/**
 * Combine multiple motion values into a new one using a string template literal.
 *
 * ```jsx
 * import {
 *   motion,
 *   useSpring,
 *   useMotionValue,
 *   useMotionTemplate
 * } from "framer-motion"
 *
 * function Component() {
 *   const shadowX = useSpring(0)
 *   const shadowY = useMotionValue(0)
 *   const shadow = useMotionTemplate`drop-shadow(${shadowX}px ${shadowY}px 20px rgba(0,0,0,0.3))`
 *
 *   return <motion.div style={{ filter: shadow }} />
 * }
 * ```
 *
 * @public
 */
function useMotionTemplate(fragments, ...values) {
  /**
   * Create a function that will build a string from the latest motion values.
   */
  const numFragments = fragments.length;
  function buildValue() {
    let output = ``;
    for (let i = 0; i < numFragments; i++) {
      output += fragments[i];
      const value = values[i];
      if (value) {
        output += isMotionValue(value) ? value.get() : value;
      }
    }
    return output;
  }
  return useCombineMotionValues(values.filter(isMotionValue), buildValue);
}
function toNumber(v) {
  if (typeof v === "number") return v;
  return parseFloat(v);
}
/**
 * Creates a `MotionValue` that, when `set`, will use a spring animation to animate to its new state.
 *
 * It can either work as a stand-alone `MotionValue` by initialising it with a value, or as a subscriber
 * to another `MotionValue`.
 *
 * @remarks
 *
 * ```jsx
 * const x = useSpring(0, { stiffness: 300 })
 * const y = useSpring(x, { damping: 10 })
 * ```
 *
 * @param inputValue - `MotionValue` or number. If provided a `MotionValue`, when the input `MotionValue` changes, the created `MotionValue` will spring towards that value.
 * @param springConfig - Configuration options for the spring.
 * @returns `MotionValue`
 *
 * @public
 */
function useSpring(source, config = {}) {
  const {
    isStatic
  } = React.useContext(MotionConfigContext);
  const activeSpringAnimation = React.useRef(null);
  const value = useMotionValue(isMotionValue(source) ? toNumber(source.get()) : source);
  const latestValue = React.useRef(value.get());
  const latestSetter = React.useRef(() => {});
  const startAnimation = () => {
    /**
     * If the previous animation hasn't had the chance to even render a frame, render it now.
     */
    const animation = activeSpringAnimation.current;
    if (animation && animation.time === 0) {
      animation.sample(frameData.delta);
    }
    stopAnimation();
    activeSpringAnimation.current = animateValue({
      keyframes: [value.get(), latestValue.current],
      velocity: value.getVelocity(),
      type: "spring",
      restDelta: 0.001,
      restSpeed: 0.01,
      ...config,
      onUpdate: latestSetter.current
    });
  };
  const stopAnimation = () => {
    if (activeSpringAnimation.current) {
      activeSpringAnimation.current.stop();
    }
  };
  React.useInsertionEffect(() => {
    return value.attach((v, set) => {
      /**
       * A more hollistic approach to this might be to use isStatic to fix VisualElement animations
       * at that level, but this will work for now
       */
      if (isStatic) return set(v);
      latestValue.current = v;
      latestSetter.current = set;
      frame.update(startAnimation);
      return value.get();
    }, stopAnimation);
  }, [JSON.stringify(config)]);
  useIsomorphicLayoutEffect(() => {
    if (isMotionValue(source)) {
      return source.on("change", v => value.set(toNumber(v)));
    }
  }, [value]);
  return value;
}
function useAnimationFrame(callback) {
  const initialTimestamp = React.useRef(0);
  const {
    isStatic
  } = React.useContext(MotionConfigContext);
  React.useEffect(() => {
    if (isStatic) return;
    const provideTimeSinceStart = ({
      timestamp,
      delta
    }) => {
      if (!initialTimestamp.current) initialTimestamp.current = timestamp;
      callback(timestamp - initialTimestamp.current, delta);
    };
    frame.update(provideTimeSinceStart, true);
    return () => cancelFrame(provideTimeSinceStart);
  }, [callback]);
}
function useTime() {
  const time = useMotionValue(0);
  useAnimationFrame(t => time.set(t));
  return time;
}

/**
 * Creates a `MotionValue` that updates when the velocity of the provided `MotionValue` changes.
 *
 * ```javascript
 * const x = useMotionValue(0)
 * const xVelocity = useVelocity(x)
 * const xAcceleration = useVelocity(xVelocity)
 * ```
 *
 * @public
 */
function useVelocity(value) {
  const velocity = useMotionValue(value.getVelocity());
  const updateVelocity = () => {
    const latest = value.getVelocity();
    velocity.set(latest);
    /**
     * If we still have velocity, schedule an update for the next frame
     * to keep checking until it is zero.
     */
    if (latest) frame.update(updateVelocity);
  };
  useMotionValueEvent(value, "change", () => {
    // Schedule an update to this value at the end of the current frame.
    frame.update(updateVelocity, false, true);
  });
  return velocity;
}
function getWillChangeName(name) {
  if (transformProps.has(name)) {
    return "transform";
  } else if (acceleratedValues.has(name)) {
    return camelToDash(name);
  }
}
class WillChangeMotionValue extends MotionValue {
  constructor() {
    super(...arguments);
    this.values = [];
  }
  add(name) {
    const styleName = getWillChangeName(name);
    if (styleName) {
      addUniqueItem(this.values, styleName);
      this.update();
    }
  }
  update() {
    this.set(this.values.length ? this.values.join(", ") : "auto");
  }
}
function useWillChange() {
  return useConstant(() => new WillChangeMotionValue("auto"));
}

/**
 * A hook that returns `true` if we should be using reduced motion based on the current device's Reduced Motion setting.
 *
 * This can be used to implement changes to your UI based on Reduced Motion. For instance, replacing motion-sickness inducing
 * `x`/`y` animations with `opacity`, disabling the autoplay of background videos, or turning off parallax motion.
 *
 * It will actively respond to changes and re-render your components with the latest setting.
 *
 * ```jsx
 * export function Sidebar({ isOpen }) {
 *   const shouldReduceMotion = useReducedMotion()
 *   const closedX = shouldReduceMotion ? 0 : "-100%"
 *
 *   return (
 *     <motion.div animate={{
 *       opacity: isOpen ? 1 : 0,
 *       x: isOpen ? 0 : closedX
 *     }} />
 *   )
 * }
 * ```
 *
 * @return boolean
 *
 * @public
 */
function useReducedMotion() {
  /**
   * Lazy initialisation of prefersReducedMotion
   */
  !hasReducedMotionListener.current && initPrefersReducedMotion();
  const [shouldReduceMotion] = React.useState(prefersReducedMotion.current);
  if (process.env.NODE_ENV !== "production") {
    warnOnce(shouldReduceMotion !== true, "You have Reduced Motion enabled on your device. Animations may not appear as expected.");
  }
  /**
   * TODO See if people miss automatically updating shouldReduceMotion setting
   */
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  const reducedMotionPreference = useReducedMotion();
  const {
    reducedMotion
  } = React.useContext(MotionConfigContext);
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}
function stopAnimation(visualElement) {
  visualElement.values.forEach(value => value.stop());
}
function setVariants(visualElement, variantLabels) {
  const reversedLabels = [...variantLabels].reverse();
  reversedLabels.forEach(key => {
    const variant = visualElement.getVariant(key);
    variant && setTarget(visualElement, variant);
    if (visualElement.variantChildren) {
      visualElement.variantChildren.forEach(child => {
        setVariants(child, variantLabels);
      });
    }
  });
}
function setValues(visualElement, definition) {
  if (Array.isArray(definition)) {
    return setVariants(visualElement, definition);
  } else if (typeof definition === "string") {
    return setVariants(visualElement, [definition]);
  } else {
    setTarget(visualElement, definition);
  }
}
/**
 * @public
 */
function animationControls() {
  /**
   * Track whether the host component has mounted.
   */
  let hasMounted = false;
  /**
   * A collection of linked component animation controls.
   */
  const subscribers = new Set();
  const controls = {
    subscribe(visualElement) {
      subscribers.add(visualElement);
      return () => void subscribers.delete(visualElement);
    },
    start(definition, transitionOverride) {
      motionUtils.invariant(hasMounted, "controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      const animations = [];
      subscribers.forEach(visualElement => {
        animations.push(animateVisualElement(visualElement, definition, {
          transitionOverride
        }));
      });
      return Promise.all(animations);
    },
    set(definition) {
      motionUtils.invariant(hasMounted, "controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.");
      return subscribers.forEach(visualElement => {
        setValues(visualElement, definition);
      });
    },
    stop() {
      subscribers.forEach(visualElement => {
        stopAnimation(visualElement);
      });
    },
    mount() {
      hasMounted = true;
      return () => {
        hasMounted = false;
        controls.stop();
      };
    }
  };
  return controls;
}
function useAnimate() {
  const scope = useConstant(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  }));
  const animate = useConstant(() => createScopedAnimate(scope));
  useUnmountEffect(() => {
    scope.animations.forEach(animation => animation.stop());
  });
  return [scope, animate];
}
function useAnimateMini() {
  const scope = useConstant(() => ({
    current: null,
    // Will be hydrated by React
    animations: []
  }));
  const animate = useConstant(() => createScopedWaapiAnimate(scope));
  useUnmountEffect(() => {
    scope.animations.forEach(animation => animation.stop());
  });
  return [scope, animate];
}

/**
 * Creates `AnimationControls`, which can be used to manually start, stop
 * and sequence animations on one or more components.
 *
 * The returned `AnimationControls` should be passed to the `animate` property
 * of the components you want to animate.
 *
 * These components can then be animated with the `start` method.
 *
 * ```jsx
 * import * as React from 'react'
 * import { motion, useAnimation } from 'framer-motion'
 *
 * export function MyComponent(props) {
 *    const controls = useAnimation()
 *
 *    controls.start({
 *        x: 100,
 *        transition: { duration: 0.5 },
 *    })
 *
 *    return <motion.div animate={controls} />
 * }
 * ```
 *
 * @returns Animation controller with `start` and `stop` methods
 *
 * @public
 */
function useAnimationControls() {
  const controls = useConstant(animationControls);
  useIsomorphicLayoutEffect(controls.mount, []);
  return controls;
}
const useAnimation = useAnimationControls;

/**
 * Attaches an event listener directly to the provided DOM element.
 *
 * Bypassing React's event system can be desirable, for instance when attaching non-passive
 * event handlers.
 *
 * ```jsx
 * const ref = useRef(null)
 *
 * useDomEvent(ref, 'wheel', onWheel, { passive: false })
 *
 * return <div ref={ref} />
 * ```
 *
 * @param ref - React.RefObject that's been provided to the element you want to bind the listener to.
 * @param eventName - Name of the event you want listen for.
 * @param handler - Function to fire when receiving the event.
 * @param options - Options to pass to `Event.addEventListener`.
 *
 * @public
 */
function useDomEvent(ref, eventName, handler, options) {
  React.useEffect(() => {
    const element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}

/**
 * Can manually trigger a drag gesture on one or more `drag`-enabled `motion` components.
 *
 * ```jsx
 * const dragControls = useDragControls()
 *
 * function startDrag(event) {
 *   dragControls.start(event, { snapToCursor: true })
 * }
 *
 * return (
 *   <>
 *     <div onPointerDown={startDrag} />
 *     <motion.div drag="x" dragControls={dragControls} />
 *   </>
 * )
 * ```
 *
 * @public
 */
class DragControls {
  constructor() {
    this.componentControls = new Set();
  }
  /**
   * Subscribe a component's internal `VisualElementDragControls` to the user-facing API.
   *
   * @internal
   */
  subscribe(controls) {
    this.componentControls.add(controls);
    return () => this.componentControls.delete(controls);
  }
  /**
   * Start a drag gesture on every `motion` component that has this set of drag controls
   * passed into it via the `dragControls` prop.
   *
   * ```jsx
   * dragControls.start(e, {
   *   snapToCursor: true
   * })
   * ```
   *
   * @param event - PointerEvent
   * @param options - Options
   *
   * @public
   */
  start(event, options) {
    this.componentControls.forEach(controls => {
      controls.start(event.nativeEvent || event, options);
    });
  }
}
const createDragControls = () => new DragControls();
/**
 * Usually, dragging is initiated by pressing down on a `motion` component with a `drag` prop
 * and moving it. For some use-cases, for instance clicking at an arbitrary point on a video scrubber, we
 * might want to initiate that dragging from a different component than the draggable one.
 *
 * By creating a `dragControls` using the `useDragControls` hook, we can pass this into
 * the draggable component's `dragControls` prop. It exposes a `start` method
 * that can start dragging from pointer events on other components.
 *
 * ```jsx
 * const dragControls = useDragControls()
 *
 * function startDrag(event) {
 *   dragControls.start(event, { snapToCursor: true })
 * }
 *
 * return (
 *   <>
 *     <div onPointerDown={startDrag} />
 *     <motion.div drag="x" dragControls={dragControls} />
 *   </>
 * )
 * ```
 *
 * @public
 */
function useDragControls() {
  return useConstant(createDragControls);
}

/**
 * Checks if a component is a `motion` component.
 */
function isMotionComponent(component) {
  return component !== null && typeof component === "object" && motionComponentSymbol in component;
}

/**
 * Unwraps a `motion` component and returns either a string for `motion.div` or
 * the React component for `motion(Component)`.
 *
 * If the component is not a `motion` component it returns undefined.
 */
function unwrapMotionComponent(component) {
  if (isMotionComponent(component)) {
    return component[motionComponentSymbol];
  }
  return undefined;
}
function useInstantLayoutTransition() {
  return startTransition;
}
function startTransition(callback) {
  if (!rootProjectionNode.current) return;
  rootProjectionNode.current.isUpdating = false;
  rootProjectionNode.current.blockUpdate();
  callback && callback();
}
function useResetProjection() {
  const reset = React.useCallback(() => {
    const root = rootProjectionNode.current;
    if (!root) return;
    root.resetTree();
  }, []);
  return reset;
}

/**
 * Cycles through a series of visual properties. Can be used to toggle between or cycle through animations. It works similar to `useState` in React. It is provided an initial array of possible states, and returns an array of two arguments.
 *
 * An index value can be passed to the returned `cycle` function to cycle to a specific index.
 *
 * ```jsx
 * import * as React from "react"
 * import { motion, useCycle } from "framer-motion"
 *
 * export const MyComponent = () => {
 *   const [x, cycleX] = useCycle(0, 50, 100)
 *
 *   return (
 *     <motion.div
 *       animate={{ x: x }}
 *       onTap={() => cycleX()}
 *      />
 *    )
 * }
 * ```
 *
 * @param items - items to cycle through
 * @returns [currentState, cycleState]
 *
 * @public
 */
function useCycle(...items) {
  const index = React.useRef(0);
  const [item, setItem] = React.useState(items[index.current]);
  const runCycle = React.useCallback(next => {
    index.current = typeof next !== "number" ? wrap(0, items.length, index.current + 1) : next;
    setItem(items[index.current]);
  },
  // The array will change on each call, but by putting items.length at
  // the front of this array, we guarantee the dependency comparison will match up
  // eslint-disable-next-line react-hooks/exhaustive-deps
  [items.length, ...items]);
  return [item, runCycle];
}
function useInView(ref, {
  root,
  margin,
  amount,
  once = false
} = {}) {
  const [isInView, setInView] = React.useState(false);
  React.useEffect(() => {
    if (!ref.current || once && isInView) return;
    const onEnter = () => {
      setInView(true);
      return once ? undefined : () => setInView(false);
    };
    const options = {
      root: root && root.current || undefined,
      margin,
      amount
    };
    return inView(ref.current, onEnter, options);
  }, [root, ref, margin, once, amount]);
  return isInView;
}
function useInstantTransition() {
  const [forceUpdate, forcedRenderCount] = useForceUpdate();
  const startInstantLayoutTransition = useInstantLayoutTransition();
  const unlockOnFrameRef = React.useRef(-1);
  React.useEffect(() => {
    /**
     * Unblock after two animation frames, otherwise this will unblock too soon.
     */
    frame.postRender(() => frame.postRender(() => {
      /**
       * If the callback has been called again after the effect
       * triggered this 2 frame delay, don't unblock animations. This
       * prevents the previous effect from unblocking the current
       * instant transition too soon. This becomes more likely when
       * used in conjunction with React.startTransition().
       */
      if (forcedRenderCount !== unlockOnFrameRef.current) return;
      instantAnimationState.current = false;
    }));
  }, [forcedRenderCount]);
  return callback => {
    startInstantLayoutTransition(() => {
      instantAnimationState.current = true;
      forceUpdate();
      callback();
      unlockOnFrameRef.current = forcedRenderCount + 1;
    });
  };
}
function disableInstantTransitions() {
  instantAnimationState.current = false;
}
const appearStoreId = (elementId, valueName) => {
  const key = transformProps.has(valueName) ? "transform" : valueName;
  return `${elementId}: ${key}`;
};
const appearAnimationStore = new Map();
const appearComplete = new Map();
function handoffOptimizedAppearAnimation(elementId, valueName, frame) {
  var _a;
  const storeId = appearStoreId(elementId, valueName);
  const optimisedAnimation = appearAnimationStore.get(storeId);
  if (!optimisedAnimation) {
    return null;
  }
  const {
    animation,
    startTime
  } = optimisedAnimation;
  function cancelAnimation() {
    var _a;
    (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, elementId, valueName, frame);
  }
  /**
   * We can cancel the animation once it's finished now that we've synced
   * with Motion.
   *
   * Prefer onfinish over finished as onfinish is backwards compatible with
   * older browsers.
   */
  animation.onfinish = cancelAnimation;
  if (startTime === null || ((_a = window.MotionHandoffIsComplete) === null || _a === void 0 ? void 0 : _a.call(window, elementId))) {
    /**
     * If the startTime is null, this animation is the Paint Ready detection animation
     * and we can cancel it immediately without handoff.
     *
     * Or if we've already handed off the animation then we're now interrupting it.
     * In which case we need to cancel it.
     */
    cancelAnimation();
    return null;
  } else {
    return startTime;
  }
}

/**
 * A single time to use across all animations to manually set startTime
 * and ensure they're all in sync.
 */
let startFrameTime;
/**
 * A dummy animation to detect when Chrome is ready to start
 * painting the page and hold off from triggering the real animation
 * until then. We only need one animation to detect paint ready.
 *
 * https://bugs.chromium.org/p/chromium/issues/detail?id=1406850
 */
let readyAnimation;
/**
 * Keep track of animations that were suspended vs cancelled so we
 * can easily resume them when we're done measuring layout.
 */
const suspendedAnimations = new Set();
function resumeSuspendedAnimations() {
  suspendedAnimations.forEach(data => {
    data.animation.play();
    data.animation.startTime = data.startTime;
  });
  suspendedAnimations.clear();
}
function startOptimizedAppearAnimation(element, name, keyframes, options, onReady) {
  // Prevent optimised appear animations if Motion has already started animating.
  if (window.MotionIsMounted) {
    return;
  }
  const id = element.dataset[optimizedAppearDataId];
  if (!id) return;
  window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
  const storeId = appearStoreId(id, name);
  if (!readyAnimation) {
    readyAnimation = startWaapiAnimation(element, name, [keyframes[0], keyframes[0]],
    /**
     * 10 secs is basically just a super-safe duration to give Chrome
     * long enough to get the animation ready.
     */
    {
      duration: 10000,
      ease: "linear"
    });
    appearAnimationStore.set(storeId, {
      animation: readyAnimation,
      startTime: null
    });
    /**
     * If there's no readyAnimation then there's been no instantiation
     * of handoff animations.
     */
    window.MotionHandoffAnimation = handoffOptimizedAppearAnimation;
    window.MotionHasOptimisedAnimation = (elementId, valueName) => {
      if (!elementId) return false;
      /**
       * Keep a map of elementIds that have started animating. We check
       * via ID instead of Element because of hydration errors and
       * pre-hydration checks. We also actively record IDs as they start
       * animating rather than simply checking for data-appear-id as
       * this attrbute might be present but not lead to an animation, for
       * instance if the element's appear animation is on a different
       * breakpoint.
       */
      if (!valueName) {
        return appearComplete.has(elementId);
      }
      const animationId = appearStoreId(elementId, valueName);
      return Boolean(appearAnimationStore.get(animationId));
    };
    window.MotionHandoffMarkAsComplete = elementId => {
      if (appearComplete.has(elementId)) {
        appearComplete.set(elementId, true);
      }
    };
    window.MotionHandoffIsComplete = elementId => {
      return appearComplete.get(elementId) === true;
    };
    /**
     * We only need to cancel transform animations as
     * they're the ones that will interfere with the
     * layout animation measurements.
     */
    window.MotionCancelOptimisedAnimation = (elementId, valueName, frame, canResume) => {
      const animationId = appearStoreId(elementId, valueName);
      const data = appearAnimationStore.get(animationId);
      if (!data) return;
      if (frame && canResume === undefined) {
        /**
         * Wait until the end of the subsequent frame to cancel the animation
         * to ensure we don't remove the animation before the main thread has
         * had a chance to resolve keyframes and render.
         */
        frame.postRender(() => {
          frame.postRender(() => {
            data.animation.cancel();
          });
        });
      } else {
        data.animation.cancel();
      }
      if (frame && canResume) {
        suspendedAnimations.add(data);
        frame.render(resumeSuspendedAnimations);
      } else {
        appearAnimationStore.delete(animationId);
        /**
         * If there are no more animations left, we can remove the cancel function.
         * This will let us know when we can stop checking for conflicting layout animations.
         */
        if (!appearAnimationStore.size) {
          window.MotionCancelOptimisedAnimation = undefined;
        }
      }
    };
    window.MotionCheckAppearSync = (visualElement, valueName, value) => {
      var _a, _b;
      const appearId = getOptimisedAppearId(visualElement);
      if (!appearId) return;
      const valueIsOptimised = (_a = window.MotionHasOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);
      const externalAnimationValue = (_b = visualElement.props.values) === null || _b === void 0 ? void 0 : _b[valueName];
      if (!valueIsOptimised || !externalAnimationValue) return;
      const removeSyncCheck = value.on("change", latestValue => {
        var _a;
        if (externalAnimationValue.get() !== latestValue) {
          (_a = window.MotionCancelOptimisedAnimation) === null || _a === void 0 ? void 0 : _a.call(window, appearId, valueName);
          removeSyncCheck();
        }
      });
      return removeSyncCheck;
    };
  }
  const startAnimation = () => {
    readyAnimation.cancel();
    const appearAnimation = startWaapiAnimation(element, name, keyframes, options);
    /**
     * Record the time of the first started animation. We call performance.now() once
     * here and once in handoff to ensure we're getting
     * close to a frame-locked time. This keeps all animations in sync.
     */
    if (startFrameTime === undefined) {
      startFrameTime = performance.now();
    }
    appearAnimation.startTime = startFrameTime;
    appearAnimationStore.set(storeId, {
      animation: appearAnimation,
      startTime: startFrameTime
    });
    if (onReady) onReady(appearAnimation);
  };
  appearComplete.set(id, false);
  if (readyAnimation.ready) {
    readyAnimation.ready.then(startAnimation).catch(motionUtils.noop);
  } else {
    startAnimation();
  }
}
const createObject = () => ({});
class StateVisualElement extends VisualElement {
  constructor() {
    super(...arguments);
    this.measureInstanceViewportBox = createBox;
  }
  build() {}
  resetTransform() {}
  restoreTransform() {}
  removeValueFromRenderState() {}
  renderInstance() {}
  scrapeMotionValuesFromProps() {
    return createObject();
  }
  getBaseTargetFromProps() {
    return undefined;
  }
  readValueFromInstance(_state, key, options) {
    return options.initialState[key] || 0;
  }
  sortInstanceNodePosition() {
    return 0;
  }
}
const useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});
/**
 * This is not an officially supported API and may be removed
 * on any version.
 */
function useAnimatedState(initialState) {
  const [animationState, setAnimationState] = React.useState(initialState);
  const visualState = useVisualState({}, false);
  const element = useConstant(() => {
    return new StateVisualElement({
      props: {
        onUpdate: v => {
          setAnimationState({
            ...v
          });
        }
      },
      visualState,
      presenceContext: null
    }, {
      initialState
    });
  });
  React.useLayoutEffect(() => {
    element.mount({});
    return () => element.unmount();
  }, [element]);
  const startAnimation = useConstant(() => animationDefinition => {
    return animateVisualElement(element, animationDefinition);
  });
  return [animationState, startAnimation];
}
let id = 0;
const AnimateSharedLayout = ({
  children
}) => {
  React__namespace.useEffect(() => {
    motionUtils.invariant(false, "AnimateSharedLayout is deprecated: https://www.framer.com/docs/guide-upgrade/##shared-layout-animations");
  }, []);
  return jsxRuntime.jsx(LayoutGroup, {
    id: useConstant(() => `asl-${id++}`),
    children: children
  });
};

// Keep things reasonable and avoid scale: Infinity. In practise we might need
// to add another value, opacity, that could interpolate scaleX/Y [0,0.01] => [0,1]
// to simply hide content at unreasonable scales.
const maxScale = 100000;
const invertScale = scale => scale > 0.001 ? 1 / scale : maxScale;
let hasWarned = false;
/**
 * Returns a `MotionValue` each for `scaleX` and `scaleY` that update with the inverse
 * of their respective parent scales.
 *
 * This is useful for undoing the distortion of content when scaling a parent component.
 *
 * By default, `useInvertedScale` will automatically fetch `scaleX` and `scaleY` from the nearest parent.
 * By passing other `MotionValue`s in as `useInvertedScale({ scaleX, scaleY })`, it will invert the output
 * of those instead.
 *
 * ```jsx
 * const MyComponent = () => {
 *   const { scaleX, scaleY } = useInvertedScale()
 *   return <motion.div style={{ scaleX, scaleY }} />
 * }
 * ```
 *
 * @deprecated
 */
function useInvertedScale(scale) {
  let parentScaleX = useMotionValue(1);
  let parentScaleY = useMotionValue(1);
  const {
    visualElement
  } = React.useContext(MotionContext);
  motionUtils.invariant(!!(scale || visualElement), "If no scale values are provided, useInvertedScale must be used within a child of another motion component.");
  motionUtils.warning(hasWarned, "useInvertedScale is deprecated and will be removed in 3.0. Use the layout prop instead.");
  hasWarned = true;
  if (scale) {
    parentScaleX = scale.scaleX || parentScaleX;
    parentScaleY = scale.scaleY || parentScaleY;
  } else if (visualElement) {
    parentScaleX = visualElement.getValue("scaleX", 1);
    parentScaleY = visualElement.getValue("scaleY", 1);
  }
  const scaleX = useTransform(parentScaleX, invertScale);
  const scaleY = useTransform(parentScaleY, invertScale);
  return {
    scaleX,
    scaleY
  };
}
Object.defineProperty(exports, "invariant", {
  enumerable: true,
  get: function () {
    return motionUtils.invariant;
  }
});
Object.defineProperty(exports, "noop", {
  enumerable: true,
  get: function () {
    return motionUtils.noop;
  }
});
Object.defineProperty(exports, "progress", {
  enumerable: true,
  get: function () {
    return motionUtils.progress;
  }
});
Object.defineProperty(exports, "isDragActive", {
  enumerable: true,
  get: function () {
    return motionDom.isDragActive;
  }
});
exports.AcceleratedAnimation = AcceleratedAnimation;
exports.AnimatePresence = AnimatePresence;
exports.AnimateSharedLayout = AnimateSharedLayout;
exports.DeprecatedLayoutGroupContext = DeprecatedLayoutGroupContext;
exports.DragControls = DragControls;
exports.FlatTree = FlatTree;
exports.LayoutGroup = LayoutGroup;
exports.LayoutGroupContext = LayoutGroupContext;
exports.LazyMotion = LazyMotion;
exports.MotionConfig = MotionConfig;
exports.MotionConfigContext = MotionConfigContext;
exports.MotionContext = MotionContext;
exports.MotionGlobalConfig = MotionGlobalConfig;
exports.MotionValue = MotionValue;
exports.PresenceContext = PresenceContext;
exports.Reorder = namespace;
exports.SwitchLayoutGroupContext = SwitchLayoutGroupContext;
exports.VisualElement = VisualElement;
exports.addPointerEvent = addPointerEvent;
exports.addPointerInfo = addPointerInfo;
exports.addScaleCorrector = addScaleCorrector;
exports.animate = animate;
exports.animateMini = animateMini;
exports.animateValue = animateValue;
exports.animateVisualElement = animateVisualElement;
exports.animationControls = animationControls;
exports.animations = animations;
exports.anticipate = anticipate;
exports.backIn = backIn;
exports.backInOut = backInOut;
exports.backOut = backOut;
exports.buildTransform = buildTransform;
exports.calcLength = calcLength;
exports.cancelFrame = cancelFrame;
exports.cancelSync = cancelSync;
exports.circIn = circIn;
exports.circInOut = circInOut;
exports.circOut = circOut;
exports.clamp = clamp;
exports.color = color;
exports.complex = complex;
exports.createBox = createBox;
exports.createRendererMotionComponent = createRendererMotionComponent;
exports.createScopedAnimate = createScopedAnimate;
exports.cubicBezier = cubicBezier;
exports.delay = delay;
exports.disableInstantTransitions = disableInstantTransitions;
exports.distance = distance;
exports.distance2D = distance2D;
exports.domAnimation = domAnimation;
exports.domMax = domMax;
exports.domMin = domMin;
exports.easeIn = easeIn;
exports.easeInOut = easeInOut;
exports.easeOut = easeOut;
exports.filterProps = filterProps;
exports.findSpring = findSpring;
exports.frame = frame;
exports.frameData = frameData;
exports.frameSteps = frameSteps;
exports.inView = inView;
exports.inertia = inertia;
exports.interpolate = interpolate;
exports.isBrowser = isBrowser;
exports.isMotionComponent = isMotionComponent;
exports.isMotionValue = isMotionValue;
exports.isValidMotionProp = isValidMotionProp;
exports.keyframes = keyframes;
exports.m = m;
exports.makeUseVisualState = makeUseVisualState;
exports.mirrorEasing = mirrorEasing;
exports.mix = mix;
exports.motion = motion;
exports.motionValue = motionValue;
exports.optimizedAppearDataAttribute = optimizedAppearDataAttribute;
exports.pipe = pipe;
exports.px = px;
exports.resolveMotionValue = resolveMotionValue;
exports.reverseEasing = reverseEasing;
exports.scroll = scroll;
exports.scrollInfo = scrollInfo;
exports.spring = spring;
exports.stagger = stagger;
exports.startOptimizedAppearAnimation = startOptimizedAppearAnimation;
exports.steps = steps;
exports.sync = sync;
exports.time = time;
exports.transform = transform;
exports.unwrapMotionComponent = unwrapMotionComponent;
exports.useAnimate = useAnimate;
exports.useAnimateMini = useAnimateMini;
exports.useAnimation = useAnimation;
exports.useAnimationControls = useAnimationControls;
exports.useAnimationFrame = useAnimationFrame;
exports.useCycle = useCycle;
exports.useDeprecatedAnimatedState = useAnimatedState;
exports.useDeprecatedInvertedScale = useInvertedScale;
exports.useDomEvent = useDomEvent;
exports.useDragControls = useDragControls;
exports.useElementScroll = useElementScroll;
exports.useForceUpdate = useForceUpdate;
exports.useInView = useInView;
exports.useInstantLayoutTransition = useInstantLayoutTransition;
exports.useInstantTransition = useInstantTransition;
exports.useIsPresent = useIsPresent;
exports.useIsomorphicLayoutEffect = useIsomorphicLayoutEffect;
exports.useMotionTemplate = useMotionTemplate;
exports.useMotionValue = useMotionValue;
exports.useMotionValueEvent = useMotionValueEvent;
exports.usePresence = usePresence;
exports.useReducedMotion = useReducedMotion;
exports.useReducedMotionConfig = useReducedMotionConfig;
exports.useResetProjection = useResetProjection;
exports.useScroll = useScroll;
exports.useSpring = useSpring;
exports.useTime = useTime;
exports.useTransform = useTransform;
exports.useUnmountEffect = useUnmountEffect;
exports.useVelocity = useVelocity;
exports.useViewportScroll = useViewportScroll;
exports.useWillChange = useWillChange;
exports.visualElementStore = visualElementStore;
exports.wrap = wrap;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJuYW1lcyI6WyJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImV4cG9ydHMiLCJ2YWx1ZSIsImpzeFJ1bnRpbWUiLCJyZXF1aXJlIiwiUmVhY3QiLCJtb3Rpb25VdGlscyIsIm1vdGlvbkRvbSIsIl9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdCIsImUiLCJuIiwiY3JlYXRlIiwia2V5cyIsImZvckVhY2giLCJrIiwiZCIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldCIsImVudW1lcmFibGUiLCJkZWZhdWx0IiwiZnJlZXplIiwiUmVhY3RfX25hbWVzcGFjZSIsIkxheW91dEdyb3VwQ29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJpc0FuaW1hdGlvbkNvbnRyb2xzIiwidiIsInN0YXJ0IiwiaXNLZXlmcmFtZXNUYXJnZXQiLCJBcnJheSIsImlzQXJyYXkiLCJzaGFsbG93Q29tcGFyZSIsIm5leHQiLCJwcmV2IiwicHJldkxlbmd0aCIsImxlbmd0aCIsImkiLCJpc1ZhcmlhbnRMYWJlbCIsImdldFZhbHVlU3RhdGUiLCJ2aXN1YWxFbGVtZW50Iiwic3RhdGUiLCJ2YWx1ZXMiLCJrZXkiLCJnZXRWZWxvY2l0eSIsInJlc29sdmVWYXJpYW50RnJvbVByb3BzIiwicHJvcHMiLCJkZWZpbml0aW9uIiwiY3VzdG9tIiwiY3VycmVudCIsInZlbG9jaXR5IiwidW5kZWZpbmVkIiwidmFyaWFudHMiLCJyZXNvbHZlVmFyaWFudCIsImdldFByb3BzIiwidmFyaWFudFByaW9yaXR5T3JkZXIiLCJ2YXJpYW50UHJvcHMiLCJNb3Rpb25HbG9iYWxDb25maWciLCJza2lwQW5pbWF0aW9ucyIsInVzZU1hbnVhbFRpbWluZyIsImNyZWF0ZVJlbmRlclN0ZXAiLCJydW5OZXh0RnJhbWUiLCJ0aGlzRnJhbWUiLCJTZXQiLCJuZXh0RnJhbWUiLCJpc1Byb2Nlc3NpbmciLCJmbHVzaE5leHRGcmFtZSIsInRvS2VlcEFsaXZlIiwiV2Vha1NldCIsImxhdGVzdEZyYW1lRGF0YSIsImRlbHRhIiwidGltZXN0YW1wIiwidHJpZ2dlckNhbGxiYWNrIiwiY2FsbGJhY2siLCJoYXMiLCJzdGVwIiwic2NoZWR1bGUiLCJrZWVwQWxpdmUiLCJpbW1lZGlhdGUiLCJhZGRUb0N1cnJlbnRGcmFtZSIsInF1ZXVlIiwiYWRkIiwiY2FuY2VsIiwiZGVsZXRlIiwicHJvY2VzcyIsImZyYW1lRGF0YSIsImNsZWFyIiwic3RlcHNPcmRlciIsIm1heEVsYXBzZWQkMSIsImNyZWF0ZVJlbmRlckJhdGNoZXIiLCJzY2hlZHVsZU5leHRCYXRjaCIsImFsbG93S2VlcEFsaXZlIiwidXNlRGVmYXVsdEVsYXBzZWQiLCJmbGFnUnVuTmV4dEZyYW1lIiwic3RlcHMiLCJyZWR1Y2UiLCJhY2MiLCJyZWFkIiwicmVzb2x2ZUtleWZyYW1lcyIsInVwZGF0ZSIsInByZVJlbmRlciIsInJlbmRlciIsInBvc3RSZW5kZXIiLCJwcm9jZXNzQmF0Y2giLCJwZXJmb3JtYW5jZSIsIm5vdyIsIk1hdGgiLCJtYXgiLCJtaW4iLCJ3YWtlIiwiZnJhbWUiLCJjYW5jZWxGcmFtZSIsImZyYW1lU3RlcHMiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJub29wIiwidHJhbnNmb3JtUHJvcE9yZGVyIiwidHJhbnNmb3JtUHJvcHMiLCJwb3NpdGlvbmFsS2V5cyIsImlzQ3VzdG9tVmFsdWUiLCJCb29sZWFuIiwibWl4IiwidG9WYWx1ZSIsInJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMiLCJjbGVhclRpbWUiLCJ0aW1lIiwic2V0IiwibmV3VGltZSIsInF1ZXVlTWljcm90YXNrIiwiYWRkVW5pcXVlSXRlbSIsImFyciIsIml0ZW0iLCJpbmRleE9mIiwicHVzaCIsInJlbW92ZUl0ZW0iLCJpbmRleCIsInNwbGljZSIsIm1vdmVJdGVtIiwiZnJvbUluZGV4IiwidG9JbmRleCIsInN0YXJ0SW5kZXgiLCJlbmRJbmRleCIsIlN1YnNjcmlwdGlvbk1hbmFnZXIiLCJjb25zdHJ1Y3RvciIsInN1YnNjcmlwdGlvbnMiLCJoYW5kbGVyIiwibm90aWZ5IiwiYSIsImIiLCJjIiwibnVtU3Vic2NyaXB0aW9ucyIsImdldFNpemUiLCJ2ZWxvY2l0eVBlclNlY29uZCIsImZyYW1lRHVyYXRpb24iLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImNvbmRpdGlvbiIsIm1lc3NhZ2UiLCJlbGVtZW50IiwiY29uc29sZSIsIndhcm4iLCJNQVhfVkVMT0NJVFlfREVMVEEiLCJpc0Zsb2F0IiwiaXNOYU4iLCJwYXJzZUZsb2F0IiwiY29sbGVjdE1vdGlvblZhbHVlcyIsIk1vdGlvblZhbHVlIiwiaW5pdCIsIm9wdGlvbnMiLCJ2ZXJzaW9uIiwiY2FuVHJhY2tWZWxvY2l0eSIsImV2ZW50cyIsInVwZGF0ZUFuZE5vdGlmeSIsImN1cnJlbnRUaW1lIiwidXBkYXRlZEF0Iiwic2V0UHJldkZyYW1lVmFsdWUiLCJzZXRDdXJyZW50IiwiY2hhbmdlIiwicmVuZGVyUmVxdWVzdCIsImhhc0FuaW1hdGVkIiwib3duZXIiLCJwcmV2RnJhbWVWYWx1ZSIsInByZXZVcGRhdGVkQXQiLCJvbkNoYW5nZSIsInN1YnNjcmlwdGlvbiIsImVudiIsIk5PREVfRU5WIiwib24iLCJldmVudE5hbWUiLCJ1bnN1YnNjcmliZSIsInN0b3AiLCJjbGVhckxpc3RlbmVycyIsImV2ZW50TWFuYWdlcnMiLCJhdHRhY2giLCJwYXNzaXZlRWZmZWN0Iiwic3RvcFBhc3NpdmVFZmZlY3QiLCJzZXRXaXRoVmVsb2NpdHkiLCJqdW1wIiwiZW5kQW5pbWF0aW9uIiwiZ2V0UHJldmlvdXMiLCJzdGFydEFuaW1hdGlvbiIsIlByb21pc2UiLCJyZXNvbHZlIiwiYW5pbWF0aW9uIiwiYW5pbWF0aW9uU3RhcnQiLCJ0aGVuIiwiYW5pbWF0aW9uQ29tcGxldGUiLCJjbGVhckFuaW1hdGlvbiIsImFuaW1hdGlvbkNhbmNlbCIsImlzQW5pbWF0aW5nIiwiZGVzdHJveSIsIm1vdGlvblZhbHVlIiwic2V0TW90aW9uVmFsdWUiLCJoYXNWYWx1ZSIsImdldFZhbHVlIiwiYWRkVmFsdWUiLCJzZXRUYXJnZXQiLCJyZXNvbHZlZCIsInRyYW5zaXRpb25FbmQiLCJ0cmFuc2l0aW9uIiwidGFyZ2V0IiwiaXNNb3Rpb25WYWx1ZSIsImlzV2lsbENoYW5nZU1vdGlvblZhbHVlIiwiYWRkVmFsdWVUb1dpbGxDaGFuZ2UiLCJ3aWxsQ2hhbmdlIiwiY2FtZWxUb0Rhc2giLCJzdHIiLCJyZXBsYWNlIiwidG9Mb3dlckNhc2UiLCJvcHRpbWl6ZWRBcHBlYXJEYXRhSWQiLCJvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlIiwiZ2V0T3B0aW1pc2VkQXBwZWFySWQiLCJpbnN0YW50QW5pbWF0aW9uU3RhdGUiLCJjYWxjQmV6aWVyIiwidCIsImExIiwiYTIiLCJzdWJkaXZpc2lvblByZWNpc2lvbiIsInN1YmRpdmlzaW9uTWF4SXRlcmF0aW9ucyIsImJpbmFyeVN1YmRpdmlkZSIsIngiLCJsb3dlckJvdW5kIiwidXBwZXJCb3VuZCIsIm1YMSIsIm1YMiIsImN1cnJlbnRYIiwiY3VycmVudFQiLCJhYnMiLCJjdWJpY0JlemllciIsIm1ZMSIsIm1ZMiIsImdldFRGb3JYIiwiYVgiLCJtaXJyb3JFYXNpbmciLCJlYXNpbmciLCJwIiwicmV2ZXJzZUVhc2luZyIsImJhY2tPdXQiLCJiYWNrSW4iLCJiYWNrSW5PdXQiLCJhbnRpY2lwYXRlIiwicG93IiwiY2lyY0luIiwic2luIiwiYWNvcyIsImNpcmNPdXQiLCJjaXJjSW5PdXQiLCJpc1plcm9WYWx1ZVN0cmluZyIsInRlc3QiLCJpc05vbmUiLCJjbGFtcCIsIm51bWJlciIsInBhcnNlIiwidHJhbnNmb3JtIiwiYWxwaGEiLCJzY2FsZSIsInNhbml0aXplIiwicm91bmQiLCJmbG9hdFJlZ2V4IiwiaXNOdWxsaXNoIiwic2luZ2xlQ29sb3JSZWdleCIsImlzQ29sb3JTdHJpbmciLCJ0eXBlIiwidGVzdFByb3AiLCJzdGFydHNXaXRoIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwic3BsaXRDb2xvciIsImFOYW1lIiwiYk5hbWUiLCJjTmFtZSIsIm1hdGNoIiwiY2xhbXBSZ2JVbml0IiwicmdiVW5pdCIsInJnYmEiLCJyZWQiLCJncmVlbiIsImJsdWUiLCJhbHBoYSQxIiwicGFyc2VIZXgiLCJyIiwiZyIsInN1YnN0cmluZyIsInBhcnNlSW50IiwiaGV4IiwiY3JlYXRlVW5pdFR5cGUiLCJ1bml0IiwiZW5kc1dpdGgiLCJzcGxpdCIsImRlZ3JlZXMiLCJwZXJjZW50IiwicHgiLCJ2aCIsInZ3IiwicHJvZ3Jlc3NQZXJjZW50YWdlIiwiaHNsYSIsImh1ZSIsInNhdHVyYXRpb24iLCJsaWdodG5lc3MiLCJjb2xvciIsImNvbG9yUmVnZXgiLCJfYSIsIl9iIiwiTlVNQkVSX1RPS0VOIiwiQ09MT1JfVE9LRU4iLCJWQVJfVE9LRU4iLCJWQVJfRlVOQ1RJT05fVE9LRU4iLCJTUExJVF9UT0tFTiIsImNvbXBsZXhSZWdleCIsImFuYWx5c2VDb21wbGV4VmFsdWUiLCJvcmlnaW5hbFZhbHVlIiwidG9TdHJpbmciLCJpbmRleGVzIiwidmFyIiwidHlwZXMiLCJ0b2tlbmlzZWQiLCJwYXJzZWRWYWx1ZSIsInBhcnNlQ29tcGxleFZhbHVlIiwiY3JlYXRlVHJhbnNmb3JtZXIiLCJzb3VyY2UiLCJudW1TZWN0aW9ucyIsIm91dHB1dCIsImNvbnZlcnROdW1iZXJzVG9aZXJvIiwiZ2V0QW5pbWF0YWJsZU5vbmUkMSIsInBhcnNlZCIsInRyYW5zZm9ybWVyIiwibWFwIiwiY29tcGxleCIsImdldEFuaW1hdGFibGVOb25lIiwibWF4RGVmYXVsdHMiLCJhcHBseURlZmF1bHRGaWx0ZXIiLCJuYW1lIiwic2xpY2UiLCJkZWZhdWx0VmFsdWUiLCJmdW5jdGlvblJlZ2V4IiwiZmlsdGVyIiwiZnVuY3Rpb25zIiwiam9pbiIsImJyb3dzZXJOdW1iZXJWYWx1ZVR5cGVzIiwiYm9yZGVyV2lkdGgiLCJib3JkZXJUb3BXaWR0aCIsImJvcmRlclJpZ2h0V2lkdGgiLCJib3JkZXJCb3R0b21XaWR0aCIsImJvcmRlckxlZnRXaWR0aCIsImJvcmRlclJhZGl1cyIsInJhZGl1cyIsImJvcmRlclRvcExlZnRSYWRpdXMiLCJib3JkZXJUb3BSaWdodFJhZGl1cyIsImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzIiwiYm9yZGVyQm90dG9tTGVmdFJhZGl1cyIsIndpZHRoIiwibWF4V2lkdGgiLCJoZWlnaHQiLCJtYXhIZWlnaHQiLCJ0b3AiLCJyaWdodCIsImJvdHRvbSIsImxlZnQiLCJwYWRkaW5nIiwicGFkZGluZ1RvcCIsInBhZGRpbmdSaWdodCIsInBhZGRpbmdCb3R0b20iLCJwYWRkaW5nTGVmdCIsIm1hcmdpbiIsIm1hcmdpblRvcCIsIm1hcmdpblJpZ2h0IiwibWFyZ2luQm90dG9tIiwibWFyZ2luTGVmdCIsImJhY2tncm91bmRQb3NpdGlvblgiLCJiYWNrZ3JvdW5kUG9zaXRpb25ZIiwidHJhbnNmb3JtVmFsdWVUeXBlcyIsInJvdGF0ZSIsInJvdGF0ZVgiLCJyb3RhdGVZIiwicm90YXRlWiIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInNrZXciLCJza2V3WCIsInNrZXdZIiwiZGlzdGFuY2UiLCJ0cmFuc2xhdGVYIiwidHJhbnNsYXRlWSIsInRyYW5zbGF0ZVoiLCJ5IiwieiIsInBlcnNwZWN0aXZlIiwidHJhbnNmb3JtUGVyc3BlY3RpdmUiLCJvcGFjaXR5Iiwib3JpZ2luWCIsIm9yaWdpblkiLCJvcmlnaW5aIiwiaW50IiwibnVtYmVyVmFsdWVUeXBlcyIsInpJbmRleCIsInNpemUiLCJmaWxsT3BhY2l0eSIsInN0cm9rZU9wYWNpdHkiLCJudW1PY3RhdmVzIiwiZGVmYXVsdFZhbHVlVHlwZXMiLCJiYWNrZ3JvdW5kQ29sb3IiLCJvdXRsaW5lQ29sb3IiLCJmaWxsIiwic3Ryb2tlIiwiYm9yZGVyQ29sb3IiLCJib3JkZXJUb3BDb2xvciIsImJvcmRlclJpZ2h0Q29sb3IiLCJib3JkZXJCb3R0b21Db2xvciIsImJvcmRlckxlZnRDb2xvciIsIldlYmtpdEZpbHRlciIsImdldERlZmF1bHRWYWx1ZVR5cGUiLCJkZWZhdWx0VmFsdWVUeXBlIiwiaW52YWxpZFRlbXBsYXRlcyIsIm1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSIsInVucmVzb2x2ZWRLZXlmcmFtZXMiLCJub25lS2V5ZnJhbWVJbmRleGVzIiwiYW5pbWF0YWJsZVRlbXBsYXRlIiwia2V5ZnJhbWUiLCJub25lSW5kZXgiLCJpc051bU9yUHhUeXBlIiwiZ2V0UG9zRnJvbU1hdHJpeCIsIm1hdHJpeCIsInBvcyIsImdldFRyYW5zbGF0ZUZyb21NYXRyaXgiLCJwb3MyIiwicG9zMyIsIl9iYm94IiwibWF0cml4M2QiLCJ0cmFuc2Zvcm1LZXlzIiwibm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMiLCJyZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtIiwicmVtb3ZlZFRyYW5zZm9ybXMiLCJwb3NpdGlvbmFsVmFsdWVzIiwidG9SZXNvbHZlIiwiaXNTY2hlZHVsZWQiLCJhbnlOZWVkc01lYXN1cmVtZW50IiwibWVhc3VyZUFsbEtleWZyYW1lcyIsInJlc29sdmVyc1RvTWVhc3VyZSIsImZyb20iLCJyZXNvbHZlciIsIm5lZWRzTWVhc3VyZW1lbnQiLCJlbGVtZW50c1RvTWVhc3VyZSIsInRyYW5zZm9ybXNUb1Jlc3RvcmUiLCJNYXAiLCJtZWFzdXJlSW5pdGlhbFN0YXRlIiwicmVzdG9yZSIsIm1lYXN1cmVFbmRTdGF0ZSIsInN1c3BlbmRlZFNjcm9sbFkiLCJ3aW5kb3ciLCJzY3JvbGxUbyIsImNvbXBsZXRlIiwicmVhZEFsbEtleWZyYW1lcyIsInJlYWRLZXlmcmFtZXMiLCJmbHVzaEtleWZyYW1lUmVzb2x2ZXJzIiwiS2V5ZnJhbWVSZXNvbHZlciIsIm9uQ29tcGxldGUiLCJpc0FzeW5jIiwiaXNDb21wbGV0ZSIsInNjaGVkdWxlUmVzb2x2ZSIsImN1cnJlbnRWYWx1ZSIsImZpbmFsS2V5ZnJhbWUiLCJ2YWx1ZUFzUmVhZCIsInJlYWRWYWx1ZSIsInNldEZpbmFsS2V5ZnJhbWUiLCJyZW5kZXJFbmRTdHlsZXMiLCJyZXN1bWUiLCJpc051bWVyaWNhbFN0cmluZyIsImNoZWNrU3RyaW5nU3RhcnRzV2l0aCIsInRva2VuIiwiaXNDU1NWYXJpYWJsZU5hbWUiLCJzdGFydHNBc1ZhcmlhYmxlVG9rZW4iLCJpc0NTU1ZhcmlhYmxlVG9rZW4iLCJzdGFydHNXaXRoVG9rZW4iLCJzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4IiwidHJpbSIsInNwbGl0Q1NTVmFyaWFibGVSZWdleCIsInBhcnNlQ1NTVmFyaWFibGUiLCJleGVjIiwidG9rZW4xIiwidG9rZW4yIiwiZmFsbGJhY2siLCJtYXhEZXB0aCIsImdldFZhcmlhYmxlVmFsdWUiLCJkZXB0aCIsImludmFyaWFudCIsImdldENvbXB1dGVkU3R5bGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwidHJpbW1lZCIsInRlc3RWYWx1ZVR5cGUiLCJhdXRvIiwiZGltZW5zaW9uVmFsdWVUeXBlcyIsImZpbmREaW1lbnNpb25WYWx1ZVR5cGUiLCJmaW5kIiwiRE9NS2V5ZnJhbWVzUmVzb2x2ZXIiLCJyZXNvbHZlTm9uZUtleWZyYW1lcyIsIm9yaWdpbiIsIm9yaWdpblR5cGUiLCJ0YXJnZXRUeXBlIiwicGFnZVlPZmZzZXQiLCJtZWFzdXJlZE9yaWdpbiIsIm1lYXN1cmVWaWV3cG9ydEJveCIsIm1lYXN1cmVLZXlmcmFtZSIsImZpbmFsS2V5ZnJhbWVJbmRleCIsInVuc2V0VHJhbnNmb3JtTmFtZSIsInVuc2V0VHJhbnNmb3JtVmFsdWUiLCJpc0FuaW1hdGFibGUiLCJoYXNLZXlmcmFtZXNDaGFuZ2VkIiwia2V5ZnJhbWVzIiwiY2FuQW5pbWF0ZSIsIm9yaWdpbktleWZyYW1lIiwidGFyZ2V0S2V5ZnJhbWUiLCJpc09yaWdpbkFuaW1hdGFibGUiLCJpc1RhcmdldEFuaW1hdGFibGUiLCJ3YXJuaW5nIiwiaXNHZW5lcmF0b3IiLCJpc05vdE51bGwiLCJnZXRGaW5hbEtleWZyYW1lIiwicmVwZWF0IiwicmVwZWF0VHlwZSIsInJlc29sdmVkS2V5ZnJhbWVzIiwiTUFYX1JFU09MVkVfREVMQVkiLCJCYXNlQW5pbWF0aW9uIiwiYXV0b3BsYXkiLCJkZWxheSIsInJlcGVhdERlbGF5IiwiaXNTdG9wcGVkIiwiaGFzQXR0ZW1wdGVkUmVzb2x2ZSIsImNyZWF0ZWRBdCIsInVwZGF0ZUZpbmlzaGVkUHJvbWlzZSIsImNhbGNTdGFydFRpbWUiLCJyZXNvbHZlZEF0IiwiX3Jlc29sdmVkIiwib25LZXlmcmFtZXNSZXNvbHZlZCIsIm9uVXBkYXRlIiwicmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSIsImR1cmF0aW9uIiwicmVzb2x2ZWRBbmltYXRpb24iLCJpbml0UGxheWJhY2siLCJvblBvc3RSZXNvbHZlZCIsInJlamVjdCIsImN1cnJlbnRGaW5pc2hlZFByb21pc2UiLCJmbGF0dGVuIiwiZWFzZSIsIm1peE51bWJlciQxIiwidG8iLCJwcm9ncmVzcyIsImh1ZVRvUmdiIiwicSIsImhzbGFUb1JnYmEiLCJtaXhJbW1lZGlhdGUiLCJtaXhMaW5lYXJDb2xvciIsImZyb21FeHBvIiwiZXhwbyIsInNxcnQiLCJjb2xvclR5cGVzIiwiZ2V0Q29sb3JUeXBlIiwiYXNSR0JBIiwibW9kZWwiLCJtaXhDb2xvciIsImZyb21SR0JBIiwidG9SR0JBIiwiYmxlbmRlZCIsImNvbWJpbmVGdW5jdGlvbnMiLCJwaXBlIiwidHJhbnNmb3JtZXJzIiwiaW52aXNpYmxlVmFsdWVzIiwibWl4VmlzaWJpbGl0eSIsIm1peE51bWJlciIsImdldE1peGVyJDEiLCJtaXhDb21wbGV4IiwibWl4QXJyYXkiLCJtaXhPYmplY3QiLCJudW1WYWx1ZXMiLCJibGVuZFZhbHVlIiwibWF0Y2hPcmRlciIsIm9yZGVyZWRPcmlnaW4iLCJwb2ludGVycyIsIm9yaWdpbkluZGV4Iiwib3JpZ2luVmFsdWUiLCJ0ZW1wbGF0ZSIsIm9yaWdpblN0YXRzIiwidGFyZ2V0U3RhdHMiLCJjYW5JbnRlcnBvbGF0ZSIsIm1peGVyIiwidmVsb2NpdHlTYW1wbGVEdXJhdGlvbiIsImNhbGNHZW5lcmF0b3JWZWxvY2l0eSIsInJlc29sdmVWYWx1ZSIsInByZXZUIiwic3ByaW5nRGVmYXVsdHMiLCJzdGlmZm5lc3MiLCJkYW1waW5nIiwibWFzcyIsImJvdW5jZSIsInZpc3VhbER1cmF0aW9uIiwicmVzdFNwZWVkIiwiZ3JhbnVsYXIiLCJyZXN0RGVsdGEiLCJtaW5EdXJhdGlvbiIsIm1heER1cmF0aW9uIiwibWluRGFtcGluZyIsIm1heERhbXBpbmciLCJzYWZlTWluIiwiZmluZFNwcmluZyIsImVudmVsb3BlIiwiZGVyaXZhdGl2ZSIsInNlY29uZHNUb01pbGxpc2Vjb25kcyIsImRhbXBpbmdSYXRpbyIsIm1pbGxpc2Vjb25kc1RvU2Vjb25kcyIsInVuZGFtcGVkRnJlcSIsImV4cG9uZW50aWFsRGVjYXkiLCJjYWxjQW5ndWxhckZyZXEiLCJleHAiLCJmIiwiZmFjdG9yIiwiaW5pdGlhbEd1ZXNzIiwiYXBwcm94aW1hdGVSb290Iiwicm9vdEl0ZXJhdGlvbnMiLCJyZXN1bHQiLCJkdXJhdGlvbktleXMiLCJwaHlzaWNzS2V5cyIsImlzU3ByaW5nVHlwZSIsInNvbWUiLCJnZXRTcHJpbmdPcHRpb25zIiwic3ByaW5nT3B0aW9ucyIsImlzUmVzb2x2ZWRGcm9tRHVyYXRpb24iLCJyb290IiwiUEkiLCJkZXJpdmVkIiwic3ByaW5nIiwib3B0aW9uc09yVmlzdWFsRHVyYXRpb24iLCJkb25lIiwiaW5pdGlhbFZlbG9jaXR5IiwiaW5pdGlhbERlbHRhIiwidW5kYW1wZWRBbmd1bGFyRnJlcSIsImlzR3JhbnVsYXJTY2FsZSIsInJlc29sdmVTcHJpbmciLCJhbmd1bGFyRnJlcSIsImNvcyIsImRhbXBlZEFuZ3VsYXJGcmVxIiwiZnJlcUZvclQiLCJzaW5oIiwiY29zaCIsImdlbmVyYXRvciIsImNhbGN1bGF0ZWREdXJhdGlvbiIsImN1cnJlbnRWZWxvY2l0eSIsImlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCIsImlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQiLCJjYWxjR2VuZXJhdG9yRHVyYXRpb24iLCJtYXhHZW5lcmF0b3JEdXJhdGlvbiIsImdlbmVyYXRlTGluZWFyRWFzaW5nIiwiaW5lcnRpYSIsInBvd2VyIiwidGltZUNvbnN0YW50IiwiYm91bmNlRGFtcGluZyIsImJvdW5jZVN0aWZmbmVzcyIsIm1vZGlmeVRhcmdldCIsImlzT3V0T2ZCb3VuZHMiLCJuZWFyZXN0Qm91bmRhcnkiLCJhbXBsaXR1ZGUiLCJpZGVhbCIsImNhbGNEZWx0YSIsImNhbGNMYXRlc3QiLCJhcHBseUZyaWN0aW9uIiwibGF0ZXN0IiwidGltZVJlYWNoZWRCb3VuZGFyeSIsInNwcmluZyQxIiwiY2hlY2tDYXRjaEJvdW5kYXJ5IiwiaGFzVXBkYXRlZEZyYW1lIiwiZWFzZUluIiwiZWFzZU91dCIsImVhc2VJbk91dCIsImlzRWFzaW5nQXJyYXkiLCJlYXNpbmdMb29rdXAiLCJsaW5lYXIiLCJlYXNpbmdEZWZpbml0aW9uVG9GdW5jdGlvbiIsImlzQmV6aWVyRGVmaW5pdGlvbiIsIngxIiwieTEiLCJ4MiIsInkyIiwiY3JlYXRlTWl4ZXJzIiwiY3VzdG9tTWl4ZXIiLCJtaXhlcnMiLCJtaXhlckZhY3RvcnkiLCJudW1NaXhlcnMiLCJlYXNpbmdGdW5jdGlvbiIsImludGVycG9sYXRlIiwiaW5wdXQiLCJpc0NsYW1wIiwiaW5wdXRMZW5ndGgiLCJpc1plcm9EZWx0YVJhbmdlIiwicmV2ZXJzZSIsImludGVycG9sYXRvciIsInByb2dyZXNzSW5SYW5nZSIsImZpbGxPZmZzZXQiLCJvZmZzZXQiLCJyZW1haW5pbmciLCJvZmZzZXRQcm9ncmVzcyIsImRlZmF1bHRPZmZzZXQkMSIsImNvbnZlcnRPZmZzZXRUb1RpbWVzIiwibyIsImRlZmF1bHRFYXNpbmckMSIsImtleWZyYW1lVmFsdWVzIiwidGltZXMiLCJlYXNpbmdGdW5jdGlvbnMiLCJhYnNvbHV0ZVRpbWVzIiwibWFwVGltZVRvS2V5ZnJhbWUiLCJmcmFtZWxvb3BEcml2ZXIiLCJwYXNzVGltZXN0YW1wIiwiZ2VuZXJhdG9ycyIsImRlY2F5IiwidHdlZW4iLCJwZXJjZW50VG9Qcm9ncmVzcyIsIk1haW5UaHJlYWRBbmltYXRpb24iLCJob2xkVGltZSIsImNhbmNlbFRpbWUiLCJwbGF5YmFja1NwZWVkIiwicGVuZGluZ1BsYXlTdGF0ZSIsInN0YXJ0VGltZSIsInRlYXJkb3duIiwib25TdG9wIiwiS2V5ZnJhbWVSZXNvbHZlciQxIiwib25SZXNvbHZlZCIsImFzc2lnbiIsImtleWZyYW1lcyQxIiwiZ2VuZXJhdG9yRmFjdG9yeSIsIm1hcFBlcmNlbnRUb0tleWZyYW1lcyIsIm1pcnJvcmVkR2VuZXJhdG9yIiwicmVzb2x2ZWREdXJhdGlvbiIsInRvdGFsRHVyYXRpb24iLCJwbGF5IiwicGF1c2UiLCJ0aWNrIiwic2FtcGxlIiwic3BlZWQiLCJ0aW1lV2l0aG91dERlbGF5IiwiaXNJbkRlbGF5UGhhc2UiLCJlbGFwc2VkIiwiZnJhbWVHZW5lcmF0b3IiLCJjdXJyZW50SXRlcmF0aW9uIiwiZmxvb3IiLCJpdGVyYXRpb25Qcm9ncmVzcyIsImlzT2RkSXRlcmF0aW9uIiwiaXNBbmltYXRpb25GaW5pc2hlZCIsImZpbmlzaCIsImRyaXZlciIsIm5ld1NwZWVkIiwiaGFzQ2hhbmdlZCIsIm9uUGxheSIsInN0b3BEcml2ZXIiLCJhbmltYXRlVmFsdWUiLCJhY2NlbGVyYXRlZFZhbHVlcyIsInN0YXJ0V2FhcGlBbmltYXRpb24iLCJ2YWx1ZU5hbWUiLCJrZXlmcmFtZU9wdGlvbnMiLCJtYXBFYXNpbmdUb05hdGl2ZUVhc2luZyIsImFuaW1hdGUiLCJpdGVyYXRpb25zIiwiZGlyZWN0aW9uIiwic3VwcG9ydHNXYWFwaSIsIm1lbW8iLCJFbGVtZW50Iiwic2FtcGxlRGVsdGEiLCJyZXF1aXJlc1ByZWdlbmVyYXRlZEtleWZyYW1lcyIsImlzV2FhcGlTdXBwb3J0ZWRFYXNpbmciLCJwcmVnZW5lcmF0ZUtleWZyYW1lcyIsInNhbXBsZUFuaW1hdGlvbiIsInByZWdlbmVyYXRlZEtleWZyYW1lcyIsInVuc3VwcG9ydGVkRWFzaW5nRnVuY3Rpb25zIiwiaXNVbnN1cHBvcnRlZEVhc2UiLCJBY2NlbGVyYXRlZEFuaW1hdGlvbiIsInN1cHBvcnRzTGluZWFyRWFzaW5nIiwicHJlZ2VuZXJhdGVkQW5pbWF0aW9uIiwicGVuZGluZ1RpbWVsaW5lIiwiYXR0YWNoVGltZWxpbmUiLCJvbmZpbmlzaCIsInBsYXliYWNrUmF0ZSIsInBsYXlTdGF0ZSIsInRpbWVsaW5lIiwic2FtcGxlVGltZSIsInN1cHBvcnRzIiwiSFRNTEVsZW1lbnQiLCJ0cmFuc2Zvcm1UZW1wbGF0ZSIsInVuZGVyRGFtcGVkU3ByaW5nIiwiY3JpdGljYWxseURhbXBlZFNwcmluZyIsImtleWZyYW1lc1RyYW5zaXRpb24iLCJnZXREZWZhdWx0VHJhbnNpdGlvbiIsInZhbHVlS2V5IiwiaXNUcmFuc2l0aW9uRGVmaW5lZCIsIndoZW4iLCJfZGVsYXkiLCJkZWxheUNoaWxkcmVuIiwic3RhZ2dlckNoaWxkcmVuIiwic3RhZ2dlckRpcmVjdGlvbiIsImFuaW1hdGVNb3Rpb25WYWx1ZSIsImlzSGFuZG9mZiIsInZhbHVlVHJhbnNpdGlvbiIsImdldFZhbHVlVHJhbnNpdGlvbiIsInNob3VsZFNraXAiLCJHcm91cFBsYXliYWNrQ29udHJvbHMiLCJzaG91bGRCbG9ja0FuaW1hdGlvbiIsInByb3RlY3RlZEtleXMiLCJuZWVkc0FuaW1hdGluZyIsInNob3VsZEJsb2NrIiwiYW5pbWF0ZVRhcmdldCIsInRhcmdldEFuZFRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uT3ZlcnJpZGUiLCJhbmltYXRpb25zIiwiYW5pbWF0aW9uVHlwZVN0YXRlIiwiYW5pbWF0aW9uU3RhdGUiLCJnZXRTdGF0ZSIsImxhdGVzdFZhbHVlcyIsInZhbHVlVGFyZ2V0IiwiTW90aW9uSGFuZG9mZkFuaW1hdGlvbiIsImFwcGVhcklkIiwic2hvdWxkUmVkdWNlTW90aW9uIiwiYWxsIiwiYW5pbWF0ZVZhcmlhbnQiLCJ2YXJpYW50IiwicHJlc2VuY2VDb250ZXh0IiwiZ2V0QW5pbWF0aW9uIiwiZ2V0Q2hpbGRBbmltYXRpb25zIiwidmFyaWFudENoaWxkcmVuIiwiZm9yd2FyZERlbGF5IiwiYW5pbWF0ZUNoaWxkcmVuIiwiZmlyc3QiLCJsYXN0IiwibWF4U3RhZ2dlckR1cmF0aW9uIiwiZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24iLCJzb3J0Iiwic29ydEJ5VHJlZU9yZGVyIiwiY2hpbGQiLCJzb3J0Tm9kZVBvc2l0aW9uIiwiYW5pbWF0ZVZpc3VhbEVsZW1lbnQiLCJyZXNvbHZlZERlZmluaXRpb24iLCJudW1WYXJpYW50UHJvcHMiLCJnZXRWYXJpYW50Q29udGV4dCIsImlzQ29udHJvbGxpbmdWYXJpYW50cyIsImNvbnRleHQiLCJwYXJlbnQiLCJpbml0aWFsIiwicHJvcCIsInJldmVyc2VQcmlvcml0eU9yZGVyIiwibnVtQW5pbWF0aW9uVHlwZXMiLCJhbmltYXRlTGlzdCIsImNyZWF0ZUFuaW1hdGlvblN0YXRlIiwiY3JlYXRlU3RhdGUiLCJpc0luaXRpYWxSZW5kZXIiLCJidWlsZFJlc29sdmVkVHlwZVZhbHVlcyIsInNldEFuaW1hdGVGdW5jdGlvbiIsIm1ha2VBbmltYXRvciIsImFuaW1hdGVDaGFuZ2VzIiwiY2hhbmdlZEFjdGl2ZVR5cGUiLCJyZW1vdmVkS2V5cyIsImVuY291bnRlcmVkS2V5cyIsInJlbW92ZWRWYXJpYW50SW5kZXgiLCJJbmZpbml0eSIsInR5cGVTdGF0ZSIsInByb3BJc1ZhcmlhbnQiLCJhY3RpdmVEZWx0YSIsImlzQWN0aXZlIiwiaXNJbmhlcml0ZWQiLCJtYW51YWxseUFuaW1hdGVPbk1vdW50IiwicHJldlByb3AiLCJ2YXJpYW50RGlkQ2hhbmdlIiwiY2hlY2tWYXJpYW50c0RpZENoYW5nZSIsInNob3VsZEFuaW1hdGVUeXBlIiwiaGFuZGxlZFJlbW92ZWRWYWx1ZXMiLCJkZWZpbml0aW9uTGlzdCIsInJlc29sdmVkVmFsdWVzIiwicHJldlJlc29sdmVkVmFsdWVzIiwiYWxsS2V5cyIsIm1hcmtUb0FuaW1hdGUiLCJsaXZlU3R5bGUiLCJ2YWx1ZUhhc0NoYW5nZWQiLCJibG9ja0luaXRpYWxBbmltYXRpb24iLCJ3aWxsQW5pbWF0ZVZpYVBhcmVudCIsImZhbGxiYWNrQW5pbWF0aW9uIiwiZmFsbGJhY2tUYXJnZXQiLCJnZXRCYXNlVGFyZ2V0Iiwic2hvdWxkQW5pbWF0ZSIsInNldEFjdGl2ZSIsInJlc2V0IiwiY3JlYXRlVHlwZVN0YXRlIiwid2hpbGVJblZpZXciLCJ3aGlsZUhvdmVyIiwid2hpbGVUYXAiLCJ3aGlsZURyYWciLCJ3aGlsZUZvY3VzIiwiZXhpdCIsIkZlYXR1cmUiLCJub2RlIiwiaXNNb3VudGVkIiwiQW5pbWF0aW9uRmVhdHVyZSIsInVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uIiwidW5tb3VudENvbnRyb2xzIiwic3Vic2NyaWJlIiwibW91bnQiLCJwcmV2QW5pbWF0ZSIsInByZXZQcm9wcyIsInVubW91bnQiLCJpZCQyIiwiRXhpdEFuaW1hdGlvbkZlYXR1cmUiLCJhcmd1bWVudHMiLCJpZCIsImlzUHJlc2VudCIsIm9uRXhpdENvbXBsZXRlIiwicHJldklzUHJlc2VudCIsInByZXZQcmVzZW5jZUNvbnRleHQiLCJleGl0QW5pbWF0aW9uIiwicmVnaXN0ZXIiLCJNb3Rpb25Db250ZXh0IiwiY3JlYXRlQXhpc0RlbHRhIiwidHJhbnNsYXRlIiwib3JpZ2luUG9pbnQiLCJjcmVhdGVEZWx0YSIsImNyZWF0ZUF4aXMiLCJjcmVhdGVCb3giLCJTQ0FMRV9QUkVDSVNJT04iLCJTQ0FMRV9NSU4iLCJTQ0FMRV9NQVgiLCJUUkFOU0xBVEVfUFJFQ0lTSU9OIiwiVFJBTlNMQVRFX01JTiIsIlRSQU5TTEFURV9NQVgiLCJjYWxjTGVuZ3RoIiwiYXhpcyIsImlzTmVhciIsIm1heERpc3RhbmNlIiwiY2FsY0F4aXNEZWx0YSIsImNhbGNCb3hEZWx0YSIsImNhbGNSZWxhdGl2ZUF4aXMiLCJyZWxhdGl2ZSIsImNhbGNSZWxhdGl2ZUJveCIsImNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbiIsImxheW91dCIsImNhbGNSZWxhdGl2ZVBvc2l0aW9uIiwidmFsaWRNb3Rpb25Qcm9wcyIsImlzVmFsaWRNb3Rpb25Qcm9wIiwic2hvdWxkRm9yd2FyZCIsImxvYWRFeHRlcm5hbElzVmFsaWRQcm9wIiwiaXNWYWxpZFByb3AiLCJmaWx0ZXJQcm9wcyIsImlzRG9tIiwiZm9yd2FyZE1vdGlvblByb3BzIiwiZmlsdGVyZWRQcm9wcyIsIlByZXNlbmNlQ29udGV4dCIsImlzVmFyaWFudE5vZGUiLCJ1c2VDb25zdGFudCIsInJlZiIsInVzZVJlZiIsInJlc29sdmVNb3Rpb25WYWx1ZSIsInVud3JhcHBlZFZhbHVlIiwibWFrZVN0YXRlIiwic2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzIiwiY3JlYXRlUmVuZGVyU3RhdGUiLCJtYWtlTGF0ZXN0VmFsdWVzIiwicmVuZGVyU3RhdGUiLCJvbk1vdW50IiwiaW5zdGFuY2UiLCJtYWtlVXNlVmlzdWFsU3RhdGUiLCJjb25maWciLCJpc1N0YXRpYyIsInVzZUNvbnRleHQiLCJtYWtlIiwic2NyYXBlTW90aW9uVmFsdWVzIiwibW90aW9uVmFsdWVzIiwiaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEiLCJpc1ZhcmlhbnROb2RlJDEiLCJpbmhlcml0IiwiaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCIsInZhcmlhbnRUb1NldCIsImxpc3QiLCJhZGREb21FdmVudCIsInBhc3NpdmUiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV4dHJhY3RFdmVudEluZm8iLCJldmVudCIsInBvaW50IiwicGFnZVgiLCJwYWdlWSIsImFkZFBvaW50ZXJJbmZvIiwiaXNQcmltYXJ5UG9pbnRlciIsImFkZFBvaW50ZXJFdmVudCIsImlzQnJvd3NlciIsInVzZVVubW91bnRFZmZlY3QiLCJ1c2VFZmZlY3QiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlSXNNb3VudGVkIiwidXNlRm9yY2VVcGRhdGUiLCJmb3JjZWRSZW5kZXJDb3VudCIsInNldEZvcmNlZFJlbmRlckNvdW50IiwidXNlU3RhdGUiLCJmb3JjZVJlbmRlciIsInVzZUNhbGxiYWNrIiwiZGVmZXJyZWRGb3JjZVJlbmRlciIsIk1vdGlvbkNvbmZpZ0NvbnRleHQiLCJ0cmFuc2Zvcm1QYWdlUG9pbnQiLCJyZWR1Y2VkTW90aW9uIiwiUG9wQ2hpbGRNZWFzdXJlIiwiQ29tcG9uZW50IiwiZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUiLCJjaGlsZFJlZiIsInNpemVSZWYiLCJvZmZzZXRIZWlnaHQiLCJvZmZzZXRXaWR0aCIsIm9mZnNldFRvcCIsIm9mZnNldExlZnQiLCJjb21wb25lbnREaWRVcGRhdGUiLCJjaGlsZHJlbiIsIlBvcENoaWxkIiwidXNlSWQiLCJub25jZSIsInVzZUluc2VydGlvbkVmZmVjdCIsImRhdGFzZXQiLCJtb3Rpb25Qb3BJZCIsInN0eWxlIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiaGVhZCIsImFwcGVuZENoaWxkIiwic2hlZXQiLCJpbnNlcnRSdWxlIiwicmVtb3ZlQ2hpbGQiLCJqc3giLCJjbG9uZUVsZW1lbnQiLCJQcmVzZW5jZUNoaWxkIiwicHJlc2VuY2VBZmZlY3RzTGF5b3V0IiwibW9kZSIsInByZXNlbmNlQ2hpbGRyZW4iLCJuZXdDaGlsZHJlbk1hcCIsIm1lbW9pemVkT25FeGl0Q29tcGxldGUiLCJjaGlsZElkIiwidXNlTWVtbyIsInJhbmRvbSIsIl8iLCJQcm92aWRlciIsInVzZVByZXNlbmNlIiwic2FmZVRvUmVtb3ZlIiwidXNlSXNQcmVzZW50IiwiZ2V0Q2hpbGRLZXkiLCJvbmx5RWxlbWVudHMiLCJmaWx0ZXJlZCIsIkNoaWxkcmVuIiwiaXNWYWxpZEVsZW1lbnQiLCJBbmltYXRlUHJlc2VuY2UiLCJwcm9wYWdhdGUiLCJpc1BhcmVudFByZXNlbnQiLCJwcmVzZW50Q2hpbGRyZW4iLCJwcmVzZW50S2V5cyIsInBlbmRpbmdQcmVzZW50Q2hpbGRyZW4iLCJleGl0Q29tcGxldGUiLCJkaWZmZWRDaGlsZHJlbiIsInNldERpZmZlZENoaWxkcmVuIiwicmVuZGVyZWRDaGlsZHJlbiIsInNldFJlbmRlcmVkQ2hpbGRyZW4iLCJpbmNsdWRlcyIsImV4aXRpbmdDaGlsZHJlbiIsIm5leHRDaGlsZHJlbiIsIkZyYWdtZW50Iiwib25FeGl0IiwiaXNFdmVyeUV4aXRDb21wbGV0ZSIsImlzRXhpdENvbXBsZXRlIiwiRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsImFuaW1hdGVTaW5nbGVWYWx1ZSIsIm1vdGlvblZhbHVlJDEiLCJ3cmFwIiwicmFuZ2VTaXplIiwiZ2V0RWFzaW5nRm9yU2VnbWVudCIsImlzRE9NS2V5ZnJhbWVzIiwicmVzb2x2ZVN1YmplY3RzIiwic3ViamVjdCIsInNjb3BlIiwic2VsZWN0b3JDYWNoZSIsInJlc29sdmVFbGVtZW50cyIsIk5vZGVMaXN0IiwiY2FsY3VsYXRlUmVwZWF0RHVyYXRpb24iLCJfcmVwZWF0RGVsYXkiLCJjYWxjTmV4dFRpbWUiLCJsYWJlbHMiLCJlcmFzZUtleWZyYW1lcyIsInNlcXVlbmNlIiwiZW5kVGltZSIsImF0IiwiYWRkS2V5ZnJhbWVzIiwibm9ybWFsaXplVGltZXMiLCJjb21wYXJlQnlUaW1lIiwiZGVmYXVsdFNlZ21lbnRFYXNpbmciLCJNQVhfUkVQRUFUIiwiY3JlYXRlQW5pbWF0aW9uc0Zyb21TZXF1ZW5jZSIsImRlZmF1bHRUcmFuc2l0aW9uIiwic2VxdWVuY2VUcmFuc2l0aW9uIiwiZGVmYXVsdER1cmF0aW9uIiwiYW5pbWF0aW9uRGVmaW5pdGlvbnMiLCJzZXF1ZW5jZXMiLCJlbGVtZW50Q2FjaGUiLCJ0aW1lTGFiZWxzIiwicHJldlRpbWUiLCJzZWdtZW50IiwicmVzb2x2ZVZhbHVlU2VxdWVuY2UiLCJ2YWx1ZUtleWZyYW1lcyIsInZhbHVlU2VxdWVuY2UiLCJlbGVtZW50SW5kZXgiLCJudW1TdWJqZWN0cyIsInZhbHVlS2V5ZnJhbWVzQXNMaXN0Iiwia2V5ZnJhbWVzQXNMaXN0IiwicmVtYWluaW5nVHJhbnNpdGlvbiIsImNhbGN1bGF0ZWREZWxheSIsIm51bUtleWZyYW1lcyIsImNyZWF0ZUdlbmVyYXRvciIsImFic29sdXRlRGVsdGEiLCJpc051bWJlcktleWZyYW1lc0FycmF5Iiwic3ByaW5nVHJhbnNpdGlvbiIsInNwcmluZ0Vhc2luZyIsImNyZWF0ZUdlbmVyYXRvckVhc2luZyIsInJlbWFpbmRlciIsInVuc2hpZnQiLCJvcmlnaW5hbEtleWZyYW1lcyIsIm9yaWdpbmFsVGltZXMiLCJvcmlnaW5hbEVhc2UiLCJyZXBlYXRJbmRleCIsImtleWZyYW1lSW5kZXgiLCJ0YXJnZXRUaW1lIiwic3ViamVjdFNlcXVlbmNlIiwiZ2V0U3ViamVjdFNlcXVlbmNlIiwiZ2V0VmFsdWVTZXF1ZW5jZSIsInN1YmplY3RzIiwic3ViamVjdEluZGV4IiwidGhpc1N1YmplY3QiLCJ2YWx1ZVNlcXVlbmNlcyIsInZhbHVlT2Zmc2V0IiwidmFsdWVFYXNpbmciLCJpc051bWJlciIsImV2ZXJ5IiwidmlzdWFsRWxlbWVudFN0b3JlIiwiV2Vha01hcCIsImlzU1ZHRWxlbWVudCIsIlNWR0VsZW1lbnQiLCJ0YWdOYW1lIiwiZmVhdHVyZVByb3BzIiwiZHJhZyIsImZvY3VzIiwiaG92ZXIiLCJ0YXAiLCJwYW4iLCJpblZpZXciLCJmZWF0dXJlRGVmaW5pdGlvbnMiLCJpc0VuYWJsZWQiLCJwcmVmZXJzUmVkdWNlZE1vdGlvbiIsImhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lciIsImluaXRQcmVmZXJzUmVkdWNlZE1vdGlvbiIsIm1hdGNoTWVkaWEiLCJtb3Rpb25NZWRpYVF1ZXJ5Iiwic2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzIiwibWF0Y2hlcyIsImFkZExpc3RlbmVyIiwidmFsdWVUeXBlcyIsImZpbmRWYWx1ZVR5cGUiLCJ1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMiLCJuZXh0VmFsdWUiLCJwcmV2VmFsdWUiLCJleGlzdGluZ1ZhbHVlIiwibGF0ZXN0VmFsdWUiLCJnZXRTdGF0aWNWYWx1ZSIsInJlbW92ZVZhbHVlIiwicHJvcEV2ZW50SGFuZGxlcnMiLCJWaXN1YWxFbGVtZW50IiwiX3Byb3BzIiwiX3ByZXZQcm9wcyIsIl92aXN1YWxFbGVtZW50IiwicmVkdWNlZE1vdGlvbkNvbmZpZyIsInZpc3VhbFN0YXRlIiwiZmVhdHVyZXMiLCJ2YWx1ZVN1YnNjcmlwdGlvbnMiLCJwcmV2TW90aW9uVmFsdWVzIiwicHJvcEV2ZW50U3Vic2NyaXB0aW9ucyIsIm5vdGlmeVVwZGF0ZSIsInRyaWdnZXJCdWlsZCIsInJlbmRlckluc3RhbmNlIiwicHJvamVjdGlvbiIsInJlbmRlclNjaGVkdWxlZEF0Iiwic2NoZWR1bGVSZW5kZXIiLCJiYXNlVGFyZ2V0IiwiaW5pdGlhbFZhbHVlcyIsImluaXRpYWxNb3Rpb25WYWx1ZXMiLCJyZW1vdmVGcm9tVmFyaWFudFRyZWUiLCJhZGRWYXJpYW50Q2hpbGQiLCJiaW5kVG9Nb3Rpb25WYWx1ZSIsInJlbW92ZSIsImZlYXR1cmUiLCJ2YWx1ZUlzVHJhbnNmb3JtIiwicmVtb3ZlT25DaGFuZ2UiLCJpc1RyYW5zZm9ybURpcnR5IiwicmVtb3ZlT25SZW5kZXJSZXF1ZXN0IiwicmVtb3ZlU3luY0NoZWNrIiwiTW90aW9uQ2hlY2tBcHBlYXJTeW5jIiwib3RoZXIiLCJzb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24iLCJ1cGRhdGVGZWF0dXJlcyIsImZlYXR1cmVEZWZpbml0aW9uIiwiRmVhdHVyZUNvbnN0cnVjdG9yIiwiYnVpbGQiLCJtZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCIsInNldFN0YXRpY1ZhbHVlIiwibGlzdGVuZXJOYW1lIiwibGlzdGVuZXIiLCJoYW5kbGVDaGlsZE1vdGlvblZhbHVlIiwiZ2V0VmFyaWFudCIsImdldFRyYW5zZm9ybVBhZ2VQb2ludCIsImdldENsb3Nlc3RWYXJpYW50Tm9kZSIsImNsb3Nlc3RWYXJpYW50Tm9kZSIsInJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlIiwiZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyIsInJlYWRWYWx1ZUZyb21JbnN0YW5jZSIsInNldEJhc2VUYXJnZXQiLCJ2YWx1ZUZyb21Jbml0aWFsIiwiYXJncyIsIkRPTVZpc3VhbEVsZW1lbnQiLCJjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiIsInZhcnMiLCJjaGlsZFN1YnNjcmlwdGlvbiIsInRleHRDb250ZW50IiwiZ2V0VmFsdWVBc1R5cGUiLCJ0cmFuc2xhdGVBbGlhcyIsIm51bVRyYW5zZm9ybXMiLCJidWlsZFRyYW5zZm9ybSIsInRyYW5zZm9ybVN0cmluZyIsInRyYW5zZm9ybUlzRGVmYXVsdCIsInZhbHVlSXNEZWZhdWx0IiwidmFsdWVBc1R5cGUiLCJ0cmFuc2Zvcm1OYW1lIiwiYnVpbGRIVE1MU3R5bGVzIiwidHJhbnNmb3JtT3JpZ2luIiwiaGFzVHJhbnNmb3JtIiwiaGFzVHJhbnNmb3JtT3JpZ2luIiwiZGFzaEtleXMiLCJhcnJheSIsImNhbWVsS2V5cyIsImJ1aWxkU1ZHUGF0aCIsImF0dHJzIiwic3BhY2luZyIsInVzZURhc2hDYXNlIiwicGF0aExlbmd0aCIsInBhdGhTcGFjaW5nIiwiY2FsY09yaWdpbiQxIiwiY2FsY1NWR1RyYW5zZm9ybU9yaWdpbiIsImRpbWVuc2lvbnMiLCJweE9yaWdpblgiLCJweE9yaWdpblkiLCJidWlsZFNWR0F0dHJzIiwiYXR0clgiLCJhdHRyWSIsImF0dHJTY2FsZSIsInBhdGhPZmZzZXQiLCJpc1NWR1RhZyIsInZpZXdCb3giLCJjYW1lbENhc2VBdHRyaWJ1dGVzIiwidGFnIiwicmVuZGVySFRNTCIsInN0eWxlUHJvcCIsImdldFByb2plY3Rpb25TdHlsZXMiLCJzZXRQcm9wZXJ0eSIsInJlbmRlclNWRyIsIl9zdHlsZVByb3AiLCJzZXRBdHRyaWJ1dGUiLCJzY2FsZUNvcnJlY3RvcnMiLCJhZGRTY2FsZUNvcnJlY3RvciIsImNvcnJlY3RvcnMiLCJpc0ZvcmNlZE1vdGlvblZhbHVlIiwibGF5b3V0SWQiLCJzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMSIsIm5ld1ZhbHVlcyIsInRhcmdldEtleSIsImNoYXJBdCIsInRvVXBwZXJDYXNlIiwiU1ZHVmlzdWFsRWxlbWVudCIsImRlZmF1bHRUeXBlIiwiZ2V0QXR0cmlidXRlIiwiY29udmVydEJvdW5kaW5nQm94VG9Cb3giLCJjb252ZXJ0Qm94VG9Cb3VuZGluZ0JveCIsInRyYW5zZm9ybUJveFBvaW50cyIsInRyYW5zZm9ybVBvaW50IiwidG9wTGVmdCIsImJvdHRvbVJpZ2h0IiwiaXNJZGVudGl0eVNjYWxlIiwiaGFzU2NhbGUiLCJoYXMyRFRyYW5zbGF0ZSIsImlzMkRUcmFuc2xhdGUiLCJzY2FsZVBvaW50IiwiZGlzdGFuY2VGcm9tT3JpZ2luIiwic2NhbGVkIiwiYXBwbHlQb2ludERlbHRhIiwiYm94U2NhbGUiLCJhcHBseUF4aXNEZWx0YSIsImFwcGx5Qm94RGVsdGEiLCJib3giLCJUUkVFX1NDQUxFX1NOQVBfTUlOIiwiVFJFRV9TQ0FMRV9TTkFQX01BWCIsImFwcGx5VHJlZURlbHRhcyIsInRyZWVTY2FsZSIsInRyZWVQYXRoIiwiaXNTaGFyZWRUcmFuc2l0aW9uIiwidHJlZUxlbmd0aCIsInByb2plY3Rpb25EZWx0YSIsImRpc3BsYXkiLCJsYXlvdXRTY3JvbGwiLCJzY3JvbGwiLCJ0cmFuc2Zvcm1Cb3giLCJ0cmFuc2xhdGVBeGlzIiwidHJhbnNmb3JtQXhpcyIsImF4aXNUcmFuc2xhdGUiLCJheGlzU2NhbGUiLCJheGlzT3JpZ2luIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwibWVhc3VyZVBhZ2VCb3giLCJyb290UHJvamVjdGlvbk5vZGUiLCJ2aWV3cG9ydEJveCIsImdldENvbXB1dGVkU3R5bGUkMSIsIkhUTUxWaXN1YWxFbGVtZW50IiwiY29tcHV0ZWRTdHlsZSIsImlzT2JqZWN0S2V5Iiwib2JqZWN0IiwiT2JqZWN0VmlzdWFsRWxlbWVudCIsImNyZWF0ZURPTVZpc3VhbEVsZW1lbnQiLCJjcmVhdGVPYmplY3RWaXN1YWxFbGVtZW50IiwiaXNTaW5nbGVWYWx1ZSIsImFuaW1hdGVTdWJqZWN0IiwiY3JlYXRlVmlzdWFsRWxlbWVudCIsImFuaW1hdGVTZXF1ZW5jZSIsImlzU2VxdWVuY2UiLCJjcmVhdGVTY29wZWRBbmltYXRlIiwic2NvcGVkQW5pbWF0ZSIsInN1YmplY3RPclNlcXVlbmNlIiwib3B0aW9uc09yS2V5ZnJhbWVzIiwic2V0Q1NTVmFyIiwic2V0U3R5bGUiLCJzdXBwb3J0c1BhcnRpYWxLZXlmcmFtZXMiLCJoeWRyYXRlS2V5ZnJhbWVzIiwiZGVmYXVsdEVhc2luZyIsImdldEVsZW1lbnRBbmltYXRpb25TdGF0ZSIsIk5hdGl2ZUFuaW1hdGlvbiIsIk5hdGl2ZUFuaW1hdGlvbkNvbnRyb2xzIiwiaXNDU1NWYXIiLCJleGlzdGluZ0FuaW1hdGlvbiIsInJlYWRJbml0aWFsS2V5ZnJhbWUiLCJnZW5lcmF0b3JPcHRpb25zIiwib25GaW5pc2giLCJzZXRWYWx1ZSIsInJlbW92ZUFuaW1hdGlvbiIsImVsZW1lbnRTdGF0ZSIsImFuaW1hdGVFbGVtZW50cyIsImVsZW1lbnRPclNlbGVjdG9yIiwiZWxlbWVudHMiLCJudW1FbGVtZW50cyIsImVsZW1lbnRUcmFuc2l0aW9uIiwidmFsdWVPcHRpb25zIiwiY3JlYXRlU2NvcGVkV2FhcGlBbmltYXRlIiwiYW5pbWF0ZU1pbmkiLCJvYnNlcnZlVGltZWxpbmUiLCJwcmV2UHJvZ3Jlc3MiLCJvbkZyYW1lIiwicGVyY2VudGFnZSIsInJlc2l6ZUhhbmRsZXJzIiwib2JzZXJ2ZXIiLCJnZXRFbGVtZW50U2l6ZSIsImJvcmRlckJveFNpemUiLCJpbmxpbmVTaXplIiwiYmxvY2tTaXplIiwiZ2V0QkJveCIsIm5vdGlmeVRhcmdldCIsImNvbnRlbnRSZWN0IiwiY29udGVudFNpemUiLCJub3RpZnlBbGwiLCJlbnRyaWVzIiwiY3JlYXRlUmVzaXplT2JzZXJ2ZXIiLCJSZXNpemVPYnNlcnZlciIsInJlc2l6ZUVsZW1lbnQiLCJlbGVtZW50SGFuZGxlcnMiLCJvYnNlcnZlIiwidW5vYnNlcnZlIiwid2luZG93Q2FsbGJhY2tzIiwid2luZG93UmVzaXplSGFuZGxlciIsImNyZWF0ZVdpbmRvd1Jlc2l6ZUhhbmRsZXIiLCJpbm5lcldpZHRoIiwiaW5uZXJIZWlnaHQiLCJpbmZvIiwicmVzaXplV2luZG93IiwicmVzaXplIiwibWF4RWxhcHNlZCIsImNyZWF0ZUF4aXNJbmZvIiwic2Nyb2xsTGVuZ3RoIiwidGFyZ2V0T2Zmc2V0IiwidGFyZ2V0TGVuZ3RoIiwiY29udGFpbmVyTGVuZ3RoIiwiY3JlYXRlU2Nyb2xsSW5mbyIsInBvc2l0aW9uIiwidXBkYXRlQXhpc0luZm8iLCJheGlzTmFtZSIsInVwZGF0ZVNjcm9sbEluZm8iLCJjYWxjSW5zZXQiLCJjb250YWluZXIiLCJpbnNldCIsIm9mZnNldFBhcmVudCIsInN2Z0JvdW5kaW5nQm94IiwicGFyZW50RWxlbWVudCIsInBhcmVudEJvdW5kaW5nQm94IiwiU1ZHR3JhcGhpY3NFbGVtZW50Iiwic3ZnIiwicGFyZW50Tm9kZSIsIm5hbWVkRWRnZXMiLCJjZW50ZXIiLCJlbmQiLCJyZXNvbHZlRWRnZSIsImVkZ2UiLCJhc051bWJlciIsImRvY3VtZW50RWxlbWVudCIsImNsaWVudFdpZHRoIiwiY2xpZW50SGVpZ2h0IiwiZGVmYXVsdE9mZnNldCIsInJlc29sdmVPZmZzZXQiLCJ0YXJnZXRJbnNldCIsIm9mZnNldERlZmluaXRpb24iLCJ0YXJnZXRQb2ludCIsImNvbnRhaW5lclBvaW50IiwiU2Nyb2xsT2Zmc2V0IiwiRW50ZXIiLCJFeGl0IiwiQW55IiwiQWxsIiwiZ2V0VGFyZ2V0U2l6ZSIsInJlc29sdmVPZmZzZXRzIiwibGVuZ3RoTGFiZWwiLCJ0YXJnZXRTaXplIiwic2Nyb2xsV2lkdGgiLCJzY3JvbGxIZWlnaHQiLCJjb250YWluZXJTaXplIiwibnVtT2Zmc2V0cyIsImludGVycG9sYXRvck9mZnNldHMiLCJtZWFzdXJlIiwiY3JlYXRlT25TY3JvbGxIYW5kbGVyIiwib25TY3JvbGwiLCJzY3JvbGxMaXN0ZW5lcnMiLCJyZXNpemVMaXN0ZW5lcnMiLCJvblNjcm9sbEhhbmRsZXJzIiwiZ2V0RXZlbnRUYXJnZXQiLCJzY3JvbGxJbmZvIiwiY29udGFpbmVySGFuZGxlcnMiLCJjb250YWluZXJIYW5kbGVyIiwibWVhc3VyZUFsbCIsInVwZGF0ZUFsbCIsImN1cnJlbnRIYW5kbGVycyIsInNjcm9sbExpc3RlbmVyIiwic2Nyb2xsVGltZWxpbmVGYWxsYmFjayIsInRpbWVsaW5lQ2FjaGUiLCJnZXRUaW1lbGluZSIsInN1cHBvcnRzU2Nyb2xsVGltZWxpbmUiLCJTY3JvbGxUaW1lbGluZSIsImlzT25TY3JvbGxXaXRoSW5mbyIsIm5lZWRzRWxlbWVudFRyYWNraW5nIiwic2Nyb2xsRnVuY3Rpb24iLCJzY3JvbGxBbmltYXRpb24iLCJ2YWx1ZUFuaW1hdGlvbiIsIm9wdGlvbnNXaXRoRGVmYXVsdHMiLCJ0aHJlc2hvbGRzIiwib25TdGFydCIsInJvb3RNYXJnaW4iLCJhbW91bnQiLCJhY3RpdmVJbnRlcnNlY3Rpb25zIiwib25JbnRlcnNlY3Rpb25DaGFuZ2UiLCJlbnRyeSIsIm9uRW5kIiwiaXNJbnRlcnNlY3RpbmciLCJuZXdPbkVuZCIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwidGhyZXNob2xkIiwiZGlzY29ubmVjdCIsIm51bVN0ZXBzIiwiZXhwYW5kZWQiLCJyb3VuZGVkIiwiY2VpbCIsImdldE9yaWdpbkluZGV4IiwidG90YWwiLCJsYXN0SW5kZXgiLCJzdGFnZ2VyIiwic3RhcnREZWxheSIsIm1heERlbGF5IiwidGltZW91dCIsImNoZWNrRWxhcHNlZCIsImRpc3RhbmNlMkQiLCJ4RGVsdGEiLCJ5RGVsdGEiLCJpc0N1c3RvbVZhbHVlVHlwZSIsImdldE1peGVyIiwidXNlSW1tZWRpYXRlIiwiYXJnT2Zmc2V0IiwiaW5wdXRWYWx1ZSIsImlucHV0UmFuZ2UiLCJvdXRwdXRSYW5nZSIsInN5bmMiLCJjYW5jZWxTeW5jIiwibWljcm90YXNrIiwiY2FuY2VsTWljcm90YXNrIiwiY29tcGFyZUJ5RGVwdGgiLCJGbGF0VHJlZSIsImlzRGlydHkiLCJib3JkZXJzIiwibnVtQm9yZGVycyIsImlzUHgiLCJtaXhWYWx1ZXMiLCJmb2xsb3ciLCJsZWFkIiwic2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSIsImlzT25seU1lbWJlciIsImVhc2VDcm9zc2ZhZGVJbiIsIm9wYWNpdHlFeGl0IiwiZWFzZUNyb3NzZmFkZU91dCIsImJvcmRlckxhYmVsIiwiZm9sbG93UmFkaXVzIiwiZ2V0UmFkaXVzIiwibGVhZFJhZGl1cyIsImNhbk1peCIsInJhZGl1c05hbWUiLCJjb21wcmVzcyIsImNvcHlBeGlzSW50byIsIm9yaWdpbkF4aXMiLCJjb3B5Qm94SW50byIsIm9yaWdpbkJveCIsImNvcHlBeGlzRGVsdGFJbnRvIiwib3JpZ2luRGVsdGEiLCJyZW1vdmVQb2ludERlbHRhIiwicmVtb3ZlQXhpc0RlbHRhIiwic291cmNlQXhpcyIsInJlbGF0aXZlUHJvZ3Jlc3MiLCJyZW1vdmVBeGlzVHJhbnNmb3JtcyIsInRyYW5zZm9ybXMiLCJzY2FsZUtleSIsIm9yaWdpbktleSIsInhLZXlzIiwieUtleXMiLCJyZW1vdmVCb3hUcmFuc2Zvcm1zIiwic291cmNlQm94IiwiaXNBeGlzRGVsdGFaZXJvIiwiaXNEZWx0YVplcm8iLCJheGlzRXF1YWxzIiwiYm94RXF1YWxzIiwiYXhpc0VxdWFsc1JvdW5kZWQiLCJib3hFcXVhbHNSb3VuZGVkIiwiYXNwZWN0UmF0aW8iLCJheGlzRGVsdGFFcXVhbHMiLCJOb2RlU3RhY2siLCJtZW1iZXJzIiwicHJldkxlYWQiLCJwcm9tb3RlIiwicmVsZWdhdGUiLCJpbmRleE9mTm9kZSIsImZpbmRJbmRleCIsIm1lbWJlciIsInByZXNlcnZlRm9sbG93T3BhY2l0eSIsInNob3ciLCJyZXN1bWVGcm9tIiwicHJlc2VydmVPcGFjaXR5Iiwic25hcHNob3QiLCJhbmltYXRpb25WYWx1ZXMiLCJpc1VwZGF0aW5nIiwiaXNMYXlvdXREaXJ0eSIsImNyb3NzZmFkZSIsImhpZGUiLCJleGl0QW5pbWF0aW9uQ29tcGxldGUiLCJyZXN1bWluZ0Zyb20iLCJyZW1vdmVMZWFkU25hcHNob3QiLCJidWlsZFByb2plY3Rpb25UcmFuc2Zvcm0iLCJsYXRlc3RUcmFuc2Zvcm0iLCJ4VHJhbnNsYXRlIiwieVRyYW5zbGF0ZSIsInpUcmFuc2xhdGUiLCJlbGVtZW50U2NhbGVYIiwiZWxlbWVudFNjYWxlWSIsImVhY2hBeGlzIiwiZ2xvYmFsUHJvamVjdGlvblN0YXRlIiwiaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSIsImhhc0V2ZXJVcGRhdGVkIiwibWV0cmljcyIsInRvdGFsTm9kZXMiLCJyZXNvbHZlZFRhcmdldERlbHRhcyIsInJlY2FsY3VsYXRlZFByb2plY3Rpb24iLCJpc0RlYnVnIiwiTW90aW9uRGVidWciLCJ0cmFuc2Zvcm1BeGVzIiwiaGlkZGVuVmlzaWJpbGl0eSIsInZpc2liaWxpdHkiLCJhbmltYXRpb25UYXJnZXQiLCJpZCQxIiwicmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtIiwic2hhcmVkQW5pbWF0aW9uVmFsdWVzIiwiY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnMiLCJwcm9qZWN0aW9uTm9kZSIsImhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIiLCJNb3Rpb25IYXNPcHRpbWlzZWRBbmltYXRpb24iLCJNb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24iLCJjcmVhdGVQcm9qZWN0aW9uTm9kZSQxIiwiYXR0YWNoUmVzaXplTGlzdGVuZXIiLCJkZWZhdWx0UGFyZW50IiwibWVhc3VyZVNjcm9sbCIsImNoZWNrSXNTY3JvbGxSb290IiwicmVzZXRUcmFuc2Zvcm0iLCJQcm9qZWN0aW9uTm9kZSIsImFuaW1hdGlvbklkIiwiaXNUcmVlQW5pbWF0aW5nIiwiaXNBbmltYXRpb25CbG9ja2VkIiwiaXNQcm9qZWN0aW9uRGlydHkiLCJpc1NoYXJlZFByb2plY3Rpb25EaXJ0eSIsInVwZGF0ZU1hbnVhbGx5QmxvY2tlZCIsInVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSIsImlzU1ZHIiwibmVlZHNSZXNldCIsInNob3VsZFJlc2V0VHJhbnNmb3JtIiwiZXZlbnRIYW5kbGVycyIsImhhc1RyZWVBbmltYXRlZCIsInVwZGF0ZVNjaGVkdWxlZCIsInNjaGVkdWxlVXBkYXRlIiwicHJvamVjdGlvblVwZGF0ZVNjaGVkdWxlZCIsImNoZWNrVXBkYXRlRmFpbGVkIiwiY2xlYXJBbGxTbmFwc2hvdHMiLCJ1cGRhdGVQcm9qZWN0aW9uIiwibm9kZXMiLCJwcm9wYWdhdGVEaXJ0eU5vZGVzIiwicmVzb2x2ZVRhcmdldERlbHRhIiwiY2FsY1Byb2plY3Rpb24iLCJjbGVhbkRpcnR5Tm9kZXMiLCJyZWNvcmQiLCJyZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQiLCJoYXNQcm9qZWN0ZWQiLCJpc1Zpc2libGUiLCJhbmltYXRpb25Qcm9ncmVzcyIsInNoYXJlZE5vZGVzIiwicGF0aCIsIm5vdGlmeUxpc3RlbmVycyIsInN1YnNjcmlwdGlvbk1hbmFnZXIiLCJoYXNMaXN0ZW5lcnMiLCJjYW5jZWxEZWxheSIsInJlc2l6ZVVuYmxvY2tVcGRhdGUiLCJmaW5pc2hBbmltYXRpb24iLCJyZWdpc3RlclNoYXJlZE5vZGUiLCJoYXNMYXlvdXRDaGFuZ2VkIiwiaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkIiwibmV3TGF5b3V0IiwiaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCIsInJlbGF0aXZlVGFyZ2V0IiwibGF5b3V0VHJhbnNpdGlvbiIsImRlZmF1bHRMYXlvdXRUcmFuc2l0aW9uIiwib25MYXlvdXRBbmltYXRpb25TdGFydCIsIm9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUiLCJ0YXJnZXRDaGFuZ2VkIiwidGFyZ2V0TGF5b3V0IiwiaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCIsImxheW91dFJvb3QiLCJjdXJyZW50QW5pbWF0aW9uIiwic2V0QW5pbWF0aW9uT3JpZ2luIiwiYW5pbWF0aW9uT3B0aW9ucyIsImlzTGVhZCIsIndpbGxVcGRhdGUiLCJzdGFjayIsImdldFN0YWNrIiwiYmxvY2tVcGRhdGUiLCJ1bmJsb2NrVXBkYXRlIiwiaXNVcGRhdGVCbG9ja2VkIiwic3RhcnRVcGRhdGUiLCJyZXNldFNrZXdBbmRSb3RhdGlvbiIsImdldFRyYW5zZm9ybVRlbXBsYXRlIiwic2hvdWxkTm90aWZ5TGlzdGVuZXJzIiwidXBkYXRlU2Nyb2xsIiwicHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUiLCJ1cGRhdGVTbmFwc2hvdCIsInVwZGF0ZVdhc0Jsb2NrZWQiLCJjbGVhck1lYXN1cmVtZW50cyIsImNsZWFySXNMYXlvdXREaXJ0eSIsInJlc2V0VHJhbnNmb3JtU3R5bGUiLCJ1cGRhdGVMYXlvdXQiLCJub3RpZnlMYXlvdXRVcGRhdGUiLCJkaWRVcGRhdGUiLCJjbGVhclNuYXBzaG90IiwicmVtb3ZlTGVhZFNuYXBzaG90cyIsInNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbiIsInNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQiLCJhbHdheXNNZWFzdXJlTGF5b3V0IiwicHJldkxheW91dCIsImxheW91dENvcnJlY3RlZCIsImxheW91dEJveCIsInBoYXNlIiwiaXNSb290Iiwid2FzUm9vdCIsImlzUmVzZXRSZXF1ZXN0ZWQiLCJoYXNQcm9qZWN0aW9uIiwidHJhbnNmb3JtVGVtcGxhdGVWYWx1ZSIsInRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCIsInJlbW92ZVRyYW5zZm9ybSIsInBhZ2VCb3giLCJyZW1vdmVFbGVtZW50U2Nyb2xsIiwicm91bmRCb3giLCJtZWFzdXJlZEJveCIsIndhc0luU2Nyb2xsUm9vdCIsImNoZWNrTm9kZVdhc1Njcm9sbFJvb3QiLCJib3hXaXRob3V0U2Nyb2xsIiwiYXBwbHlUcmFuc2Zvcm0iLCJ0cmFuc2Zvcm1Pbmx5Iiwid2l0aFRyYW5zZm9ybXMiLCJib3hXaXRob3V0VHJhbnNmb3JtIiwibm9kZUJveCIsInNldFRhcmdldERlbHRhIiwidGFyZ2V0RGVsdGEiLCJzZXRPcHRpb25zIiwiZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCIsInJlbGF0aXZlUGFyZW50IiwiZm9yY2VSZWNhbGN1bGF0aW9uIiwiZ2V0TGVhZCIsImlzU2hhcmVkIiwiY2FuU2tpcCIsImF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCIsImdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50IiwicmVsYXRpdmVUYXJnZXRPcmlnaW4iLCJ0YXJnZXRXaXRoVHJhbnNmb3JtcyIsImlzUHJvamVjdGluZyIsInBlbmRpbmdBbmltYXRpb24iLCJwcmV2VHJlZVNjYWxlWCIsInByZXZUcmVlU2NhbGVZIiwicHJldlByb2plY3Rpb25EZWx0YSIsImNyZWF0ZVByb2plY3Rpb25EZWx0YXMiLCJwcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtIiwic25hcHNob3RMYXRlc3RWYWx1ZXMiLCJtaXhlZFZhbHVlcyIsInJlbGF0aXZlTGF5b3V0Iiwic25hcHNob3RTb3VyY2UiLCJsYXlvdXRTb3VyY2UiLCJpc1NoYXJlZExheW91dEFuaW1hdGlvbiIsImhhc09wYWNpdHlDcm9zc2ZhZGUiLCJwcmV2UmVsYXRpdmVUYXJnZXQiLCJtaXhUYXJnZXREZWx0YSIsIm1peEF4aXNEZWx0YSIsIm1peEJveCIsImNvbXBsZXRlQW5pbWF0aW9uIiwiYXBwbHlUcmFuc2Zvcm1zVG9UYXJnZXQiLCJzaG91bGRBbmltYXRlUG9zaXRpb25Pbmx5IiwiYW5pbWF0aW9uVHlwZSIsInhMZW5ndGgiLCJ5TGVuZ3RoIiwiaW5pdGlhbFByb21vdGlvbkNvbmZpZyIsInNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eSIsImdldFByZXZMZWFkIiwiaGFzRGlzdG9ydGluZ1RyYW5zZm9ybSIsInJlc2V0VmFsdWVzIiwic3R5bGVzIiwicG9pbnRlckV2ZW50cyIsImVtcHR5U3R5bGVzIiwidmFsdWVzVG9SZW5kZXIiLCJjb3JyZWN0IiwiYXBwbHlUbyIsImNvcnJlY3RlZCIsIm51bSIsInJlc2V0VHJlZSIsIm1lYXN1cmVkTGF5b3V0IiwiYXhpc1NuYXBzaG90IiwibGF5b3V0RGVsdGEiLCJ2aXN1YWxEZWx0YSIsInBhcmVudFNuYXBzaG90IiwicGFyZW50TGF5b3V0IiwicmVsYXRpdmVTbmFwc2hvdCIsIm9uQmVmb3JlTGF5b3V0TWVhc3VyZSIsIm1peEF4aXMiLCJ1c2VyQWdlbnRDb250YWlucyIsInN0cmluZyIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInJvdW5kUG9pbnQiLCJyb3VuZEF4aXMiLCJEb2N1bWVudFByb2plY3Rpb25Ob2RlIiwic2Nyb2xsTGVmdCIsImJvZHkiLCJzY3JvbGxUb3AiLCJIVE1MUHJvamVjdGlvbk5vZGUiLCJkb2N1bWVudE5vZGUiLCJub2RlR3JvdXAiLCJkaXJ0eUFsbCIsImRpcnR5IiwicGl4ZWxzVG9QZXJjZW50IiwicGl4ZWxzIiwiY29ycmVjdEJvcmRlclJhZGl1cyIsImNvcnJlY3RCb3hTaGFkb3ciLCJvcmlnaW5hbCIsInNoYWRvdyIsInhTY2FsZSIsInlTY2FsZSIsImF2ZXJhZ2VTY2FsZSIsInNob3VsZEluaGVyaXRHcm91cCIsInNob3VsZEluaGVyaXRJZCIsIkxheW91dEdyb3VwIiwibGF5b3V0R3JvdXBDb250ZXh0IiwiZGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dCIsInVwc3RyZWFtSWQiLCJncm91cCIsIm1lbW9pemVkQ29udGV4dCIsIkxhenlDb250ZXh0Iiwic3RyaWN0IiwibG9hZEZlYXR1cmVzIiwiTGF6eU1vdGlvbiIsInNldElzTG9hZGVkIiwiaXNMYXp5QnVuZGxlIiwibG9hZGVkUmVuZGVyZXIiLCJyZW5kZXJlciIsImxvYWRlZEZlYXR1cmVzIiwiTW90aW9uQ29uZmlnIiwiSlNPTiIsInN0cmluZ2lmeSIsIlJlb3JkZXJDb250ZXh0IiwiY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkiLCJjb21wb25lbnRGYWN0b3J5IiwiUHJveHkiLCJjb21wb25lbnRDYWNoZSIsImRlcHJlY2F0ZWRGYWN0b3J5RnVuY3Rpb24iLCJfdGFyZ2V0IiwiUGFuU2Vzc2lvbiIsImhhbmRsZXJzIiwiY29udGV4dFdpbmRvdyIsImRyYWdTbmFwVG9PcmlnaW4iLCJzdGFydEV2ZW50IiwibGFzdE1vdmVFdmVudCIsImxhc3RNb3ZlRXZlbnRJbmZvIiwidXBkYXRlUG9pbnQiLCJnZXRQYW5JbmZvIiwiaGlzdG9yeSIsImlzUGFuU3RhcnRlZCIsImlzRGlzdGFuY2VQYXN0VGhyZXNob2xkIiwib25Nb3ZlIiwiaGFuZGxlUG9pbnRlck1vdmUiLCJoYW5kbGVQb2ludGVyVXAiLCJvblNlc3Npb25FbmQiLCJyZXN1bWVBbmltYXRpb24iLCJwYW5JbmZvIiwiaW5pdGlhbEluZm8iLCJvblNlc3Npb25TdGFydCIsInJlbW92ZUxpc3RlbmVycyIsInVwZGF0ZUhhbmRsZXJzIiwic3VidHJhY3RQb2ludCIsImxhc3REZXZpY2VQb2ludCIsInN0YXJ0RGV2aWNlUG9pbnQiLCJ0aW1lRGVsdGEiLCJ0aW1lc3RhbXBlZFBvaW50IiwibGFzdFBvaW50IiwiaXNSZWZPYmplY3QiLCJhcHBseUNvbnN0cmFpbnRzIiwiZWxhc3RpYyIsImNhbGNSZWxhdGl2ZUF4aXNDb25zdHJhaW50cyIsImNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzIiwiY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzIiwibGF5b3V0QXhpcyIsImNvbnN0cmFpbnRzQXhpcyIsImNhbGNWaWV3cG9ydENvbnN0cmFpbnRzIiwiY29uc3RyYWludHNCb3giLCJjYWxjT3JpZ2luIiwic291cmNlTGVuZ3RoIiwicmViYXNlQXhpc0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHMiLCJyZWxhdGl2ZUNvbnN0cmFpbnRzIiwiZGVmYXVsdEVsYXN0aWMiLCJyZXNvbHZlRHJhZ0VsYXN0aWMiLCJkcmFnRWxhc3RpYyIsInJlc29sdmVBeGlzRWxhc3RpYyIsIm1pbkxhYmVsIiwibWF4TGFiZWwiLCJyZXNvbHZlUG9pbnRFbGFzdGljIiwibGFiZWwiLCJnZXRDb250ZXh0V2luZG93Iiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiZWxlbWVudERyYWdDb250cm9scyIsIlZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMiLCJvcGVuRHJhZ0xvY2siLCJpc0RyYWdnaW5nIiwiY3VycmVudERpcmVjdGlvbiIsImhhc011dGF0ZWRDb25zdHJhaW50cyIsIm9yaWdpbkV2ZW50Iiwic25hcFRvQ3Vyc29yIiwicGF1c2VBbmltYXRpb24iLCJzdG9wQW5pbWF0aW9uIiwiZHJhZ1Byb3BhZ2F0aW9uIiwib25EcmFnU3RhcnQiLCJzZXREcmFnTG9jayIsInJlc29sdmVDb25zdHJhaW50cyIsImdldEF4aXNNb3Rpb25WYWx1ZSIsIm1lYXN1cmVkQXhpcyIsImRyYWdEaXJlY3Rpb25Mb2NrIiwib25EaXJlY3Rpb25Mb2NrIiwib25EcmFnIiwiZ2V0Q3VycmVudERpcmVjdGlvbiIsInVwZGF0ZUF4aXMiLCJnZXRBbmltYXRpb25TdGF0ZSIsInBhblNlc3Npb24iLCJvbkRyYWdFbmQiLCJfcG9pbnQiLCJzaG91bGREcmFnIiwiYXhpc1ZhbHVlIiwiZHJhZ0NvbnN0cmFpbnRzIiwicHJldkNvbnN0cmFpbnRzIiwicmVzb2x2ZVJlZkNvbnN0cmFpbnRzIiwib25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIiwiY29uc3RyYWludHNFbGVtZW50IiwibWVhc3VyZWRDb25zdHJhaW50cyIsInVzZXJDb25zdHJhaW50cyIsImRyYWdNb21lbnR1bSIsImRyYWdUcmFuc2l0aW9uIiwib25EcmFnVHJhbnNpdGlvbkVuZCIsIm1vbWVudHVtQW5pbWF0aW9ucyIsInN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uIiwiZHJhZ0tleSIsImV4dGVybmFsTW90aW9uVmFsdWUiLCJzY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMiLCJib3hQcm9ncmVzcyIsImFkZExpc3RlbmVycyIsInN0b3BQb2ludGVyTGlzdGVuZXIiLCJkcmFnTGlzdGVuZXIiLCJtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIiwic3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciIsInN0b3BSZXNpemVMaXN0ZW5lciIsInN0b3BMYXlvdXRVcGRhdGVMaXN0ZW5lciIsImxvY2tUaHJlc2hvbGQiLCJEcmFnR2VzdHVyZSIsInJlbW92ZUdyb3VwQ29udHJvbHMiLCJjb250cm9scyIsImRyYWdDb250cm9scyIsImFzeW5jSGFuZGxlciIsIlBhbkdlc3R1cmUiLCJyZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyIiwib25Qb2ludGVyRG93biIsInBvaW50ZXJEb3duRXZlbnQiLCJzZXNzaW9uIiwiY3JlYXRlUGFuSGFuZGxlcnMiLCJvblBhblNlc3Npb25TdGFydCIsIm9uUGFuU3RhcnQiLCJvblBhbiIsIm9uUGFuRW5kIiwiU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0IiwiTWVhc3VyZUxheW91dFdpdGhDb250ZXh0IiwiY29tcG9uZW50RGlkTW91bnQiLCJsYXlvdXRHcm91cCIsInN3aXRjaExheW91dEdyb3VwIiwiZGVmYXVsdFNjYWxlQ29ycmVjdG9ycyIsImxheW91dERlcGVuZGVuY3kiLCJjb21wb25lbnRXaWxsVW5tb3VudCIsInByb21vdGVDb250ZXh0IiwiZGVyZWdpc3RlciIsIk1lYXN1cmVMYXlvdXQiLCJib3hTaGFkb3ciLCJoYW5kbGVIb3ZlckV2ZW50IiwibGlmZWN5Y2xlIiwiSG92ZXJHZXN0dXJlIiwiZW5kRXZlbnQiLCJGb2N1c0dlc3R1cmUiLCJvbkZvY3VzIiwiaXNGb2N1c1Zpc2libGUiLCJvbkJsdXIiLCJoYW5kbGVQcmVzc0V2ZW50IiwiUHJlc3NHZXN0dXJlIiwicHJlc3MiLCJzdWNjZXNzIiwidXNlR2xvYmFsVGFyZ2V0IiwiZ2xvYmFsVGFwVGFyZ2V0Iiwib2JzZXJ2ZXJDYWxsYmFja3MiLCJvYnNlcnZlcnMiLCJmaXJlT2JzZXJ2ZXJDYWxsYmFjayIsImZpcmVBbGxPYnNlcnZlckNhbGxiYWNrcyIsImluaXRJbnRlcnNlY3Rpb25PYnNlcnZlciIsImxvb2t1cFJvb3QiLCJyb290T2JzZXJ2ZXJzIiwib2JzZXJ2ZUludGVyc2VjdGlvbiIsInJvb3RJbnRlcmVzZWN0aW9uT2JzZXJ2ZXIiLCJ0aHJlc2hvbGROYW1lcyIsIkluVmlld0ZlYXR1cmUiLCJoYXNFbnRlcmVkVmlldyIsImlzSW5WaWV3Iiwic3RhcnRPYnNlcnZlciIsInZpZXdwb3J0Iiwib25jZSIsIm9uSW50ZXJzZWN0aW9uVXBkYXRlIiwib25WaWV3cG9ydEVudGVyIiwib25WaWV3cG9ydExlYXZlIiwiaGFzT3B0aW9uc0NoYW5nZWQiLCJoYXNWaWV3cG9ydE9wdGlvbkNoYW5nZWQiLCJwcmV2Vmlld3BvcnQiLCJnZXN0dXJlQW5pbWF0aW9ucyIsImdldEN1cnJlbnRUcmVlVmFyaWFudHMiLCJ1c2VDcmVhdGVNb3Rpb25Db250ZXh0IiwidmFyaWFudExhYmVsc0FzRGVwZW5kZW5jeSIsIm1vdGlvbkNvbXBvbmVudFN5bWJvbCIsIlN5bWJvbCIsImZvciIsInVzZU1vdGlvblJlZiIsImV4dGVybmFsUmVmIiwidXNlVmlzdWFsRWxlbWVudCIsIlByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IiLCJsYXp5Q29udGV4dCIsInZpc3VhbEVsZW1lbnRSZWYiLCJpbml0aWFsTGF5b3V0R3JvdXBDb25maWciLCJjcmVhdGVQcm9qZWN0aW9uTm9kZSIsIm9wdGltaXNlZEFwcGVhcklkIiwid2FudHNIYW5kb2ZmIiwiTW90aW9uSGFuZG9mZklzQ29tcGxldGUiLCJNb3Rpb25Jc01vdW50ZWQiLCJNb3Rpb25IYW5kb2ZmTWFya0FzQ29tcGxldGUiLCJnZXRDbG9zZXN0UHJvamVjdGluZ05vZGUiLCJhbGxvd1Byb2plY3Rpb24iLCJjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCIsInByZWxvYWRlZEZlYXR1cmVzIiwidXNlUmVuZGVyIiwidXNlVmlzdWFsU3RhdGUiLCJNb3Rpb25Db21wb25lbnQiLCJjb25maWdBbmRQcm9wcyIsInVzZUxheW91dElkIiwidXNlU3RyaWN0TW9kZSIsImxheW91dFByb2plY3Rpb24iLCJnZXRQcm9qZWN0aW9uRnVuY3Rpb25hbGl0eSIsImpzeHMiLCJkaXNwbGF5TmFtZSIsIkZvcndhcmRSZWZNb3Rpb25Db21wb25lbnQiLCJmb3J3YXJkUmVmIiwibGF5b3V0R3JvdXBJZCIsImlzU3RyaWN0Iiwic3RyaWN0TWVzc2FnZSIsImlnbm9yZVN0cmljdCIsImNvbWJpbmVkIiwibG93ZXJjYXNlU1ZHRWxlbWVudHMiLCJpc1NWR0NvbXBvbmVudCIsImNyZWF0ZUh0bWxSZW5kZXJTdGF0ZSIsImNyZWF0ZVN2Z1JlbmRlclN0YXRlIiwidXBkYXRlU1ZHRGltZW5zaW9ucyIsImxheW91dFByb3BzIiwic3ZnTW90aW9uQ29uZmlnIiwibmVlZHNNZWFzdXJlIiwiaHRtbE1vdGlvbkNvbmZpZyIsImNvcHlSYXdWYWx1ZXNPbmx5IiwidXNlSW5pdGlhbE1vdGlvblZhbHVlcyIsInVzZVN0eWxlIiwidXNlSFRNTFByb3BzIiwiaHRtbFByb3BzIiwiZHJhZ2dhYmxlIiwidXNlclNlbGVjdCIsIldlYmtpdFVzZXJTZWxlY3QiLCJXZWJraXRUb3VjaENhbGxvdXQiLCJ0b3VjaEFjdGlvbiIsInRhYkluZGV4Iiwib25UYXAiLCJvblRhcFN0YXJ0IiwidXNlU1ZHUHJvcHMiLCJfaXNTdGF0aWMiLCJ2aXN1YWxQcm9wcyIsInJhd1N0eWxlcyIsImNyZWF0ZVVzZVJlbmRlciIsInVzZVZpc3VhbFByb3BzIiwiZWxlbWVudFByb3BzIiwiY3JlYXRlTW90aW9uQ29tcG9uZW50RmFjdG9yeSIsImNyZWF0ZU1vdGlvbkNvbXBvbmVudCIsImJhc2VDb25maWciLCJjcmVhdGVEb21WaXN1YWxFbGVtZW50IiwibW90aW9uIiwiY2hlY2tSZW9yZGVyIiwib3JkZXIiLCJuZXh0T2Zmc2V0IiwibmV4dEl0ZW0iLCJuZXh0TGF5b3V0IiwibmV4dEl0ZW1DZW50ZXIiLCJSZW9yZGVyR3JvdXBDb21wb25lbnQiLCJhcyIsIm9uUmVvcmRlciIsImlzUmVvcmRlcmluZyIsInJlZ2lzdGVySXRlbSIsImlkeCIsImNvbXBhcmVNaW4iLCJ1cGRhdGVPcmRlciIsIm5ld09yZGVyIiwiUmVvcmRlckdyb3VwIiwidXNlTW90aW9uVmFsdWUiLCJzZXRMYXRlc3QiLCJ1c2VDb21iaW5lTW90aW9uVmFsdWVzIiwiY29tYmluZVZhbHVlcyIsInVwZGF0ZVZhbHVlIiwidXNlQ29tcHV0ZWQiLCJjb21wdXRlIiwidXNlVHJhbnNmb3JtIiwiaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIiLCJ1c2VMaXN0VHJhbnNmb3JtIiwidXNlRGVmYXVsdE1vdGlvblZhbHVlIiwiUmVvcmRlckl0ZW1Db21wb25lbnQiLCJsYXRlc3RYIiwibGF0ZXN0WSIsImdlc3R1cmVQb2ludCIsIm9uTGF5b3V0TWVhc3VyZSIsIm1lYXN1cmVkIiwiUmVvcmRlckl0ZW0iLCJuYW1lc3BhY2UiLCJfX3Byb3RvX18iLCJHcm91cCIsIkl0ZW0iLCJjcmVhdGVNaW5pbWFsTW90aW9uQ29tcG9uZW50IiwibSIsImRvbUFuaW1hdGlvbiIsImRvbU1heCIsImRvbU1pbiIsInVzZU1vdGlvblZhbHVlRXZlbnQiLCJyZWZXYXJuaW5nIiwiY3JlYXRlU2Nyb2xsTW90aW9uVmFsdWVzIiwic2Nyb2xsWCIsInNjcm9sbFkiLCJzY3JvbGxYUHJvZ3Jlc3MiLCJzY3JvbGxZUHJvZ3Jlc3MiLCJ1c2VTY3JvbGwiLCJsYXlvdXRFZmZlY3QiLCJ1c2VMaWZlY3ljbGVFZmZlY3QiLCJfcHJvZ3Jlc3MiLCJ1c2VFbGVtZW50U2Nyb2xsIiwidXNlVmlld3BvcnRTY3JvbGwiLCJ1c2VNb3Rpb25UZW1wbGF0ZSIsImZyYWdtZW50cyIsIm51bUZyYWdtZW50cyIsImJ1aWxkVmFsdWUiLCJ0b051bWJlciIsInVzZVNwcmluZyIsImFjdGl2ZVNwcmluZ0FuaW1hdGlvbiIsImxhdGVzdFNldHRlciIsInVzZUFuaW1hdGlvbkZyYW1lIiwiaW5pdGlhbFRpbWVzdGFtcCIsInByb3ZpZGVUaW1lU2luY2VTdGFydCIsInVzZVRpbWUiLCJ1c2VWZWxvY2l0eSIsInVwZGF0ZVZlbG9jaXR5IiwiZ2V0V2lsbENoYW5nZU5hbWUiLCJXaWxsQ2hhbmdlTW90aW9uVmFsdWUiLCJzdHlsZU5hbWUiLCJ1c2VXaWxsQ2hhbmdlIiwidXNlUmVkdWNlZE1vdGlvbiIsInVzZVJlZHVjZWRNb3Rpb25Db25maWciLCJyZWR1Y2VkTW90aW9uUHJlZmVyZW5jZSIsInNldFZhcmlhbnRzIiwidmFyaWFudExhYmVscyIsInJldmVyc2VkTGFiZWxzIiwic2V0VmFsdWVzIiwiYW5pbWF0aW9uQ29udHJvbHMiLCJoYXNNb3VudGVkIiwic3Vic2NyaWJlcnMiLCJ1c2VBbmltYXRlIiwidXNlQW5pbWF0ZU1pbmkiLCJ1c2VBbmltYXRpb25Db250cm9scyIsInVzZUFuaW1hdGlvbiIsInVzZURvbUV2ZW50IiwiRHJhZ0NvbnRyb2xzIiwiY29tcG9uZW50Q29udHJvbHMiLCJuYXRpdmVFdmVudCIsImNyZWF0ZURyYWdDb250cm9scyIsInVzZURyYWdDb250cm9scyIsImlzTW90aW9uQ29tcG9uZW50IiwiY29tcG9uZW50IiwidW53cmFwTW90aW9uQ29tcG9uZW50IiwidXNlSW5zdGFudExheW91dFRyYW5zaXRpb24iLCJzdGFydFRyYW5zaXRpb24iLCJ1c2VSZXNldFByb2plY3Rpb24iLCJ1c2VDeWNsZSIsIml0ZW1zIiwic2V0SXRlbSIsInJ1bkN5Y2xlIiwidXNlSW5WaWV3Iiwic2V0SW5WaWV3Iiwib25FbnRlciIsInVzZUluc3RhbnRUcmFuc2l0aW9uIiwiZm9yY2VVcGRhdGUiLCJzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uIiwidW5sb2NrT25GcmFtZVJlZiIsImRpc2FibGVJbnN0YW50VHJhbnNpdGlvbnMiLCJhcHBlYXJTdG9yZUlkIiwiZWxlbWVudElkIiwiYXBwZWFyQW5pbWF0aW9uU3RvcmUiLCJhcHBlYXJDb21wbGV0ZSIsImhhbmRvZmZPcHRpbWl6ZWRBcHBlYXJBbmltYXRpb24iLCJzdG9yZUlkIiwib3B0aW1pc2VkQW5pbWF0aW9uIiwiY2FuY2VsQW5pbWF0aW9uIiwic3RhcnRGcmFtZVRpbWUiLCJyZWFkeUFuaW1hdGlvbiIsInN1c3BlbmRlZEFuaW1hdGlvbnMiLCJyZXN1bWVTdXNwZW5kZWRBbmltYXRpb25zIiwiZGF0YSIsInN0YXJ0T3B0aW1pemVkQXBwZWFyQW5pbWF0aW9uIiwib25SZWFkeSIsImNhblJlc3VtZSIsInZhbHVlSXNPcHRpbWlzZWQiLCJleHRlcm5hbEFuaW1hdGlvblZhbHVlIiwiYXBwZWFyQW5pbWF0aW9uIiwicmVhZHkiLCJjYXRjaCIsImNyZWF0ZU9iamVjdCIsIlN0YXRlVmlzdWFsRWxlbWVudCIsInJlc3RvcmVUcmFuc2Zvcm0iLCJfc3RhdGUiLCJpbml0aWFsU3RhdGUiLCJ1c2VBbmltYXRlZFN0YXRlIiwic2V0QW5pbWF0aW9uU3RhdGUiLCJhbmltYXRpb25EZWZpbml0aW9uIiwiQW5pbWF0ZVNoYXJlZExheW91dCIsIm1heFNjYWxlIiwiaW52ZXJ0U2NhbGUiLCJoYXNXYXJuZWQiLCJ1c2VJbnZlcnRlZFNjYWxlIiwicGFyZW50U2NhbGVYIiwicGFyZW50U2NhbGVZIiwiaXNEcmFnQWN0aXZlIiwiUmVvcmRlciIsInVzZURlcHJlY2F0ZWRBbmltYXRlZFN0YXRlIiwidXNlRGVwcmVjYXRlZEludmVydGVkU2NhbGUiXSwic291cmNlcyI6WyJpbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBqc3hSdW50aW1lID0gcmVxdWlyZSgncmVhY3QvanN4LXJ1bnRpbWUnKTtcbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgbW90aW9uVXRpbHMgPSByZXF1aXJlKCdtb3Rpb24tdXRpbHMnKTtcbnZhciBtb3Rpb25Eb20gPSByZXF1aXJlKCdtb3Rpb24tZG9tJyk7XG5cbmZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlRGVmYXVsdChlKSB7XG4gICAgdmFyIG4gPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmIChlKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKGUpLmZvckVhY2goZnVuY3Rpb24gKGspIHtcbiAgICAgICAgICAgIGlmIChrICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IoZSwgayk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG4sIGssIGQuZ2V0ID8gZCA6IHtcbiAgICAgICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBlW2tdOyB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBuLmRlZmF1bHQgPSBlO1xuICAgIHJldHVybiBPYmplY3QuZnJlZXplKG4pO1xufVxuXG52YXIgUmVhY3RfX25hbWVzcGFjZSA9IC8qI19fUFVSRV9fKi9faW50ZXJvcE5hbWVzcGFjZURlZmF1bHQoUmVhY3QpO1xuXG5jb25zdCBMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuZnVuY3Rpb24gaXNBbmltYXRpb25Db250cm9scyh2KSB7XG4gICAgcmV0dXJuICh2ICE9PSBudWxsICYmXG4gICAgICAgIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIHR5cGVvZiB2LnN0YXJ0ID09PSBcImZ1bmN0aW9uXCIpO1xufVxuXG5jb25zdCBpc0tleWZyYW1lc1RhcmdldCA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG59O1xuXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZShuZXh0LCBwcmV2KSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByZXYpKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgY29uc3QgcHJldkxlbmd0aCA9IHByZXYubGVuZ3RoO1xuICAgIGlmIChwcmV2TGVuZ3RoICE9PSBuZXh0Lmxlbmd0aClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJldkxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChwcmV2W2ldICE9PSBuZXh0W2ldKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBEZWNpZGVzIGlmIHRoZSBzdXBwbGllZCB2YXJpYWJsZSBpcyB2YXJpYW50IGxhYmVsXG4gKi9cbmZ1bmN0aW9uIGlzVmFyaWFudExhYmVsKHYpIHtcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgfHwgQXJyYXkuaXNBcnJheSh2KTtcbn1cblxuZnVuY3Rpb24gZ2V0VmFsdWVTdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgY29uc3Qgc3RhdGUgPSBbe30sIHt9XTtcbiAgICB2aXN1YWxFbGVtZW50ID09PSBudWxsIHx8IHZpc3VhbEVsZW1lbnQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHZpc3VhbEVsZW1lbnQudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICAgICAgc3RhdGVbMF1ba2V5XSA9IHZhbHVlLmdldCgpO1xuICAgICAgICBzdGF0ZVsxXVtrZXldID0gdmFsdWUuZ2V0VmVsb2NpdHkoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudEZyb21Qcm9wcyhwcm9wcywgZGVmaW5pdGlvbiwgY3VzdG9tLCB2aXN1YWxFbGVtZW50KSB7XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHZhcmlhbnQgZGVmaW5pdGlvbiBpcyBhIGZ1bmN0aW9uLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IFtjdXJyZW50LCB2ZWxvY2l0eV0gPSBnZXRWYWx1ZVN0YXRlKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICBkZWZpbml0aW9uID0gZGVmaW5pdGlvbihjdXN0b20gIT09IHVuZGVmaW5lZCA/IGN1c3RvbSA6IHByb3BzLmN1c3RvbSwgY3VycmVudCwgdmVsb2NpdHkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdmFyaWFudCBkZWZpbml0aW9uIGlzIGEgdmFyaWFudCBsYWJlbCwgb3JcbiAgICAgKiB0aGUgZnVuY3Rpb24gcmV0dXJuZWQgYSB2YXJpYW50IGxhYmVsLCByZXNvbHZlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBkZWZpbml0aW9uID0gcHJvcHMudmFyaWFudHMgJiYgcHJvcHMudmFyaWFudHNbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0IHRoaXMgcG9pbnQgd2UndmUgcmVzb2x2ZWQgYm90aCBmdW5jdGlvbnMgYW5kIHZhcmlhbnQgbGFiZWxzLFxuICAgICAqIGJ1dCB0aGUgcmVzb2x2ZWQgdmFyaWFudCBsYWJlbCBtaWdodCBpdHNlbGYgaGF2ZSBiZWVuIGEgZnVuY3Rpb24uXG4gICAgICogSWYgc28sIHJlc29sdmUuIFRoaXMgY2FuIG9ubHkgaGF2ZSByZXR1cm5lZCBhIHZhbGlkIHRhcmdldCBvYmplY3QuXG4gICAgICovXG4gICAgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY29uc3QgW2N1cnJlbnQsIHZlbG9jaXR5XSA9IGdldFZhbHVlU3RhdGUodmlzdWFsRWxlbWVudCk7XG4gICAgICAgIGRlZmluaXRpb24gPSBkZWZpbml0aW9uKGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCBjdXJyZW50LCB2ZWxvY2l0eSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBjdXN0b20pIHtcbiAgICBjb25zdCBwcm9wcyA9IHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKTtcbiAgICByZXR1cm4gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGRlZmluaXRpb24sIGN1c3RvbSAhPT0gdW5kZWZpbmVkID8gY3VzdG9tIDogcHJvcHMuY3VzdG9tLCB2aXN1YWxFbGVtZW50KTtcbn1cblxuY29uc3QgdmFyaWFudFByaW9yaXR5T3JkZXIgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJ3aGlsZUluVmlld1wiLFxuICAgIFwid2hpbGVGb2N1c1wiLFxuICAgIFwid2hpbGVIb3ZlclwiLFxuICAgIFwid2hpbGVUYXBcIixcbiAgICBcIndoaWxlRHJhZ1wiLFxuICAgIFwiZXhpdFwiLFxuXTtcbmNvbnN0IHZhcmlhbnRQcm9wcyA9IFtcImluaXRpYWxcIiwgLi4udmFyaWFudFByaW9yaXR5T3JkZXJdO1xuXG5jb25zdCBNb3Rpb25HbG9iYWxDb25maWcgPSB7XG4gICAgc2tpcEFuaW1hdGlvbnM6IGZhbHNlLFxuICAgIHVzZU1hbnVhbFRpbWluZzogZmFsc2UsXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJTdGVwKHJ1bk5leHRGcmFtZSkge1xuICAgIC8qKlxuICAgICAqIFdlIGNyZWF0ZSBhbmQgcmV1c2UgdHdvIHF1ZXVlcywgb25lIHRvIHF1ZXVlIGpvYnMgZm9yIHRoZSBjdXJyZW50IGZyYW1lXG4gICAgICogYW5kIG9uZSBmb3IgdGhlIG5leHQuIFdlIHJldXNlIHRvIGF2b2lkIHRyaWdnZXJpbmcgR0MgYWZ0ZXIgeCBmcmFtZXMuXG4gICAgICovXG4gICAgbGV0IHRoaXNGcmFtZSA9IG5ldyBTZXQoKTtcbiAgICBsZXQgbmV4dEZyYW1lID0gbmV3IFNldCgpO1xuICAgIC8qKlxuICAgICAqIFRyYWNrIHdoZXRoZXIgd2UncmUgY3VycmVudGx5IHByb2Nlc3Npbmcgam9icyBpbiB0aGlzIHN0ZXAuIFRoaXMgd2F5XG4gICAgICogd2UgY2FuIGRlY2lkZSB3aGV0aGVyIHRvIHNjaGVkdWxlIG5ldyBqb2JzIGZvciB0aGlzIGZyYW1lIG9yIG5leHQuXG4gICAgICovXG4gICAgbGV0IGlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgIGxldCBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEEgc2V0IG9mIHByb2Nlc3NlcyB3aGljaCB3ZXJlIG1hcmtlZCBrZWVwQWxpdmUgd2hlbiBzY2hlZHVsZWQuXG4gICAgICovXG4gICAgY29uc3QgdG9LZWVwQWxpdmUgPSBuZXcgV2Vha1NldCgpO1xuICAgIGxldCBsYXRlc3RGcmFtZURhdGEgPSB7XG4gICAgICAgIGRlbHRhOiAwLjAsXG4gICAgICAgIHRpbWVzdGFtcDogMC4wLFxuICAgICAgICBpc1Byb2Nlc3Npbmc6IGZhbHNlLFxuICAgIH07XG4gICAgZnVuY3Rpb24gdHJpZ2dlckNhbGxiYWNrKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0b0tlZXBBbGl2ZS5oYXMoY2FsbGJhY2spKSB7XG4gICAgICAgICAgICBzdGVwLnNjaGVkdWxlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHJ1bk5leHRGcmFtZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxiYWNrKGxhdGVzdEZyYW1lRGF0YSk7XG4gICAgfVxuICAgIGNvbnN0IHN0ZXAgPSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY2hlZHVsZSBhIHByb2Nlc3MgdG8gcnVuIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICAgKi9cbiAgICAgICAgc2NoZWR1bGU6IChjYWxsYmFjaywga2VlcEFsaXZlID0gZmFsc2UsIGltbWVkaWF0ZSA9IGZhbHNlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhZGRUb0N1cnJlbnRGcmFtZSA9IGltbWVkaWF0ZSAmJiBpc1Byb2Nlc3Npbmc7XG4gICAgICAgICAgICBjb25zdCBxdWV1ZSA9IGFkZFRvQ3VycmVudEZyYW1lID8gdGhpc0ZyYW1lIDogbmV4dEZyYW1lO1xuICAgICAgICAgICAgaWYgKGtlZXBBbGl2ZSlcbiAgICAgICAgICAgICAgICB0b0tlZXBBbGl2ZS5hZGQoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKCFxdWV1ZS5oYXMoY2FsbGJhY2spKVxuICAgICAgICAgICAgICAgIHF1ZXVlLmFkZChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYW5jZWwgdGhlIHByb3ZpZGVkIGNhbGxiYWNrIGZyb20gcnVubmluZyBvbiB0aGUgbmV4dCBmcmFtZS5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbDogKGNhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBuZXh0RnJhbWUuZGVsZXRlKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRvS2VlcEFsaXZlLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFeGVjdXRlIGFsbCBzY2hlZHVsZSBjYWxsYmFja3MuXG4gICAgICAgICAqL1xuICAgICAgICBwcm9jZXNzOiAoZnJhbWVEYXRhKSA9PiB7XG4gICAgICAgICAgICBsYXRlc3RGcmFtZURhdGEgPSBmcmFtZURhdGE7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIGFscmVhZHkgcHJvY2Vzc2luZyB3ZSd2ZSBwcm9iYWJseSBiZWVuIHRyaWdnZXJlZCBieSBhIGZsdXNoU3luY1xuICAgICAgICAgICAgICogaW5zaWRlIGFuIGV4aXN0aW5nIHByb2Nlc3MuIEluc3RlYWQgb2YgZXhlY3V0aW5nLCBtYXJrIGZsdXNoTmV4dEZyYW1lXG4gICAgICAgICAgICAgKiBhcyB0cnVlIGFuZCBlbnN1cmUgd2UgZmx1c2ggdGhlIGZvbGxvd2luZyBmcmFtZSBhdCB0aGUgZW5kIG9mIHRoaXMgb25lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNQcm9jZXNzaW5nKSB7XG4gICAgICAgICAgICAgICAgZmx1c2hOZXh0RnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgICAgICBbdGhpc0ZyYW1lLCBuZXh0RnJhbWVdID0gW25leHRGcmFtZSwgdGhpc0ZyYW1lXTtcbiAgICAgICAgICAgIC8vIEV4ZWN1dGUgdGhpcyBmcmFtZVxuICAgICAgICAgICAgdGhpc0ZyYW1lLmZvckVhY2godHJpZ2dlckNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBmcmFtZSBzbyBubyBjYWxsYmFja3MgcmVtYWluLiBUaGlzIGlzIHRvIGF2b2lkXG4gICAgICAgICAgICAvLyBtZW1vcnkgbGVha3Mgc2hvdWxkIHRoaXMgcmVuZGVyIHN0ZXAgbm90IHJ1biBmb3IgYSB3aGlsZS5cbiAgICAgICAgICAgIHRoaXNGcmFtZS5jbGVhcigpO1xuICAgICAgICAgICAgaXNQcm9jZXNzaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZmx1c2hOZXh0RnJhbWUpIHtcbiAgICAgICAgICAgICAgICBmbHVzaE5leHRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHN0ZXAucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIHN0ZXA7XG59XG5cbmNvbnN0IHN0ZXBzT3JkZXIgPSBbXG4gICAgXCJyZWFkXCIsIC8vIFJlYWRcbiAgICBcInJlc29sdmVLZXlmcmFtZXNcIiwgLy8gV3JpdGUvUmVhZC9Xcml0ZS9SZWFkXG4gICAgXCJ1cGRhdGVcIiwgLy8gQ29tcHV0ZVxuICAgIFwicHJlUmVuZGVyXCIsIC8vIENvbXB1dGVcbiAgICBcInJlbmRlclwiLCAvLyBXcml0ZVxuICAgIFwicG9zdFJlbmRlclwiLCAvLyBDb21wdXRlXG5dO1xuY29uc3QgbWF4RWxhcHNlZCQxID0gNDA7XG5mdW5jdGlvbiBjcmVhdGVSZW5kZXJCYXRjaGVyKHNjaGVkdWxlTmV4dEJhdGNoLCBhbGxvd0tlZXBBbGl2ZSkge1xuICAgIGxldCBydW5OZXh0RnJhbWUgPSBmYWxzZTtcbiAgICBsZXQgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgIGNvbnN0IHN0YXRlID0ge1xuICAgICAgICBkZWx0YTogMC4wLFxuICAgICAgICB0aW1lc3RhbXA6IDAuMCxcbiAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSxcbiAgICB9O1xuICAgIGNvbnN0IGZsYWdSdW5OZXh0RnJhbWUgPSAoKSA9PiAocnVuTmV4dEZyYW1lID0gdHJ1ZSk7XG4gICAgY29uc3Qgc3RlcHMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgYWNjW2tleV0gPSBjcmVhdGVSZW5kZXJTdGVwKGZsYWdSdW5OZXh0RnJhbWUpO1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCB7IHJlYWQsIHJlc29sdmVLZXlmcmFtZXMsIHVwZGF0ZSwgcHJlUmVuZGVyLCByZW5kZXIsIHBvc3RSZW5kZXIgfSA9IHN0ZXBzO1xuICAgIGNvbnN0IHByb2Nlc3NCYXRjaCA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgdGltZXN0YW1wID0gTW90aW9uR2xvYmFsQ29uZmlnLnVzZU1hbnVhbFRpbWluZ1xuICAgICAgICAgICAgPyBzdGF0ZS50aW1lc3RhbXBcbiAgICAgICAgICAgIDogcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJ1bk5leHRGcmFtZSA9IGZhbHNlO1xuICAgICAgICBzdGF0ZS5kZWx0YSA9IHVzZURlZmF1bHRFbGFwc2VkXG4gICAgICAgICAgICA/IDEwMDAgLyA2MFxuICAgICAgICAgICAgOiBNYXRoLm1heChNYXRoLm1pbih0aW1lc3RhbXAgLSBzdGF0ZS50aW1lc3RhbXAsIG1heEVsYXBzZWQkMSksIDEpO1xuICAgICAgICBzdGF0ZS50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG4gICAgICAgIHN0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7XG4gICAgICAgIC8vIFVucm9sbGVkIHJlbmRlciBsb29wIGZvciBiZXR0ZXIgcGVyLWZyYW1lIHBlcmZvcm1hbmNlXG4gICAgICAgIHJlYWQucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHJlc29sdmVLZXlmcmFtZXMucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHVwZGF0ZS5wcm9jZXNzKHN0YXRlKTtcbiAgICAgICAgcHJlUmVuZGVyLnByb2Nlc3Moc3RhdGUpO1xuICAgICAgICByZW5kZXIucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHBvc3RSZW5kZXIucHJvY2VzcyhzdGF0ZSk7XG4gICAgICAgIHN0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICBpZiAocnVuTmV4dEZyYW1lICYmIGFsbG93S2VlcEFsaXZlKSB7XG4gICAgICAgICAgICB1c2VEZWZhdWx0RWxhcHNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2NoZWR1bGVOZXh0QmF0Y2gocHJvY2Vzc0JhdGNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgd2FrZSA9ICgpID0+IHtcbiAgICAgICAgcnVuTmV4dEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgdXNlRGVmYXVsdEVsYXBzZWQgPSB0cnVlO1xuICAgICAgICBpZiAoIXN0YXRlLmlzUHJvY2Vzc2luZykge1xuICAgICAgICAgICAgc2NoZWR1bGVOZXh0QmF0Y2gocHJvY2Vzc0JhdGNoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc2NoZWR1bGUgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICAgICAgY29uc3Qgc3RlcCA9IHN0ZXBzW2tleV07XG4gICAgICAgIGFjY1trZXldID0gKHByb2Nlc3MsIGtlZXBBbGl2ZSA9IGZhbHNlLCBpbW1lZGlhdGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFydW5OZXh0RnJhbWUpXG4gICAgICAgICAgICAgICAgd2FrZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHN0ZXAuc2NoZWR1bGUocHJvY2Vzcywga2VlcEFsaXZlLCBpbW1lZGlhdGUpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICBjb25zdCBjYW5jZWwgPSAocHJvY2VzcykgPT4ge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ZXBzT3JkZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHN0ZXBzW3N0ZXBzT3JkZXJbaV1dLmNhbmNlbChwcm9jZXNzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHsgc2NoZWR1bGUsIGNhbmNlbCwgc3RhdGUsIHN0ZXBzIH07XG59XG5cbmNvbnN0IHsgc2NoZWR1bGU6IGZyYW1lLCBjYW5jZWw6IGNhbmNlbEZyYW1lLCBzdGF0ZTogZnJhbWVEYXRhLCBzdGVwczogZnJhbWVTdGVwcywgfSA9IGNyZWF0ZVJlbmRlckJhdGNoZXIodHlwZW9mIHJlcXVlc3RBbmltYXRpb25GcmFtZSAhPT0gXCJ1bmRlZmluZWRcIiA/IHJlcXVlc3RBbmltYXRpb25GcmFtZSA6IG1vdGlvblV0aWxzLm5vb3AsIHRydWUpO1xuXG4vKipcbiAqIEdlbmVyYXRlIGEgbGlzdCBvZiBldmVyeSBwb3NzaWJsZSB0cmFuc2Zvcm0ga2V5LlxuICovXG5jb25zdCB0cmFuc2Zvcm1Qcm9wT3JkZXIgPSBbXG4gICAgXCJ0cmFuc2Zvcm1QZXJzcGVjdGl2ZVwiLFxuICAgIFwieFwiLFxuICAgIFwieVwiLFxuICAgIFwielwiLFxuICAgIFwidHJhbnNsYXRlWFwiLFxuICAgIFwidHJhbnNsYXRlWVwiLFxuICAgIFwidHJhbnNsYXRlWlwiLFxuICAgIFwic2NhbGVcIixcbiAgICBcInNjYWxlWFwiLFxuICAgIFwic2NhbGVZXCIsXG4gICAgXCJyb3RhdGVcIixcbiAgICBcInJvdGF0ZVhcIixcbiAgICBcInJvdGF0ZVlcIixcbiAgICBcInJvdGF0ZVpcIixcbiAgICBcInNrZXdcIixcbiAgICBcInNrZXdYXCIsXG4gICAgXCJza2V3WVwiLFxuXTtcbi8qKlxuICogQSBxdWljayBsb29rdXAgZm9yIHRyYW5zZm9ybSBwcm9wcy5cbiAqL1xuY29uc3QgdHJhbnNmb3JtUHJvcHMgPSBuZXcgU2V0KHRyYW5zZm9ybVByb3BPcmRlcik7XG5cbmNvbnN0IHBvc2l0aW9uYWxLZXlzID0gbmV3IFNldChbXG4gICAgXCJ3aWR0aFwiLFxuICAgIFwiaGVpZ2h0XCIsXG4gICAgXCJ0b3BcIixcbiAgICBcImxlZnRcIixcbiAgICBcInJpZ2h0XCIsXG4gICAgXCJib3R0b21cIixcbiAgICAuLi50cmFuc2Zvcm1Qcm9wT3JkZXIsXG5dKTtcblxuY29uc3QgaXNDdXN0b21WYWx1ZSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4odiAmJiB0eXBlb2YgdiA9PT0gXCJvYmplY3RcIiAmJiB2Lm1peCAmJiB2LnRvVmFsdWUpO1xufTtcbmNvbnN0IHJlc29sdmVGaW5hbFZhbHVlSW5LZXlmcmFtZXMgPSAodikgPT4ge1xuICAgIC8vIFRPRE8gbWF5YmUgdGhyb3cgaWYgdi5sZW5ndGggLSAxIGlzIHBsYWNlaG9sZGVyIHRva2VuP1xuICAgIHJldHVybiBpc0tleWZyYW1lc1RhcmdldCh2KSA/IHZbdi5sZW5ndGggLSAxXSB8fCAwIDogdjtcbn07XG5cbmxldCBub3c7XG5mdW5jdGlvbiBjbGVhclRpbWUoKSB7XG4gICAgbm93ID0gdW5kZWZpbmVkO1xufVxuLyoqXG4gKiBBbiBldmVudGxvb3Atc3luY2hyb25vdXMgYWx0ZXJuYXRpdmUgdG8gcGVyZm9ybWFuY2Uubm93KCkuXG4gKlxuICogRW5zdXJlcyB0aGF0IHRpbWUgbWVhc3VyZW1lbnRzIHJlbWFpbiBjb25zaXN0ZW50IHdpdGhpbiBhIHN5bmNocm9ub3VzIGNvbnRleHQuXG4gKiBVc3VhbGx5IGNhbGxpbmcgcGVyZm9ybWFuY2Uubm93KCkgdHdpY2Ugd2l0aGluIHRoZSBzYW1lIHN5bmNocm9ub3VzIGNvbnRleHRcbiAqIHdpbGwgcmV0dXJuIGRpZmZlcmVudCB2YWx1ZXMgd2hpY2ggaXNuJ3QgdXNlZnVsIGZvciBhbmltYXRpb25zIHdoZW4gd2UncmUgdXN1YWxseVxuICogdHJ5aW5nIHRvIHN5bmMgYW5pbWF0aW9ucyB0byB0aGUgc2FtZSBmcmFtZS5cbiAqL1xuY29uc3QgdGltZSA9IHtcbiAgICBub3c6ICgpID0+IHtcbiAgICAgICAgaWYgKG5vdyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aW1lLnNldChmcmFtZURhdGEuaXNQcm9jZXNzaW5nIHx8IE1vdGlvbkdsb2JhbENvbmZpZy51c2VNYW51YWxUaW1pbmdcbiAgICAgICAgICAgICAgICA/IGZyYW1lRGF0YS50aW1lc3RhbXBcbiAgICAgICAgICAgICAgICA6IHBlcmZvcm1hbmNlLm5vdygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm93O1xuICAgIH0sXG4gICAgc2V0OiAobmV3VGltZSkgPT4ge1xuICAgICAgICBub3cgPSBuZXdUaW1lO1xuICAgICAgICBxdWV1ZU1pY3JvdGFzayhjbGVhclRpbWUpO1xuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBhZGRVbmlxdWVJdGVtKGFyciwgaXRlbSkge1xuICAgIGlmIChhcnIuaW5kZXhPZihpdGVtKSA9PT0gLTEpXG4gICAgICAgIGFyci5wdXNoKGl0ZW0pO1xufVxuZnVuY3Rpb24gcmVtb3ZlSXRlbShhcnIsIGl0ZW0pIHtcbiAgICBjb25zdCBpbmRleCA9IGFyci5pbmRleE9mKGl0ZW0pO1xuICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICBhcnIuc3BsaWNlKGluZGV4LCAxKTtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBhcnJheS1tb3ZlXG5mdW5jdGlvbiBtb3ZlSXRlbShbLi4uYXJyXSwgZnJvbUluZGV4LCB0b0luZGV4KSB7XG4gICAgY29uc3Qgc3RhcnRJbmRleCA9IGZyb21JbmRleCA8IDAgPyBhcnIubGVuZ3RoICsgZnJvbUluZGV4IDogZnJvbUluZGV4O1xuICAgIGlmIChzdGFydEluZGV4ID49IDAgJiYgc3RhcnRJbmRleCA8IGFyci5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZW5kSW5kZXggPSB0b0luZGV4IDwgMCA/IGFyci5sZW5ndGggKyB0b0luZGV4IDogdG9JbmRleDtcbiAgICAgICAgY29uc3QgW2l0ZW1dID0gYXJyLnNwbGljZShmcm9tSW5kZXgsIDEpO1xuICAgICAgICBhcnIuc3BsaWNlKGVuZEluZGV4LCAwLCBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycjtcbn1cblxuY2xhc3MgU3Vic2NyaXB0aW9uTWFuYWdlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IFtdO1xuICAgIH1cbiAgICBhZGQoaGFuZGxlcikge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgICAgIHJldHVybiAoKSA9PiByZW1vdmVJdGVtKHRoaXMuc3Vic2NyaXB0aW9ucywgaGFuZGxlcik7XG4gICAgfVxuICAgIG5vdGlmeShhLCBiLCBjKSB7XG4gICAgICAgIGNvbnN0IG51bVN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoO1xuICAgICAgICBpZiAoIW51bVN1YnNjcmlwdGlvbnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmIChudW1TdWJzY3JpcHRpb25zID09PSAxKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZXJlJ3Mgb25seSBhIHNpbmdsZSBoYW5kbGVyIHdlIGNhbiBqdXN0IGNhbGwgaXQgd2l0aG91dCBpbnZva2luZyBhIGxvb3AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc1swXShhLCBiLCBjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3Vic2NyaXB0aW9uczsgaSsrKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ2hlY2sgd2hldGhlciB0aGUgaGFuZGxlciBleGlzdHMgYmVmb3JlIGZpcmluZyBhcyBpdCdzIHBvc3NpYmxlXG4gICAgICAgICAgICAgICAgICogdGhlIHN1YnNjcmlwdGlvbnMgd2VyZSBtb2RpZmllZCBkdXJpbmcgdGhpcyBsb29wIHJ1bm5pbmcuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuc3Vic2NyaXB0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICBoYW5kbGVyICYmIGhhbmRsZXIoYSwgYiwgYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3Vic2NyaXB0aW9ucy5sZW5ndGg7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMubGVuZ3RoID0gMDtcbiAgICB9XG59XG5cbi8qXG4gIENvbnZlcnQgdmVsb2NpdHkgaW50byB2ZWxvY2l0eSBwZXIgc2Vjb25kXG5cbiAgQHBhcmFtIFtudW1iZXJdOiBVbml0IHBlciBmcmFtZVxuICBAcGFyYW0gW251bWJlcl06IEZyYW1lIGR1cmF0aW9uIGluIG1zXG4qL1xuZnVuY3Rpb24gdmVsb2NpdHlQZXJTZWNvbmQodmVsb2NpdHksIGZyYW1lRHVyYXRpb24pIHtcbiAgICByZXR1cm4gZnJhbWVEdXJhdGlvbiA/IHZlbG9jaXR5ICogKDEwMDAgLyBmcmFtZUR1cmF0aW9uKSA6IDA7XG59XG5cbmNvbnN0IHdhcm5lZCA9IG5ldyBTZXQoKTtcbmZ1bmN0aW9uIHdhcm5PbmNlKGNvbmRpdGlvbiwgbWVzc2FnZSwgZWxlbWVudCkge1xuICAgIGlmIChjb25kaXRpb24gfHwgd2FybmVkLmhhcyhtZXNzYWdlKSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnNvbGUud2FybihtZXNzYWdlKTtcbiAgICBpZiAoZWxlbWVudClcbiAgICAgICAgY29uc29sZS53YXJuKGVsZW1lbnQpO1xuICAgIHdhcm5lZC5hZGQobWVzc2FnZSk7XG59XG5cbi8qKlxuICogTWF4aW11bSB0aW1lIGJldHdlZW4gdGhlIHZhbHVlIG9mIHR3byBmcmFtZXMsIGJleW9uZCB3aGljaCB3ZVxuICogYXNzdW1lIHRoZSB2ZWxvY2l0eSBoYXMgc2luY2UgYmVlbiAwLlxuICovXG5jb25zdCBNQVhfVkVMT0NJVFlfREVMVEEgPSAzMDtcbmNvbnN0IGlzRmxvYXQgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQodmFsdWUpKTtcbn07XG5jb25zdCBjb2xsZWN0TW90aW9uVmFsdWVzID0ge1xuICAgIGN1cnJlbnQ6IHVuZGVmaW5lZCxcbn07XG4vKipcbiAqIGBNb3Rpb25WYWx1ZWAgaXMgdXNlZCB0byB0cmFjayB0aGUgc3RhdGUgYW5kIHZlbG9jaXR5IG9mIG1vdGlvbiB2YWx1ZXMuXG4gKlxuICogQHB1YmxpY1xuICovXG5jbGFzcyBNb3Rpb25WYWx1ZSB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGluaXQgLSBUaGUgaW5pdGlhdGluZyB2YWx1ZVxuICAgICAqIEBwYXJhbSBjb25maWcgLSBPcHRpb25hbCBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICAgKlxuICAgICAqIC0gIGB0cmFuc2Zvcm1lcmA6IEEgZnVuY3Rpb24gdG8gdHJhbnNmb3JtIGluY29taW5nIHZhbHVlcyB3aXRoLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaW5pdCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHdpbGwgYmUgcmVwbGFjZWQgYnkgdGhlIGJ1aWxkIHN0ZXAgd2l0aCB0aGUgbGF0ZXN0IHZlcnNpb24gbnVtYmVyLlxuICAgICAgICAgKiBXaGVuIE1vdGlvblZhbHVlcyBhcmUgcHJvdmlkZWQgdG8gbW90aW9uIGNvbXBvbmVudHMsIHdhcm4gaWYgdmVyc2lvbnMgYXJlIG1peGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52ZXJzaW9uID0gXCIxMS4xOC4yXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUcmFja3Mgd2hldGhlciB0aGlzIHZhbHVlIGNhbiBvdXRwdXQgYSB2ZWxvY2l0eS4gQ3VycmVudGx5IHRoaXMgaXMgb25seSB0cnVlXG4gICAgICAgICAqIGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljYWwsIGJ1dCB3ZSBtaWdodCBiZSBhYmxlIHRvIHdpZGVuIHRoZSBzY29wZSBoZXJlIGFuZCBzdXBwb3J0XG4gICAgICAgICAqIG90aGVyIHZhbHVlIHR5cGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAaW50ZXJuYWxcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY2FuVHJhY2tWZWxvY2l0eSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBhIFN1YnNjcmlwdGlvbk1hbmFnZXIgZm9yIGVhY2ggYWN0aXZlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgdGhpcy51cGRhdGVBbmROb3RpZnkgPSAodiwgcmVuZGVyID0gdHJ1ZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudFRpbWUgPSB0aW1lLm5vdygpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSB1cGRhdGluZyB0aGUgdmFsdWUgZHVyaW5nIGFub3RoZXIgZnJhbWUgb3IgZXZlbnRsb29wXG4gICAgICAgICAgICAgKiB0aGFuIHRoZSBwcmV2aW91cyBmcmFtZSwgdGhlbiB0aGUgd2Ugc2V0IHRoZSBwcmV2aW91cyBmcmFtZSB2YWx1ZVxuICAgICAgICAgICAgICogdG8gY3VycmVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMudXBkYXRlZEF0ICE9PSBjdXJyZW50VGltZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0UHJldkZyYW1lVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucHJldiA9IHRoaXMuY3VycmVudDtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3VycmVudCh2KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB1cGRhdGUgc3Vic2NyaWJlcnNcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQgIT09IHRoaXMucHJldiAmJiB0aGlzLmV2ZW50cy5jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5jaGFuZ2Uubm90aWZ5KHRoaXMuY3VycmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgcmVuZGVyIHN1YnNjcmliZXJzXG4gICAgICAgICAgICBpZiAocmVuZGVyICYmIHRoaXMuZXZlbnRzLnJlbmRlclJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5yZW5kZXJSZXF1ZXN0Lm5vdGlmeSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2V0Q3VycmVudChpbml0KTtcbiAgICAgICAgdGhpcy5vd25lciA9IG9wdGlvbnMub3duZXI7XG4gICAgfVxuICAgIHNldEN1cnJlbnQoY3VycmVudCkge1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICB0aGlzLnVwZGF0ZWRBdCA9IHRpbWUubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmNhblRyYWNrVmVsb2NpdHkgPT09IG51bGwgJiYgY3VycmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmNhblRyYWNrVmVsb2NpdHkgPSBpc0Zsb2F0KHRoaXMuY3VycmVudCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0UHJldkZyYW1lVmFsdWUocHJldkZyYW1lVmFsdWUgPSB0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgdGhpcy5wcmV2RnJhbWVWYWx1ZSA9IHByZXZGcmFtZVZhbHVlO1xuICAgICAgICB0aGlzLnByZXZVcGRhdGVkQXQgPSB0aGlzLnVwZGF0ZWRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBiZSBub3RpZmllZCB3aGVuIHRoZSBgTW90aW9uVmFsdWVgIGlzIHVwZGF0ZWQuXG4gICAgICpcbiAgICAgKiBJdCByZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIHdpbGwgY2FuY2VsIHRoZSBzdWJzY3JpcHRpb24uXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxpbmcgYG9uQ2hhbmdlYCBpbnNpZGUgYSBSZWFjdCBjb21wb25lbnQsIGl0IHNob3VsZCBiZSB3cmFwcGVkIHdpdGggdGhlXG4gICAgICogYHVzZUVmZmVjdGAgaG9vay4gQXMgaXQgcmV0dXJucyBhbiB1bnN1YnNjcmliZSBmdW5jdGlvbiwgdGhpcyBzaG91bGQgYmUgcmV0dXJuZWRcbiAgICAgKiBmcm9tIHRoZSBgdXNlRWZmZWN0YCBmdW5jdGlvbiB0byBlbnN1cmUgeW91IGRvbid0IGFkZCBkdXBsaWNhdGUgc3Vic2NyaWJlcnMuLlxuICAgICAqXG4gICAgICogYGBganN4XG4gICAgICogZXhwb3J0IGNvbnN0IE15Q29tcG9uZW50ID0gKCkgPT4ge1xuICAgICAqICAgY29uc3QgeCA9IHVzZU1vdGlvblZhbHVlKDApXG4gICAgICogICBjb25zdCB5ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiAgIGNvbnN0IG9wYWNpdHkgPSB1c2VNb3Rpb25WYWx1ZSgxKVxuICAgICAqXG4gICAgICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgICAqICAgICBmdW5jdGlvbiB1cGRhdGVPcGFjaXR5KCkge1xuICAgICAqICAgICAgIGNvbnN0IG1heFhZID0gTWF0aC5tYXgoeC5nZXQoKSwgeS5nZXQoKSlcbiAgICAgKiAgICAgICBjb25zdCBuZXdPcGFjaXR5ID0gdHJhbnNmb3JtKG1heFhZLCBbMCwgMTAwXSwgWzEsIDBdKVxuICAgICAqICAgICAgIG9wYWNpdHkuc2V0KG5ld09wYWNpdHkpXG4gICAgICogICAgIH1cbiAgICAgKlxuICAgICAqICAgICBjb25zdCB1bnN1YnNjcmliZVggPSB4Lm9uKFwiY2hhbmdlXCIsIHVwZGF0ZU9wYWNpdHkpXG4gICAgICogICAgIGNvbnN0IHVuc3Vic2NyaWJlWSA9IHkub24oXCJjaGFuZ2VcIiwgdXBkYXRlT3BhY2l0eSlcbiAgICAgKlxuICAgICAqICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAqICAgICAgIHVuc3Vic2NyaWJlWCgpXG4gICAgICogICAgICAgdW5zdWJzY3JpYmVZKClcbiAgICAgKiAgICAgfVxuICAgICAqICAgfSwgW10pXG4gICAgICpcbiAgICAgKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyB4IH19IC8+XG4gICAgICogfVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIHN1YnNjcmliZXIgLSBBIGZ1bmN0aW9uIHRoYXQgcmVjZWl2ZXMgdGhlIGxhdGVzdCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCB3aWxsIGNhbmNlbCB0aGlzIHN1YnNjcmlwdGlvbi5cbiAgICAgKlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgb25DaGFuZ2Uoc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgIHdhcm5PbmNlKGZhbHNlLCBgdmFsdWUub25DaGFuZ2UoY2FsbGJhY2spIGlzIGRlcHJlY2F0ZWQuIFN3aXRjaCB0byB2YWx1ZS5vbihcImNoYW5nZVwiLCBjYWxsYmFjaykuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMub24oXCJjaGFuZ2VcIiwgc3Vic2NyaXB0aW9uKTtcbiAgICB9XG4gICAgb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZXZlbnRzW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgICAgIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0gPSBuZXcgU3Vic2NyaXB0aW9uTWFuYWdlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gdGhpcy5ldmVudHNbZXZlbnROYW1lXS5hZGQoY2FsbGJhY2spO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImNoYW5nZVwiKSB7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UgaGF2ZSBubyBtb3JlIGNoYW5nZSBsaXN0ZW5lcnMgYnkgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgICogb2YgdGhlIG5leHQgZnJhbWUsIHN0b3AgYWN0aXZlIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnJhbWUucmVhZCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5ldmVudHMuY2hhbmdlLmdldFNpemUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdG9wKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVuc3Vic2NyaWJlO1xuICAgIH1cbiAgICBjbGVhckxpc3RlbmVycygpIHtcbiAgICAgICAgZm9yIChjb25zdCBldmVudE1hbmFnZXJzIGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1tldmVudE1hbmFnZXJzXS5jbGVhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGEgcGFzc2l2ZSBlZmZlY3QgdG8gdGhlIGBNb3Rpb25WYWx1ZWAuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBhdHRhY2gocGFzc2l2ZUVmZmVjdCwgc3RvcFBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgdGhpcy5wYXNzaXZlRWZmZWN0ID0gcGFzc2l2ZUVmZmVjdDtcbiAgICAgICAgdGhpcy5zdG9wUGFzc2l2ZUVmZmVjdCA9IHN0b3BQYXNzaXZlRWZmZWN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGF0ZSBvZiB0aGUgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIEByZW1hcmtzXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAgICAgKiB4LnNldCgxMClcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBsYXRlc3QgLSBMYXRlc3QgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSByZW5kZXIgLSBXaGV0aGVyIHRvIG5vdGlmeSByZW5kZXIgc3Vic2NyaWJlcnMuIERlZmF1bHRzIHRvIGB0cnVlYFxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNldCh2LCByZW5kZXIgPSB0cnVlKSB7XG4gICAgICAgIGlmICghcmVuZGVyIHx8ICF0aGlzLnBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQW5kTm90aWZ5KHYsIHJlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhc3NpdmVFZmZlY3QodiwgdGhpcy51cGRhdGVBbmROb3RpZnkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNldFdpdGhWZWxvY2l0eShwcmV2LCBjdXJyZW50LCBkZWx0YSkge1xuICAgICAgICB0aGlzLnNldChjdXJyZW50KTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnByZXZGcmFtZVZhbHVlID0gcHJldjtcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlZEF0ID0gdGhpcy51cGRhdGVkQXQgLSBkZWx0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzdGF0ZSBvZiB0aGUgYE1vdGlvblZhbHVlYCwgc3RvcHBpbmcgYW55IGFjdGl2ZSBhbmltYXRpb25zLFxuICAgICAqIGVmZmVjdHMsIGFuZCByZXNldHMgdmVsb2NpdHkgdG8gYDBgLlxuICAgICAqL1xuICAgIGp1bXAodiwgZW5kQW5pbWF0aW9uID0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFuZE5vdGlmeSh2KTtcbiAgICAgICAgdGhpcy5wcmV2ID0gdjtcbiAgICAgICAgdGhpcy5wcmV2VXBkYXRlZEF0ID0gdGhpcy5wcmV2RnJhbWVWYWx1ZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgZW5kQW5pbWF0aW9uICYmIHRoaXMuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5zdG9wUGFzc2l2ZUVmZmVjdClcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGF0ZXN0IHN0YXRlIG9mIGBNb3Rpb25WYWx1ZWBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIC0gVGhlIGxhdGVzdCBzdGF0ZSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0KCkge1xuICAgICAgICBpZiAoY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb2xsZWN0TW90aW9uVmFsdWVzLmN1cnJlbnQucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0UHJldmlvdXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXY7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxhdGVzdCB2ZWxvY2l0eSBvZiBgTW90aW9uVmFsdWVgXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyAtIFRoZSBsYXRlc3QgdmVsb2NpdHkgb2YgYE1vdGlvblZhbHVlYC4gUmV0dXJucyBgMGAgaWYgdGhlIHN0YXRlIGlzIG5vbi1udW1lcmljYWwuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0VmVsb2NpdHkoKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaW1lID0gdGltZS5ub3coKTtcbiAgICAgICAgaWYgKCF0aGlzLmNhblRyYWNrVmVsb2NpdHkgfHxcbiAgICAgICAgICAgIHRoaXMucHJldkZyYW1lVmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgICAgICAgY3VycmVudFRpbWUgLSB0aGlzLnVwZGF0ZWRBdCA+IE1BWF9WRUxPQ0lUWV9ERUxUQSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVsdGEgPSBNYXRoLm1pbih0aGlzLnVwZGF0ZWRBdCAtIHRoaXMucHJldlVwZGF0ZWRBdCwgTUFYX1ZFTE9DSVRZX0RFTFRBKTtcbiAgICAgICAgLy8gQ2FzdHMgYmVjYXVzZSBvZiBwYXJzZUZsb2F0J3MgcG9vciB0eXBpbmdcbiAgICAgICAgcmV0dXJuIHZlbG9jaXR5UGVyU2Vjb25kKHBhcnNlRmxvYXQodGhpcy5jdXJyZW50KSAtXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMucHJldkZyYW1lVmFsdWUpLCBkZWx0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVycyBhIG5ldyBhbmltYXRpb24gdG8gY29udHJvbCB0aGlzIGBNb3Rpb25WYWx1ZWAuIE9ubHkgb25lXG4gICAgICogYW5pbWF0aW9uIGNhbiBkcml2ZSBhIGBNb3Rpb25WYWx1ZWAgYXQgb25lIHRpbWUuXG4gICAgICpcbiAgICAgKiBgYGBqc3hcbiAgICAgKiB2YWx1ZS5zdGFydCgpXG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYW5pbWF0aW9uIC0gQSBmdW5jdGlvbiB0aGF0IHN0YXJ0cyB0aGUgcHJvdmlkZWQgYW5pbWF0aW9uXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGFydChzdGFydEFuaW1hdGlvbikge1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhhc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uID0gc3RhcnRBbmltYXRpb24ocmVzb2x2ZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uU3RhcnQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25TdGFydC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5ldmVudHMuYW5pbWF0aW9uQ29tcGxldGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50cy5hbmltYXRpb25Db21wbGV0ZS5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY2xlYXJBbmltYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN0b3AgdGhlIGN1cnJlbnRseSBhY3RpdmUgYW5pbWF0aW9uLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGlmICh0aGlzLmFuaW1hdGlvbikge1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRzLmFuaW1hdGlvbkNhbmNlbC5ub3RpZnkoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyQW5pbWF0aW9uKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoaXMgdmFsdWUgaXMgY3VycmVudGx5IGFuaW1hdGluZy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpc0FuaW1hdGluZygpIHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIGNsZWFyQW5pbWF0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5hbmltYXRpb247XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlc3Ryb3kgYW5kIGNsZWFuIHVwIHN1YnNjcmliZXJzIHRvIHRoaXMgYE1vdGlvblZhbHVlYC5cbiAgICAgKlxuICAgICAqIFRoZSBgTW90aW9uVmFsdWVgIGhvb2tzIGxpa2UgYHVzZU1vdGlvblZhbHVlYCBhbmQgYHVzZVRyYW5zZm9ybWAgYXV0b21hdGljYWxseVxuICAgICAqIGhhbmRsZSB0aGUgbGlmZWN5Y2xlIG9mIHRoZSByZXR1cm5lZCBgTW90aW9uVmFsdWVgLCBzbyB0aGlzIG1ldGhvZCBpcyBvbmx5IG5lY2Vzc2FyeSBpZiB5b3UndmUgbWFudWFsbHlcbiAgICAgKiBjcmVhdGVkIGEgYE1vdGlvblZhbHVlYCB2aWEgdGhlIGBtb3Rpb25WYWx1ZWAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jbGVhckxpc3RlbmVycygpO1xuICAgICAgICB0aGlzLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcFBhc3NpdmVFZmZlY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIG1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1vdGlvblZhbHVlKGluaXQsIG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIFNldCBWaXN1YWxFbGVtZW50J3MgTW90aW9uVmFsdWUsIGNyZWF0aW5nIGEgbmV3IE1vdGlvblZhbHVlIGZvciBpdCBpZlxuICogaXQgZG9lc24ndCBleGlzdC5cbiAqL1xuZnVuY3Rpb24gc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSkge1xuICAgIGlmICh2aXN1YWxFbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpLnNldCh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2aXN1YWxFbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUodmFsdWUpKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbikge1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgbGV0IHsgdHJhbnNpdGlvbkVuZCA9IHt9LCB0cmFuc2l0aW9uID0ge30sIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQgfHwge307XG4gICAgdGFyZ2V0ID0geyAuLi50YXJnZXQsIC4uLnRyYW5zaXRpb25FbmQgfTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSByZXNvbHZlRmluYWxWYWx1ZUluS2V5ZnJhbWVzKHRhcmdldFtrZXldKTtcbiAgICAgICAgc2V0TW90aW9uVmFsdWUodmlzdWFsRWxlbWVudCwga2V5LCB2YWx1ZSk7XG4gICAgfVxufVxuXG5jb25zdCBpc01vdGlvblZhbHVlID0gKHZhbHVlKSA9PiBCb29sZWFuKHZhbHVlICYmIHZhbHVlLmdldFZlbG9jaXR5KTtcblxuZnVuY3Rpb24gaXNXaWxsQ2hhbmdlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpc01vdGlvblZhbHVlKHZhbHVlKSAmJiB2YWx1ZS5hZGQpO1xufVxuXG5mdW5jdGlvbiBhZGRWYWx1ZVRvV2lsbENoYW5nZSh2aXN1YWxFbGVtZW50LCBrZXkpIHtcbiAgICBjb25zdCB3aWxsQ2hhbmdlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShcIndpbGxDaGFuZ2VcIik7XG4gICAgLyoqXG4gICAgICogSXQgY291bGQgYmUgdGhhdCBhIHVzZXIgaGFzIHNldCB3aWxsQ2hhbmdlIHRvIGEgcmVndWxhciBNb3Rpb25WYWx1ZSxcbiAgICAgKiBpbiB3aGljaCBjYXNlIHdlIGNhbid0IGFkZCB0aGUgdmFsdWUgdG8gaXQuXG4gICAgICovXG4gICAgaWYgKGlzV2lsbENoYW5nZU1vdGlvblZhbHVlKHdpbGxDaGFuZ2UpKSB7XG4gICAgICAgIHJldHVybiB3aWxsQ2hhbmdlLmFkZChrZXkpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGNhbWVsQ2FzZSB0byBkYXNoLWNhc2UgcHJvcGVydGllcy5cbiAqL1xuY29uc3QgY2FtZWxUb0Rhc2ggPSAoc3RyKSA9PiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZ3UsIFwiJDEtJDJcIikudG9Mb3dlckNhc2UoKTtcblxuY29uc3Qgb3B0aW1pemVkQXBwZWFyRGF0YUlkID0gXCJmcmFtZXJBcHBlYXJJZFwiO1xuY29uc3Qgb3B0aW1pemVkQXBwZWFyRGF0YUF0dHJpYnV0ZSA9IFwiZGF0YS1cIiArIGNhbWVsVG9EYXNoKG9wdGltaXplZEFwcGVhckRhdGFJZCk7XG5cbmZ1bmN0aW9uIGdldE9wdGltaXNlZEFwcGVhcklkKHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gdmlzdWFsRWxlbWVudC5wcm9wc1tvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlXTtcbn1cblxuY29uc3QgaW5zdGFudEFuaW1hdGlvblN0YXRlID0ge1xuICAgIGN1cnJlbnQ6IGZhbHNlLFxufTtcblxuLypcbiAgQmV6aWVyIGZ1bmN0aW9uIGdlbmVyYXRvclxuICBUaGlzIGhhcyBiZWVuIG1vZGlmaWVkIGZyb20gR2HDq3RhbiBSZW5hdWRlYXUncyBCZXppZXJFYXNpbmdcbiAgaHR0cHM6Ly9naXRodWIuY29tL2dyZS9iZXppZXItZWFzaW5nL2Jsb2IvbWFzdGVyL3NyYy9pbmRleC5qc1xuICBodHRwczovL2dpdGh1Yi5jb20vZ3JlL2Jlemllci1lYXNpbmcvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICBcbiAgSSd2ZSByZW1vdmVkIHRoZSBuZXd0b25SYXBoc29uSXRlcmF0ZSBhbGdvIGJlY2F1c2UgaW4gYmVuY2htYXJraW5nIGl0XG4gIHdhc24ndCBub3RpY2lhYmx5IGZhc3RlciB0aGFuIGJpbmFyeVN1YmRpdmlzaW9uLCBpbmRlZWQgcmVtb3ZpbmcgaXRcbiAgdXN1YWxseSBpbXByb3ZlZCB0aW1lcywgZGVwZW5kaW5nIG9uIHRoZSBjdXJ2ZS5cbiAgSSBhbHNvIHJlbW92ZWQgdGhlIGxvb2t1cCB0YWJsZSwgYXMgZm9yIHRoZSBhZGRlZCBidW5kbGUgc2l6ZSBhbmQgbG9vcCB3ZSdyZVxuICBvbmx5IGN1dHRpbmcgfjQgb3Igc28gc3ViZGl2aXNpb24gaXRlcmF0aW9ucy4gSSBidW1wZWQgdGhlIG1heCBpdGVyYXRpb25zIHVwXG4gIHRvIDEyIHRvIGNvbXBlbnNhdGUgYW5kIHRoaXMgc3RpbGwgdGVuZGVkIHRvIGJlIGZhc3RlciBmb3Igbm8gcGVyY2VpdmFibGVcbiAgbG9zcyBpbiBhY2N1cmFjeS5cbiAgVXNhZ2VcbiAgICBjb25zdCBlYXNlT3V0ID0gY3ViaWNCZXppZXIoLjE3LC42NywuODMsLjY3KTtcbiAgICBjb25zdCB4ID0gZWFzZU91dCgwLjUpOyAvLyByZXR1cm5zIDAuNjI3Li4uXG4qL1xuLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbmNvbnN0IGNhbGNCZXppZXIgPSAodCwgYTEsIGEyKSA9PiAoKCgxLjAgLSAzLjAgKiBhMiArIDMuMCAqIGExKSAqIHQgKyAoMy4wICogYTIgLSA2LjAgKiBhMSkpICogdCArIDMuMCAqIGExKSAqXG4gICAgdDtcbmNvbnN0IHN1YmRpdmlzaW9uUHJlY2lzaW9uID0gMC4wMDAwMDAxO1xuY29uc3Qgc3ViZGl2aXNpb25NYXhJdGVyYXRpb25zID0gMTI7XG5mdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoeCwgbG93ZXJCb3VuZCwgdXBwZXJCb3VuZCwgbVgxLCBtWDIpIHtcbiAgICBsZXQgY3VycmVudFg7XG4gICAgbGV0IGN1cnJlbnRUO1xuICAgIGxldCBpID0gMDtcbiAgICBkbyB7XG4gICAgICAgIGN1cnJlbnRUID0gbG93ZXJCb3VuZCArICh1cHBlckJvdW5kIC0gbG93ZXJCb3VuZCkgLyAyLjA7XG4gICAgICAgIGN1cnJlbnRYID0gY2FsY0JlemllcihjdXJyZW50VCwgbVgxLCBtWDIpIC0geDtcbiAgICAgICAgaWYgKGN1cnJlbnRYID4gMC4wKSB7XG4gICAgICAgICAgICB1cHBlckJvdW5kID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb3dlckJvdW5kID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICB9IHdoaWxlIChNYXRoLmFicyhjdXJyZW50WCkgPiBzdWJkaXZpc2lvblByZWNpc2lvbiAmJlxuICAgICAgICArK2kgPCBzdWJkaXZpc2lvbk1heEl0ZXJhdGlvbnMpO1xuICAgIHJldHVybiBjdXJyZW50VDtcbn1cbmZ1bmN0aW9uIGN1YmljQmV6aWVyKG1YMSwgbVkxLCBtWDIsIG1ZMikge1xuICAgIC8vIElmIHRoaXMgaXMgYSBsaW5lYXIgZ3JhZGllbnQsIHJldHVybiBsaW5lYXIgZWFzaW5nXG4gICAgaWYgKG1YMSA9PT0gbVkxICYmIG1YMiA9PT0gbVkyKVxuICAgICAgICByZXR1cm4gbW90aW9uVXRpbHMubm9vcDtcbiAgICBjb25zdCBnZXRURm9yWCA9IChhWCkgPT4gYmluYXJ5U3ViZGl2aWRlKGFYLCAwLCAxLCBtWDEsIG1YMik7XG4gICAgLy8gSWYgYW5pbWF0aW9uIGlzIGF0IHN0YXJ0L2VuZCwgcmV0dXJuIHQgd2l0aG91dCBlYXNpbmdcbiAgICByZXR1cm4gKHQpID0+IHQgPT09IDAgfHwgdCA9PT0gMSA/IHQgOiBjYWxjQmV6aWVyKGdldFRGb3JYKHQpLCBtWTEsIG1ZMik7XG59XG5cbi8vIEFjY2VwdHMgYW4gZWFzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9uZSB0aGF0IG91dHB1dHMgbWlycm9yZWQgdmFsdWVzIGZvclxuLy8gdGhlIHNlY29uZCBoYWxmIG9mIHRoZSBhbmltYXRpb24uIFR1cm5zIGVhc2VJbiBpbnRvIGVhc2VJbk91dC5cbmNvbnN0IG1pcnJvckVhc2luZyA9IChlYXNpbmcpID0+IChwKSA9PiBwIDw9IDAuNSA/IGVhc2luZygyICogcCkgLyAyIDogKDIgLSBlYXNpbmcoMiAqICgxIC0gcCkpKSAvIDI7XG5cbi8vIEFjY2VwdHMgYW4gZWFzaW5nIGZ1bmN0aW9uIGFuZCByZXR1cm5zIGEgbmV3IG9uZSB0aGF0IG91dHB1dHMgcmV2ZXJzZWQgdmFsdWVzLlxuLy8gVHVybnMgZWFzZUluIGludG8gZWFzZU91dC5cbmNvbnN0IHJldmVyc2VFYXNpbmcgPSAoZWFzaW5nKSA9PiAocCkgPT4gMSAtIGVhc2luZygxIC0gcCk7XG5cbmNvbnN0IGJhY2tPdXQgPSAvKkBfX1BVUkVfXyovIGN1YmljQmV6aWVyKDAuMzMsIDEuNTMsIDAuNjksIDAuOTkpO1xuY29uc3QgYmFja0luID0gLypAX19QVVJFX18qLyByZXZlcnNlRWFzaW5nKGJhY2tPdXQpO1xuY29uc3QgYmFja0luT3V0ID0gLypAX19QVVJFX18qLyBtaXJyb3JFYXNpbmcoYmFja0luKTtcblxuY29uc3QgYW50aWNpcGF0ZSA9IChwKSA9PiAocCAqPSAyKSA8IDEgPyAwLjUgKiBiYWNrSW4ocCkgOiAwLjUgKiAoMiAtIE1hdGgucG93KDIsIC0xMCAqIChwIC0gMSkpKTtcblxuY29uc3QgY2lyY0luID0gKHApID0+IDEgLSBNYXRoLnNpbihNYXRoLmFjb3MocCkpO1xuY29uc3QgY2lyY091dCA9IHJldmVyc2VFYXNpbmcoY2lyY0luKTtcbmNvbnN0IGNpcmNJbk91dCA9IG1pcnJvckVhc2luZyhjaXJjSW4pO1xuXG4vKipcbiAqIENoZWNrIGlmIHRoZSB2YWx1ZSBpcyBhIHplcm8gdmFsdWUgc3RyaW5nIGxpa2UgXCIwcHhcIiBvciBcIjAlXCJcbiAqL1xuY29uc3QgaXNaZXJvVmFsdWVTdHJpbmcgPSAodikgPT4gL14wW14uXFxzXSskL3UudGVzdCh2KTtcblxuZnVuY3Rpb24gaXNOb25lKHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IDA7XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gXCJub25lXCIgfHwgdmFsdWUgPT09IFwiMFwiIHx8IGlzWmVyb1ZhbHVlU3RyaW5nKHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuY29uc3QgY2xhbXAgPSAobWluLCBtYXgsIHYpID0+IHtcbiAgICBpZiAodiA+IG1heClcbiAgICAgICAgcmV0dXJuIG1heDtcbiAgICBpZiAodiA8IG1pbilcbiAgICAgICAgcmV0dXJuIG1pbjtcbiAgICByZXR1cm4gdjtcbn07XG5cbmNvbnN0IG51bWJlciA9IHtcbiAgICB0ZXN0OiAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIsXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gdixcbn07XG5jb25zdCBhbHBoYSA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gY2xhbXAoMCwgMSwgdiksXG59O1xuY29uc3Qgc2NhbGUgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIGRlZmF1bHQ6IDEsXG59O1xuXG4vLyBJZiB0aGlzIG51bWJlciBpcyBhIGRlY2ltYWwsIG1ha2UgaXQganVzdCBmaXZlIGRlY2ltYWwgcGxhY2VzXG4vLyB0byBhdm9pZCBleHBvbmVudHNcbmNvbnN0IHNhbml0aXplID0gKHYpID0+IE1hdGgucm91bmQodiAqIDEwMDAwMCkgLyAxMDAwMDA7XG5cbmNvbnN0IGZsb2F0UmVnZXggPSAvLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspL2d1O1xuXG5mdW5jdGlvbiBpc051bGxpc2godikge1xuICAgIHJldHVybiB2ID09IG51bGw7XG59XG5cbmNvbnN0IHNpbmdsZUNvbG9yUmVnZXggPSAvXig/OiNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCkpJC9pdTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHByb3ZpZGVkIHN0cmluZyBpcyBhIGNvbG9yLCBpZSByZ2JhKDAsMCwwLDApIG9yICMwMDAsXG4gKiBidXQgZmFsc2UgaWYgYSBudW1iZXIgb3IgbXVsdGlwbGUgY29sb3JzXG4gKi9cbmNvbnN0IGlzQ29sb3JTdHJpbmcgPSAodHlwZSwgdGVzdFByb3ApID0+ICh2KSA9PiB7XG4gICAgcmV0dXJuIEJvb2xlYW4oKHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgIHNpbmdsZUNvbG9yUmVnZXgudGVzdCh2KSAmJlxuICAgICAgICB2LnN0YXJ0c1dpdGgodHlwZSkpIHx8XG4gICAgICAgICh0ZXN0UHJvcCAmJlxuICAgICAgICAgICAgIWlzTnVsbGlzaCh2KSAmJlxuICAgICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHYsIHRlc3RQcm9wKSkpO1xufTtcbmNvbnN0IHNwbGl0Q29sb3IgPSAoYU5hbWUsIGJOYW1lLCBjTmFtZSkgPT4gKHYpID0+IHtcbiAgICBpZiAodHlwZW9mIHYgIT09IFwic3RyaW5nXCIpXG4gICAgICAgIHJldHVybiB2O1xuICAgIGNvbnN0IFthLCBiLCBjLCBhbHBoYV0gPSB2Lm1hdGNoKGZsb2F0UmVnZXgpO1xuICAgIHJldHVybiB7XG4gICAgICAgIFthTmFtZV06IHBhcnNlRmxvYXQoYSksXG4gICAgICAgIFtiTmFtZV06IHBhcnNlRmxvYXQoYiksXG4gICAgICAgIFtjTmFtZV06IHBhcnNlRmxvYXQoYyksXG4gICAgICAgIGFscGhhOiBhbHBoYSAhPT0gdW5kZWZpbmVkID8gcGFyc2VGbG9hdChhbHBoYSkgOiAxLFxuICAgIH07XG59O1xuXG5jb25zdCBjbGFtcFJnYlVuaXQgPSAodikgPT4gY2xhbXAoMCwgMjU1LCB2KTtcbmNvbnN0IHJnYlVuaXQgPSB7XG4gICAgLi4ubnVtYmVyLFxuICAgIHRyYW5zZm9ybTogKHYpID0+IE1hdGgucm91bmQoY2xhbXBSZ2JVbml0KHYpKSxcbn07XG5jb25zdCByZ2JhID0ge1xuICAgIHRlc3Q6IC8qQF9fUFVSRV9fKi8gaXNDb2xvclN0cmluZyhcInJnYlwiLCBcInJlZFwiKSxcbiAgICBwYXJzZTogLypAX19QVVJFX18qLyBzcGxpdENvbG9yKFwicmVkXCIsIFwiZ3JlZW5cIiwgXCJibHVlXCIpLFxuICAgIHRyYW5zZm9ybTogKHsgcmVkLCBncmVlbiwgYmx1ZSwgYWxwaGE6IGFscGhhJDEgPSAxIH0pID0+IFwicmdiYShcIiArXG4gICAgICAgIHJnYlVuaXQudHJhbnNmb3JtKHJlZCkgK1xuICAgICAgICBcIiwgXCIgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShncmVlbikgK1xuICAgICAgICBcIiwgXCIgK1xuICAgICAgICByZ2JVbml0LnRyYW5zZm9ybShibHVlKSArXG4gICAgICAgIFwiLCBcIiArXG4gICAgICAgIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgK1xuICAgICAgICBcIilcIixcbn07XG5cbmZ1bmN0aW9uIHBhcnNlSGV4KHYpIHtcbiAgICBsZXQgciA9IFwiXCI7XG4gICAgbGV0IGcgPSBcIlwiO1xuICAgIGxldCBiID0gXCJcIjtcbiAgICBsZXQgYSA9IFwiXCI7XG4gICAgLy8gSWYgd2UgaGF2ZSA2IGNoYXJhY3RlcnMsIGllICNGRjAwMDBcbiAgICBpZiAodi5sZW5ndGggPiA1KSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cmluZygxLCAzKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyaW5nKDMsIDUpO1xuICAgICAgICBiID0gdi5zdWJzdHJpbmcoNSwgNyk7XG4gICAgICAgIGEgPSB2LnN1YnN0cmluZyg3LCA5KTtcbiAgICAgICAgLy8gT3Igd2UgaGF2ZSAzIGNoYXJhY3RlcnMsIGllICNGMDBcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHIgPSB2LnN1YnN0cmluZygxLCAyKTtcbiAgICAgICAgZyA9IHYuc3Vic3RyaW5nKDIsIDMpO1xuICAgICAgICBiID0gdi5zdWJzdHJpbmcoMywgNCk7XG4gICAgICAgIGEgPSB2LnN1YnN0cmluZyg0LCA1KTtcbiAgICAgICAgciArPSByO1xuICAgICAgICBnICs9IGc7XG4gICAgICAgIGIgKz0gYjtcbiAgICAgICAgYSArPSBhO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZWQ6IHBhcnNlSW50KHIsIDE2KSxcbiAgICAgICAgZ3JlZW46IHBhcnNlSW50KGcsIDE2KSxcbiAgICAgICAgYmx1ZTogcGFyc2VJbnQoYiwgMTYpLFxuICAgICAgICBhbHBoYTogYSA/IHBhcnNlSW50KGEsIDE2KSAvIDI1NSA6IDEsXG4gICAgfTtcbn1cbmNvbnN0IGhleCA9IHtcbiAgICB0ZXN0OiAvKkBfX1BVUkVfXyovIGlzQ29sb3JTdHJpbmcoXCIjXCIpLFxuICAgIHBhcnNlOiBwYXJzZUhleCxcbiAgICB0cmFuc2Zvcm06IHJnYmEudHJhbnNmb3JtLFxufTtcblxuY29uc3QgY3JlYXRlVW5pdFR5cGUgPSAodW5pdCkgPT4gKHtcbiAgICB0ZXN0OiAodikgPT4gdHlwZW9mIHYgPT09IFwic3RyaW5nXCIgJiYgdi5lbmRzV2l0aCh1bml0KSAmJiB2LnNwbGl0KFwiIFwiKS5sZW5ndGggPT09IDEsXG4gICAgcGFyc2U6IHBhcnNlRmxvYXQsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gYCR7dn0ke3VuaXR9YCxcbn0pO1xuY29uc3QgZGVncmVlcyA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJkZWdcIik7XG5jb25zdCBwZXJjZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcIiVcIik7XG5jb25zdCBweCA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlVW5pdFR5cGUoXCJweFwiKTtcbmNvbnN0IHZoID0gLypAX19QVVJFX18qLyBjcmVhdGVVbml0VHlwZShcInZoXCIpO1xuY29uc3QgdncgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVVuaXRUeXBlKFwidndcIik7XG5jb25zdCBwcm9ncmVzc1BlcmNlbnRhZ2UgPSB7XG4gICAgLi4ucGVyY2VudCxcbiAgICBwYXJzZTogKHYpID0+IHBlcmNlbnQucGFyc2UodikgLyAxMDAsXG4gICAgdHJhbnNmb3JtOiAodikgPT4gcGVyY2VudC50cmFuc2Zvcm0odiAqIDEwMCksXG59O1xuXG5jb25zdCBoc2xhID0ge1xuICAgIHRlc3Q6IC8qQF9fUFVSRV9fKi8gaXNDb2xvclN0cmluZyhcImhzbFwiLCBcImh1ZVwiKSxcbiAgICBwYXJzZTogLypAX19QVVJFX18qLyBzcGxpdENvbG9yKFwiaHVlXCIsIFwic2F0dXJhdGlvblwiLCBcImxpZ2h0bmVzc1wiKSxcbiAgICB0cmFuc2Zvcm06ICh7IGh1ZSwgc2F0dXJhdGlvbiwgbGlnaHRuZXNzLCBhbHBoYTogYWxwaGEkMSA9IDEgfSkgPT4ge1xuICAgICAgICByZXR1cm4gKFwiaHNsYShcIiArXG4gICAgICAgICAgICBNYXRoLnJvdW5kKGh1ZSkgK1xuICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgIHBlcmNlbnQudHJhbnNmb3JtKHNhbml0aXplKHNhdHVyYXRpb24pKSArXG4gICAgICAgICAgICBcIiwgXCIgK1xuICAgICAgICAgICAgcGVyY2VudC50cmFuc2Zvcm0oc2FuaXRpemUobGlnaHRuZXNzKSkgK1xuICAgICAgICAgICAgXCIsIFwiICtcbiAgICAgICAgICAgIHNhbml0aXplKGFscGhhLnRyYW5zZm9ybShhbHBoYSQxKSkgK1xuICAgICAgICAgICAgXCIpXCIpO1xuICAgIH0sXG59O1xuXG5jb25zdCBjb2xvciA9IHtcbiAgICB0ZXN0OiAodikgPT4gcmdiYS50ZXN0KHYpIHx8IGhleC50ZXN0KHYpIHx8IGhzbGEudGVzdCh2KSxcbiAgICBwYXJzZTogKHYpID0+IHtcbiAgICAgICAgaWYgKHJnYmEudGVzdCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHJnYmEucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaHNsYS50ZXN0KHYpKSB7XG4gICAgICAgICAgICByZXR1cm4gaHNsYS5wYXJzZSh2KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBoZXgucGFyc2Uodik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRyYW5zZm9ybTogKHYpID0+IHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/IHZcbiAgICAgICAgICAgIDogdi5oYXNPd25Qcm9wZXJ0eShcInJlZFwiKVxuICAgICAgICAgICAgICAgID8gcmdiYS50cmFuc2Zvcm0odilcbiAgICAgICAgICAgICAgICA6IGhzbGEudHJhbnNmb3JtKHYpO1xuICAgIH0sXG59O1xuXG5jb25zdCBjb2xvclJlZ2V4ID0gLyg/OiNbXFxkYS1mXXszLDh9fCg/OnJnYnxoc2wpYT9cXCgoPzotP1tcXGQuXSslP1ssXFxzXSspezJ9LT9bXFxkLl0rJT9cXHMqKD86WywvXVxccyopPyg/OlxcYlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKyk/JT9cXCkpL2dpdTtcblxuZnVuY3Rpb24gdGVzdCh2KSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gKGlzTmFOKHYpICYmXG4gICAgICAgIHR5cGVvZiB2ID09PSBcInN0cmluZ1wiICYmXG4gICAgICAgICgoKF9hID0gdi5tYXRjaChmbG9hdFJlZ2V4KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgfHwgMCkgK1xuICAgICAgICAgICAgKCgoX2IgPSB2Lm1hdGNoKGNvbG9yUmVnZXgpKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwKSA+XG4gICAgICAgICAgICAwKTtcbn1cbmNvbnN0IE5VTUJFUl9UT0tFTiA9IFwibnVtYmVyXCI7XG5jb25zdCBDT0xPUl9UT0tFTiA9IFwiY29sb3JcIjtcbmNvbnN0IFZBUl9UT0tFTiA9IFwidmFyXCI7XG5jb25zdCBWQVJfRlVOQ1RJT05fVE9LRU4gPSBcInZhcihcIjtcbmNvbnN0IFNQTElUX1RPS0VOID0gXCIke31cIjtcbi8vIHRoaXMgcmVnZXggY29uc2lzdHMgb2YgdGhlIGBzaW5nbGVDc3NWYXJpYWJsZVJlZ2V4fHJnYkhTTFZhbHVlUmVnZXh8ZGlnaXRSZWdleGBcbmNvbnN0IGNvbXBsZXhSZWdleCA9IC92YXJcXHMqXFwoXFxzKi0tKD86W1xcdy1dK1xccyp8W1xcdy1dK1xccyosKD86XFxzKlteKShcXHNdfFxccypcXCgoPzpbXikoXXxcXChbXikoXSpcXCkpKlxcKSkrXFxzKilcXCl8I1tcXGRhLWZdezMsOH18KD86cmdifGhzbClhP1xcKCg/Oi0/W1xcZC5dKyU/WyxcXHNdKyl7Mn0tP1tcXGQuXSslP1xccyooPzpbLC9dXFxzKik/KD86XFxiXFxkKyg/OlxcLlxcZCspP3xcXC5cXGQrKT8lP1xcKXwtPyg/OlxcZCsoPzpcXC5cXGQrKT98XFwuXFxkKykvZ2l1O1xuZnVuY3Rpb24gYW5hbHlzZUNvbXBsZXhWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IG9yaWdpbmFsVmFsdWUgPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgIGNvbnN0IGluZGV4ZXMgPSB7XG4gICAgICAgIGNvbG9yOiBbXSxcbiAgICAgICAgbnVtYmVyOiBbXSxcbiAgICAgICAgdmFyOiBbXSxcbiAgICB9O1xuICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRva2VuaXNlZCA9IG9yaWdpbmFsVmFsdWUucmVwbGFjZShjb21wbGV4UmVnZXgsIChwYXJzZWRWYWx1ZSkgPT4ge1xuICAgICAgICBpZiAoY29sb3IudGVzdChwYXJzZWRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGluZGV4ZXMuY29sb3IucHVzaChpKTtcbiAgICAgICAgICAgIHR5cGVzLnB1c2goQ09MT1JfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2goY29sb3IucGFyc2UocGFyc2VkVmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwYXJzZWRWYWx1ZS5zdGFydHNXaXRoKFZBUl9GVU5DVElPTl9UT0tFTikpIHtcbiAgICAgICAgICAgIGluZGV4ZXMudmFyLnB1c2goaSk7XG4gICAgICAgICAgICB0eXBlcy5wdXNoKFZBUl9UT0tFTik7XG4gICAgICAgICAgICB2YWx1ZXMucHVzaChwYXJzZWRWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpbmRleGVzLm51bWJlci5wdXNoKGkpO1xuICAgICAgICAgICAgdHlwZXMucHVzaChOVU1CRVJfVE9LRU4pO1xuICAgICAgICAgICAgdmFsdWVzLnB1c2gocGFyc2VGbG9hdChwYXJzZWRWYWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgICsraTtcbiAgICAgICAgcmV0dXJuIFNQTElUX1RPS0VOO1xuICAgIH0pO1xuICAgIGNvbnN0IHNwbGl0ID0gdG9rZW5pc2VkLnNwbGl0KFNQTElUX1RPS0VOKTtcbiAgICByZXR1cm4geyB2YWx1ZXMsIHNwbGl0LCBpbmRleGVzLCB0eXBlcyB9O1xufVxuZnVuY3Rpb24gcGFyc2VDb21wbGV4VmFsdWUodikge1xuICAgIHJldHVybiBhbmFseXNlQ29tcGxleFZhbHVlKHYpLnZhbHVlcztcbn1cbmZ1bmN0aW9uIGNyZWF0ZVRyYW5zZm9ybWVyKHNvdXJjZSkge1xuICAgIGNvbnN0IHsgc3BsaXQsIHR5cGVzIH0gPSBhbmFseXNlQ29tcGxleFZhbHVlKHNvdXJjZSk7XG4gICAgY29uc3QgbnVtU2VjdGlvbnMgPSBzcGxpdC5sZW5ndGg7XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGxldCBvdXRwdXQgPSBcIlwiO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVNlY3Rpb25zOyBpKyspIHtcbiAgICAgICAgICAgIG91dHB1dCArPSBzcGxpdFtpXTtcbiAgICAgICAgICAgIGlmICh2W2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdHlwZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUgPT09IE5VTUJFUl9UT0tFTikge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gc2FuaXRpemUodltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGUgPT09IENPTE9SX1RPS0VOKSB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dCArPSBjb2xvci50cmFuc2Zvcm0odltpXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQgKz0gdltpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9O1xufVxuY29uc3QgY29udmVydE51bWJlcnNUb1plcm8gPSAodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIgPyAwIDogdjtcbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lJDEodikge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlQ29tcGxleFZhbHVlKHYpO1xuICAgIGNvbnN0IHRyYW5zZm9ybWVyID0gY3JlYXRlVHJhbnNmb3JtZXIodik7XG4gICAgcmV0dXJuIHRyYW5zZm9ybWVyKHBhcnNlZC5tYXAoY29udmVydE51bWJlcnNUb1plcm8pKTtcbn1cbmNvbnN0IGNvbXBsZXggPSB7XG4gICAgdGVzdCxcbiAgICBwYXJzZTogcGFyc2VDb21wbGV4VmFsdWUsXG4gICAgY3JlYXRlVHJhbnNmb3JtZXIsXG4gICAgZ2V0QW5pbWF0YWJsZU5vbmU6IGdldEFuaW1hdGFibGVOb25lJDEsXG59O1xuXG4vKipcbiAqIFByb3BlcnRpZXMgdGhhdCBzaG91bGQgZGVmYXVsdCB0byAxIG9yIDEwMCVcbiAqL1xuY29uc3QgbWF4RGVmYXVsdHMgPSBuZXcgU2V0KFtcImJyaWdodG5lc3NcIiwgXCJjb250cmFzdFwiLCBcInNhdHVyYXRlXCIsIFwib3BhY2l0eVwiXSk7XG5mdW5jdGlvbiBhcHBseURlZmF1bHRGaWx0ZXIodikge1xuICAgIGNvbnN0IFtuYW1lLCB2YWx1ZV0gPSB2LnNsaWNlKDAsIC0xKS5zcGxpdChcIihcIik7XG4gICAgaWYgKG5hbWUgPT09IFwiZHJvcC1zaGFkb3dcIilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgY29uc3QgW251bWJlcl0gPSB2YWx1ZS5tYXRjaChmbG9hdFJlZ2V4KSB8fCBbXTtcbiAgICBpZiAoIW51bWJlcilcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgY29uc3QgdW5pdCA9IHZhbHVlLnJlcGxhY2UobnVtYmVyLCBcIlwiKTtcbiAgICBsZXQgZGVmYXVsdFZhbHVlID0gbWF4RGVmYXVsdHMuaGFzKG5hbWUpID8gMSA6IDA7XG4gICAgaWYgKG51bWJlciAhPT0gdmFsdWUpXG4gICAgICAgIGRlZmF1bHRWYWx1ZSAqPSAxMDA7XG4gICAgcmV0dXJuIG5hbWUgKyBcIihcIiArIGRlZmF1bHRWYWx1ZSArIHVuaXQgKyBcIilcIjtcbn1cbmNvbnN0IGZ1bmN0aW9uUmVnZXggPSAvXFxiKFthLXotXSopXFwoLio/XFwpL2d1O1xuY29uc3QgZmlsdGVyID0ge1xuICAgIC4uLmNvbXBsZXgsXG4gICAgZ2V0QW5pbWF0YWJsZU5vbmU6ICh2KSA9PiB7XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9ucyA9IHYubWF0Y2goZnVuY3Rpb25SZWdleCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbnMgPyBmdW5jdGlvbnMubWFwKGFwcGx5RGVmYXVsdEZpbHRlcikuam9pbihcIiBcIikgOiB2O1xuICAgIH0sXG59O1xuXG5jb25zdCBicm93c2VyTnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAvLyBCb3JkZXIgcHJvcHNcbiAgICBib3JkZXJXaWR0aDogcHgsXG4gICAgYm9yZGVyVG9wV2lkdGg6IHB4LFxuICAgIGJvcmRlclJpZ2h0V2lkdGg6IHB4LFxuICAgIGJvcmRlckJvdHRvbVdpZHRoOiBweCxcbiAgICBib3JkZXJMZWZ0V2lkdGg6IHB4LFxuICAgIGJvcmRlclJhZGl1czogcHgsXG4gICAgcmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBweCxcbiAgICBib3JkZXJUb3BSaWdodFJhZGl1czogcHgsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IHB4LFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IHB4LFxuICAgIC8vIFBvc2l0aW9uaW5nIHByb3BzXG4gICAgd2lkdGg6IHB4LFxuICAgIG1heFdpZHRoOiBweCxcbiAgICBoZWlnaHQ6IHB4LFxuICAgIG1heEhlaWdodDogcHgsXG4gICAgdG9wOiBweCxcbiAgICByaWdodDogcHgsXG4gICAgYm90dG9tOiBweCxcbiAgICBsZWZ0OiBweCxcbiAgICAvLyBTcGFjaW5nIHByb3BzXG4gICAgcGFkZGluZzogcHgsXG4gICAgcGFkZGluZ1RvcDogcHgsXG4gICAgcGFkZGluZ1JpZ2h0OiBweCxcbiAgICBwYWRkaW5nQm90dG9tOiBweCxcbiAgICBwYWRkaW5nTGVmdDogcHgsXG4gICAgbWFyZ2luOiBweCxcbiAgICBtYXJnaW5Ub3A6IHB4LFxuICAgIG1hcmdpblJpZ2h0OiBweCxcbiAgICBtYXJnaW5Cb3R0b206IHB4LFxuICAgIG1hcmdpbkxlZnQ6IHB4LFxuICAgIC8vIE1pc2NcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25YOiBweCxcbiAgICBiYWNrZ3JvdW5kUG9zaXRpb25ZOiBweCxcbn07XG5cbmNvbnN0IHRyYW5zZm9ybVZhbHVlVHlwZXMgPSB7XG4gICAgcm90YXRlOiBkZWdyZWVzLFxuICAgIHJvdGF0ZVg6IGRlZ3JlZXMsXG4gICAgcm90YXRlWTogZGVncmVlcyxcbiAgICByb3RhdGVaOiBkZWdyZWVzLFxuICAgIHNjYWxlLFxuICAgIHNjYWxlWDogc2NhbGUsXG4gICAgc2NhbGVZOiBzY2FsZSxcbiAgICBzY2FsZVo6IHNjYWxlLFxuICAgIHNrZXc6IGRlZ3JlZXMsXG4gICAgc2tld1g6IGRlZ3JlZXMsXG4gICAgc2tld1k6IGRlZ3JlZXMsXG4gICAgZGlzdGFuY2U6IHB4LFxuICAgIHRyYW5zbGF0ZVg6IHB4LFxuICAgIHRyYW5zbGF0ZVk6IHB4LFxuICAgIHRyYW5zbGF0ZVo6IHB4LFxuICAgIHg6IHB4LFxuICAgIHk6IHB4LFxuICAgIHo6IHB4LFxuICAgIHBlcnNwZWN0aXZlOiBweCxcbiAgICB0cmFuc2Zvcm1QZXJzcGVjdGl2ZTogcHgsXG4gICAgb3BhY2l0eTogYWxwaGEsXG4gICAgb3JpZ2luWDogcHJvZ3Jlc3NQZXJjZW50YWdlLFxuICAgIG9yaWdpblk6IHByb2dyZXNzUGVyY2VudGFnZSxcbiAgICBvcmlnaW5aOiBweCxcbn07XG5cbmNvbnN0IGludCA9IHtcbiAgICAuLi5udW1iZXIsXG4gICAgdHJhbnNmb3JtOiBNYXRoLnJvdW5kLFxufTtcblxuY29uc3QgbnVtYmVyVmFsdWVUeXBlcyA9IHtcbiAgICAuLi5icm93c2VyTnVtYmVyVmFsdWVUeXBlcyxcbiAgICAuLi50cmFuc2Zvcm1WYWx1ZVR5cGVzLFxuICAgIHpJbmRleDogaW50LFxuICAgIHNpemU6IHB4LFxuICAgIC8vIFNWR1xuICAgIGZpbGxPcGFjaXR5OiBhbHBoYSxcbiAgICBzdHJva2VPcGFjaXR5OiBhbHBoYSxcbiAgICBudW1PY3RhdmVzOiBpbnQsXG59O1xuXG4vKipcbiAqIEEgbWFwIG9mIGRlZmF1bHQgdmFsdWUgdHlwZXMgZm9yIGNvbW1vbiB2YWx1ZXNcbiAqL1xuY29uc3QgZGVmYXVsdFZhbHVlVHlwZXMgPSB7XG4gICAgLi4ubnVtYmVyVmFsdWVUeXBlcyxcbiAgICAvLyBDb2xvciBwcm9wc1xuICAgIGNvbG9yLFxuICAgIGJhY2tncm91bmRDb2xvcjogY29sb3IsXG4gICAgb3V0bGluZUNvbG9yOiBjb2xvcixcbiAgICBmaWxsOiBjb2xvcixcbiAgICBzdHJva2U6IGNvbG9yLFxuICAgIC8vIEJvcmRlciBwcm9wc1xuICAgIGJvcmRlckNvbG9yOiBjb2xvcixcbiAgICBib3JkZXJUb3BDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyUmlnaHRDb2xvcjogY29sb3IsXG4gICAgYm9yZGVyQm90dG9tQ29sb3I6IGNvbG9yLFxuICAgIGJvcmRlckxlZnRDb2xvcjogY29sb3IsXG4gICAgZmlsdGVyLFxuICAgIFdlYmtpdEZpbHRlcjogZmlsdGVyLFxufTtcbi8qKlxuICogR2V0cyB0aGUgZGVmYXVsdCBWYWx1ZVR5cGUgZm9yIHRoZSBwcm92aWRlZCB2YWx1ZSBrZXlcbiAqL1xuY29uc3QgZ2V0RGVmYXVsdFZhbHVlVHlwZSA9IChrZXkpID0+IGRlZmF1bHRWYWx1ZVR5cGVzW2tleV07XG5cbmZ1bmN0aW9uIGdldEFuaW1hdGFibGVOb25lKGtleSwgdmFsdWUpIHtcbiAgICBsZXQgZGVmYXVsdFZhbHVlVHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICBpZiAoZGVmYXVsdFZhbHVlVHlwZSAhPT0gZmlsdGVyKVxuICAgICAgICBkZWZhdWx0VmFsdWVUeXBlID0gY29tcGxleDtcbiAgICAvLyBJZiB2YWx1ZSBpcyBub3QgcmVjb2duaXNlZCBhcyBhbmltYXRhYmxlLCBpZSBcIm5vbmVcIiwgY3JlYXRlIGFuIGFuaW1hdGFibGUgdmVyc2lvbiBvcmlnaW4gYmFzZWQgb24gdGhlIHRhcmdldFxuICAgIHJldHVybiBkZWZhdWx0VmFsdWVUeXBlLmdldEFuaW1hdGFibGVOb25lXG4gICAgICAgID8gZGVmYXVsdFZhbHVlVHlwZS5nZXRBbmltYXRhYmxlTm9uZSh2YWx1ZSlcbiAgICAgICAgOiB1bmRlZmluZWQ7XG59XG5cbi8qKlxuICogSWYgd2UgZW5jb3VudGVyIGtleWZyYW1lcyBsaWtlIFwibm9uZVwiIG9yIFwiMFwiIGFuZCB3ZSBhbHNvIGhhdmUga2V5ZnJhbWVzIGxpa2VcbiAqIFwiI2ZmZlwiIG9yIFwiMjAwcHggMjAwcHhcIiB3ZSB3YW50IHRvIGZpbmQgYSBrZXlmcmFtZSB0byBzZXJ2ZSBhcyBhIHRlbXBsYXRlIGZvclxuICogdGhlIFwibm9uZVwiIGtleWZyYW1lcy4gSW4gdGhpcyBjYXNlIFwiI2ZmZlwiIG9yIFwiMjAwcHggMjAwcHhcIiAtIHRoZW4gdGhlc2UgZ2V0IHR1cm5lZCBpbnRvXG4gKiB6ZXJvIGVxdWl2YWxlbnRzLCBpLmUuIFwiI2ZmZjBcIiBvciBcIjBweCAwcHhcIi5cbiAqL1xuY29uc3QgaW52YWxpZFRlbXBsYXRlcyA9IG5ldyBTZXQoW1wiYXV0b1wiLCBcIm5vbmVcIiwgXCIwXCJdKTtcbmZ1bmN0aW9uIG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSh1bnJlc29sdmVkS2V5ZnJhbWVzLCBub25lS2V5ZnJhbWVJbmRleGVzLCBuYW1lKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCBhbmltYXRhYmxlVGVtcGxhdGUgPSB1bmRlZmluZWQ7XG4gICAgd2hpbGUgKGkgPCB1bnJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAmJiAhYW5pbWF0YWJsZVRlbXBsYXRlKSB7XG4gICAgICAgIGNvbnN0IGtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgaWYgKHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgIWludmFsaWRUZW1wbGF0ZXMuaGFzKGtleWZyYW1lKSAmJlxuICAgICAgICAgICAgYW5hbHlzZUNvbXBsZXhWYWx1ZShrZXlmcmFtZSkudmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgYW5pbWF0YWJsZVRlbXBsYXRlID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChhbmltYXRhYmxlVGVtcGxhdGUgJiYgbmFtZSkge1xuICAgICAgICBmb3IgKGNvbnN0IG5vbmVJbmRleCBvZiBub25lS2V5ZnJhbWVJbmRleGVzKSB7XG4gICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW25vbmVJbmRleF0gPSBnZXRBbmltYXRhYmxlTm9uZShuYW1lLCBhbmltYXRhYmxlVGVtcGxhdGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5jb25zdCBpc051bU9yUHhUeXBlID0gKHYpID0+IHYgPT09IG51bWJlciB8fCB2ID09PSBweDtcbmNvbnN0IGdldFBvc0Zyb21NYXRyaXggPSAobWF0cml4LCBwb3MpID0+IHBhcnNlRmxvYXQobWF0cml4LnNwbGl0KFwiLCBcIilbcG9zXSk7XG5jb25zdCBnZXRUcmFuc2xhdGVGcm9tTWF0cml4ID0gKHBvczIsIHBvczMpID0+IChfYmJveCwgeyB0cmFuc2Zvcm0gfSkgPT4ge1xuICAgIGlmICh0cmFuc2Zvcm0gPT09IFwibm9uZVwiIHx8ICF0cmFuc2Zvcm0pXG4gICAgICAgIHJldHVybiAwO1xuICAgIGNvbnN0IG1hdHJpeDNkID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4M2RcXCgoLispXFwpJC91KTtcbiAgICBpZiAobWF0cml4M2QpIHtcbiAgICAgICAgcmV0dXJuIGdldFBvc0Zyb21NYXRyaXgobWF0cml4M2RbMV0sIHBvczMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWF0cml4ID0gdHJhbnNmb3JtLm1hdGNoKC9ebWF0cml4XFwoKC4rKVxcKSQvdSk7XG4gICAgICAgIGlmIChtYXRyaXgpIHtcbiAgICAgICAgICAgIHJldHVybiBnZXRQb3NGcm9tTWF0cml4KG1hdHJpeFsxXSwgcG9zMik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCB0cmFuc2Zvcm1LZXlzID0gbmV3IFNldChbXCJ4XCIsIFwieVwiLCBcInpcIl0pO1xuY29uc3Qgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMgPSB0cmFuc2Zvcm1Qcm9wT3JkZXIuZmlsdGVyKChrZXkpID0+ICF0cmFuc2Zvcm1LZXlzLmhhcyhrZXkpKTtcbmZ1bmN0aW9uIHJlbW92ZU5vblRyYW5zbGF0aW9uYWxUcmFuc2Zvcm0odmlzdWFsRWxlbWVudCkge1xuICAgIGNvbnN0IHJlbW92ZWRUcmFuc2Zvcm1zID0gW107XG4gICAgbm9uVHJhbnNsYXRpb25hbFRyYW5zZm9ybUtleXMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmVtb3ZlZFRyYW5zZm9ybXMucHVzaChba2V5LCB2YWx1ZS5nZXQoKV0pO1xuICAgICAgICAgICAgdmFsdWUuc2V0KGtleS5zdGFydHNXaXRoKFwic2NhbGVcIikgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVtb3ZlZFRyYW5zZm9ybXM7XG59XG5jb25zdCBwb3NpdGlvbmFsVmFsdWVzID0ge1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICB3aWR0aDogKHsgeCB9LCB7IHBhZGRpbmdMZWZ0ID0gXCIwXCIsIHBhZGRpbmdSaWdodCA9IFwiMFwiIH0pID0+IHgubWF4IC0geC5taW4gLSBwYXJzZUZsb2F0KHBhZGRpbmdMZWZ0KSAtIHBhcnNlRmxvYXQocGFkZGluZ1JpZ2h0KSxcbiAgICBoZWlnaHQ6ICh7IHkgfSwgeyBwYWRkaW5nVG9wID0gXCIwXCIsIHBhZGRpbmdCb3R0b20gPSBcIjBcIiB9KSA9PiB5Lm1heCAtIHkubWluIC0gcGFyc2VGbG9hdChwYWRkaW5nVG9wKSAtIHBhcnNlRmxvYXQocGFkZGluZ0JvdHRvbSksXG4gICAgdG9wOiAoX2Jib3gsIHsgdG9wIH0pID0+IHBhcnNlRmxvYXQodG9wKSxcbiAgICBsZWZ0OiAoX2Jib3gsIHsgbGVmdCB9KSA9PiBwYXJzZUZsb2F0KGxlZnQpLFxuICAgIGJvdHRvbTogKHsgeSB9LCB7IHRvcCB9KSA9PiBwYXJzZUZsb2F0KHRvcCkgKyAoeS5tYXggLSB5Lm1pbiksXG4gICAgcmlnaHQ6ICh7IHggfSwgeyBsZWZ0IH0pID0+IHBhcnNlRmxvYXQobGVmdCkgKyAoeC5tYXggLSB4Lm1pbiksXG4gICAgLy8gVHJhbnNmb3JtXG4gICAgeDogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg0LCAxMyksXG4gICAgeTogZ2V0VHJhbnNsYXRlRnJvbU1hdHJpeCg1LCAxNCksXG59O1xuLy8gQWxpYXMgdHJhbnNsYXRlIGxvbmdmb3JtIG5hbWVzXG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVggPSBwb3NpdGlvbmFsVmFsdWVzLng7XG5wb3NpdGlvbmFsVmFsdWVzLnRyYW5zbGF0ZVkgPSBwb3NpdGlvbmFsVmFsdWVzLnk7XG5cbmNvbnN0IHRvUmVzb2x2ZSA9IG5ldyBTZXQoKTtcbmxldCBpc1NjaGVkdWxlZCA9IGZhbHNlO1xubGV0IGFueU5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbmZ1bmN0aW9uIG1lYXN1cmVBbGxLZXlmcmFtZXMoKSB7XG4gICAgaWYgKGFueU5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZXJzVG9NZWFzdXJlID0gQXJyYXkuZnJvbSh0b1Jlc29sdmUpLmZpbHRlcigocmVzb2x2ZXIpID0+IHJlc29sdmVyLm5lZWRzTWVhc3VyZW1lbnQpO1xuICAgICAgICBjb25zdCBlbGVtZW50c1RvTWVhc3VyZSA9IG5ldyBTZXQocmVzb2x2ZXJzVG9NZWFzdXJlLm1hcCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmVsZW1lbnQpKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3Jtc1RvUmVzdG9yZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFdyaXRlIHBhc3NcbiAgICAgICAgICogSWYgd2UncmUgbWVhc3VyaW5nIGVsZW1lbnRzIHdlIHdhbnQgdG8gcmVtb3ZlIGJvdW5kaW5nIGJveC1jaGFuZ2luZyB0cmFuc2Zvcm1zLlxuICAgICAgICAgKi9cbiAgICAgICAgZWxlbWVudHNUb01lYXN1cmUuZm9yRWFjaCgoZWxlbWVudCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlZFRyYW5zZm9ybXMgPSByZW1vdmVOb25UcmFuc2xhdGlvbmFsVHJhbnNmb3JtKGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZW1vdmVkVHJhbnNmb3Jtcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdHJhbnNmb3Jtc1RvUmVzdG9yZS5zZXQoZWxlbWVudCwgcmVtb3ZlZFRyYW5zZm9ybXMpO1xuICAgICAgICAgICAgZWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFJlYWRcbiAgICAgICAgcmVzb2x2ZXJzVG9NZWFzdXJlLmZvckVhY2goKHJlc29sdmVyKSA9PiByZXNvbHZlci5tZWFzdXJlSW5pdGlhbFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICBlbGVtZW50c1RvTWVhc3VyZS5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbmRlcigpO1xuICAgICAgICAgICAgY29uc3QgcmVzdG9yZSA9IHRyYW5zZm9ybXNUb1Jlc3RvcmUuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlc3RvcmUpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IGVsZW1lbnQuZ2V0VmFsdWUoa2V5KSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNldCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSZWFkXG4gICAgICAgIHJlc29sdmVyc1RvTWVhc3VyZS5mb3JFYWNoKChyZXNvbHZlcikgPT4gcmVzb2x2ZXIubWVhc3VyZUVuZFN0YXRlKCkpO1xuICAgICAgICAvLyBXcml0ZVxuICAgICAgICByZXNvbHZlcnNUb01lYXN1cmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgICAgIGlmIChyZXNvbHZlci5zdXNwZW5kZWRTY3JvbGxZICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgcmVzb2x2ZXIuc3VzcGVuZGVkU2Nyb2xsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhbnlOZWVkc01lYXN1cmVtZW50ID0gZmFsc2U7XG4gICAgaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHJlc29sdmVyLmNvbXBsZXRlKCkpO1xuICAgIHRvUmVzb2x2ZS5jbGVhcigpO1xufVxuZnVuY3Rpb24gcmVhZEFsbEtleWZyYW1lcygpIHtcbiAgICB0b1Jlc29sdmUuZm9yRWFjaCgocmVzb2x2ZXIpID0+IHtcbiAgICAgICAgcmVzb2x2ZXIucmVhZEtleWZyYW1lcygpO1xuICAgICAgICBpZiAocmVzb2x2ZXIubmVlZHNNZWFzdXJlbWVudCkge1xuICAgICAgICAgICAgYW55TmVlZHNNZWFzdXJlbWVudCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGZsdXNoS2V5ZnJhbWVSZXNvbHZlcnMoKSB7XG4gICAgcmVhZEFsbEtleWZyYW1lcygpO1xuICAgIG1lYXN1cmVBbGxLZXlmcmFtZXMoKTtcbn1cbmNsYXNzIEtleWZyYW1lUmVzb2x2ZXIge1xuICAgIGNvbnN0cnVjdG9yKHVucmVzb2x2ZWRLZXlmcmFtZXMsIG9uQ29tcGxldGUsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBpc0FzeW5jID0gZmFsc2UpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBoYXMgY29tcGxldGVkLiBPbmNlIGNvbXBsZXRlLCBpdCBuZXZlclxuICAgICAgICAgKiBuZWVkcyB0byBhdHRlbXB0IGtleWZyYW1lIHJlc29sdXRpb24gYWdhaW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBhc3luYy4gSWYgaXQgaXMsIGl0J2xsIGJlIGFkZGVkIHRvIHRoZVxuICAgICAgICAgKiByZXNvbHZlciBxdWV1ZSBhbmQgZmx1c2hlZCBpbiB0aGUgbmV4dCBmcmFtZS4gUmVzb2x2ZXJzIHRoYXQgYXJlbid0IGdvaW5nXG4gICAgICAgICAqIHRvIHRyaWdnZXIgcmVhZC93cml0ZSB0aHJhc2hpbmcgZG9uJ3QgbmVlZCB0byBiZSBhc3luYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNBc3luYyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVHJhY2sgd2hldGhlciB0aGlzIHJlc29sdmVyIG5lZWRzIHRvIHBlcmZvcm0gYSBtZWFzdXJlbWVudFxuICAgICAgICAgKiB0byByZXNvbHZlIGl0cyBrZXlmcmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5lZWRzTWVhc3VyZW1lbnQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRyYWNrIHdoZXRoZXIgdGhpcyByZXNvbHZlciBpcyBjdXJyZW50bHkgc2NoZWR1bGVkIHRvIHJlc29sdmVcbiAgICAgICAgICogdG8gYWxsb3cgaXQgdG8gYmUgY2FuY2VsbGVkIGFuZCByZXN1bWVkIGV4dGVybmFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzU2NoZWR1bGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMudW5yZXNvbHZlZEtleWZyYW1lcyA9IFsuLi51bnJlc29sdmVkS2V5ZnJhbWVzXTtcbiAgICAgICAgdGhpcy5vbkNvbXBsZXRlID0gb25Db21wbGV0ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5tb3Rpb25WYWx1ZSA9IG1vdGlvblZhbHVlO1xuICAgICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgICB0aGlzLmlzQXN5bmMgPSBpc0FzeW5jO1xuICAgIH1cbiAgICBzY2hlZHVsZVJlc29sdmUoKSB7XG4gICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5pc0FzeW5jKSB7XG4gICAgICAgICAgICB0b1Jlc29sdmUuYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKCFpc1NjaGVkdWxlZCkge1xuICAgICAgICAgICAgICAgIGlzU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmcmFtZS5yZWFkKHJlYWRBbGxLZXlmcmFtZXMpO1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlc29sdmVLZXlmcmFtZXMobWVhc3VyZUFsbEtleWZyYW1lcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlYWRLZXlmcmFtZXMoKTtcbiAgICAgICAgICAgIHRoaXMuY29tcGxldGUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWFkS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUsIGVsZW1lbnQsIG1vdGlvblZhbHVlIH0gPSB0aGlzO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSBrZXlmcmFtZSBpcyBudWxsLCB3ZSBoeWRyYXRlIGl0IGVpdGhlciBieSByZWFkaW5nIGl0IGZyb21cbiAgICAgICAgICogdGhlIGluc3RhbmNlLCBvciBwcm9wYWdhdGluZyBmcm9tIHByZXZpb3VzIGtleWZyYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKHVucmVzb2x2ZWRLZXlmcmFtZXNbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGUgZmlyc3Qga2V5ZnJhbWUgaXMgbnVsbCwgd2UgbmVlZCB0byBmaW5kIGl0cyB2YWx1ZSBieSBzYW1wbGluZyB0aGUgZWxlbWVudFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRWYWx1ZSA9IG1vdGlvblZhbHVlID09PSBudWxsIHx8IG1vdGlvblZhbHVlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBtb3Rpb25WYWx1ZS5nZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gY3VycmVudFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVsZW1lbnQgJiYgbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWVBc1JlYWQgPSBlbGVtZW50LnJlYWRWYWx1ZShuYW1lLCBmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWx1ZUFzUmVhZCAhPT0gdW5kZWZpbmVkICYmIHZhbHVlQXNSZWFkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5yZXNvbHZlZEtleWZyYW1lc1swXSA9IHZhbHVlQXNSZWFkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0gPSBmaW5hbEtleWZyYW1lO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSAmJiBjdXJyZW50VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KHVucmVzb2x2ZWRLZXlmcmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHNldEZpbmFsS2V5ZnJhbWUoKSB7IH1cbiAgICBtZWFzdXJlSW5pdGlhbFN0YXRlKCkgeyB9XG4gICAgcmVuZGVyRW5kU3R5bGVzKCkgeyB9XG4gICAgbWVhc3VyZUVuZFN0YXRlKCkgeyB9XG4gICAgY29tcGxldGUoKSB7XG4gICAgICAgIHRoaXMuaXNDb21wbGV0ZSA9IHRydWU7XG4gICAgICAgIHRoaXMub25Db21wbGV0ZSh0aGlzLnVucmVzb2x2ZWRLZXlmcmFtZXMsIHRoaXMuZmluYWxLZXlmcmFtZSk7XG4gICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMuaXNTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRvUmVzb2x2ZS5kZWxldGUodGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzdW1lKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNDb21wbGV0ZSlcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZXNvbHZlKCk7XG4gICAgfVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIGEgbnVtZXJpY2FsIHN0cmluZywgaWUgYSBzdHJpbmcgdGhhdCBpcyBwdXJlbHkgYSBudW1iZXIgZWcgXCIxMDBcIiBvciBcIi0xMDAuMVwiXG4gKi9cbmNvbnN0IGlzTnVtZXJpY2FsU3RyaW5nID0gKHYpID0+IC9eLT8oPzpcXGQrKD86XFwuXFxkKyk/fFxcLlxcZCspJC91LnRlc3Qodik7XG5cbmNvbnN0IGNoZWNrU3RyaW5nU3RhcnRzV2l0aCA9ICh0b2tlbikgPT4gKGtleSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBrZXkuc3RhcnRzV2l0aCh0b2tlbik7XG5jb25zdCBpc0NTU1ZhcmlhYmxlTmFtZSA9IFxuLypAX19QVVJFX18qLyBjaGVja1N0cmluZ1N0YXJ0c1dpdGgoXCItLVwiKTtcbmNvbnN0IHN0YXJ0c0FzVmFyaWFibGVUb2tlbiA9IFxuLypAX19QVVJFX18qLyBjaGVja1N0cmluZ1N0YXJ0c1dpdGgoXCJ2YXIoLS1cIik7XG5jb25zdCBpc0NTU1ZhcmlhYmxlVG9rZW4gPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBzdGFydHNXaXRoVG9rZW4gPSBzdGFydHNBc1ZhcmlhYmxlVG9rZW4odmFsdWUpO1xuICAgIGlmICghc3RhcnRzV2l0aFRva2VuKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gRW5zdXJlIGFueSBjb21tZW50cyBhcmUgc3RyaXBwZWQgZnJvbSB0aGUgdmFsdWUgYXMgdGhpcyBjYW4gaGFybSBwZXJmb3JtYW5jZSBvZiB0aGUgcmVnZXguXG4gICAgcmV0dXJuIHNpbmdsZUNzc1ZhcmlhYmxlUmVnZXgudGVzdCh2YWx1ZS5zcGxpdChcIi8qXCIpWzBdLnRyaW0oKSk7XG59O1xuY29uc3Qgc2luZ2xlQ3NzVmFyaWFibGVSZWdleCA9IC92YXJcXCgtLSg/OltcXHctXStcXHMqfFtcXHctXStcXHMqLCg/OlxccypbXikoXFxzXXxcXHMqXFwoKD86W14pKF18XFwoW14pKF0qXFwpKSpcXCkpK1xccyopXFwpJC9pdTtcblxuLyoqXG4gKiBQYXJzZSBGcmFtZXIncyBzcGVjaWFsIENTUyB2YXJpYWJsZSBmb3JtYXQgaW50byBhIENTUyB0b2tlbiBhbmQgYSBmYWxsYmFjay5cbiAqXG4gKiBgYGBcbiAqIGB2YXIoLS1mb28sICNmZmYpYCA9PiBbYC0tZm9vYCwgJyNmZmYnXVxuICogYGBgXG4gKlxuICogQHBhcmFtIGN1cnJlbnRcbiAqL1xuY29uc3Qgc3BsaXRDU1NWYXJpYWJsZVJlZ2V4ID0gXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVkb3MtZGV0ZWN0b3Ivbm8tdW5zYWZlLXJlZ2V4IC0tIGZhbHNlIHBvc2l0aXZlLCBhcyBpdCBjYW4gbWF0Y2ggYSBsb3Qgb2Ygd29yZHNcbi9edmFyXFwoLS0oPzooW1xcdy1dKyl8KFtcXHctXSspLCA/KFthLXpBLVpcXGQgKCklIy4sLV0rKSlcXCkvdTtcbmZ1bmN0aW9uIHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCkge1xuICAgIGNvbnN0IG1hdGNoID0gc3BsaXRDU1NWYXJpYWJsZVJlZ2V4LmV4ZWMoY3VycmVudCk7XG4gICAgaWYgKCFtYXRjaClcbiAgICAgICAgcmV0dXJuIFssXTtcbiAgICBjb25zdCBbLCB0b2tlbjEsIHRva2VuMiwgZmFsbGJhY2tdID0gbWF0Y2g7XG4gICAgcmV0dXJuIFtgLS0ke3Rva2VuMSAhPT0gbnVsbCAmJiB0b2tlbjEgIT09IHZvaWQgMCA/IHRva2VuMSA6IHRva2VuMn1gLCBmYWxsYmFja107XG59XG5jb25zdCBtYXhEZXB0aCA9IDQ7XG5mdW5jdGlvbiBnZXRWYXJpYWJsZVZhbHVlKGN1cnJlbnQsIGVsZW1lbnQsIGRlcHRoID0gMSkge1xuICAgIG1vdGlvblV0aWxzLmludmFyaWFudChkZXB0aCA8PSBtYXhEZXB0aCwgYE1heCBDU1MgdmFyaWFibGUgZmFsbGJhY2sgZGVwdGggZGV0ZWN0ZWQgaW4gcHJvcGVydHkgXCIke2N1cnJlbnR9XCIuIFRoaXMgbWF5IGluZGljYXRlIGEgY2lyY3VsYXIgZmFsbGJhY2sgZGVwZW5kZW5jeS5gKTtcbiAgICBjb25zdCBbdG9rZW4sIGZhbGxiYWNrXSA9IHBhcnNlQ1NTVmFyaWFibGUoY3VycmVudCk7XG4gICAgLy8gTm8gQ1NTIHZhcmlhYmxlIGRldGVjdGVkXG4gICAgaWYgKCF0b2tlbilcbiAgICAgICAgcmV0dXJuO1xuICAgIC8vIEF0dGVtcHQgdG8gcmVhZCB0aGlzIENTUyB2YXJpYWJsZSBvZmYgdGhlIGVsZW1lbnRcbiAgICBjb25zdCByZXNvbHZlZCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUodG9rZW4pO1xuICAgIGlmIChyZXNvbHZlZCkge1xuICAgICAgICBjb25zdCB0cmltbWVkID0gcmVzb2x2ZWQudHJpbSgpO1xuICAgICAgICByZXR1cm4gaXNOdW1lcmljYWxTdHJpbmcodHJpbW1lZCkgPyBwYXJzZUZsb2F0KHRyaW1tZWQpIDogdHJpbW1lZDtcbiAgICB9XG4gICAgcmV0dXJuIGlzQ1NTVmFyaWFibGVUb2tlbihmYWxsYmFjaylcbiAgICAgICAgPyBnZXRWYXJpYWJsZVZhbHVlKGZhbGxiYWNrLCBlbGVtZW50LCBkZXB0aCArIDEpXG4gICAgICAgIDogZmFsbGJhY2s7XG59XG5cbi8qKlxuICogVGVzdHMgYSBwcm92aWRlZCB2YWx1ZSBhZ2FpbnN0IGEgVmFsdWVUeXBlXG4gKi9cbmNvbnN0IHRlc3RWYWx1ZVR5cGUgPSAodikgPT4gKHR5cGUpID0+IHR5cGUudGVzdCh2KTtcblxuLyoqXG4gKiBWYWx1ZVR5cGUgZm9yIFwiYXV0b1wiXG4gKi9cbmNvbnN0IGF1dG8gPSB7XG4gICAgdGVzdDogKHYpID0+IHYgPT09IFwiYXV0b1wiLFxuICAgIHBhcnNlOiAodikgPT4gdixcbn07XG5cbi8qKlxuICogQSBsaXN0IG9mIHZhbHVlIHR5cGVzIGNvbW1vbmx5IHVzZWQgZm9yIGRpbWVuc2lvbnNcbiAqL1xuY29uc3QgZGltZW5zaW9uVmFsdWVUeXBlcyA9IFtudW1iZXIsIHB4LCBwZXJjZW50LCBkZWdyZWVzLCB2dywgdmgsIGF1dG9dO1xuLyoqXG4gKiBUZXN0cyBhIGRpbWVuc2lvbmFsIHZhbHVlIGFnYWluc3QgdGhlIGxpc3Qgb2YgZGltZW5zaW9uIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgZmluZERpbWVuc2lvblZhbHVlVHlwZSA9ICh2KSA9PiBkaW1lbnNpb25WYWx1ZVR5cGVzLmZpbmQodGVzdFZhbHVlVHlwZSh2KSk7XG5cbmNsYXNzIERPTUtleWZyYW1lc1Jlc29sdmVyIGV4dGVuZHMgS2V5ZnJhbWVSZXNvbHZlciB7XG4gICAgY29uc3RydWN0b3IodW5yZXNvbHZlZEtleWZyYW1lcywgb25Db21wbGV0ZSwgbmFtZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQpIHtcbiAgICAgICAgc3VwZXIodW5yZXNvbHZlZEtleWZyYW1lcywgb25Db21wbGV0ZSwgbmFtZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICByZWFkS2V5ZnJhbWVzKCkge1xuICAgICAgICBjb25zdCB7IHVucmVzb2x2ZWRLZXlmcmFtZXMsIGVsZW1lbnQsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBzdXBlci5yZWFkS2V5ZnJhbWVzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhbnkga2V5ZnJhbWUgaXMgYSBDU1MgdmFyaWFibGUsIHdlIG5lZWQgdG8gZmluZCBpdHMgdmFsdWUgYnkgc2FtcGxpbmcgdGhlIGVsZW1lbnRcbiAgICAgICAgICovXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IGtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tpXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ZnJhbWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZSA9IGtleWZyYW1lLnRyaW0oKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNDU1NWYXJpYWJsZVRva2VuKGtleWZyYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXNvbHZlZCA9IGdldFZhcmlhYmxlVmFsdWUoa2V5ZnJhbWUsIGVsZW1lbnQuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNvbHZlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPT09IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maW5hbEtleWZyYW1lID0ga2V5ZnJhbWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmUgXCJub25lXCIgdmFsdWVzLiBXZSBkbyB0aGlzIHBvdGVudGlhbGx5IHR3aWNlIC0gb25jZSBiZWZvcmUgYW5kIG9uY2UgYWZ0ZXIgbWVhc3VyaW5nIGtleWZyYW1lcy5cbiAgICAgICAgICogVGhpcyBjb3VsZCBiZSBzZWVuIGFzIGluZWZmaWNpZW50IGJ1dCBpdCdzIGEgdHJhZGUtb2ZmIHRvIGF2b2lkIG1lYXN1cmVtZW50cyBpbiBtb3JlIHNpdHVhdGlvbnMsIHdoaWNoXG4gICAgICAgICAqIGhhdmUgYSBmYXIgYmlnZ2VyIHBlcmZvcm1hbmNlIGltcGFjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucmVzb2x2ZU5vbmVLZXlmcmFtZXMoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRvIHNlZSBpZiB1bml0IHR5cGUgaGFzIGNoYW5nZWQuIElmIHNvIHNjaGVkdWxlIGpvYnMgdGhhdCB3aWxsXG4gICAgICAgICAqIHRlbXBvcmFyaWx5IHNldCBzdHlsZXMgdG8gdGhlIGRlc3RpbmF0aW9uIGtleWZyYW1lcy5cbiAgICAgICAgICogU2tpcCBpZiB3ZSBoYXZlIG1vcmUgdGhhbiB0d28ga2V5ZnJhbWVzIG9yIHRoaXMgaXNuJ3QgYSBwb3NpdGlvbmFsIHZhbHVlLlxuICAgICAgICAgKiBUT0RPOiBXZSBjYW4gdGhyb3cgaWYgdGhlcmUgYXJlIG11bHRpcGxlIGtleWZyYW1lcyBhbmQgdGhlIHZhbHVlIHR5cGUgY2hhbmdlcy5cbiAgICAgICAgICovXG4gICAgICAgIGlmICghcG9zaXRpb25hbEtleXMuaGFzKG5hbWUpIHx8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgW29yaWdpbiwgdGFyZ2V0XSA9IHVucmVzb2x2ZWRLZXlmcmFtZXM7XG4gICAgICAgIGNvbnN0IG9yaWdpblR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKG9yaWdpbik7XG4gICAgICAgIGNvbnN0IHRhcmdldFR5cGUgPSBmaW5kRGltZW5zaW9uVmFsdWVUeXBlKHRhcmdldCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBFaXRoZXIgd2UgZG9uJ3QgcmVjb2duaXNlIHRoZXNlIHZhbHVlIHR5cGVzIG9yIHdlIGNhbiBhbmltYXRlIGJldHdlZW4gdGhlbS5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChvcmlnaW5UeXBlID09PSB0YXJnZXRUeXBlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYm90aCB2YWx1ZXMgYXJlIG51bWJlcnMgb3IgcGl4ZWxzLCB3ZSBjYW4gYW5pbWF0ZSBiZXR3ZWVuIHRoZW0gYnlcbiAgICAgICAgICogY29udmVydGluZyB0aGVtIHRvIG51bWJlcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaXNOdW1PclB4VHlwZShvcmlnaW5UeXBlKSAmJiBpc051bU9yUHhUeXBlKHRhcmdldFR5cGUpKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHVucmVzb2x2ZWRLZXlmcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ldID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFbHNlLCB0aGUgb25seSB3YXkgdG8gcmVzb2x2ZSB0aGlzIGlzIGJ5IG1lYXN1cmluZyB0aGUgZWxlbWVudC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5uZWVkc01lYXN1cmVtZW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlTm9uZUtleWZyYW1lcygpIHtcbiAgICAgICAgY29uc3QgeyB1bnJlc29sdmVkS2V5ZnJhbWVzLCBuYW1lIH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBub25lS2V5ZnJhbWVJbmRleGVzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzTm9uZSh1bnJlc29sdmVkS2V5ZnJhbWVzW2ldKSkge1xuICAgICAgICAgICAgICAgIG5vbmVLZXlmcmFtZUluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobm9uZUtleWZyYW1lSW5kZXhlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1ha2VOb25lS2V5ZnJhbWVzQW5pbWF0YWJsZSh1bnJlc29sdmVkS2V5ZnJhbWVzLCBub25lS2V5ZnJhbWVJbmRleGVzLCBuYW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlSW5pdGlhbFN0YXRlKCkge1xuICAgICAgICBjb25zdCB7IGVsZW1lbnQsIHVucmVzb2x2ZWRLZXlmcmFtZXMsIG5hbWUgfSA9IHRoaXM7XG4gICAgICAgIGlmICghZWxlbWVudCB8fCAhZWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAobmFtZSA9PT0gXCJoZWlnaHRcIikge1xuICAgICAgICAgICAgdGhpcy5zdXNwZW5kZWRTY3JvbGxZID0gd2luZG93LnBhZ2VZT2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubWVhc3VyZWRPcmlnaW4gPSBwb3NpdGlvbmFsVmFsdWVzW25hbWVdKGVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCksIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQuY3VycmVudCkpO1xuICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzWzBdID0gdGhpcy5tZWFzdXJlZE9yaWdpbjtcbiAgICAgICAgLy8gU2V0IGZpbmFsIGtleSBmcmFtZSB0byBtZWFzdXJlIGFmdGVyIG5leHQgcmVuZGVyXG4gICAgICAgIGNvbnN0IG1lYXN1cmVLZXlmcmFtZSA9IHVucmVzb2x2ZWRLZXlmcmFtZXNbdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKG1lYXN1cmVLZXlmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBlbGVtZW50LmdldFZhbHVlKG5hbWUsIG1lYXN1cmVLZXlmcmFtZSkuanVtcChtZWFzdXJlS2V5ZnJhbWUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBtZWFzdXJlRW5kU3RhdGUoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgeyBlbGVtZW50LCBuYW1lLCB1bnJlc29sdmVkS2V5ZnJhbWVzIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LmdldFZhbHVlKG5hbWUpO1xuICAgICAgICB2YWx1ZSAmJiB2YWx1ZS5qdW1wKHRoaXMubWVhc3VyZWRPcmlnaW4sIGZhbHNlKTtcbiAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZUluZGV4ID0gdW5yZXNvbHZlZEtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICBjb25zdCBmaW5hbEtleWZyYW1lID0gdW5yZXNvbHZlZEtleWZyYW1lc1tmaW5hbEtleWZyYW1lSW5kZXhdO1xuICAgICAgICB1bnJlc29sdmVkS2V5ZnJhbWVzW2ZpbmFsS2V5ZnJhbWVJbmRleF0gPSBwb3NpdGlvbmFsVmFsdWVzW25hbWVdKGVsZW1lbnQubWVhc3VyZVZpZXdwb3J0Qm94KCksIHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQuY3VycmVudCkpO1xuICAgICAgICBpZiAoZmluYWxLZXlmcmFtZSAhPT0gbnVsbCAmJiB0aGlzLmZpbmFsS2V5ZnJhbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5maW5hbEtleWZyYW1lID0gZmluYWxLZXlmcmFtZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSByZW1vdmVkIHRyYW5zZm9ybSB2YWx1ZXMsIHJlYXBwbHkgdGhlbSBiZWZvcmUgdGhlIG5leHQgcmVuZGVyXG4gICAgICAgIGlmICgoX2EgPSB0aGlzLnJlbW92ZWRUcmFuc2Zvcm1zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZWRUcmFuc2Zvcm1zLmZvckVhY2goKFt1bnNldFRyYW5zZm9ybU5hbWUsIHVuc2V0VHJhbnNmb3JtVmFsdWVdKSA9PiB7XG4gICAgICAgICAgICAgICAgZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICAuZ2V0VmFsdWUodW5zZXRUcmFuc2Zvcm1OYW1lKVxuICAgICAgICAgICAgICAgICAgICAuc2V0KHVuc2V0VHJhbnNmb3JtVmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlTm9uZUtleWZyYW1lcygpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuaW1hdGFibGUuIEV4YW1wbGVzOlxuICpcbiAqIOKchTogMTAwLCBcIjEwMHB4XCIsIFwiI2ZmZlwiXG4gKiDinYw6IFwiYmxvY2tcIiwgXCJ1cmwoMi5qcGcpXCJcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jb25zdCBpc0FuaW1hdGFibGUgPSAodmFsdWUsIG5hbWUpID0+IHtcbiAgICAvLyBJZiB0aGUgbGlzdCBvZiBrZXlzIHRhdCBtaWdodCBiZSBub24tYW5pbWF0YWJsZSBncm93cywgcmVwbGFjZSB3aXRoIFNldFxuICAgIGlmIChuYW1lID09PSBcInpJbmRleFwiKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy8gSWYgaXQncyBhIG51bWJlciBvciBhIGtleWZyYW1lcyBhcnJheSwgd2UgY2FuIGFuaW1hdGUgaXQuIFdlIG1pZ2h0IGF0IHNvbWUgcG9pbnRcbiAgICAvLyBuZWVkIHRvIGRvIGEgZGVlcCBpc0FuaW1hdGFibGUgY2hlY2sgb2Yga2V5ZnJhbWVzLCBvciBsZXQgUG9wbW90aW9uIGhhbmRsZSB0aGlzLFxuICAgIC8vIGJ1dCBmb3Igbm93IGxldHMgbGVhdmUgaXQgbGlrZSB0aGlzIGZvciBwZXJmb3JtYW5jZSByZWFzb25zXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBBcnJheS5pc0FycmF5KHZhbHVlKSlcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJiAvLyBJdCdzIGFuaW1hdGFibGUgaWYgd2UgaGF2ZSBhIHN0cmluZ1xuICAgICAgICAoY29tcGxleC50ZXN0KHZhbHVlKSB8fCB2YWx1ZSA9PT0gXCIwXCIpICYmIC8vIEFuZCBpdCBjb250YWlucyBudW1iZXJzIGFuZC9vciBjb2xvcnNcbiAgICAgICAgIXZhbHVlLnN0YXJ0c1dpdGgoXCJ1cmwoXCIpIC8vIFVubGVzcyBpdCBzdGFydHMgd2l0aCBcInVybChcIlxuICAgICkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gaGFzS2V5ZnJhbWVzQ2hhbmdlZChrZXlmcmFtZXMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0ga2V5ZnJhbWVzWzBdO1xuICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID09PSAxKVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGtleWZyYW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoa2V5ZnJhbWVzW2ldICE9PSBjdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuZnVuY3Rpb24gY2FuQW5pbWF0ZShrZXlmcmFtZXMsIG5hbWUsIHR5cGUsIHZlbG9jaXR5KSB7XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgd2UncmUgYWJsZSB0byBhbmltYXRlIGJldHdlZW4gdGhlIHN0YXJ0IGFuZCBlbmQga2V5ZnJhbWVzLFxuICAgICAqIGFuZCB0aHJvdyBhIHdhcm5pbmcgaWYgd2UncmUgYXR0ZW1wdGluZyB0byBhbmltYXRlIGJldHdlZW4gb25lIHRoYXQnc1xuICAgICAqIGFuaW1hdGFibGUgYW5kIGFub3RoZXIgdGhhdCBpc24ndC5cbiAgICAgKi9cbiAgICBjb25zdCBvcmlnaW5LZXlmcmFtZSA9IGtleWZyYW1lc1swXTtcbiAgICBpZiAob3JpZ2luS2V5ZnJhbWUgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvKipcbiAgICAgKiBUaGVzZSBhcmVuJ3QgdHJhZGl0aW9uYWxseSBhbmltYXRhYmxlIGJ1dCB3ZSBkbyBzdXBwb3J0IHRoZW0uXG4gICAgICogSW4gZnV0dXJlIHdlIGNvdWxkIGxvb2sgaW50byBtYWtpbmcgdGhpcyBtb3JlIGdlbmVyaWMgb3IgcmVwbGFjaW5nXG4gICAgICogdGhpcyBmdW5jdGlvbiB3aXRoIG1peCgpID09PSBtaXhJbW1lZGlhdGVcbiAgICAgKi9cbiAgICBpZiAobmFtZSA9PT0gXCJkaXNwbGF5XCIgfHwgbmFtZSA9PT0gXCJ2aXNpYmlsaXR5XCIpXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIGNvbnN0IHRhcmdldEtleWZyYW1lID0ga2V5ZnJhbWVzW2tleWZyYW1lcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBpc09yaWdpbkFuaW1hdGFibGUgPSBpc0FuaW1hdGFibGUob3JpZ2luS2V5ZnJhbWUsIG5hbWUpO1xuICAgIGNvbnN0IGlzVGFyZ2V0QW5pbWF0YWJsZSA9IGlzQW5pbWF0YWJsZSh0YXJnZXRLZXlmcmFtZSwgbmFtZSk7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhpc09yaWdpbkFuaW1hdGFibGUgPT09IGlzVGFyZ2V0QW5pbWF0YWJsZSwgYFlvdSBhcmUgdHJ5aW5nIHRvIGFuaW1hdGUgJHtuYW1lfSBmcm9tIFwiJHtvcmlnaW5LZXlmcmFtZX1cIiB0byBcIiR7dGFyZ2V0S2V5ZnJhbWV9XCIuICR7b3JpZ2luS2V5ZnJhbWV9IGlzIG5vdCBhbiBhbmltYXRhYmxlIHZhbHVlIC0gdG8gZW5hYmxlIHRoaXMgYW5pbWF0aW9uIHNldCAke29yaWdpbktleWZyYW1lfSB0byBhIHZhbHVlIGFuaW1hdGFibGUgdG8gJHt0YXJnZXRLZXlmcmFtZX0gdmlhIHRoZSBcXGBzdHlsZVxcYCBwcm9wZXJ0eS5gKTtcbiAgICAvLyBBbHdheXMgc2tpcCBpZiBhbnkgb2YgdGhlc2UgYXJlIHRydWVcbiAgICBpZiAoIWlzT3JpZ2luQW5pbWF0YWJsZSB8fCAhaXNUYXJnZXRBbmltYXRhYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIChoYXNLZXlmcmFtZXNDaGFuZ2VkKGtleWZyYW1lcykgfHxcbiAgICAgICAgKCh0eXBlID09PSBcInNwcmluZ1wiIHx8IG1vdGlvbkRvbS5pc0dlbmVyYXRvcih0eXBlKSkgJiYgdmVsb2NpdHkpKTtcbn1cblxuY29uc3QgaXNOb3ROdWxsID0gKHZhbHVlKSA9PiB2YWx1ZSAhPT0gbnVsbDtcbmZ1bmN0aW9uIGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB7IHJlcGVhdCwgcmVwZWF0VHlwZSA9IFwibG9vcFwiIH0sIGZpbmFsS2V5ZnJhbWUpIHtcbiAgICBjb25zdCByZXNvbHZlZEtleWZyYW1lcyA9IGtleWZyYW1lcy5maWx0ZXIoaXNOb3ROdWxsKTtcbiAgICBjb25zdCBpbmRleCA9IHJlcGVhdCAmJiByZXBlYXRUeXBlICE9PSBcImxvb3BcIiAmJiByZXBlYXQgJSAyID09PSAxXG4gICAgICAgID8gMFxuICAgICAgICA6IHJlc29sdmVkS2V5ZnJhbWVzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuICFpbmRleCB8fCBmaW5hbEtleWZyYW1lID09PSB1bmRlZmluZWRcbiAgICAgICAgPyByZXNvbHZlZEtleWZyYW1lc1tpbmRleF1cbiAgICAgICAgOiBmaW5hbEtleWZyYW1lO1xufVxuXG4vKipcbiAqIE1heGltdW0gdGltZSBhbGxvd2VkIGJldHdlZW4gYW4gYW5pbWF0aW9uIGJlaW5nIGNyZWF0ZWQgYW5kIGl0IGJlaW5nXG4gKiByZXNvbHZlZCBmb3IgdXMgdG8gdXNlIHRoZSBsYXR0ZXIgYXMgdGhlIHN0YXJ0IHRpbWUuXG4gKlxuICogVGhpcyBpcyB0byBlbnN1cmUgdGhhdCB3aGlsZSB3ZSBwcmVmZXIgdG8gXCJzdGFydFwiIGFuIGFuaW1hdGlvbiBhcyBzb29uXG4gKiBhcyBpdCdzIHRyaWdnZXJlZCwgd2UgYWxzbyB3YW50IHRvIGF2b2lkIGEgdmlzdWFsIGp1bXAgaWYgdGhlcmUncyBhIGJpZyBkZWxheVxuICogYmV0d2VlbiB0aGVzZSB0d28gbW9tZW50cy5cbiAqL1xuY29uc3QgTUFYX1JFU09MVkVfREVMQVkgPSA0MDtcbmNsYXNzIEJhc2VBbmltYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgYXV0b3BsYXkgPSB0cnVlLCBkZWxheSA9IDAsIHR5cGUgPSBcImtleWZyYW1lc1wiLCByZXBlYXQgPSAwLCByZXBlYXREZWxheSA9IDAsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiwgLi4ub3B0aW9ucyB9KSB7XG4gICAgICAgIC8vIFRyYWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBoYXMgYmVlbiBzdG9wcGVkLiBTdG9wcGVkIGFuaW1hdGlvbnMgd29uJ3QgcmVzdGFydC5cbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oYXNBdHRlbXB0ZWRSZXNvbHZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gdGltZS5ub3coKTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgYXV0b3BsYXksXG4gICAgICAgICAgICBkZWxheSxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICByZXBlYXQsXG4gICAgICAgICAgICByZXBlYXREZWxheSxcbiAgICAgICAgICAgIHJlcGVhdFR5cGUsXG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCB1c2VzIHRoZSBjcmVhdGVkQXQgYW5kIHJlc29sdmVkQXQgdG8gY2FsY3VsYXRlIHRoZVxuICAgICAqIGFuaW1hdGlvbiBzdGFydFRpbWUuICpJZGVhbGx5Kiwgd2Ugd291bGQgdXNlIHRoZSBjcmVhdGVkQXQgdGltZSBhcyB0PTBcbiAgICAgKiBhcyB0aGUgZm9sbG93aW5nIGZyYW1lIHdvdWxkIHRoZW4gYmUgdGhlIGZpcnN0IGZyYW1lIG9mIHRoZSBhbmltYXRpb24gaW5cbiAgICAgKiBwcm9ncmVzcywgd2hpY2ggd291bGQgZmVlbCBzbmFwcGllci5cbiAgICAgKlxuICAgICAqIEhvd2V2ZXIsIGlmIHRoZXJlJ3MgYSBkZWxheSAobWFpbiB0aHJlYWQgd29yaykgYmV0d2VlbiB0aGUgY3JlYXRpb24gb2ZcbiAgICAgKiB0aGUgYW5pbWF0aW9uIGFuZCB0aGUgZmlyc3QgY29tbWl0ZWQgZnJhbWUsIHdlIHByZWZlciB0byB1c2UgcmVzb2x2ZWRBdFxuICAgICAqIHRvIGF2b2lkIGEgc3VkZGVuIGp1bXAgaW50byB0aGUgYW5pbWF0aW9uLlxuICAgICAqL1xuICAgIGNhbGNTdGFydFRpbWUoKSB7XG4gICAgICAgIGlmICghdGhpcy5yZXNvbHZlZEF0KVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlZEF0O1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlZEF0IC0gdGhpcy5jcmVhdGVkQXQgPiBNQVhfUkVTT0xWRV9ERUxBWVxuICAgICAgICAgICAgPyB0aGlzLnJlc29sdmVkQXRcbiAgICAgICAgICAgIDogdGhpcy5jcmVhdGVkQXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgZ2V0dGVyIGZvciByZXNvbHZlZCBkYXRhLiBJZiBrZXlmcmFtZXMgYXJlIG5vdCB5ZXQgcmVzb2x2ZWQsIGFjY2Vzc2luZ1xuICAgICAqIHRoaXMucmVzb2x2ZWQgd2lsbCBzeW5jaHJvbm91c2x5IGZsdXNoIGFsbCBwZW5kaW5nIGtleWZyYW1lIHJlc29sdmVycy5cbiAgICAgKiBUaGlzIGlzIGEgZGVvcHRpbWlzYXRpb24sIGJ1dCBhdCBpdHMgd29yc3Qgc3RpbGwgYmF0Y2hlcyByZWFkL3dyaXRlcy5cbiAgICAgKi9cbiAgICBnZXQgcmVzb2x2ZWQoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmVzb2x2ZWQgJiYgIXRoaXMuaGFzQXR0ZW1wdGVkUmVzb2x2ZSkge1xuICAgICAgICAgICAgZmx1c2hLZXlmcmFtZVJlc29sdmVycygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBtZXRob2QgdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGtleWZyYW1lcyByZXNvbHZlciBjb21wbGV0ZXMuIFRoaXMgbWV0aG9kXG4gICAgICogd2lsbCBjaGVjayBpZiBpdHMgcG9zc2libGUgdG8gcnVuIHRoZSBhbmltYXRpb24gYW5kLCBpZiBub3QsIHNraXAgaXQuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIGNhbGwgaW5pdFBsYXliYWNrIG9uIHRoZSBpbXBsZW1lbnRpbmcgY2xhc3MuXG4gICAgICovXG4gICAgb25LZXlmcmFtZXNSZXNvbHZlZChrZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlZEF0ID0gdGltZS5ub3coKTtcbiAgICAgICAgdGhpcy5oYXNBdHRlbXB0ZWRSZXNvbHZlID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCB0eXBlLCB2ZWxvY2l0eSwgZGVsYXksIG9uQ29tcGxldGUsIG9uVXBkYXRlLCBpc0dlbmVyYXRvciwgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIGNhbid0IGFuaW1hdGUgdGhpcyB2YWx1ZSB3aXRoIHRoZSByZXNvbHZlZCBrZXlmcmFtZXNcbiAgICAgICAgICogdGhlbiB3ZSBzaG91bGQgY29tcGxldGUgaXQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoIWlzR2VuZXJhdG9yICYmICFjYW5BbmltYXRlKGtleWZyYW1lcywgbmFtZSwgdHlwZSwgdmVsb2NpdHkpKSB7XG4gICAgICAgICAgICAvLyBGaW5pc2ggaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCB8fCAhZGVsYXkpIHtcbiAgICAgICAgICAgICAgICBvblVwZGF0ZSAmJlxuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZShnZXRGaW5hbEtleWZyYW1lKGtleWZyYW1lcywgdGhpcy5vcHRpb25zLCBmaW5hbEtleWZyYW1lKSk7XG4gICAgICAgICAgICAgICAgb25Db21wbGV0ZSAmJiBvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gRmluaXNoIGFmdGVyIGEgZGVsYXlcbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5kdXJhdGlvbiA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzb2x2ZWRBbmltYXRpb24gPSB0aGlzLmluaXRQbGF5YmFjayhrZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICBpZiAocmVzb2x2ZWRBbmltYXRpb24gPT09IGZhbHNlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl9yZXNvbHZlZCA9IHtcbiAgICAgICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgICAgIGZpbmFsS2V5ZnJhbWUsXG4gICAgICAgICAgICAuLi5yZXNvbHZlZEFuaW1hdGlvbixcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5vblBvc3RSZXNvbHZlZCgpO1xuICAgIH1cbiAgICBvblBvc3RSZXNvbHZlZCgpIHsgfVxuICAgIC8qKlxuICAgICAqIEFsbG93cyB0aGUgcmV0dXJuZWQgYW5pbWF0aW9uIHRvIGJlIGF3YWl0ZWQgb3IgcHJvbWlzZS1jaGFpbmVkLiBDdXJyZW50bHlcbiAgICAgKiByZXNvbHZlcyB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMgYXQgYWxsIGJ1dCBpbiBhIGZ1dHVyZSB1cGRhdGUgY291bGQvc2hvdWxkXG4gICAgICogcmVqZWN0IGlmIGl0cyBjYW5jZWxzLlxuICAgICAqL1xuICAgIHRoZW4ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgIH1cbiAgICBmbGF0dGVuKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMudHlwZSA9IFwia2V5ZnJhbWVzXCI7XG4gICAgICAgIHRoaXMub3B0aW9ucy5lYXNlID0gXCJsaW5lYXJcIjtcbiAgICB9XG4gICAgdXBkYXRlRmluaXNoZWRQcm9taXNlKCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRGaW5pc2hlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlRmluaXNoZWRQcm9taXNlID0gcmVzb2x2ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKlxuICBWYWx1ZSBpbiByYW5nZSBmcm9tIHByb2dyZXNzXG5cbiAgR2l2ZW4gYSBsb3dlciBsaW1pdCBhbmQgYW4gdXBwZXIgbGltaXQsIHdlIHJldHVybiB0aGUgdmFsdWUgd2l0aGluXG4gIHRoYXQgcmFuZ2UgYXMgZXhwcmVzc2VkIGJ5IHByb2dyZXNzICh1c3VhbGx5IGEgbnVtYmVyIGZyb20gMCB0byAxKVxuXG4gIFNvIHByb2dyZXNzID0gMC41IHdvdWxkIGNoYW5nZVxuXG4gIGZyb20gLS0tLS0tLS0gdG9cblxuICB0b1xuXG4gIGZyb20gLS0tLSB0b1xuXG4gIEUuZy4gZnJvbSA9IDEwLCB0byA9IDIwLCBwcm9ncmVzcyA9IDAuNSA9PiAxNVxuXG4gIEBwYXJhbSBbbnVtYmVyXTogTG93ZXIgbGltaXQgb2YgcmFuZ2VcbiAgQHBhcmFtIFtudW1iZXJdOiBVcHBlciBsaW1pdCBvZiByYW5nZVxuICBAcGFyYW0gW251bWJlcl06IFRoZSBwcm9ncmVzcyBiZXR3ZWVuIGxvd2VyIGFuZCB1cHBlciBsaW1pdHMgZXhwcmVzc2VkIDAtMVxuICBAcmV0dXJuIFtudW1iZXJdOiBWYWx1ZSBhcyBjYWxjdWxhdGVkIGZyb20gcHJvZ3Jlc3Mgd2l0aGluIHJhbmdlIChub3QgbGltaXRlZCB3aXRoaW4gcmFuZ2UpXG4qL1xuY29uc3QgbWl4TnVtYmVyJDEgPSAoZnJvbSwgdG8sIHByb2dyZXNzKSA9PiB7XG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIHByb2dyZXNzO1xufTtcblxuLy8gQWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL21qYWNrc29uLzUzMTEyNTZcbmZ1bmN0aW9uIGh1ZVRvUmdiKHAsIHEsIHQpIHtcbiAgICBpZiAodCA8IDApXG4gICAgICAgIHQgKz0gMTtcbiAgICBpZiAodCA+IDEpXG4gICAgICAgIHQgLT0gMTtcbiAgICBpZiAodCA8IDEgLyA2KVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiA2ICogdDtcbiAgICBpZiAodCA8IDEgLyAyKVxuICAgICAgICByZXR1cm4gcTtcbiAgICBpZiAodCA8IDIgLyAzKVxuICAgICAgICByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgcmV0dXJuIHA7XG59XG5mdW5jdGlvbiBoc2xhVG9SZ2JhKHsgaHVlLCBzYXR1cmF0aW9uLCBsaWdodG5lc3MsIGFscGhhIH0pIHtcbiAgICBodWUgLz0gMzYwO1xuICAgIHNhdHVyYXRpb24gLz0gMTAwO1xuICAgIGxpZ2h0bmVzcyAvPSAxMDA7XG4gICAgbGV0IHJlZCA9IDA7XG4gICAgbGV0IGdyZWVuID0gMDtcbiAgICBsZXQgYmx1ZSA9IDA7XG4gICAgaWYgKCFzYXR1cmF0aW9uKSB7XG4gICAgICAgIHJlZCA9IGdyZWVuID0gYmx1ZSA9IGxpZ2h0bmVzcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IHEgPSBsaWdodG5lc3MgPCAwLjVcbiAgICAgICAgICAgID8gbGlnaHRuZXNzICogKDEgKyBzYXR1cmF0aW9uKVxuICAgICAgICAgICAgOiBsaWdodG5lc3MgKyBzYXR1cmF0aW9uIC0gbGlnaHRuZXNzICogc2F0dXJhdGlvbjtcbiAgICAgICAgY29uc3QgcCA9IDIgKiBsaWdodG5lc3MgLSBxO1xuICAgICAgICByZWQgPSBodWVUb1JnYihwLCBxLCBodWUgKyAxIC8gMyk7XG4gICAgICAgIGdyZWVuID0gaHVlVG9SZ2IocCwgcSwgaHVlKTtcbiAgICAgICAgYmx1ZSA9IGh1ZVRvUmdiKHAsIHEsIGh1ZSAtIDEgLyAzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcmVkOiBNYXRoLnJvdW5kKHJlZCAqIDI1NSksXG4gICAgICAgIGdyZWVuOiBNYXRoLnJvdW5kKGdyZWVuICogMjU1KSxcbiAgICAgICAgYmx1ZTogTWF0aC5yb3VuZChibHVlICogMjU1KSxcbiAgICAgICAgYWxwaGEsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gbWl4SW1tZWRpYXRlKGEsIGIpIHtcbiAgICByZXR1cm4gKHApID0+IChwID4gMCA/IGIgOiBhKTtcbn1cblxuLy8gTGluZWFyIGNvbG9yIHNwYWNlIGJsZW5kaW5nXG4vLyBFeHBsYWluZWQgaHR0cHM6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1MS25xRUNjZzZHd1xuLy8gRGVtb25zdHJhdGVkIGh0dHA6Ly9jb2RlcGVuLmlvL29zdWJsYWtlL3Blbi94R1ZWYU5cbmNvbnN0IG1peExpbmVhckNvbG9yID0gKGZyb20sIHRvLCB2KSA9PiB7XG4gICAgY29uc3QgZnJvbUV4cG8gPSBmcm9tICogZnJvbTtcbiAgICBjb25zdCBleHBvID0gdiAqICh0byAqIHRvIC0gZnJvbUV4cG8pICsgZnJvbUV4cG87XG4gICAgcmV0dXJuIGV4cG8gPCAwID8gMCA6IE1hdGguc3FydChleHBvKTtcbn07XG5jb25zdCBjb2xvclR5cGVzID0gW2hleCwgcmdiYSwgaHNsYV07XG5jb25zdCBnZXRDb2xvclR5cGUgPSAodikgPT4gY29sb3JUeXBlcy5maW5kKCh0eXBlKSA9PiB0eXBlLnRlc3QodikpO1xuZnVuY3Rpb24gYXNSR0JBKGNvbG9yKSB7XG4gICAgY29uc3QgdHlwZSA9IGdldENvbG9yVHlwZShjb2xvcik7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhCb29sZWFuKHR5cGUpLCBgJyR7Y29sb3J9JyBpcyBub3QgYW4gYW5pbWF0YWJsZSBjb2xvci4gVXNlIHRoZSBlcXVpdmFsZW50IGNvbG9yIGNvZGUgaW5zdGVhZC5gKTtcbiAgICBpZiAoIUJvb2xlYW4odHlwZSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBsZXQgbW9kZWwgPSB0eXBlLnBhcnNlKGNvbG9yKTtcbiAgICBpZiAodHlwZSA9PT0gaHNsYSkge1xuICAgICAgICAvLyBUT0RPIFJlbW92ZSB0aGlzIGNhc3QgLSBuZWVkZWQgc2luY2UgTW90aW9uJ3Mgc3RyaWN0ZXIgdHlwaW5nXG4gICAgICAgIG1vZGVsID0gaHNsYVRvUmdiYShtb2RlbCk7XG4gICAgfVxuICAgIHJldHVybiBtb2RlbDtcbn1cbmNvbnN0IG1peENvbG9yID0gKGZyb20sIHRvKSA9PiB7XG4gICAgY29uc3QgZnJvbVJHQkEgPSBhc1JHQkEoZnJvbSk7XG4gICAgY29uc3QgdG9SR0JBID0gYXNSR0JBKHRvKTtcbiAgICBpZiAoIWZyb21SR0JBIHx8ICF0b1JHQkEpIHtcbiAgICAgICAgcmV0dXJuIG1peEltbWVkaWF0ZShmcm9tLCB0byk7XG4gICAgfVxuICAgIGNvbnN0IGJsZW5kZWQgPSB7IC4uLmZyb21SR0JBIH07XG4gICAgcmV0dXJuICh2KSA9PiB7XG4gICAgICAgIGJsZW5kZWQucmVkID0gbWl4TGluZWFyQ29sb3IoZnJvbVJHQkEucmVkLCB0b1JHQkEucmVkLCB2KTtcbiAgICAgICAgYmxlbmRlZC5ncmVlbiA9IG1peExpbmVhckNvbG9yKGZyb21SR0JBLmdyZWVuLCB0b1JHQkEuZ3JlZW4sIHYpO1xuICAgICAgICBibGVuZGVkLmJsdWUgPSBtaXhMaW5lYXJDb2xvcihmcm9tUkdCQS5ibHVlLCB0b1JHQkEuYmx1ZSwgdik7XG4gICAgICAgIGJsZW5kZWQuYWxwaGEgPSBtaXhOdW1iZXIkMShmcm9tUkdCQS5hbHBoYSwgdG9SR0JBLmFscGhhLCB2KTtcbiAgICAgICAgcmV0dXJuIHJnYmEudHJhbnNmb3JtKGJsZW5kZWQpO1xuICAgIH07XG59O1xuXG4vKipcbiAqIFBpcGVcbiAqIENvbXBvc2Ugb3RoZXIgdHJhbnNmb3JtZXJzIHRvIHJ1biBsaW5lYXJpbHlcbiAqIHBpcGUobWluKDIwKSwgbWF4KDQwKSlcbiAqIEBwYXJhbSAgey4uLmZ1bmN0aW9uc30gdHJhbnNmb3JtZXJzXG4gKiBAcmV0dXJuIHtmdW5jdGlvbn1cbiAqL1xuY29uc3QgY29tYmluZUZ1bmN0aW9ucyA9IChhLCBiKSA9PiAodikgPT4gYihhKHYpKTtcbmNvbnN0IHBpcGUgPSAoLi4udHJhbnNmb3JtZXJzKSA9PiB0cmFuc2Zvcm1lcnMucmVkdWNlKGNvbWJpbmVGdW5jdGlvbnMpO1xuXG5jb25zdCBpbnZpc2libGVWYWx1ZXMgPSBuZXcgU2V0KFtcIm5vbmVcIiwgXCJoaWRkZW5cIl0pO1xuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBwcm92aWRlZCBhIHByb2dyZXNzIHZhbHVlIGJldHdlZW4gMCBhbmQgMSxcbiAqIHdpbGwgcmV0dXJuIHRoZSBcIm5vbmVcIiBvciBcImhpZGRlblwiIHN0cmluZyBvbmx5IHdoZW4gdGhlIHByb2dyZXNzIGlzIHRoYXQgb2ZcbiAqIHRoZSBvcmlnaW4gb3IgdGFyZ2V0LlxuICovXG5mdW5jdGlvbiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgaWYgKGludmlzaWJsZVZhbHVlcy5oYXMob3JpZ2luKSkge1xuICAgICAgICByZXR1cm4gKHApID0+IChwIDw9IDAgPyBvcmlnaW4gOiB0YXJnZXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIChwKSA9PiAocCA+PSAxID8gdGFyZ2V0IDogb3JpZ2luKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIG1peE51bWJlcihhLCBiKSB7XG4gICAgcmV0dXJuIChwKSA9PiBtaXhOdW1iZXIkMShhLCBiLCBwKTtcbn1cbmZ1bmN0aW9uIGdldE1peGVyJDEoYSkge1xuICAgIGlmICh0eXBlb2YgYSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICByZXR1cm4gbWl4TnVtYmVyO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gaXNDU1NWYXJpYWJsZVRva2VuKGEpXG4gICAgICAgICAgICA/IG1peEltbWVkaWF0ZVxuICAgICAgICAgICAgOiBjb2xvci50ZXN0KGEpXG4gICAgICAgICAgICAgICAgPyBtaXhDb2xvclxuICAgICAgICAgICAgICAgIDogbWl4Q29tcGxleDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhKSkge1xuICAgICAgICByZXR1cm4gbWl4QXJyYXk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIHJldHVybiBjb2xvci50ZXN0KGEpID8gbWl4Q29sb3IgOiBtaXhPYmplY3Q7XG4gICAgfVxuICAgIHJldHVybiBtaXhJbW1lZGlhdGU7XG59XG5mdW5jdGlvbiBtaXhBcnJheShhLCBiKSB7XG4gICAgY29uc3Qgb3V0cHV0ID0gWy4uLmFdO1xuICAgIGNvbnN0IG51bVZhbHVlcyA9IG91dHB1dC5sZW5ndGg7XG4gICAgY29uc3QgYmxlbmRWYWx1ZSA9IGEubWFwKCh2LCBpKSA9PiBnZXRNaXhlciQxKHYpKHYsIGJbaV0pKTtcbiAgICByZXR1cm4gKHApID0+IHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1WYWx1ZXM7IGkrKykge1xuICAgICAgICAgICAgb3V0cHV0W2ldID0gYmxlbmRWYWx1ZVtpXShwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtaXhPYmplY3QoYSwgYikge1xuICAgIGNvbnN0IG91dHB1dCA9IHsgLi4uYSwgLi4uYiB9O1xuICAgIGNvbnN0IGJsZW5kVmFsdWUgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvdXRwdXQpIHtcbiAgICAgICAgaWYgKGFba2V5XSAhPT0gdW5kZWZpbmVkICYmIGJba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBibGVuZFZhbHVlW2tleV0gPSBnZXRNaXhlciQxKGFba2V5XSkoYVtrZXldLCBiW2tleV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBibGVuZFZhbHVlKSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IGJsZW5kVmFsdWVba2V5XSh2KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH07XG59XG5mdW5jdGlvbiBtYXRjaE9yZGVyKG9yaWdpbiwgdGFyZ2V0KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IG9yZGVyZWRPcmlnaW4gPSBbXTtcbiAgICBjb25zdCBwb2ludGVycyA9IHsgY29sb3I6IDAsIHZhcjogMCwgbnVtYmVyOiAwIH07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0YXJnZXQudmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0YXJnZXQudHlwZXNbaV07XG4gICAgICAgIGNvbnN0IG9yaWdpbkluZGV4ID0gb3JpZ2luLmluZGV4ZXNbdHlwZV1bcG9pbnRlcnNbdHlwZV1dO1xuICAgICAgICBjb25zdCBvcmlnaW5WYWx1ZSA9IChfYSA9IG9yaWdpbi52YWx1ZXNbb3JpZ2luSW5kZXhdKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAwO1xuICAgICAgICBvcmRlcmVkT3JpZ2luW2ldID0gb3JpZ2luVmFsdWU7XG4gICAgICAgIHBvaW50ZXJzW3R5cGVdKys7XG4gICAgfVxuICAgIHJldHVybiBvcmRlcmVkT3JpZ2luO1xufVxuY29uc3QgbWl4Q29tcGxleCA9IChvcmlnaW4sIHRhcmdldCkgPT4ge1xuICAgIGNvbnN0IHRlbXBsYXRlID0gY29tcGxleC5jcmVhdGVUcmFuc2Zvcm1lcih0YXJnZXQpO1xuICAgIGNvbnN0IG9yaWdpblN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZShvcmlnaW4pO1xuICAgIGNvbnN0IHRhcmdldFN0YXRzID0gYW5hbHlzZUNvbXBsZXhWYWx1ZSh0YXJnZXQpO1xuICAgIGNvbnN0IGNhbkludGVycG9sYXRlID0gb3JpZ2luU3RhdHMuaW5kZXhlcy52YXIubGVuZ3RoID09PSB0YXJnZXRTdGF0cy5pbmRleGVzLnZhci5sZW5ndGggJiZcbiAgICAgICAgb3JpZ2luU3RhdHMuaW5kZXhlcy5jb2xvci5sZW5ndGggPT09IHRhcmdldFN0YXRzLmluZGV4ZXMuY29sb3IubGVuZ3RoICYmXG4gICAgICAgIG9yaWdpblN0YXRzLmluZGV4ZXMubnVtYmVyLmxlbmd0aCA+PSB0YXJnZXRTdGF0cy5pbmRleGVzLm51bWJlci5sZW5ndGg7XG4gICAgaWYgKGNhbkludGVycG9sYXRlKSB7XG4gICAgICAgIGlmICgoaW52aXNpYmxlVmFsdWVzLmhhcyhvcmlnaW4pICYmXG4gICAgICAgICAgICAhdGFyZ2V0U3RhdHMudmFsdWVzLmxlbmd0aCkgfHxcbiAgICAgICAgICAgIChpbnZpc2libGVWYWx1ZXMuaGFzKHRhcmdldCkgJiZcbiAgICAgICAgICAgICAgICAhb3JpZ2luU3RhdHMudmFsdWVzLmxlbmd0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBtaXhWaXNpYmlsaXR5KG9yaWdpbiwgdGFyZ2V0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGlwZShtaXhBcnJheShtYXRjaE9yZGVyKG9yaWdpblN0YXRzLCB0YXJnZXRTdGF0cyksIHRhcmdldFN0YXRzLnZhbHVlcyksIHRlbXBsYXRlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIG1vdGlvblV0aWxzLndhcm5pbmcodHJ1ZSwgYENvbXBsZXggdmFsdWVzICcke29yaWdpbn0nIGFuZCAnJHt0YXJnZXR9JyB0b28gZGlmZmVyZW50IHRvIG1peC4gRW5zdXJlIGFsbCBjb2xvcnMgYXJlIG9mIHRoZSBzYW1lIHR5cGUsIGFuZCB0aGF0IGVhY2ggY29udGFpbnMgdGhlIHNhbWUgcXVhbnRpdHkgb2YgbnVtYmVyIGFuZCBjb2xvciB2YWx1ZXMuIEZhbGxpbmcgYmFjayB0byBpbnN0YW50IHRyYW5zaXRpb24uYCk7XG4gICAgICAgIHJldHVybiBtaXhJbW1lZGlhdGUob3JpZ2luLCB0YXJnZXQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIG1peChmcm9tLCB0bywgcCkge1xuICAgIGlmICh0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiAmJlxuICAgICAgICB0eXBlb2YgdG8gPT09IFwibnVtYmVyXCIgJiZcbiAgICAgICAgdHlwZW9mIHAgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG1peE51bWJlciQxKGZyb20sIHRvLCBwKTtcbiAgICB9XG4gICAgY29uc3QgbWl4ZXIgPSBnZXRNaXhlciQxKGZyb20pO1xuICAgIHJldHVybiBtaXhlcihmcm9tLCB0byk7XG59XG5cbmNvbnN0IHZlbG9jaXR5U2FtcGxlRHVyYXRpb24gPSA1OyAvLyBtc1xuZnVuY3Rpb24gY2FsY0dlbmVyYXRvclZlbG9jaXR5KHJlc29sdmVWYWx1ZSwgdCwgY3VycmVudCkge1xuICAgIGNvbnN0IHByZXZUID0gTWF0aC5tYXgodCAtIHZlbG9jaXR5U2FtcGxlRHVyYXRpb24sIDApO1xuICAgIHJldHVybiB2ZWxvY2l0eVBlclNlY29uZChjdXJyZW50IC0gcmVzb2x2ZVZhbHVlKHByZXZUKSwgdCAtIHByZXZUKTtcbn1cblxuY29uc3Qgc3ByaW5nRGVmYXVsdHMgPSB7XG4gICAgLy8gRGVmYXVsdCBzcHJpbmcgcGh5c2ljc1xuICAgIHN0aWZmbmVzczogMTAwLFxuICAgIGRhbXBpbmc6IDEwLFxuICAgIG1hc3M6IDEuMCxcbiAgICB2ZWxvY2l0eTogMC4wLFxuICAgIC8vIERlZmF1bHQgZHVyYXRpb24vYm91bmNlLWJhc2VkIG9wdGlvbnNcbiAgICBkdXJhdGlvbjogODAwLCAvLyBpbiBtc1xuICAgIGJvdW5jZTogMC4zLFxuICAgIHZpc3VhbER1cmF0aW9uOiAwLjMsIC8vIGluIHNlY29uZHNcbiAgICAvLyBSZXN0IHRocmVzaG9sZHNcbiAgICByZXN0U3BlZWQ6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDEsXG4gICAgICAgIGRlZmF1bHQ6IDIsXG4gICAgfSxcbiAgICByZXN0RGVsdGE6IHtcbiAgICAgICAgZ3JhbnVsYXI6IDAuMDA1LFxuICAgICAgICBkZWZhdWx0OiAwLjUsXG4gICAgfSxcbiAgICAvLyBMaW1pdHNcbiAgICBtaW5EdXJhdGlvbjogMC4wMSwgLy8gaW4gc2Vjb25kc1xuICAgIG1heER1cmF0aW9uOiAxMC4wLCAvLyBpbiBzZWNvbmRzXG4gICAgbWluRGFtcGluZzogMC4wNSxcbiAgICBtYXhEYW1waW5nOiAxLFxufTtcblxuY29uc3Qgc2FmZU1pbiA9IDAuMDAxO1xuZnVuY3Rpb24gZmluZFNwcmluZyh7IGR1cmF0aW9uID0gc3ByaW5nRGVmYXVsdHMuZHVyYXRpb24sIGJvdW5jZSA9IHNwcmluZ0RlZmF1bHRzLmJvdW5jZSwgdmVsb2NpdHkgPSBzcHJpbmdEZWZhdWx0cy52ZWxvY2l0eSwgbWFzcyA9IHNwcmluZ0RlZmF1bHRzLm1hc3MsIH0pIHtcbiAgICBsZXQgZW52ZWxvcGU7XG4gICAgbGV0IGRlcml2YXRpdmU7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhkdXJhdGlvbiA8PSBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHMoc3ByaW5nRGVmYXVsdHMubWF4RHVyYXRpb24pLCBcIlNwcmluZyBkdXJhdGlvbiBtdXN0IGJlIDEwIHNlY29uZHMgb3IgbGVzc1wiKTtcbiAgICBsZXQgZGFtcGluZ1JhdGlvID0gMSAtIGJvdW5jZTtcbiAgICAvKipcbiAgICAgKiBSZXN0cmljdCBkYW1waW5nUmF0aW8gYW5kIGR1cmF0aW9uIHRvIHdpdGhpbiBhY2NlcHRhYmxlIHJhbmdlcy5cbiAgICAgKi9cbiAgICBkYW1waW5nUmF0aW8gPSBjbGFtcChzcHJpbmdEZWZhdWx0cy5taW5EYW1waW5nLCBzcHJpbmdEZWZhdWx0cy5tYXhEYW1waW5nLCBkYW1waW5nUmF0aW8pO1xuICAgIGR1cmF0aW9uID0gY2xhbXAoc3ByaW5nRGVmYXVsdHMubWluRHVyYXRpb24sIHNwcmluZ0RlZmF1bHRzLm1heER1cmF0aW9uLCBtb3Rpb25VdGlscy5taWxsaXNlY29uZHNUb1NlY29uZHMoZHVyYXRpb24pKTtcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5kZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgICAqL1xuICAgICAgICBlbnZlbG9wZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGEgPSBleHBvbmVudGlhbERlY2F5IC0gdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBiID0gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKTtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgcmV0dXJuIHNhZmVNaW4gLSAoYSAvIGIpICogYztcbiAgICAgICAgfTtcbiAgICAgICAgZGVyaXZhdGl2ZSA9ICh1bmRhbXBlZEZyZXEpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGV4cG9uZW50aWFsRGVjYXkgPSB1bmRhbXBlZEZyZXEgKiBkYW1waW5nUmF0aW87XG4gICAgICAgICAgICBjb25zdCBkZWx0YSA9IGV4cG9uZW50aWFsRGVjYXkgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGQgPSBkZWx0YSAqIHZlbG9jaXR5ICsgdmVsb2NpdHk7XG4gICAgICAgICAgICBjb25zdCBlID0gTWF0aC5wb3coZGFtcGluZ1JhdGlvLCAyKSAqIE1hdGgucG93KHVuZGFtcGVkRnJlcSwgMikgKiBkdXJhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IGYgPSBNYXRoLmV4cCgtZGVsdGEpO1xuICAgICAgICAgICAgY29uc3QgZyA9IGNhbGNBbmd1bGFyRnJlcShNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAgICAgY29uc3QgZmFjdG9yID0gLWVudmVsb3BlKHVuZGFtcGVkRnJlcSkgKyBzYWZlTWluID4gMCA/IC0xIDogMTtcbiAgICAgICAgICAgIHJldHVybiAoZmFjdG9yICogKChkIC0gZSkgKiBmKSkgLyBnO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyaXRpY2FsbHktZGFtcGVkIHNwcmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgZW52ZWxvcGUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodW5kYW1wZWRGcmVxIC0gdmVsb2NpdHkpICogZHVyYXRpb24gKyAxO1xuICAgICAgICAgICAgcmV0dXJuIC1zYWZlTWluICsgYSAqIGI7XG4gICAgICAgIH07XG4gICAgICAgIGRlcml2YXRpdmUgPSAodW5kYW1wZWRGcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gTWF0aC5leHAoLXVuZGFtcGVkRnJlcSAqIGR1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGIgPSAodmVsb2NpdHkgLSB1bmRhbXBlZEZyZXEpICogKGR1cmF0aW9uICogZHVyYXRpb24pO1xuICAgICAgICAgICAgcmV0dXJuIGEgKiBiO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpbml0aWFsR3Vlc3MgPSA1IC8gZHVyYXRpb247XG4gICAgY29uc3QgdW5kYW1wZWRGcmVxID0gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpO1xuICAgIGR1cmF0aW9uID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGR1cmF0aW9uKTtcbiAgICBpZiAoaXNOYU4odW5kYW1wZWRGcmVxKSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RpZmZuZXNzOiBzcHJpbmdEZWZhdWx0cy5zdGlmZm5lc3MsXG4gICAgICAgICAgICBkYW1waW5nOiBzcHJpbmdEZWZhdWx0cy5kYW1waW5nLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdGlmZm5lc3MgPSBNYXRoLnBvdyh1bmRhbXBlZEZyZXEsIDIpICogbWFzcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHN0aWZmbmVzcyxcbiAgICAgICAgICAgIGRhbXBpbmc6IGRhbXBpbmdSYXRpbyAqIDIgKiBNYXRoLnNxcnQobWFzcyAqIHN0aWZmbmVzcyksXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgfTtcbiAgICB9XG59XG5jb25zdCByb290SXRlcmF0aW9ucyA9IDEyO1xuZnVuY3Rpb24gYXBwcm94aW1hdGVSb290KGVudmVsb3BlLCBkZXJpdmF0aXZlLCBpbml0aWFsR3Vlc3MpIHtcbiAgICBsZXQgcmVzdWx0ID0gaW5pdGlhbEd1ZXNzO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcm9vdEl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgLSBlbnZlbG9wZShyZXN1bHQpIC8gZGVyaXZhdGl2ZShyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY2FsY0FuZ3VsYXJGcmVxKHVuZGFtcGVkRnJlcSwgZGFtcGluZ1JhdGlvKSB7XG4gICAgcmV0dXJuIHVuZGFtcGVkRnJlcSAqIE1hdGguc3FydCgxIC0gZGFtcGluZ1JhdGlvICogZGFtcGluZ1JhdGlvKTtcbn1cblxuY29uc3QgZHVyYXRpb25LZXlzID0gW1wiZHVyYXRpb25cIiwgXCJib3VuY2VcIl07XG5jb25zdCBwaHlzaWNzS2V5cyA9IFtcInN0aWZmbmVzc1wiLCBcImRhbXBpbmdcIiwgXCJtYXNzXCJdO1xuZnVuY3Rpb24gaXNTcHJpbmdUeXBlKG9wdGlvbnMsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5zb21lKChrZXkpID0+IG9wdGlvbnNba2V5XSAhPT0gdW5kZWZpbmVkKTtcbn1cbmZ1bmN0aW9uIGdldFNwcmluZ09wdGlvbnMob3B0aW9ucykge1xuICAgIGxldCBzcHJpbmdPcHRpb25zID0ge1xuICAgICAgICB2ZWxvY2l0eTogc3ByaW5nRGVmYXVsdHMudmVsb2NpdHksXG4gICAgICAgIHN0aWZmbmVzczogc3ByaW5nRGVmYXVsdHMuc3RpZmZuZXNzLFxuICAgICAgICBkYW1waW5nOiBzcHJpbmdEZWZhdWx0cy5kYW1waW5nLFxuICAgICAgICBtYXNzOiBzcHJpbmdEZWZhdWx0cy5tYXNzLFxuICAgICAgICBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uOiBmYWxzZSxcbiAgICAgICAgLi4ub3B0aW9ucyxcbiAgICB9O1xuICAgIC8vIHN0aWZmbmVzcy9kYW1waW5nL21hc3Mgb3ZlcnJpZGVzIGR1cmF0aW9uL2JvdW5jZVxuICAgIGlmICghaXNTcHJpbmdUeXBlKG9wdGlvbnMsIHBoeXNpY3NLZXlzKSAmJlxuICAgICAgICBpc1NwcmluZ1R5cGUob3B0aW9ucywgZHVyYXRpb25LZXlzKSkge1xuICAgICAgICBpZiAob3B0aW9ucy52aXN1YWxEdXJhdGlvbikge1xuICAgICAgICAgICAgY29uc3QgdmlzdWFsRHVyYXRpb24gPSBvcHRpb25zLnZpc3VhbER1cmF0aW9uO1xuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICgyICogTWF0aC5QSSkgLyAodmlzdWFsRHVyYXRpb24gKiAxLjIpO1xuICAgICAgICAgICAgY29uc3Qgc3RpZmZuZXNzID0gcm9vdCAqIHJvb3Q7XG4gICAgICAgICAgICBjb25zdCBkYW1waW5nID0gMiAqXG4gICAgICAgICAgICAgICAgY2xhbXAoMC4wNSwgMSwgMSAtIChvcHRpb25zLmJvdW5jZSB8fCAwKSkgKlxuICAgICAgICAgICAgICAgIE1hdGguc3FydChzdGlmZm5lc3MpO1xuICAgICAgICAgICAgc3ByaW5nT3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAuLi5zcHJpbmdPcHRpb25zLFxuICAgICAgICAgICAgICAgIG1hc3M6IHNwcmluZ0RlZmF1bHRzLm1hc3MsXG4gICAgICAgICAgICAgICAgc3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgIGRhbXBpbmcsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZGVyaXZlZCA9IGZpbmRTcHJpbmcob3B0aW9ucyk7XG4gICAgICAgICAgICBzcHJpbmdPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnNwcmluZ09wdGlvbnMsXG4gICAgICAgICAgICAgICAgLi4uZGVyaXZlZCxcbiAgICAgICAgICAgICAgICBtYXNzOiBzcHJpbmdEZWZhdWx0cy5tYXNzLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNwcmluZ09wdGlvbnMuaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNwcmluZ09wdGlvbnM7XG59XG5mdW5jdGlvbiBzcHJpbmcob3B0aW9uc09yVmlzdWFsRHVyYXRpb24gPSBzcHJpbmdEZWZhdWx0cy52aXN1YWxEdXJhdGlvbiwgYm91bmNlID0gc3ByaW5nRGVmYXVsdHMuYm91bmNlKSB7XG4gICAgY29uc3Qgb3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JWaXN1YWxEdXJhdGlvbiAhPT0gXCJvYmplY3RcIlxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHZpc3VhbER1cmF0aW9uOiBvcHRpb25zT3JWaXN1YWxEdXJhdGlvbixcbiAgICAgICAgICAgIGtleWZyYW1lczogWzAsIDFdLFxuICAgICAgICAgICAgYm91bmNlLFxuICAgICAgICB9XG4gICAgICAgIDogb3B0aW9uc09yVmlzdWFsRHVyYXRpb247XG4gICAgbGV0IHsgcmVzdFNwZWVkLCByZXN0RGVsdGEgfSA9IG9wdGlvbnM7XG4gICAgY29uc3Qgb3JpZ2luID0gb3B0aW9ucy5rZXlmcmFtZXNbMF07XG4gICAgY29uc3QgdGFyZ2V0ID0gb3B0aW9ucy5rZXlmcmFtZXNbb3B0aW9ucy5rZXlmcmFtZXMubGVuZ3RoIC0gMV07XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyB0aGUgSXRlcmF0b3Itc3BlYyByZXR1cm4gdmFsdWUuIFdlIGVuc3VyZSBpdCdzIG11dGFibGUgcmF0aGVyIHRoYW4gdXNpbmcgYSBnZW5lcmF0b3JcbiAgICAgKiB0byByZWR1Y2UgR0MgZHVyaW5nIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBjb25zdCBzdGF0ZSA9IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBvcmlnaW4gfTtcbiAgICBjb25zdCB7IHN0aWZmbmVzcywgZGFtcGluZywgbWFzcywgZHVyYXRpb24sIHZlbG9jaXR5LCBpc1Jlc29sdmVkRnJvbUR1cmF0aW9uLCB9ID0gZ2V0U3ByaW5nT3B0aW9ucyh7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIHZlbG9jaXR5OiAtbW90aW9uVXRpbHMubWlsbGlzZWNvbmRzVG9TZWNvbmRzKG9wdGlvbnMudmVsb2NpdHkgfHwgMCksXG4gICAgfSk7XG4gICAgY29uc3QgaW5pdGlhbFZlbG9jaXR5ID0gdmVsb2NpdHkgfHwgMC4wO1xuICAgIGNvbnN0IGRhbXBpbmdSYXRpbyA9IGRhbXBpbmcgLyAoMiAqIE1hdGguc3FydChzdGlmZm5lc3MgKiBtYXNzKSk7XG4gICAgY29uc3QgaW5pdGlhbERlbHRhID0gdGFyZ2V0IC0gb3JpZ2luO1xuICAgIGNvbnN0IHVuZGFtcGVkQW5ndWxhckZyZXEgPSBtb3Rpb25VdGlscy5taWxsaXNlY29uZHNUb1NlY29uZHMoTWF0aC5zcXJ0KHN0aWZmbmVzcyAvIG1hc3MpKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSB3b3JraW5nIG9uIGEgZ3JhbnVsYXIgc2NhbGUsIHVzZSBzbWFsbGVyIGRlZmF1bHRzIGZvciBkZXRlcm1pbmluZ1xuICAgICAqIHdoZW4gdGhlIHNwcmluZyBpcyBmaW5pc2hlZC5cbiAgICAgKlxuICAgICAqIFRoZXNlIGRlZmF1bHRzIGhhdmUgYmVlbiBzZWxlY3RlZCBlbXByaWNhbGx5IGJhc2VkIG9uIHdoYXQgc3RyaWtlcyBhIGdvb2RcbiAgICAgKiByYXRpbyBiZXR3ZWVuIGZlZWxpbmcgZ29vZCBhbmQgZmluaXNoaW5nIGFzIHNvb24gYXMgY2hhbmdlcyBhcmUgaW1wZXJjZXB0aWJsZS5cbiAgICAgKi9cbiAgICBjb25zdCBpc0dyYW51bGFyU2NhbGUgPSBNYXRoLmFicyhpbml0aWFsRGVsdGEpIDwgNTtcbiAgICByZXN0U3BlZWQgfHwgKHJlc3RTcGVlZCA9IGlzR3JhbnVsYXJTY2FsZVxuICAgICAgICA/IHNwcmluZ0RlZmF1bHRzLnJlc3RTcGVlZC5ncmFudWxhclxuICAgICAgICA6IHNwcmluZ0RlZmF1bHRzLnJlc3RTcGVlZC5kZWZhdWx0KTtcbiAgICByZXN0RGVsdGEgfHwgKHJlc3REZWx0YSA9IGlzR3JhbnVsYXJTY2FsZVxuICAgICAgICA/IHNwcmluZ0RlZmF1bHRzLnJlc3REZWx0YS5ncmFudWxhclxuICAgICAgICA6IHNwcmluZ0RlZmF1bHRzLnJlc3REZWx0YS5kZWZhdWx0KTtcbiAgICBsZXQgcmVzb2x2ZVNwcmluZztcbiAgICBpZiAoZGFtcGluZ1JhdGlvIDwgMSkge1xuICAgICAgICBjb25zdCBhbmd1bGFyRnJlcSA9IGNhbGNBbmd1bGFyRnJlcSh1bmRhbXBlZEFuZ3VsYXJGcmVxLCBkYW1waW5nUmF0aW8pO1xuICAgICAgICAvLyBVbmRlcmRhbXBlZCBzcHJpbmdcbiAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICByZXR1cm4gKHRhcmdldCAtXG4gICAgICAgICAgICAgICAgZW52ZWxvcGUgKlxuICAgICAgICAgICAgICAgICAgICAoKChpbml0aWFsVmVsb2NpdHkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGluZ1JhdGlvICogdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgL1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ndWxhckZyZXEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luKGFuZ3VsYXJGcmVxICogdCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5pdGlhbERlbHRhICogTWF0aC5jb3MoYW5ndWxhckZyZXEgKiB0KSkpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIGlmIChkYW1waW5nUmF0aW8gPT09IDEpIHtcbiAgICAgICAgLy8gQ3JpdGljYWxseSBkYW1wZWQgc3ByaW5nXG4gICAgICAgIHJlc29sdmVTcHJpbmcgPSAodCkgPT4gdGFyZ2V0IC1cbiAgICAgICAgICAgIE1hdGguZXhwKC11bmRhbXBlZEFuZ3VsYXJGcmVxICogdCkgKlxuICAgICAgICAgICAgICAgIChpbml0aWFsRGVsdGEgK1xuICAgICAgICAgICAgICAgICAgICAoaW5pdGlhbFZlbG9jaXR5ICsgdW5kYW1wZWRBbmd1bGFyRnJlcSAqIGluaXRpYWxEZWx0YSkgKiB0KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIE92ZXJkYW1wZWQgc3ByaW5nXG4gICAgICAgIGNvbnN0IGRhbXBlZEFuZ3VsYXJGcmVxID0gdW5kYW1wZWRBbmd1bGFyRnJlcSAqIE1hdGguc3FydChkYW1waW5nUmF0aW8gKiBkYW1waW5nUmF0aW8gLSAxKTtcbiAgICAgICAgcmVzb2x2ZVNwcmluZyA9ICh0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbnZlbG9wZSA9IE1hdGguZXhwKC1kYW1waW5nUmF0aW8gKiB1bmRhbXBlZEFuZ3VsYXJGcmVxICogdCk7XG4gICAgICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgc2luaCBvciBjb3NoIHZhbHVlcyBjYW4gaGl0IEluZmluaXR5IHNvIHdlIGNhcCB0aGVtIGhlcmVcbiAgICAgICAgICAgIGNvbnN0IGZyZXFGb3JUID0gTWF0aC5taW4oZGFtcGVkQW5ndWxhckZyZXEgKiB0LCAzMDApO1xuICAgICAgICAgICAgcmV0dXJuICh0YXJnZXQgLVxuICAgICAgICAgICAgICAgIChlbnZlbG9wZSAqXG4gICAgICAgICAgICAgICAgICAgICgoaW5pdGlhbFZlbG9jaXR5ICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhbXBpbmdSYXRpbyAqIHVuZGFtcGVkQW5ndWxhckZyZXEgKiBpbml0aWFsRGVsdGEpICpcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGguc2luaChmcmVxRm9yVCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXRpYWxEZWx0YSAqXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5jb3NoKGZyZXFGb3JUKSkpIC9cbiAgICAgICAgICAgICAgICAgICAgZGFtcGVkQW5ndWxhckZyZXEpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBnZW5lcmF0b3IgPSB7XG4gICAgICAgIGNhbGN1bGF0ZWREdXJhdGlvbjogaXNSZXNvbHZlZEZyb21EdXJhdGlvbiA/IGR1cmF0aW9uIHx8IG51bGwgOiBudWxsLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY3VycmVudCA9IHJlc29sdmVTcHJpbmcodCk7XG4gICAgICAgICAgICBpZiAoIWlzUmVzb2x2ZWRGcm9tRHVyYXRpb24pIHtcbiAgICAgICAgICAgICAgICBsZXQgY3VycmVudFZlbG9jaXR5ID0gMC4wO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIFdlIG9ubHkgbmVlZCB0byBjYWxjdWxhdGUgdmVsb2NpdHkgZm9yIHVuZGVyLWRhbXBlZCBzcHJpbmdzXG4gICAgICAgICAgICAgICAgICogYXMgb3Zlci0gYW5kIGNyaXRpY2FsbHktZGFtcGVkIHNwcmluZ3MgY2FuJ3Qgb3ZlcnNob290LCBzb1xuICAgICAgICAgICAgICAgICAqIGNoZWNraW5nIG9ubHkgZm9yIGRpc3BsYWNlbWVudCBpcyBlbm91Z2guXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKGRhbXBpbmdSYXRpbyA8IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFZlbG9jaXR5ID1cbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG1vdGlvblV0aWxzLnNlY29uZHNUb01pbGxpc2Vjb25kcyhpbml0aWFsVmVsb2NpdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBjYWxjR2VuZXJhdG9yVmVsb2NpdHkocmVzb2x2ZVNwcmluZywgdCwgY3VycmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCA9IE1hdGguYWJzKGN1cnJlbnRWZWxvY2l0eSkgPD0gcmVzdFNwZWVkO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzQmVsb3dEaXNwbGFjZW1lbnRUaHJlc2hvbGQgPSBNYXRoLmFicyh0YXJnZXQgLSBjdXJyZW50KSA8PSByZXN0RGVsdGE7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9XG4gICAgICAgICAgICAgICAgICAgIGlzQmVsb3dWZWxvY2l0eVRocmVzaG9sZCAmJiBpc0JlbG93RGlzcGxhY2VtZW50VGhyZXNob2xkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuZG9uZSA9IHQgPj0gZHVyYXRpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IHN0YXRlLmRvbmUgPyB0YXJnZXQgOiBjdXJyZW50O1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgICAgICB0b1N0cmluZzogKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY2FsY3VsYXRlZER1cmF0aW9uID0gTWF0aC5taW4obW90aW9uRG9tLmNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpLCBtb3Rpb25Eb20ubWF4R2VuZXJhdG9yRHVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgZWFzaW5nID0gbW90aW9uRG9tLmdlbmVyYXRlTGluZWFyRWFzaW5nKChwcm9ncmVzcykgPT4gZ2VuZXJhdG9yLm5leHQoY2FsY3VsYXRlZER1cmF0aW9uICogcHJvZ3Jlc3MpLnZhbHVlLCBjYWxjdWxhdGVkRHVyYXRpb24sIDMwKTtcbiAgICAgICAgICAgIHJldHVybiBjYWxjdWxhdGVkRHVyYXRpb24gKyBcIm1zIFwiICsgZWFzaW5nO1xuICAgICAgICB9LFxuICAgIH07XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbn1cblxuZnVuY3Rpb24gaW5lcnRpYSh7IGtleWZyYW1lcywgdmVsb2NpdHkgPSAwLjAsIHBvd2VyID0gMC44LCB0aW1lQ29uc3RhbnQgPSAzMjUsIGJvdW5jZURhbXBpbmcgPSAxMCwgYm91bmNlU3RpZmZuZXNzID0gNTAwLCBtb2RpZnlUYXJnZXQsIG1pbiwgbWF4LCByZXN0RGVsdGEgPSAwLjUsIHJlc3RTcGVlZCwgfSkge1xuICAgIGNvbnN0IG9yaWdpbiA9IGtleWZyYW1lc1swXTtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgZG9uZTogZmFsc2UsXG4gICAgICAgIHZhbHVlOiBvcmlnaW4sXG4gICAgfTtcbiAgICBjb25zdCBpc091dE9mQm91bmRzID0gKHYpID0+IChtaW4gIT09IHVuZGVmaW5lZCAmJiB2IDwgbWluKSB8fCAobWF4ICE9PSB1bmRlZmluZWQgJiYgdiA+IG1heCk7XG4gICAgY29uc3QgbmVhcmVzdEJvdW5kYXJ5ID0gKHYpID0+IHtcbiAgICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1heDtcbiAgICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIG1pbjtcbiAgICAgICAgcmV0dXJuIE1hdGguYWJzKG1pbiAtIHYpIDwgTWF0aC5hYnMobWF4IC0gdikgPyBtaW4gOiBtYXg7XG4gICAgfTtcbiAgICBsZXQgYW1wbGl0dWRlID0gcG93ZXIgKiB2ZWxvY2l0eTtcbiAgICBjb25zdCBpZGVhbCA9IG9yaWdpbiArIGFtcGxpdHVkZTtcbiAgICBjb25zdCB0YXJnZXQgPSBtb2RpZnlUYXJnZXQgPT09IHVuZGVmaW5lZCA/IGlkZWFsIDogbW9kaWZ5VGFyZ2V0KGlkZWFsKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGUgdGFyZ2V0IGhhcyBjaGFuZ2VkIHdlIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZSBhbXBsaXR1ZGUsIG90aGVyd2lzZVxuICAgICAqIHRoZSBhbmltYXRpb24gd2lsbCBzdGFydCBmcm9tIHRoZSB3cm9uZyBwb3NpdGlvbi5cbiAgICAgKi9cbiAgICBpZiAodGFyZ2V0ICE9PSBpZGVhbClcbiAgICAgICAgYW1wbGl0dWRlID0gdGFyZ2V0IC0gb3JpZ2luO1xuICAgIGNvbnN0IGNhbGNEZWx0YSA9ICh0KSA9PiAtYW1wbGl0dWRlICogTWF0aC5leHAoLXQgLyB0aW1lQ29uc3RhbnQpO1xuICAgIGNvbnN0IGNhbGNMYXRlc3QgPSAodCkgPT4gdGFyZ2V0ICsgY2FsY0RlbHRhKHQpO1xuICAgIGNvbnN0IGFwcGx5RnJpY3Rpb24gPSAodCkgPT4ge1xuICAgICAgICBjb25zdCBkZWx0YSA9IGNhbGNEZWx0YSh0KTtcbiAgICAgICAgY29uc3QgbGF0ZXN0ID0gY2FsY0xhdGVzdCh0KTtcbiAgICAgICAgc3RhdGUuZG9uZSA9IE1hdGguYWJzKGRlbHRhKSA8PSByZXN0RGVsdGE7XG4gICAgICAgIHN0YXRlLnZhbHVlID0gc3RhdGUuZG9uZSA/IHRhcmdldCA6IGxhdGVzdDtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElkZWFsbHkgdGhpcyB3b3VsZCByZXNvbHZlIGZvciB0IGluIGEgc3RhdGVsZXNzIHdheSwgd2UgY291bGRcbiAgICAgKiBkbyB0aGF0IGJ5IGFsd2F5cyBwcmVjYWxjdWxhdGluZyB0aGUgYW5pbWF0aW9uIGJ1dCBhcyB3ZSBrbm93XG4gICAgICogdGhpcyB3aWxsIGJlIGRvbmUgYW55d2F5IHdlIGNhbiBhc3N1bWUgdGhhdCBzcHJpbmcgd2lsbFxuICAgICAqIGJlIGRpc2NvdmVyZWQgZHVyaW5nIHRoYXQuXG4gICAgICovXG4gICAgbGV0IHRpbWVSZWFjaGVkQm91bmRhcnk7XG4gICAgbGV0IHNwcmluZyQxO1xuICAgIGNvbnN0IGNoZWNrQ2F0Y2hCb3VuZGFyeSA9ICh0KSA9PiB7XG4gICAgICAgIGlmICghaXNPdXRPZkJvdW5kcyhzdGF0ZS52YWx1ZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRpbWVSZWFjaGVkQm91bmRhcnkgPSB0O1xuICAgICAgICBzcHJpbmckMSA9IHNwcmluZyh7XG4gICAgICAgICAgICBrZXlmcmFtZXM6IFtzdGF0ZS52YWx1ZSwgbmVhcmVzdEJvdW5kYXJ5KHN0YXRlLnZhbHVlKV0sXG4gICAgICAgICAgICB2ZWxvY2l0eTogY2FsY0dlbmVyYXRvclZlbG9jaXR5KGNhbGNMYXRlc3QsIHQsIHN0YXRlLnZhbHVlKSwgLy8gVE9ETzogVGhpcyBzaG91bGQgYmUgcGFzc2luZyAqIDEwMDBcbiAgICAgICAgICAgIGRhbXBpbmc6IGJvdW5jZURhbXBpbmcsXG4gICAgICAgICAgICBzdGlmZm5lc3M6IGJvdW5jZVN0aWZmbmVzcyxcbiAgICAgICAgICAgIHJlc3REZWx0YSxcbiAgICAgICAgICAgIHJlc3RTcGVlZCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjaGVja0NhdGNoQm91bmRhcnkoMCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY2FsY3VsYXRlZER1cmF0aW9uOiBudWxsLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSBuZWVkIHRvIHJlc29sdmUgdGhlIGZyaWN0aW9uIHRvIGZpZ3VyZSBvdXQgaWYgd2UgbmVlZCBhXG4gICAgICAgICAgICAgKiBzcHJpbmcgYnV0IHdlIGRvbid0IHdhbnQgdG8gZG8gdGhpcyB0d2ljZSBwZXIgZnJhbWUuIFNvIGhlcmVcbiAgICAgICAgICAgICAqIHdlIGZsYWcgaWYgd2UgdXBkYXRlZCBmb3IgdGhpcyBmcmFtZSBhbmQgbGF0ZXIgaWYgd2UgZGlkXG4gICAgICAgICAgICAgKiB3ZSBjYW4gc2tpcCBkb2luZyBpdCBhZ2Fpbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbGV0IGhhc1VwZGF0ZWRGcmFtZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCFzcHJpbmckMSAmJiB0aW1lUmVhY2hlZEJvdW5kYXJ5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBoYXNVcGRhdGVkRnJhbWUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGFwcGx5RnJpY3Rpb24odCk7XG4gICAgICAgICAgICAgICAgY2hlY2tDYXRjaEJvdW5kYXJ5KHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIGEgc3ByaW5nIGFuZCB0aGUgcHJvdmlkZWQgdCBpcyBiZXlvbmQgdGhlIG1vbWVudCB0aGUgZnJpY3Rpb25cbiAgICAgICAgICAgICAqIGFuaW1hdGlvbiBjcm9zc2VkIHRoZSBtaW4vbWF4IGJvdW5kYXJ5LCB1c2UgdGhlIHNwcmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRpbWVSZWFjaGVkQm91bmRhcnkgIT09IHVuZGVmaW5lZCAmJiB0ID49IHRpbWVSZWFjaGVkQm91bmRhcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3ByaW5nJDEubmV4dCh0IC0gdGltZVJlYWNoZWRCb3VuZGFyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAhaGFzVXBkYXRlZEZyYW1lICYmIGFwcGx5RnJpY3Rpb24odCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IGVhc2VJbiA9IC8qQF9fUFVSRV9fKi8gY3ViaWNCZXppZXIoMC40MiwgMCwgMSwgMSk7XG5jb25zdCBlYXNlT3V0ID0gLypAX19QVVJFX18qLyBjdWJpY0JlemllcigwLCAwLCAwLjU4LCAxKTtcbmNvbnN0IGVhc2VJbk91dCA9IC8qQF9fUFVSRV9fKi8gY3ViaWNCZXppZXIoMC40MiwgMCwgMC41OCwgMSk7XG5cbmNvbnN0IGlzRWFzaW5nQXJyYXkgPSAoZWFzZSkgPT4ge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGVhc2UpICYmIHR5cGVvZiBlYXNlWzBdICE9PSBcIm51bWJlclwiO1xufTtcblxuY29uc3QgZWFzaW5nTG9va3VwID0ge1xuICAgIGxpbmVhcjogbW90aW9uVXRpbHMubm9vcCxcbiAgICBlYXNlSW4sXG4gICAgZWFzZUluT3V0LFxuICAgIGVhc2VPdXQsXG4gICAgY2lyY0luLFxuICAgIGNpcmNJbk91dCxcbiAgICBjaXJjT3V0LFxuICAgIGJhY2tJbixcbiAgICBiYWNrSW5PdXQsXG4gICAgYmFja091dCxcbiAgICBhbnRpY2lwYXRlLFxufTtcbmNvbnN0IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uID0gKGRlZmluaXRpb24pID0+IHtcbiAgICBpZiAobW90aW9uRG9tLmlzQmV6aWVyRGVmaW5pdGlvbihkZWZpbml0aW9uKSkge1xuICAgICAgICAvLyBJZiBjdWJpYyBiZXppZXIgZGVmaW5pdGlvbiwgY3JlYXRlIGJlemllciBjdXJ2ZVxuICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoZGVmaW5pdGlvbi5sZW5ndGggPT09IDQsIGBDdWJpYyBiZXppZXIgYXJyYXlzIG11c3QgY29udGFpbiBmb3VyIG51bWVyaWNhbCB2YWx1ZXMuYCk7XG4gICAgICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSBkZWZpbml0aW9uO1xuICAgICAgICByZXR1cm4gY3ViaWNCZXppZXIoeDEsIHkxLCB4MiwgeTIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGVmaW5pdGlvbiA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAvLyBFbHNlIGxvb2t1cCBmcm9tIHRhYmxlXG4gICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl0gIT09IHVuZGVmaW5lZCwgYEludmFsaWQgZWFzaW5nIHR5cGUgJyR7ZGVmaW5pdGlvbn0nYCk7XG4gICAgICAgIHJldHVybiBlYXNpbmdMb29rdXBbZGVmaW5pdGlvbl07XG4gICAgfVxuICAgIHJldHVybiBkZWZpbml0aW9uO1xufTtcblxuZnVuY3Rpb24gY3JlYXRlTWl4ZXJzKG91dHB1dCwgZWFzZSwgY3VzdG9tTWl4ZXIpIHtcbiAgICBjb25zdCBtaXhlcnMgPSBbXTtcbiAgICBjb25zdCBtaXhlckZhY3RvcnkgPSBjdXN0b21NaXhlciB8fCBtaXg7XG4gICAgY29uc3QgbnVtTWl4ZXJzID0gb3V0cHV0Lmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1NaXhlcnM7IGkrKykge1xuICAgICAgICBsZXQgbWl4ZXIgPSBtaXhlckZhY3Rvcnkob3V0cHV0W2ldLCBvdXRwdXRbaSArIDFdKTtcbiAgICAgICAgaWYgKGVhc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGVhc2luZ0Z1bmN0aW9uID0gQXJyYXkuaXNBcnJheShlYXNlKSA/IGVhc2VbaV0gfHwgbW90aW9uVXRpbHMubm9vcCA6IGVhc2U7XG4gICAgICAgICAgICBtaXhlciA9IHBpcGUoZWFzaW5nRnVuY3Rpb24sIG1peGVyKTtcbiAgICAgICAgfVxuICAgICAgICBtaXhlcnMucHVzaChtaXhlcik7XG4gICAgfVxuICAgIHJldHVybiBtaXhlcnM7XG59XG4vKipcbiAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgbWFwcyBmcm9tIGEgbnVtZXJpY2FsIGlucHV0IGFycmF5IHRvIGEgZ2VuZXJpYyBvdXRwdXQgYXJyYXkuXG4gKlxuICogQWNjZXB0czpcbiAqICAgLSBOdW1iZXJzXG4gKiAgIC0gQ29sb3JzIChoZXgsIGhzbCwgaHNsYSwgcmdiLCByZ2JhKVxuICogICAtIENvbXBsZXggKGNvbWJpbmF0aW9ucyBvZiBvbmUgb3IgbW9yZSBudW1iZXJzIG9yIHN0cmluZ3MpXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBtaXhDb2xvciA9IGludGVycG9sYXRlKFswLCAxXSwgWycjZmZmJywgJyMwMDAnXSlcbiAqXG4gKiBtaXhDb2xvcigwLjUpIC8vICdyZ2JhKDEyOCwgMTI4LCAxMjgsIDEpJ1xuICogYGBgXG4gKlxuICogVE9ETyBSZXZpc3QgdGhpcyBhcHByb2FjaCBvbmNlIHdlJ3ZlIG1vdmVkIHRvIGRhdGEgbW9kZWxzIGZvciB2YWx1ZXMsXG4gKiBwcm9iYWJseSBub3QgbmVlZGVkIHRvIHByZWdlbmVyYXRlIG1peGVyIGZ1bmN0aW9ucy5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGludGVycG9sYXRlKGlucHV0LCBvdXRwdXQsIHsgY2xhbXA6IGlzQ2xhbXAgPSB0cnVlLCBlYXNlLCBtaXhlciB9ID0ge30pIHtcbiAgICBjb25zdCBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoaW5wdXRMZW5ndGggPT09IG91dHB1dC5sZW5ndGgsIFwiQm90aCBpbnB1dCBhbmQgb3V0cHV0IHJhbmdlcyBtdXN0IGJlIHRoZSBzYW1lIGxlbmd0aFwiKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBvbmx5IHByb3ZpZGVkIGEgc2luZ2xlIGlucHV0LCB3ZSBjYW4ganVzdCBtYWtlIGEgZnVuY3Rpb25cbiAgICAgKiB0aGF0IHJldHVybnMgdGhlIG91dHB1dC5cbiAgICAgKi9cbiAgICBpZiAoaW5wdXRMZW5ndGggPT09IDEpXG4gICAgICAgIHJldHVybiAoKSA9PiBvdXRwdXRbMF07XG4gICAgaWYgKGlucHV0TGVuZ3RoID09PSAyICYmIG91dHB1dFswXSA9PT0gb3V0cHV0WzFdKVxuICAgICAgICByZXR1cm4gKCkgPT4gb3V0cHV0WzFdO1xuICAgIGNvbnN0IGlzWmVyb0RlbHRhUmFuZ2UgPSBpbnB1dFswXSA9PT0gaW5wdXRbMV07XG4gICAgLy8gSWYgaW5wdXQgcnVucyBoaWdoZXN0IC0+IGxvd2VzdCwgcmV2ZXJzZSBib3RoIGFycmF5c1xuICAgIGlmIChpbnB1dFswXSA+IGlucHV0W2lucHV0TGVuZ3RoIC0gMV0pIHtcbiAgICAgICAgaW5wdXQgPSBbLi4uaW5wdXRdLnJldmVyc2UoKTtcbiAgICAgICAgb3V0cHV0ID0gWy4uLm91dHB1dF0ucmV2ZXJzZSgpO1xuICAgIH1cbiAgICBjb25zdCBtaXhlcnMgPSBjcmVhdGVNaXhlcnMob3V0cHV0LCBlYXNlLCBtaXhlcik7XG4gICAgY29uc3QgbnVtTWl4ZXJzID0gbWl4ZXJzLmxlbmd0aDtcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSAodikgPT4ge1xuICAgICAgICBpZiAoaXNaZXJvRGVsdGFSYW5nZSAmJiB2IDwgaW5wdXRbMF0pXG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0WzBdO1xuICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgIGlmIChudW1NaXhlcnMgPiAxKSB7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IGlucHV0Lmxlbmd0aCAtIDI7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh2IDwgaW5wdXRbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm9ncmVzc0luUmFuZ2UgPSBtb3Rpb25VdGlscy5wcm9ncmVzcyhpbnB1dFtpXSwgaW5wdXRbaSArIDFdLCB2KTtcbiAgICAgICAgcmV0dXJuIG1peGVyc1tpXShwcm9ncmVzc0luUmFuZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGlzQ2xhbXBcbiAgICAgICAgPyAodikgPT4gaW50ZXJwb2xhdG9yKGNsYW1wKGlucHV0WzBdLCBpbnB1dFtpbnB1dExlbmd0aCAtIDFdLCB2KSlcbiAgICAgICAgOiBpbnRlcnBvbGF0b3I7XG59XG5cbmZ1bmN0aW9uIGZpbGxPZmZzZXQob2Zmc2V0LCByZW1haW5pbmcpIHtcbiAgICBjb25zdCBtaW4gPSBvZmZzZXRbb2Zmc2V0Lmxlbmd0aCAtIDFdO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IHJlbWFpbmluZzsgaSsrKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFByb2dyZXNzID0gbW90aW9uVXRpbHMucHJvZ3Jlc3MoMCwgcmVtYWluaW5nLCBpKTtcbiAgICAgICAgb2Zmc2V0LnB1c2gobWl4TnVtYmVyJDEobWluLCAxLCBvZmZzZXRQcm9ncmVzcykpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdE9mZnNldCQxKGFycikge1xuICAgIGNvbnN0IG9mZnNldCA9IFswXTtcbiAgICBmaWxsT2Zmc2V0KG9mZnNldCwgYXJyLmxlbmd0aCAtIDEpO1xuICAgIHJldHVybiBvZmZzZXQ7XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRPZmZzZXRUb1RpbWVzKG9mZnNldCwgZHVyYXRpb24pIHtcbiAgICByZXR1cm4gb2Zmc2V0Lm1hcCgobykgPT4gbyAqIGR1cmF0aW9uKTtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdEVhc2luZyQxKHZhbHVlcywgZWFzaW5nKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5tYXAoKCkgPT4gZWFzaW5nIHx8IGVhc2VJbk91dCkuc3BsaWNlKDAsIHZhbHVlcy5sZW5ndGggLSAxKTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lcyh7IGR1cmF0aW9uID0gMzAwLCBrZXlmcmFtZXM6IGtleWZyYW1lVmFsdWVzLCB0aW1lcywgZWFzZSA9IFwiZWFzZUluT3V0XCIsIH0pIHtcbiAgICAvKipcbiAgICAgKiBFYXNpbmcgZnVuY3Rpb25zIGNhbiBiZSBleHRlcm5hbGx5IGRlZmluZWQgYXMgc3RyaW5ncy4gSGVyZSB3ZSBjb252ZXJ0IHRoZW1cbiAgICAgKiBpbnRvIGFjdHVhbCBmdW5jdGlvbnMuXG4gICAgICovXG4gICAgY29uc3QgZWFzaW5nRnVuY3Rpb25zID0gaXNFYXNpbmdBcnJheShlYXNlKVxuICAgICAgICA/IGVhc2UubWFwKGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKVxuICAgICAgICA6IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgIC8qKlxuICAgICAqIFRoaXMgaXMgdGhlIEl0ZXJhdG9yLXNwZWMgcmV0dXJuIHZhbHVlLiBXZSBlbnN1cmUgaXQncyBtdXRhYmxlIHJhdGhlciB0aGFuIHVzaW5nIGEgZ2VuZXJhdG9yXG4gICAgICogdG8gcmVkdWNlIEdDIGR1cmluZyBhbmltYXRpb24uXG4gICAgICovXG4gICAgY29uc3Qgc3RhdGUgPSB7XG4gICAgICAgIGRvbmU6IGZhbHNlLFxuICAgICAgICB2YWx1ZToga2V5ZnJhbWVWYWx1ZXNbMF0sXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSB0aW1lcyBhcnJheSBiYXNlZCBvbiB0aGUgcHJvdmlkZWQgMC0xIG9mZnNldHNcbiAgICAgKi9cbiAgICBjb25zdCBhYnNvbHV0ZVRpbWVzID0gY29udmVydE9mZnNldFRvVGltZXMoXG4gICAgLy8gT25seSB1c2UgdGhlIHByb3ZpZGVkIG9mZnNldHMgaWYgdGhleSdyZSB0aGUgY29ycmVjdCBsZW5ndGhcbiAgICAvLyBUT0RPIE1heWJlIHdlIHNob3VsZCB3YXJuIGhlcmUgaWYgdGhlcmUncyBhIGxlbmd0aCBtaXNtYXRjaFxuICAgIHRpbWVzICYmIHRpbWVzLmxlbmd0aCA9PT0ga2V5ZnJhbWVWYWx1ZXMubGVuZ3RoXG4gICAgICAgID8gdGltZXNcbiAgICAgICAgOiBkZWZhdWx0T2Zmc2V0JDEoa2V5ZnJhbWVWYWx1ZXMpLCBkdXJhdGlvbik7XG4gICAgY29uc3QgbWFwVGltZVRvS2V5ZnJhbWUgPSBpbnRlcnBvbGF0ZShhYnNvbHV0ZVRpbWVzLCBrZXlmcmFtZVZhbHVlcywge1xuICAgICAgICBlYXNlOiBBcnJheS5pc0FycmF5KGVhc2luZ0Z1bmN0aW9ucylcbiAgICAgICAgICAgID8gZWFzaW5nRnVuY3Rpb25zXG4gICAgICAgICAgICA6IGRlZmF1bHRFYXNpbmckMShrZXlmcmFtZVZhbHVlcywgZWFzaW5nRnVuY3Rpb25zKSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjYWxjdWxhdGVkRHVyYXRpb246IGR1cmF0aW9uLFxuICAgICAgICBuZXh0OiAodCkgPT4ge1xuICAgICAgICAgICAgc3RhdGUudmFsdWUgPSBtYXBUaW1lVG9LZXlmcmFtZSh0KTtcbiAgICAgICAgICAgIHN0YXRlLmRvbmUgPSB0ID49IGR1cmF0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgICAgICB9LFxuICAgIH07XG59XG5cbmNvbnN0IGZyYW1lbG9vcERyaXZlciA9ICh1cGRhdGUpID0+IHtcbiAgICBjb25zdCBwYXNzVGltZXN0YW1wID0gKHsgdGltZXN0YW1wIH0pID0+IHVwZGF0ZSh0aW1lc3RhbXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHN0YXJ0OiAoKSA9PiBmcmFtZS51cGRhdGUocGFzc1RpbWVzdGFtcCwgdHJ1ZSksXG4gICAgICAgIHN0b3A6ICgpID0+IGNhbmNlbEZyYW1lKHBhc3NUaW1lc3RhbXApLFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgcHJvY2Vzc2luZyB0aGlzIGZyYW1lIHdlIGNhbiB1c2UgdGhlXG4gICAgICAgICAqIGZyYW1lbG9ja2VkIHRpbWVzdGFtcCB0byBrZWVwIHRoaW5ncyBpbiBzeW5jLlxuICAgICAgICAgKi9cbiAgICAgICAgbm93OiAoKSA9PiAoZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyA/IGZyYW1lRGF0YS50aW1lc3RhbXAgOiB0aW1lLm5vdygpKSxcbiAgICB9O1xufTtcblxuY29uc3QgZ2VuZXJhdG9ycyA9IHtcbiAgICBkZWNheTogaW5lcnRpYSxcbiAgICBpbmVydGlhLFxuICAgIHR3ZWVuOiBrZXlmcmFtZXMsXG4gICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgc3ByaW5nLFxufTtcbmNvbnN0IHBlcmNlbnRUb1Byb2dyZXNzID0gKHBlcmNlbnQpID0+IHBlcmNlbnQgLyAxMDA7XG4vKipcbiAqIEFuaW1hdGlvbiB0aGF0IHJ1bnMgb24gdGhlIG1haW4gdGhyZWFkLiBEZXNpZ25lZCB0byBiZSBXQUFQSS1zcGVjIGluIHRoZSBzdWJzZXQgb2ZcbiAqIGZlYXR1cmVzIHdlIGV4cG9zZSBwdWJsaWNhbGx5LiBNb3N0bHkgdGhlIGNvbXBhdGliaWxpdHkgaXMgdG8gZW5zdXJlIHZpc3VhbCBpZGVudGl0eVxuICogYmV0d2VlbiBib3RoIFdBQVBJIGFuZCBtYWluIHRocmVhZCBhbmltYXRpb25zLlxuICovXG5jbGFzcyBNYWluVGhyZWFkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSB0aW1lIGF0IHdoaWNoIHRoZSBhbmltYXRpb24gd2FzIHBhdXNlZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHRpbWUgYXQgd2hpY2ggdGhlIGFuaW1hdGlvbiB3YXMgY2FuY2VsbGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUaW1lID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBjdXJyZW50IHRpbWUgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGxheWJhY2sgc3BlZWQgYXMgYSBmYWN0b3IuIDAgd291bGQgYmUgc3RvcHBlZCwgLTEgcmV2ZXJzZSBhbmQgMiBkb3VibGUgc3BlZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBsYXliYWNrU3BlZWQgPSAxO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHN0YXRlIG9mIHRoZSBhbmltYXRpb24gdG8gYXBwbHkgd2hlbiB0aGUgYW5pbWF0aW9uIGlzIHJlc29sdmVkLiBUaGlzXG4gICAgICAgICAqIGFsbG93cyBjYWxscyB0byB0aGUgcHVibGljIEFQSSB0byBjb250cm9sIHRoZSBhbmltYXRpb24gYmVmb3JlIGl0IGlzIHJlc29sdmVkLFxuICAgICAgICAgKiB3aXRob3V0IHVzIGhhdmluZyB0byByZXNvbHZlIGl0IGZpcnN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgdGltZSBhdCB3aGljaCB0aGUgYW5pbWF0aW9uIHdhcyBzdGFydGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBudWxsO1xuICAgICAgICB0aGlzLnN0YXRlID0gXCJpZGxlXCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIG1ldGhvZCBpcyBib3VuZCB0byB0aGUgaW5zdGFuY2UgdG8gZml4IGEgcGF0dGVybiB3aGVyZVxuICAgICAgICAgKiBhbmltYXRpb24uc3RvcCBpcyByZXR1cm5lZCBhcyBhIHJlZmVyZW5jZSBmcm9tIGEgdXNlRWZmZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImlkbGVcIilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnRlYXJkb3duKCk7XG4gICAgICAgICAgICBjb25zdCB7IG9uU3RvcCB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICAgICAgb25TdG9wICYmIG9uU3RvcCgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50LCBrZXlmcmFtZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgY29uc3QgS2V5ZnJhbWVSZXNvbHZlciQxID0gKGVsZW1lbnQgPT09IG51bGwgfHwgZWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudC5LZXlmcmFtZVJlc29sdmVyKSB8fCBLZXlmcmFtZVJlc29sdmVyO1xuICAgICAgICBjb25zdCBvblJlc29sdmVkID0gKHJlc29sdmVkS2V5ZnJhbWVzLCBmaW5hbEtleWZyYW1lKSA9PiB0aGlzLm9uS2V5ZnJhbWVzUmVzb2x2ZWQocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB0aGlzLnJlc29sdmVyID0gbmV3IEtleWZyYW1lUmVzb2x2ZXIkMShrZXlmcmFtZXMsIG9uUmVzb2x2ZWQsIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgZmxhdHRlbigpIHtcbiAgICAgICAgc3VwZXIuZmxhdHRlbigpO1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhbHJlYWR5IHJlc29sdmVkIHRoZSBhbmltYXRpb24sIHJlLWluaXRpYWxpc2UgaXRcbiAgICAgICAgaWYgKHRoaXMuX3Jlc29sdmVkKSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX3Jlc29sdmVkLCB0aGlzLmluaXRQbGF5YmFjayh0aGlzLl9yZXNvbHZlZC5rZXlmcmFtZXMpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpbml0UGxheWJhY2soa2V5ZnJhbWVzJDEpIHtcbiAgICAgICAgY29uc3QgeyB0eXBlID0gXCJrZXlmcmFtZXNcIiwgcmVwZWF0ID0gMCwgcmVwZWF0RGVsYXkgPSAwLCByZXBlYXRUeXBlLCB2ZWxvY2l0eSA9IDAsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGdlbmVyYXRvckZhY3RvcnkgPSBtb3Rpb25Eb20uaXNHZW5lcmF0b3IodHlwZSlcbiAgICAgICAgICAgID8gdHlwZVxuICAgICAgICAgICAgOiBnZW5lcmF0b3JzW3R5cGVdIHx8IGtleWZyYW1lcztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG91ciBnZW5lcmF0b3IgZG9lc24ndCBzdXBwb3J0IG1peGluZyBudW1iZXJzLCB3ZSBuZWVkIHRvIHJlcGxhY2Uga2V5ZnJhbWVzIHdpdGhcbiAgICAgICAgICogWzAsIDEwMF0gYW5kIHRoZW4gbWFrZSBhIGZ1bmN0aW9uIHRoYXQgbWFwcyB0aGF0IHRvIHRoZSBhY3R1YWwga2V5ZnJhbWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiAxMDAgaXMgY2hvc2VuIGluc3RlYWQgb2YgMSBhcyBpdCB3b3JrcyBuaWNlciB3aXRoIHNwcmluZyBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IG1hcFBlcmNlbnRUb0tleWZyYW1lcztcbiAgICAgICAgbGV0IG1pcnJvcmVkR2VuZXJhdG9yO1xuICAgICAgICBpZiAoZ2VuZXJhdG9yRmFjdG9yeSAhPT0ga2V5ZnJhbWVzICYmXG4gICAgICAgICAgICB0eXBlb2Yga2V5ZnJhbWVzJDFbMF0gIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoa2V5ZnJhbWVzJDEubGVuZ3RoID09PSAyLCBgT25seSB0d28ga2V5ZnJhbWVzIGN1cnJlbnRseSBzdXBwb3J0ZWQgd2l0aCBzcHJpbmcgYW5kIGluZXJ0aWEgYW5pbWF0aW9ucy4gVHJ5aW5nIHRvIGFuaW1hdGUgJHtrZXlmcmFtZXMkMX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1hcFBlcmNlbnRUb0tleWZyYW1lcyA9IHBpcGUocGVyY2VudFRvUHJvZ3Jlc3MsIG1peChrZXlmcmFtZXMkMVswXSwga2V5ZnJhbWVzJDFbMV0pKTtcbiAgICAgICAgICAgIGtleWZyYW1lcyQxID0gWzAsIDEwMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZ2VuZXJhdG9yID0gZ2VuZXJhdG9yRmFjdG9yeSh7IC4uLnRoaXMub3B0aW9ucywga2V5ZnJhbWVzOiBrZXlmcmFtZXMkMSB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlIGhhdmUgYSBtaXJyb3IgcmVwZWF0IHR5cGUgd2UgbmVlZCB0byBjcmVhdGUgYSBzZWNvbmQgZ2VuZXJhdG9yIHRoYXQgb3V0cHV0cyB0aGVcbiAgICAgICAgICogbWlycm9yZWQgKG5vdCByZXZlcnNlZCkgYW5pbWF0aW9uIGFuZCBsYXRlciBwaW5nIHBvbmcgYmV0d2VlbiB0aGUgdHdvIGdlbmVyYXRvcnMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVwZWF0VHlwZSA9PT0gXCJtaXJyb3JcIikge1xuICAgICAgICAgICAgbWlycm9yZWRHZW5lcmF0b3IgPSBnZW5lcmF0b3JGYWN0b3J5KHtcbiAgICAgICAgICAgICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzOiBbLi4ua2V5ZnJhbWVzJDFdLnJldmVyc2UoKSxcbiAgICAgICAgICAgICAgICB2ZWxvY2l0eTogLXZlbG9jaXR5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGR1cmF0aW9uIGlzIHVuZGVmaW5lZCBhbmQgd2UgaGF2ZSByZXBlYXQgb3B0aW9ucyxcbiAgICAgICAgICogd2UgbmVlZCB0byBjYWxjdWxhdGUgYSBkdXJhdGlvbiBmcm9tIHRoZSBnZW5lcmF0b3IuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIHNldCBpdCB0byB0aGUgZ2VuZXJhdG9yIGl0c2VsZiB0byBjYWNoZSB0aGUgZHVyYXRpb24uXG4gICAgICAgICAqIEFueSB0aW1lbGluZSByZXNvbHZlciB3aWxsIG5lZWQgdG8gaGF2ZSBhbHJlYWR5IHByZWNhbGN1bGF0ZWRcbiAgICAgICAgICogdGhlIGR1cmF0aW9uIGJ5IHRoaXMgc3RlcC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChnZW5lcmF0b3IuY2FsY3VsYXRlZER1cmF0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICBnZW5lcmF0b3IuY2FsY3VsYXRlZER1cmF0aW9uID0gbW90aW9uRG9tLmNhbGNHZW5lcmF0b3JEdXJhdGlvbihnZW5lcmF0b3IpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgY2FsY3VsYXRlZER1cmF0aW9uIH0gPSBnZW5lcmF0b3I7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkRHVyYXRpb24gPSBjYWxjdWxhdGVkRHVyYXRpb24gKyByZXBlYXREZWxheTtcbiAgICAgICAgY29uc3QgdG90YWxEdXJhdGlvbiA9IHJlc29sdmVkRHVyYXRpb24gKiAocmVwZWF0ICsgMSkgLSByZXBlYXREZWxheTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdlbmVyYXRvcixcbiAgICAgICAgICAgIG1pcnJvcmVkR2VuZXJhdG9yLFxuICAgICAgICAgICAgbWFwUGVyY2VudFRvS2V5ZnJhbWVzLFxuICAgICAgICAgICAgY2FsY3VsYXRlZER1cmF0aW9uLFxuICAgICAgICAgICAgcmVzb2x2ZWREdXJhdGlvbixcbiAgICAgICAgICAgIHRvdGFsRHVyYXRpb24sXG4gICAgICAgIH07XG4gICAgfVxuICAgIG9uUG9zdFJlc29sdmVkKCkge1xuICAgICAgICBjb25zdCB7IGF1dG9wbGF5ID0gdHJ1ZSB9ID0gdGhpcy5vcHRpb25zO1xuICAgICAgICB0aGlzLnBsYXkoKTtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9PT0gXCJwYXVzZWRcIiB8fCAhYXV0b3BsYXkpIHtcbiAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnBlbmRpbmdQbGF5U3RhdGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGljayh0aW1lc3RhbXAsIHNhbXBsZSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIC8vIElmIHRoZSBhbmltYXRpb25zIGhhcyBmYWlsZWQgdG8gcmVzb2x2ZSwgcmV0dXJuIHRoZSBmaW5hbCBrZXlmcmFtZS5cbiAgICAgICAgaWYgKCFyZXNvbHZlZCkge1xuICAgICAgICAgICAgY29uc3QgeyBrZXlmcmFtZXMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBmaW5hbEtleWZyYW1lLCBnZW5lcmF0b3IsIG1pcnJvcmVkR2VuZXJhdG9yLCBtYXBQZXJjZW50VG9LZXlmcmFtZXMsIGtleWZyYW1lcywgY2FsY3VsYXRlZER1cmF0aW9uLCB0b3RhbER1cmF0aW9uLCByZXNvbHZlZER1cmF0aW9uLCB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIGlmICh0aGlzLnN0YXJ0VGltZSA9PT0gbnVsbClcbiAgICAgICAgICAgIHJldHVybiBnZW5lcmF0b3IubmV4dCgwKTtcbiAgICAgICAgY29uc3QgeyBkZWxheSwgcmVwZWF0LCByZXBlYXRUeXBlLCByZXBlYXREZWxheSwgb25VcGRhdGUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHJlcXVlc3RBbmltYXRpb25GcmFtZSB0aW1lc3RhbXBzIGNhbiBjb21lIHRocm91Z2ggYXMgbG93ZXIgdGhhblxuICAgICAgICAgKiB0aGUgc3RhcnRUaW1lIGFzIHNldCBieSBwZXJmb3JtYW5jZS5ub3coKS4gSGVyZSB3ZSBwcmV2ZW50IHRoaXMsXG4gICAgICAgICAqIHRob3VnaCBpbiB0aGUgZnV0dXJlIGl0IGNvdWxkIGJlIHBvc3NpYmxlIHRvIG1ha2Ugc2V0dGluZyBzdGFydFRpbWVcbiAgICAgICAgICogYSBwZW5kaW5nIG9wZXJhdGlvbiB0aGF0IGdldHMgcmVzb2x2ZWQgaGVyZS5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnNwZWVkID4gMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbih0aGlzLnN0YXJ0VGltZSwgdGltZXN0YW1wKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnNwZWVkIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBNYXRoLm1pbih0aW1lc3RhbXAgLSB0b3RhbER1cmF0aW9uIC8gdGhpcy5zcGVlZCwgdGhpcy5zdGFydFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSBjdXJyZW50VGltZVxuICAgICAgICBpZiAoc2FtcGxlKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZXN0YW1wO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaG9sZFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSB0aGlzLmhvbGRUaW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gUm91bmRpbmcgdGhlIHRpbWUgYmVjYXVzZSBmbG9hdGluZyBwb2ludCBhcml0aG1ldGljIGlzIG5vdCBhbHdheXMgYWNjdXJhdGUsIGUuZy4gMzAwMC4zNjcgLSAxMDAwLjM2NyA9XG4gICAgICAgICAgICAvLyAyMDAwLjAwMDAwMDAwMDAwMDIuIFRoaXMgaXMgYSBwcm9ibGVtIHdoZW4gd2UgYXJlIGNvbXBhcmluZyB0aGUgY3VycmVudFRpbWUgd2l0aCB0aGUgZHVyYXRpb24sIGZvclxuICAgICAgICAgICAgLy8gZXhhbXBsZS5cbiAgICAgICAgICAgIHRoaXMuY3VycmVudFRpbWUgPVxuICAgICAgICAgICAgICAgIE1hdGgucm91bmQodGltZXN0YW1wIC0gdGhpcy5zdGFydFRpbWUpICogdGhpcy5zcGVlZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWJhc2Ugb24gZGVsYXlcbiAgICAgICAgY29uc3QgdGltZVdpdGhvdXREZWxheSA9IHRoaXMuY3VycmVudFRpbWUgLSBkZWxheSAqICh0aGlzLnNwZWVkID49IDAgPyAxIDogLTEpO1xuICAgICAgICBjb25zdCBpc0luRGVsYXlQaGFzZSA9IHRoaXMuc3BlZWQgPj0gMFxuICAgICAgICAgICAgPyB0aW1lV2l0aG91dERlbGF5IDwgMFxuICAgICAgICAgICAgOiB0aW1lV2l0aG91dERlbGF5ID4gdG90YWxEdXJhdGlvbjtcbiAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IE1hdGgubWF4KHRpbWVXaXRob3V0RGVsYXksIDApO1xuICAgICAgICAvLyBJZiB0aGlzIGFuaW1hdGlvbiBoYXMgZmluaXNoZWQsIHNldCB0aGUgY3VycmVudCB0aW1lICB0byB0aGUgdG90YWwgZHVyYXRpb24uXG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIgJiYgdGhpcy5ob2xkVGltZSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VGltZSA9IHRvdGFsRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGVsYXBzZWQgPSB0aGlzLmN1cnJlbnRUaW1lO1xuICAgICAgICBsZXQgZnJhbWVHZW5lcmF0b3IgPSBnZW5lcmF0b3I7XG4gICAgICAgIGlmIChyZXBlYXQpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IHRoZSBjdXJyZW50IHByb2dyZXNzICgwLTEpIG9mIHRoZSBhbmltYXRpb24uIElmIHQgaXMgPlxuICAgICAgICAgICAgICogdGhhbiBkdXJhdGlvbiB3ZSdsbCBnZXQgdmFsdWVzIGxpa2UgMi41IChtaWR3YXkgdGhyb3VnaCB0aGVcbiAgICAgICAgICAgICAqIHRoaXJkIGl0ZXJhdGlvbilcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBNYXRoLm1pbih0aGlzLmN1cnJlbnRUaW1lLCB0b3RhbER1cmF0aW9uKSAvIHJlc29sdmVkRHVyYXRpb247XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgY3VycmVudCBpdGVyYXRpb24gKDAgaW5kZXhlZCkuIEZvciBpbnN0YW5jZSB0aGUgZmxvb3Igb2ZcbiAgICAgICAgICAgICAqIDIuNSBpcyAyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgY3VycmVudEl0ZXJhdGlvbiA9IE1hdGguZmxvb3IocHJvZ3Jlc3MpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGl0ZXJhdGlvbiBieSB0YWtpbmcgdGhlIHJlbWFpbmRlclxuICAgICAgICAgICAgICogc28gMi41IGlzIDAuNSB0aHJvdWdoIGl0ZXJhdGlvbiAyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCBpdGVyYXRpb25Qcm9ncmVzcyA9IHByb2dyZXNzICUgMS4wO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiBpdGVyYXRpb24gcHJvZ3Jlc3MgaXMgMSB3ZSBjb3VudCB0aGF0IGFzIHRoZSBlbmRcbiAgICAgICAgICAgICAqIG9mIHRoZSBwcmV2aW91cyBpdGVyYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghaXRlcmF0aW9uUHJvZ3Jlc3MgJiYgcHJvZ3Jlc3MgPj0gMSkge1xuICAgICAgICAgICAgICAgIGl0ZXJhdGlvblByb2dyZXNzID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGl0ZXJhdGlvblByb2dyZXNzID09PSAxICYmIGN1cnJlbnRJdGVyYXRpb24tLTtcbiAgICAgICAgICAgIGN1cnJlbnRJdGVyYXRpb24gPSBNYXRoLm1pbihjdXJyZW50SXRlcmF0aW9uLCByZXBlYXQgKyAxKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmV2ZXJzZSBwcm9ncmVzcyBpZiB3ZSdyZSBub3QgcnVubmluZyBpbiBcIm5vcm1hbFwiIGRpcmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBpc09kZEl0ZXJhdGlvbiA9IEJvb2xlYW4oY3VycmVudEl0ZXJhdGlvbiAlIDIpO1xuICAgICAgICAgICAgaWYgKGlzT2RkSXRlcmF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGVhdFR5cGUgPT09IFwicmV2ZXJzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvblByb2dyZXNzID0gMSAtIGl0ZXJhdGlvblByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwZWF0RGVsYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGlvblByb2dyZXNzIC09IHJlcGVhdERlbGF5IC8gcmVzb2x2ZWREdXJhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChyZXBlYXRUeXBlID09PSBcIm1pcnJvclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lR2VuZXJhdG9yID0gbWlycm9yZWRHZW5lcmF0b3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxhcHNlZCA9IGNsYW1wKDAsIDEsIGl0ZXJhdGlvblByb2dyZXNzKSAqIHJlc29sdmVkRHVyYXRpb247XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIGluIG5lZ2F0aXZlIHRpbWUsIHNldCBzdGF0ZSBhcyB0aGUgaW5pdGlhbCBrZXlmcmFtZS5cbiAgICAgICAgICogVGhpcyBwcmV2ZW50cyBkZWxheTogeCwgZHVyYXRpb246IDAgYW5pbWF0aW9ucyBmcm9tIGZpbmlzaGluZ1xuICAgICAgICAgKiBpbnN0YW50bHkuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdGF0ZSA9IGlzSW5EZWxheVBoYXNlXG4gICAgICAgICAgICA/IHsgZG9uZTogZmFsc2UsIHZhbHVlOiBrZXlmcmFtZXNbMF0gfVxuICAgICAgICAgICAgOiBmcmFtZUdlbmVyYXRvci5uZXh0KGVsYXBzZWQpO1xuICAgICAgICBpZiAobWFwUGVyY2VudFRvS2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IG1hcFBlcmNlbnRUb0tleWZyYW1lcyhzdGF0ZS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHsgZG9uZSB9ID0gc3RhdGU7XG4gICAgICAgIGlmICghaXNJbkRlbGF5UGhhc2UgJiYgY2FsY3VsYXRlZER1cmF0aW9uICE9PSBudWxsKSB7XG4gICAgICAgICAgICBkb25lID1cbiAgICAgICAgICAgICAgICB0aGlzLnNwZWVkID49IDBcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLmN1cnJlbnRUaW1lID49IHRvdGFsRHVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLmN1cnJlbnRUaW1lIDw9IDA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNBbmltYXRpb25GaW5pc2hlZCA9IHRoaXMuaG9sZFRpbWUgPT09IG51bGwgJiZcbiAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSBcImZpbmlzaGVkXCIgfHwgKHRoaXMuc3RhdGUgPT09IFwicnVubmluZ1wiICYmIGRvbmUpKTtcbiAgICAgICAgaWYgKGlzQW5pbWF0aW9uRmluaXNoZWQgJiYgZmluYWxLZXlmcmFtZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzdGF0ZS52YWx1ZSA9IGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMsIGZpbmFsS2V5ZnJhbWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvblVwZGF0ZSkge1xuICAgICAgICAgICAgb25VcGRhdGUoc3RhdGUudmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkZpbmlzaGVkKSB7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGF0ZTtcbiAgICB9XG4gICAgZ2V0IGR1cmF0aW9uKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQgPyBtb3Rpb25VdGlscy5taWxsaXNlY29uZHNUb1NlY29uZHMocmVzb2x2ZWQuY2FsY3VsYXRlZER1cmF0aW9uKSA6IDA7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICByZXR1cm4gbW90aW9uVXRpbHMubWlsbGlzZWNvbmRzVG9TZWNvbmRzKHRoaXMuY3VycmVudFRpbWUpO1xuICAgIH1cbiAgICBzZXQgdGltZShuZXdUaW1lKSB7XG4gICAgICAgIG5ld1RpbWUgPSBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgICAgIHRoaXMuY3VycmVudFRpbWUgPSBuZXdUaW1lO1xuICAgICAgICBpZiAodGhpcy5ob2xkVGltZSAhPT0gbnVsbCB8fCB0aGlzLnNwZWVkID09PSAwKSB7XG4gICAgICAgICAgICB0aGlzLmhvbGRUaW1lID0gbmV3VGltZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSB0aGlzLmRyaXZlci5ub3coKSAtIG5ld1RpbWUgLyB0aGlzLnNwZWVkO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheWJhY2tTcGVlZDtcbiAgICB9XG4gICAgc2V0IHNwZWVkKG5ld1NwZWVkKSB7XG4gICAgICAgIGNvbnN0IGhhc0NoYW5nZWQgPSB0aGlzLnBsYXliYWNrU3BlZWQgIT09IG5ld1NwZWVkO1xuICAgICAgICB0aGlzLnBsYXliYWNrU3BlZWQgPSBuZXdTcGVlZDtcbiAgICAgICAgaWYgKGhhc0NoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMudGltZSA9IG1vdGlvblV0aWxzLm1pbGxpc2Vjb25kc1RvU2Vjb25kcyh0aGlzLmN1cnJlbnRUaW1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAoIXRoaXMucmVzb2x2ZXIuaXNTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZXIucmVzdW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gXCJydW5uaW5nXCI7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTdG9wcGVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGRyaXZlciA9IGZyYW1lbG9vcERyaXZlciwgb25QbGF5LCBzdGFydFRpbWUgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgaWYgKCF0aGlzLmRyaXZlcikge1xuICAgICAgICAgICAgdGhpcy5kcml2ZXIgPSBkcml2ZXIoKHRpbWVzdGFtcCkgPT4gdGhpcy50aWNrKHRpbWVzdGFtcCkpO1xuICAgICAgICB9XG4gICAgICAgIG9uUGxheSAmJiBvblBsYXkoKTtcbiAgICAgICAgY29uc3Qgbm93ID0gdGhpcy5kcml2ZXIubm93KCk7XG4gICAgICAgIGlmICh0aGlzLmhvbGRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IG5vdyAtIHRoaXMuaG9sZFRpbWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXRoaXMuc3RhcnRUaW1lKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHN0YXJ0VGltZSAhPT0gbnVsbCAmJiBzdGFydFRpbWUgIT09IHZvaWQgMCA/IHN0YXJ0VGltZSA6IHRoaXMuY2FsY1N0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgdGhpcy5zdGFydFRpbWUgPSBub3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbmNlbFRpbWUgPSB0aGlzLnN0YXJ0VGltZTtcbiAgICAgICAgdGhpcy5ob2xkVGltZSA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZXQgcGxheVN0YXRlIHRvIHJ1bm5pbmcgb25seSBhZnRlciB3ZSd2ZSB1c2VkIGl0IGluXG4gICAgICAgICAqIHRoZSBwcmV2aW91cyBsb2dpYy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RhdGUgPSBcInJ1bm5pbmdcIjtcbiAgICAgICAgdGhpcy5kcml2ZXIuc3RhcnQoKTtcbiAgICB9XG4gICAgcGF1c2UoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nUGxheVN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gXCJwYXVzZWRcIjtcbiAgICAgICAgdGhpcy5ob2xkVGltZSA9IChfYSA9IHRoaXMuY3VycmVudFRpbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IDA7XG4gICAgfVxuICAgIGNvbXBsZXRlKCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gXCJydW5uaW5nXCIpIHtcbiAgICAgICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGVuZGluZ1BsYXlTdGF0ZSA9IHRoaXMuc3RhdGUgPSBcImZpbmlzaGVkXCI7XG4gICAgICAgIHRoaXMuaG9sZFRpbWUgPSBudWxsO1xuICAgIH1cbiAgICBmaW5pc2goKSB7XG4gICAgICAgIHRoaXMudGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IFwiZmluaXNoZWRcIjtcbiAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIG9uQ29tcGxldGUgJiYgb25Db21wbGV0ZSgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhbmNlbFRpbWUgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGljayh0aGlzLmNhbmNlbFRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudGVhcmRvd24oKTtcbiAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICB9XG4gICAgdGVhcmRvd24oKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBcImlkbGVcIjtcbiAgICAgICAgdGhpcy5zdG9wRHJpdmVyKCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnN0YXJ0VGltZSA9IHRoaXMuY2FuY2VsVGltZSA9IG51bGw7XG4gICAgICAgIHRoaXMucmVzb2x2ZXIuY2FuY2VsKCk7XG4gICAgfVxuICAgIHN0b3BEcml2ZXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5kcml2ZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuZHJpdmVyLnN0b3AoKTtcbiAgICAgICAgdGhpcy5kcml2ZXIgPSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHNhbXBsZSh0aW1lKSB7XG4gICAgICAgIHRoaXMuc3RhcnRUaW1lID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXMudGljayh0aW1lLCB0cnVlKTtcbiAgICB9XG59XG4vLyBMZWdhY3kgaW50ZXJmYWNlXG5mdW5jdGlvbiBhbmltYXRlVmFsdWUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTWFpblRocmVhZEFuaW1hdGlvbihvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgdmFsdWVzIHRoYXQgY2FuIGJlIGhhcmR3YXJlLWFjY2VsZXJhdGVkLlxuICovXG5jb25zdCBhY2NlbGVyYXRlZFZhbHVlcyA9IG5ldyBTZXQoW1xuICAgIFwib3BhY2l0eVwiLFxuICAgIFwiY2xpcFBhdGhcIixcbiAgICBcImZpbHRlclwiLFxuICAgIFwidHJhbnNmb3JtXCIsXG4gICAgLy8gVE9ETzogQ2FuIGJlIGFjY2VsZXJhdGVkIGJ1dCBjdXJyZW50bHkgZGlzYWJsZWQgdW50aWwgaHR0cHM6Ly9pc3N1ZXMuY2hyb21pdW0ub3JnL2lzc3Vlcy80MTQ5MTA5OCBpcyByZXNvbHZlZFxuICAgIC8vIG9yIHVudGlsIHdlIGltcGxlbWVudCBzdXBwb3J0IGZvciBsaW5lYXIoKSBlYXNpbmcuXG4gICAgLy8gXCJiYWNrZ3JvdW5kLWNvbG9yXCJcbl0pO1xuXG5mdW5jdGlvbiBzdGFydFdhYXBpQW5pbWF0aW9uKGVsZW1lbnQsIHZhbHVlTmFtZSwga2V5ZnJhbWVzLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIHJlcGVhdCA9IDAsIHJlcGVhdFR5cGUgPSBcImxvb3BcIiwgZWFzZSA9IFwiZWFzZUluT3V0XCIsIHRpbWVzLCB9ID0ge30pIHtcbiAgICBjb25zdCBrZXlmcmFtZU9wdGlvbnMgPSB7IFt2YWx1ZU5hbWVdOiBrZXlmcmFtZXMgfTtcbiAgICBpZiAodGltZXMpXG4gICAgICAgIGtleWZyYW1lT3B0aW9ucy5vZmZzZXQgPSB0aW1lcztcbiAgICBjb25zdCBlYXNpbmcgPSBtb3Rpb25Eb20ubWFwRWFzaW5nVG9OYXRpdmVFYXNpbmcoZWFzZSwgZHVyYXRpb24pO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgaXMgYW4gZWFzaW5nIGFycmF5LCBhcHBseSB0byBrZXlmcmFtZXMsIG5vdCBhbmltYXRpb24gYXMgYSB3aG9sZVxuICAgICAqL1xuICAgIGlmIChBcnJheS5pc0FycmF5KGVhc2luZykpXG4gICAgICAgIGtleWZyYW1lT3B0aW9ucy5lYXNpbmcgPSBlYXNpbmc7XG4gICAgcmV0dXJuIGVsZW1lbnQuYW5pbWF0ZShrZXlmcmFtZU9wdGlvbnMsIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmc6ICFBcnJheS5pc0FycmF5KGVhc2luZykgPyBlYXNpbmcgOiBcImxpbmVhclwiLFxuICAgICAgICBmaWxsOiBcImJvdGhcIixcbiAgICAgICAgaXRlcmF0aW9uczogcmVwZWF0ICsgMSxcbiAgICAgICAgZGlyZWN0aW9uOiByZXBlYXRUeXBlID09PSBcInJldmVyc2VcIiA/IFwiYWx0ZXJuYXRlXCIgOiBcIm5vcm1hbFwiLFxuICAgIH0pO1xufVxuXG5jb25zdCBzdXBwb3J0c1dhYXBpID0gLypAX19QVVJFX18qLyBtb3Rpb25VdGlscy5tZW1vKCgpID0+IE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKEVsZW1lbnQucHJvdG90eXBlLCBcImFuaW1hdGVcIikpO1xuXG4vKipcbiAqIDEwbXMgaXMgY2hvc2VuIGhlcmUgYXMgaXQgc3RyaWtlcyBhIGJhbGFuY2UgYmV0d2VlbiBzbW9vdGhcbiAqIHJlc3VsdHMgKG1vcmUgdGhhbiBvbmUga2V5ZnJhbWUgcGVyIGZyYW1lIGF0IDYwZnBzKSBhbmRcbiAqIGtleWZyYW1lIHF1YW50aXR5LlxuICovXG5jb25zdCBzYW1wbGVEZWx0YSA9IDEwOyAvL21zXG4vKipcbiAqIEltcGxlbWVudCBhIHByYWN0aWNhbCBtYXggZHVyYXRpb24gZm9yIGtleWZyYW1lIGdlbmVyYXRpb25cbiAqIHRvIHByZXZlbnQgaW5maW5pdGUgbG9vcHNcbiAqL1xuY29uc3QgbWF4RHVyYXRpb24gPSAyMDAwMDtcbi8qKlxuICogQ2hlY2sgaWYgYW4gYW5pbWF0aW9uIGNhbiBydW4gbmF0aXZlbHkgdmlhIFdBQVBJIG9yIHJlcXVpcmVzIHByZWdlbmVyYXRlZCBrZXlmcmFtZXMuXG4gKiBXQUFQSSBkb2Vzbid0IHN1cHBvcnQgc3ByaW5nIG9yIGZ1bmN0aW9uIGVhc2luZ3Mgc28gd2UgcnVuIHRoZXNlIGFzIEpTIGFuaW1hdGlvbiBiZWZvcmVcbiAqIGhhbmRpbmcgb2ZmLlxuICovXG5mdW5jdGlvbiByZXF1aXJlc1ByZWdlbmVyYXRlZEtleWZyYW1lcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIChtb3Rpb25Eb20uaXNHZW5lcmF0b3Iob3B0aW9ucy50eXBlKSB8fFxuICAgICAgICBvcHRpb25zLnR5cGUgPT09IFwic3ByaW5nXCIgfHxcbiAgICAgICAgIW1vdGlvbkRvbS5pc1dhYXBpU3VwcG9ydGVkRWFzaW5nKG9wdGlvbnMuZWFzZSkpO1xufVxuZnVuY3Rpb24gcHJlZ2VuZXJhdGVLZXlmcmFtZXMoa2V5ZnJhbWVzLCBvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbWFpbi10aHJlYWQgYW5pbWF0aW9uIHRvIHByZWdlbmVyYXRlIGtleWZyYW1lcy5cbiAgICAgKiBXZSBzYW1wbGUgdGhpcyBhdCByZWd1bGFyIGludGVydmFscyB0byBnZW5lcmF0ZSBrZXlmcmFtZXMgdGhhdCB3ZSB0aGVuXG4gICAgICogbGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2Vlbi5cbiAgICAgKi9cbiAgICBjb25zdCBzYW1wbGVBbmltYXRpb24gPSBuZXcgTWFpblRocmVhZEFuaW1hdGlvbih7XG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIGtleWZyYW1lcyxcbiAgICAgICAgcmVwZWF0OiAwLFxuICAgICAgICBkZWxheTogMCxcbiAgICAgICAgaXNHZW5lcmF0b3I6IHRydWUsXG4gICAgfSk7XG4gICAgbGV0IHN0YXRlID0geyBkb25lOiBmYWxzZSwgdmFsdWU6IGtleWZyYW1lc1swXSB9O1xuICAgIGNvbnN0IHByZWdlbmVyYXRlZEtleWZyYW1lcyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEJhaWwgYWZ0ZXIgMjAgc2Vjb25kcyBvZiBwcmUtZ2VuZXJhdGVkIGtleWZyYW1lcyBhcyBpdCdzIGxpa2VseVxuICAgICAqIHdlJ3JlIGhlYWRpbmcgZm9yIGFuIGluZmluaXRlIGxvb3AuXG4gICAgICovXG4gICAgbGV0IHQgPSAwO1xuICAgIHdoaWxlICghc3RhdGUuZG9uZSAmJiB0IDwgbWF4RHVyYXRpb24pIHtcbiAgICAgICAgc3RhdGUgPSBzYW1wbGVBbmltYXRpb24uc2FtcGxlKHQpO1xuICAgICAgICBwcmVnZW5lcmF0ZWRLZXlmcmFtZXMucHVzaChzdGF0ZS52YWx1ZSk7XG4gICAgICAgIHQgKz0gc2FtcGxlRGVsdGE7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIHRpbWVzOiB1bmRlZmluZWQsXG4gICAgICAgIGtleWZyYW1lczogcHJlZ2VuZXJhdGVkS2V5ZnJhbWVzLFxuICAgICAgICBkdXJhdGlvbjogdCAtIHNhbXBsZURlbHRhLFxuICAgICAgICBlYXNlOiBcImxpbmVhclwiLFxuICAgIH07XG59XG5jb25zdCB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucyA9IHtcbiAgICBhbnRpY2lwYXRlLFxuICAgIGJhY2tJbk91dCxcbiAgICBjaXJjSW5PdXQsXG59O1xuZnVuY3Rpb24gaXNVbnN1cHBvcnRlZEVhc2Uoa2V5KSB7XG4gICAgcmV0dXJuIGtleSBpbiB1bnN1cHBvcnRlZEVhc2luZ0Z1bmN0aW9ucztcbn1cbmNsYXNzIEFjY2VsZXJhdGVkQW5pbWF0aW9uIGV4dGVuZHMgQmFzZUFuaW1hdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBzdXBlcihvcHRpb25zKTtcbiAgICAgICAgY29uc3QgeyBuYW1lLCBtb3Rpb25WYWx1ZSwgZWxlbWVudCwga2V5ZnJhbWVzIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIHRoaXMucmVzb2x2ZXIgPSBuZXcgRE9NS2V5ZnJhbWVzUmVzb2x2ZXIoa2V5ZnJhbWVzLCAocmVzb2x2ZWRLZXlmcmFtZXMsIGZpbmFsS2V5ZnJhbWUpID0+IHRoaXMub25LZXlmcmFtZXNSZXNvbHZlZChyZXNvbHZlZEtleWZyYW1lcywgZmluYWxLZXlmcmFtZSksIG5hbWUsIG1vdGlvblZhbHVlLCBlbGVtZW50KTtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5zY2hlZHVsZVJlc29sdmUoKTtcbiAgICB9XG4gICAgaW5pdFBsYXliYWNrKGtleWZyYW1lcywgZmluYWxLZXlmcmFtZSkge1xuICAgICAgICBsZXQgeyBkdXJhdGlvbiA9IDMwMCwgdGltZXMsIGVhc2UsIHR5cGUsIG1vdGlvblZhbHVlLCBuYW1lLCBzdGFydFRpbWUsIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBlbGVtZW50IGhhcyBzaW5jZSBiZWVuIHVubW91bnRlZCwgcmV0dXJuIGZhbHNlIHRvIGluZGljYXRlXG4gICAgICAgICAqIHRoZSBhbmltYXRpb24gZmFpbGVkIHRvIGluaXRpYWxpc2VkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFtb3Rpb25WYWx1ZS5vd25lciB8fCAhbW90aW9uVmFsdWUub3duZXIuY3VycmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgdXNlciBoYXMgcHJvdmlkZWQgYW4gZWFzaW5nIGZ1bmN0aW9uIG5hbWUgdGhhdCBpc24ndCBzdXBwb3J0ZWRcbiAgICAgICAgICogYnkgV0FBUEkgKGxpa2UgXCJhbnRpY2lwYXRlXCIpLCB3ZSBuZWVkIHRvIHByb3ZpZGUgdGhlIGNvcnJlc3Nwb25kaW5nXG4gICAgICAgICAqIGZ1bmN0aW9uLiBUaGlzIHdpbGwgbGF0ZXIgZ2V0IGNvbnZlcnRlZCB0byBhIGxpbmVhcigpIGVhc2luZyBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlb2YgZWFzZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgbW90aW9uRG9tLnN1cHBvcnRzTGluZWFyRWFzaW5nKCkgJiZcbiAgICAgICAgICAgIGlzVW5zdXBwb3J0ZWRFYXNlKGVhc2UpKSB7XG4gICAgICAgICAgICBlYXNlID0gdW5zdXBwb3J0ZWRFYXNpbmdGdW5jdGlvbnNbZWFzZV07XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoaXMgYW5pbWF0aW9uIG5lZWRzIHByZS1nZW5lcmF0ZWQga2V5ZnJhbWVzIHRoZW4gZ2VuZXJhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocmVxdWlyZXNQcmVnZW5lcmF0ZWRLZXlmcmFtZXModGhpcy5vcHRpb25zKSkge1xuICAgICAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlLCBvblVwZGF0ZSwgbW90aW9uVmFsdWUsIGVsZW1lbnQsIC4uLm9wdGlvbnMgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGNvbnN0IHByZWdlbmVyYXRlZEFuaW1hdGlvbiA9IHByZWdlbmVyYXRlS2V5ZnJhbWVzKGtleWZyYW1lcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBrZXlmcmFtZXMgPSBwcmVnZW5lcmF0ZWRBbmltYXRpb24ua2V5ZnJhbWVzO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyBhIHZlcnkgc2hvcnQgYW5pbWF0aW9uLCBlbnN1cmUgd2UgaGF2ZVxuICAgICAgICAgICAgLy8gYXQgbGVhc3QgdHdvIGtleWZyYW1lcyB0byBhbmltYXRlIGJldHdlZW4gYXMgb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgICAgIC8vIGNhbid0IGFuaW1hdGUgYmV0d2VlbiBhIHNpbmdsZSBrZXlmcmFtZS5cbiAgICAgICAgICAgIGlmIChrZXlmcmFtZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzWzFdID0ga2V5ZnJhbWVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb24gPSBwcmVnZW5lcmF0ZWRBbmltYXRpb24uZHVyYXRpb247XG4gICAgICAgICAgICB0aW1lcyA9IHByZWdlbmVyYXRlZEFuaW1hdGlvbi50aW1lcztcbiAgICAgICAgICAgIGVhc2UgPSBwcmVnZW5lcmF0ZWRBbmltYXRpb24uZWFzZTtcbiAgICAgICAgICAgIHR5cGUgPSBcImtleWZyYW1lc1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHN0YXJ0V2FhcGlBbmltYXRpb24obW90aW9uVmFsdWUub3duZXIuY3VycmVudCwgbmFtZSwga2V5ZnJhbWVzLCB7IC4uLnRoaXMub3B0aW9ucywgZHVyYXRpb24sIHRpbWVzLCBlYXNlIH0pO1xuICAgICAgICAvLyBPdmVycmlkZSB0aGUgYnJvd3NlciBjYWxjdWxhdGVkIHN0YXJ0VGltZSB3aXRoIG9uZSBzeW5jaHJvbmlzZWQgdG8gb3RoZXIgSlNcbiAgICAgICAgLy8gYW5kIFdBQVBJIGFuaW1hdGlvbnMgc3RhcnRpbmcgdGhpcyBldmVudCBsb29wLlxuICAgICAgICBhbmltYXRpb24uc3RhcnRUaW1lID0gc3RhcnRUaW1lICE9PSBudWxsICYmIHN0YXJ0VGltZSAhPT0gdm9pZCAwID8gc3RhcnRUaW1lIDogdGhpcy5jYWxjU3RhcnRUaW1lKCk7XG4gICAgICAgIGlmICh0aGlzLnBlbmRpbmdUaW1lbGluZSkge1xuICAgICAgICAgICAgbW90aW9uRG9tLmF0dGFjaFRpbWVsaW5lKGFuaW1hdGlvbiwgdGhpcy5wZW5kaW5nVGltZWxpbmUpO1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFByZWZlciB0aGUgYG9uZmluaXNoYCBwcm9wIGFzIGl0J3MgbW9yZSB3aWRlbHkgc3VwcG9ydGVkIHRoYW5cbiAgICAgICAgICAgICAqIHRoZSBgZmluaXNoZWRgIHByb21pc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSGVyZSwgd2Ugc3luY2hyb25vdXNseSBzZXQgdGhlIHByb3ZpZGVkIE1vdGlvblZhbHVlIHRvIHRoZSBlbmRcbiAgICAgICAgICAgICAqIGtleWZyYW1lLiBJZiB3ZSBkaWRuJ3QsIHdoZW4gdGhlIFdBQVBJIGFuaW1hdGlvbiBpcyBmaW5pc2hlZCBpdCB3b3VsZFxuICAgICAgICAgICAgICogYmUgcmVtb3ZlZCBmcm9tIHRoZSBlbGVtZW50IHdoaWNoIHdvdWxkIHRoZW4gcmV2ZXJ0IHRvIGl0cyBvbGQgc3R5bGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhbmltYXRpb24ub25maW5pc2ggPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBvbkNvbXBsZXRlIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgbW90aW9uVmFsdWUuc2V0KGdldEZpbmFsS2V5ZnJhbWUoa2V5ZnJhbWVzLCB0aGlzLm9wdGlvbnMsIGZpbmFsS2V5ZnJhbWUpKTtcbiAgICAgICAgICAgICAgICBvbkNvbXBsZXRlICYmIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uLFxuICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICB0aW1lcyxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBlYXNlLFxuICAgICAgICAgICAga2V5ZnJhbWVzOiBrZXlmcmFtZXMsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldCBkdXJhdGlvbigpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICBjb25zdCB7IGR1cmF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1vdGlvblV0aWxzLm1pbGxpc2Vjb25kc1RvU2Vjb25kcyhkdXJhdGlvbik7XG4gICAgfVxuICAgIGdldCB0aW1lKCkge1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgcmV0dXJuIG1vdGlvblV0aWxzLm1pbGxpc2Vjb25kc1RvU2Vjb25kcyhhbmltYXRpb24uY3VycmVudFRpbWUgfHwgMCk7XG4gICAgfVxuICAgIHNldCB0aW1lKG5ld1RpbWUpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24uY3VycmVudFRpbWUgPSBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHMobmV3VGltZSk7XG4gICAgfVxuICAgIGdldCBzcGVlZCgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIHJldHVybiBhbmltYXRpb24ucGxheWJhY2tSYXRlO1xuICAgIH1cbiAgICBzZXQgc3BlZWQobmV3U3BlZWQpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24ucGxheWJhY2tSYXRlID0gbmV3U3BlZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBcImlkbGVcIjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnBsYXlTdGF0ZTtcbiAgICB9XG4gICAgZ2V0IHN0YXJ0VGltZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgIC8vIENvZXJjZSB0byBudW1iZXIgYXMgVHlwZVNjcmlwdCBpbmNvcnJlY3RseSB0eXBlcyB0aGlzXG4gICAgICAgIC8vIGFzIENTU051bWJlcmlzaFxuICAgICAgICByZXR1cm4gYW5pbWF0aW9uLnN0YXJ0VGltZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwbGFjZSB0aGUgZGVmYXVsdCBEb2N1bWVudFRpbWVsaW5lIHdpdGggYW5vdGhlciBBbmltYXRpb25UaW1lbGluZS5cbiAgICAgKiBDdXJyZW50bHkgdXNlZCBmb3Igc2Nyb2xsIGFuaW1hdGlvbnMuXG4gICAgICovXG4gICAgYXR0YWNoVGltZWxpbmUodGltZWxpbmUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZXNvbHZlZCkge1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGltZWxpbmUgPSB0aW1lbGluZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgICAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgbW90aW9uRG9tLmF0dGFjaFRpbWVsaW5lKGFuaW1hdGlvbiwgdGltZWxpbmUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5pc1N0b3BwZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0aW9uIH0gPSByZXNvbHZlZDtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5wbGF5U3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb24ucGxheSgpO1xuICAgIH1cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb24gfSA9IHJlc29sdmVkO1xuICAgICAgICBhbmltYXRpb24ucGF1c2UoKTtcbiAgICB9XG4gICAgc3RvcCgpIHtcbiAgICAgICAgdGhpcy5yZXNvbHZlci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5pc1N0b3BwZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJpZGxlXCIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICBjb25zdCB7IHJlc29sdmVkIH0gPSB0aGlzO1xuICAgICAgICBpZiAoIXJlc29sdmVkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCB7IGFuaW1hdGlvbiwga2V5ZnJhbWVzLCBkdXJhdGlvbiwgdHlwZSwgZWFzZSwgdGltZXMgfSA9IHJlc29sdmVkO1xuICAgICAgICBpZiAoYW5pbWF0aW9uLnBsYXlTdGF0ZSA9PT0gXCJpZGxlXCIgfHxcbiAgICAgICAgICAgIGFuaW1hdGlvbi5wbGF5U3RhdGUgPT09IFwiZmluaXNoZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXQUFQSSBkb2Vzbid0IG5hdGl2ZWx5IGhhdmUgYW55IGludGVycnVwdGlvbiBjYXBhYmlsaXRpZXMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFJhdGhlciB0aGFuIHJlYWQgY29tbWl0ZWQgc3R5bGVzIGJhY2sgb3V0IG9mIHRoZSBET00sIHdlIGNhblxuICAgICAgICAgKiBjcmVhdGUgYSByZW5kZXJsZXNzIEpTIGFuaW1hdGlvbiBhbmQgc2FtcGxlIGl0IHR3aWNlIHRvIGNhbGN1bGF0ZVxuICAgICAgICAgKiBpdHMgY3VycmVudCB2YWx1ZSwgXCJwcmV2aW91c1wiIHZhbHVlLCBhbmQgdGhlcmVmb3JlIGFsbG93XG4gICAgICAgICAqIE1vdGlvbiB0byBjYWxjdWxhdGUgdmVsb2NpdHkgZm9yIGFueSBzdWJzZXF1ZW50IGFuaW1hdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0aGlzLnRpbWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbW90aW9uVmFsdWUsIG9uVXBkYXRlLCBvbkNvbXBsZXRlLCBlbGVtZW50LCAuLi5vcHRpb25zIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVBbmltYXRpb24gPSBuZXcgTWFpblRocmVhZEFuaW1hdGlvbih7XG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMsXG4gICAgICAgICAgICAgICAgZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBlYXNlLFxuICAgICAgICAgICAgICAgIHRpbWVzLFxuICAgICAgICAgICAgICAgIGlzR2VuZXJhdG9yOiB0cnVlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBzYW1wbGVUaW1lID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRoaXMudGltZSk7XG4gICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXRXaXRoVmVsb2NpdHkoc2FtcGxlQW5pbWF0aW9uLnNhbXBsZShzYW1wbGVUaW1lIC0gc2FtcGxlRGVsdGEpLnZhbHVlLCBzYW1wbGVBbmltYXRpb24uc2FtcGxlKHNhbXBsZVRpbWUpLnZhbHVlLCBzYW1wbGVEZWx0YSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvblN0b3AgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgb25TdG9wICYmIG9uU3RvcCgpO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgIH1cbiAgICBjb21wbGV0ZSgpIHtcbiAgICAgICAgY29uc3QgeyByZXNvbHZlZCB9ID0gdGhpcztcbiAgICAgICAgaWYgKCFyZXNvbHZlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVzb2x2ZWQuYW5pbWF0aW9uLmZpbmlzaCgpO1xuICAgIH1cbiAgICBjYW5jZWwoKSB7XG4gICAgICAgIGNvbnN0IHsgcmVzb2x2ZWQgfSA9IHRoaXM7XG4gICAgICAgIGlmICghcmVzb2x2ZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJlc29sdmVkLmFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICB9XG4gICAgc3RhdGljIHN1cHBvcnRzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgeyBtb3Rpb25WYWx1ZSwgbmFtZSwgcmVwZWF0RGVsYXksIHJlcGVhdFR5cGUsIGRhbXBpbmcsIHR5cGUgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmICghbW90aW9uVmFsdWUgfHxcbiAgICAgICAgICAgICFtb3Rpb25WYWx1ZS5vd25lciB8fFxuICAgICAgICAgICAgIShtb3Rpb25WYWx1ZS5vd25lci5jdXJyZW50IGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBvblVwZGF0ZSwgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IG1vdGlvblZhbHVlLm93bmVyLmdldFByb3BzKCk7XG4gICAgICAgIHJldHVybiAoc3VwcG9ydHNXYWFwaSgpICYmXG4gICAgICAgICAgICBuYW1lICYmXG4gICAgICAgICAgICBhY2NlbGVyYXRlZFZhbHVlcy5oYXMobmFtZSkgJiZcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgd2UncmUgb3V0cHV0dGluZyB2YWx1ZXMgdG8gb25VcGRhdGUgdGhlbiB3ZSBjYW4ndCB1c2UgV0FBUEkgYXMgdGhlcmUnc1xuICAgICAgICAgICAgICogbm8gd2F5IHRvIHJlYWQgdGhlIHZhbHVlIGZyb20gV0FBUEkgZXZlcnkgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICFvblVwZGF0ZSAmJlxuICAgICAgICAgICAgIXRyYW5zZm9ybVRlbXBsYXRlICYmXG4gICAgICAgICAgICAhcmVwZWF0RGVsYXkgJiZcbiAgICAgICAgICAgIHJlcGVhdFR5cGUgIT09IFwibWlycm9yXCIgJiZcbiAgICAgICAgICAgIGRhbXBpbmcgIT09IDAgJiZcbiAgICAgICAgICAgIHR5cGUgIT09IFwiaW5lcnRpYVwiKTtcbiAgICB9XG59XG5cbmNvbnN0IHVuZGVyRGFtcGVkU3ByaW5nID0ge1xuICAgIHR5cGU6IFwic3ByaW5nXCIsXG4gICAgc3RpZmZuZXNzOiA1MDAsXG4gICAgZGFtcGluZzogMjUsXG4gICAgcmVzdFNwZWVkOiAxMCxcbn07XG5jb25zdCBjcml0aWNhbGx5RGFtcGVkU3ByaW5nID0gKHRhcmdldCkgPT4gKHtcbiAgICB0eXBlOiBcInNwcmluZ1wiLFxuICAgIHN0aWZmbmVzczogNTUwLFxuICAgIGRhbXBpbmc6IHRhcmdldCA9PT0gMCA/IDIgKiBNYXRoLnNxcnQoNTUwKSA6IDMwLFxuICAgIHJlc3RTcGVlZDogMTAsXG59KTtcbmNvbnN0IGtleWZyYW1lc1RyYW5zaXRpb24gPSB7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBkdXJhdGlvbjogMC44LFxufTtcbi8qKlxuICogRGVmYXVsdCBlYXNpbmcgY3VydmUgaXMgYSBzbGlnaHRseSBzaGFsbG93ZXIgdmVyc2lvbiBvZlxuICogdGhlIGRlZmF1bHQgYnJvd3NlciBlYXNpbmcgY3VydmUuXG4gKi9cbmNvbnN0IGVhc2UgPSB7XG4gICAgdHlwZTogXCJrZXlmcmFtZXNcIixcbiAgICBlYXNlOiBbMC4yNSwgMC4xLCAwLjM1LCAxXSxcbiAgICBkdXJhdGlvbjogMC4zLFxufTtcbmNvbnN0IGdldERlZmF1bHRUcmFuc2l0aW9uID0gKHZhbHVlS2V5LCB7IGtleWZyYW1lcyB9KSA9PiB7XG4gICAgaWYgKGtleWZyYW1lcy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiBrZXlmcmFtZXNUcmFuc2l0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1Qcm9wcy5oYXModmFsdWVLZXkpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUtleS5zdGFydHNXaXRoKFwic2NhbGVcIilcbiAgICAgICAgICAgID8gY3JpdGljYWxseURhbXBlZFNwcmluZyhrZXlmcmFtZXNbMV0pXG4gICAgICAgICAgICA6IHVuZGVyRGFtcGVkU3ByaW5nO1xuICAgIH1cbiAgICByZXR1cm4gZWFzZTtcbn07XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgYSB0cmFuc2l0aW9uIGlzIGRlZmluZWQgb24gYSBnaXZlbiBUcmFuc2l0aW9uLlxuICogVGhpcyBmaWx0ZXJzIG91dCBvcmNoZXN0cmF0aW9uIG9wdGlvbnMgYW5kIHJldHVybnMgdHJ1ZVxuICogaWYgYW55IG9wdGlvbnMgYXJlIGxlZnQuXG4gKi9cbmZ1bmN0aW9uIGlzVHJhbnNpdGlvbkRlZmluZWQoeyB3aGVuLCBkZWxheTogX2RlbGF5LCBkZWxheUNoaWxkcmVuLCBzdGFnZ2VyQ2hpbGRyZW4sIHN0YWdnZXJEaXJlY3Rpb24sIHJlcGVhdCwgcmVwZWF0VHlwZSwgcmVwZWF0RGVsYXksIGZyb20sIGVsYXBzZWQsIC4uLnRyYW5zaXRpb24gfSkge1xuICAgIHJldHVybiAhIU9iamVjdC5rZXlzKHRyYW5zaXRpb24pLmxlbmd0aDtcbn1cblxuY29uc3QgYW5pbWF0ZU1vdGlvblZhbHVlID0gKG5hbWUsIHZhbHVlLCB0YXJnZXQsIHRyYW5zaXRpb24gPSB7fSwgZWxlbWVudCwgaXNIYW5kb2ZmKSA9PiAob25Db21wbGV0ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlVHJhbnNpdGlvbiA9IG1vdGlvbkRvbS5nZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwgbmFtZSkgfHwge307XG4gICAgLyoqXG4gICAgICogTW9zdCB0cmFuc2l0aW9uIHZhbHVlcyBhcmUgY3VycmVudGx5IGNvbXBsZXRlbHkgb3ZlcndyaXR0ZW4gYnkgdmFsdWUtc3BlY2lmaWNcbiAgICAgKiB0cmFuc2l0aW9ucy4gSW4gdGhlIGZ1dHVyZSBpdCdkIGJlIG5pY2VyIHRvIGJsZW5kIHRoZXNlIHRyYW5zaXRpb25zLiBCdXQgZm9yIG5vd1xuICAgICAqIGRlbGF5IGFjdHVhbGx5IGRvZXMgaW5oZXJpdCBmcm9tIHRoZSByb290IHRyYW5zaXRpb24gaWYgbm90IHZhbHVlLXNwZWNpZmljLlxuICAgICAqL1xuICAgIGNvbnN0IGRlbGF5ID0gdmFsdWVUcmFuc2l0aW9uLmRlbGF5IHx8IHRyYW5zaXRpb24uZGVsYXkgfHwgMDtcbiAgICAvKipcbiAgICAgKiBFbGFwc2VkIGlzbid0IGEgcHVibGljIHRyYW5zaXRpb24gb3B0aW9uIGJ1dCBjYW4gYmUgcGFzc2VkIHRocm91Z2ggZnJvbVxuICAgICAqIG9wdGltaXplZCBhcHBlYXIgZWZmZWN0cyBpbiBtaWxsaXNlY29uZHMuXG4gICAgICovXG4gICAgbGV0IHsgZWxhcHNlZCA9IDAgfSA9IHRyYW5zaXRpb247XG4gICAgZWxhcHNlZCA9IGVsYXBzZWQgLSBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHMoZGVsYXkpO1xuICAgIGxldCBvcHRpb25zID0ge1xuICAgICAgICBrZXlmcmFtZXM6IEFycmF5LmlzQXJyYXkodGFyZ2V0KSA/IHRhcmdldCA6IFtudWxsLCB0YXJnZXRdLFxuICAgICAgICBlYXNlOiBcImVhc2VPdXRcIixcbiAgICAgICAgdmVsb2NpdHk6IHZhbHVlLmdldFZlbG9jaXR5KCksXG4gICAgICAgIC4uLnZhbHVlVHJhbnNpdGlvbixcbiAgICAgICAgZGVsYXk6IC1lbGFwc2VkLFxuICAgICAgICBvblVwZGF0ZTogKHYpID0+IHtcbiAgICAgICAgICAgIHZhbHVlLnNldCh2KTtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vblVwZGF0ZSAmJiB2YWx1ZVRyYW5zaXRpb24ub25VcGRhdGUodik7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgIG9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlICYmIHZhbHVlVHJhbnNpdGlvbi5vbkNvbXBsZXRlKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG5hbWUsXG4gICAgICAgIG1vdGlvblZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZWxlbWVudDogaXNIYW5kb2ZmID8gdW5kZWZpbmVkIDogZWxlbWVudCxcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gdHJhbnNpdGlvbiBkZWZpbmVkIGZvciB0aGlzIHZhbHVlLCB3ZSBjYW4gZ2VuZXJhdGVcbiAgICAgKiB1bnFpdWUgdHJhbnNpdGlvbiBzZXR0aW5ncyBmb3IgdGhpcyB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAoIWlzVHJhbnNpdGlvbkRlZmluZWQodmFsdWVUcmFuc2l0aW9uKSkge1xuICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIC4uLmdldERlZmF1bHRUcmFuc2l0aW9uKG5hbWUsIG9wdGlvbnMpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCb3RoIFdBQVBJIGFuZCBvdXIgaW50ZXJuYWwgYW5pbWF0aW9uIGZ1bmN0aW9ucyB1c2UgZHVyYXRpb25zXG4gICAgICogYXMgZGVmaW5lZCBieSBtaWxsaXNlY29uZHMsIHdoaWxlIG91ciBleHRlcm5hbCBBUEkgZGVmaW5lcyB0aGVtXG4gICAgICogYXMgc2Vjb25kcy5cbiAgICAgKi9cbiAgICBpZiAob3B0aW9ucy5kdXJhdGlvbikge1xuICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG9wdGlvbnMuZHVyYXRpb24pO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5yZXBlYXREZWxheSkge1xuICAgICAgICBvcHRpb25zLnJlcGVhdERlbGF5ID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKG9wdGlvbnMucmVwZWF0RGVsYXkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5mcm9tICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgb3B0aW9ucy5rZXlmcmFtZXNbMF0gPSBvcHRpb25zLmZyb207XG4gICAgfVxuICAgIGxldCBzaG91bGRTa2lwID0gZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudHlwZSA9PT0gZmFsc2UgfHxcbiAgICAgICAgKG9wdGlvbnMuZHVyYXRpb24gPT09IDAgJiYgIW9wdGlvbnMucmVwZWF0RGVsYXkpKSB7XG4gICAgICAgIG9wdGlvbnMuZHVyYXRpb24gPSAwO1xuICAgICAgICBpZiAob3B0aW9ucy5kZWxheSA9PT0gMCkge1xuICAgICAgICAgICAgc2hvdWxkU2tpcCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50IHx8XG4gICAgICAgIE1vdGlvbkdsb2JhbENvbmZpZy5za2lwQW5pbWF0aW9ucykge1xuICAgICAgICBzaG91bGRTa2lwID0gdHJ1ZTtcbiAgICAgICAgb3B0aW9ucy5kdXJhdGlvbiA9IDA7XG4gICAgICAgIG9wdGlvbnMuZGVsYXkgPSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBjYW4gb3IgbXVzdCBza2lwIGNyZWF0aW5nIHRoZSBhbmltYXRpb24sIGFuZCBhcHBseSBvbmx5XG4gICAgICogdGhlIGZpbmFsIGtleWZyYW1lLCBkbyBzby4gV2UgYWxzbyBjaGVjayBvbmNlIGtleWZyYW1lcyBhcmUgcmVzb2x2ZWQgYnV0XG4gICAgICogdGhpcyBlYXJseSBjaGVjayBwcmV2ZW50cyB0aGUgbmVlZCB0byBjcmVhdGUgYW4gYW5pbWF0aW9uIGF0IGFsbC5cbiAgICAgKi9cbiAgICBpZiAoc2hvdWxkU2tpcCAmJiAhaXNIYW5kb2ZmICYmIHZhbHVlLmdldCgpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3QgZmluYWxLZXlmcmFtZSA9IGdldEZpbmFsS2V5ZnJhbWUob3B0aW9ucy5rZXlmcmFtZXMsIHZhbHVlVHJhbnNpdGlvbik7XG4gICAgICAgIGlmIChmaW5hbEtleWZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZShmaW5hbEtleWZyYW1lKTtcbiAgICAgICAgICAgICAgICBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gV2Ugc3RpbGwgd2FudCB0byByZXR1cm4gc29tZSBhbmltYXRpb24gY29udHJvbHMgaGVyZSByYXRoZXJcbiAgICAgICAgICAgIC8vIHRoYW4gcmV0dXJuaW5nIHVuZGVmaW5lZFxuICAgICAgICAgICAgcmV0dXJuIG5ldyBtb3Rpb25Eb20uR3JvdXBQbGF5YmFja0NvbnRyb2xzKFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbmltYXRlIHZpYSBXQUFQSSBpZiBwb3NzaWJsZS4gSWYgdGhpcyBpcyBhIGhhbmRvZmYgYW5pbWF0aW9uLCB0aGUgb3B0aW1pc2VkIGFuaW1hdGlvbiB3aWxsIGJlIHJ1bm5pbmcgdmlhXG4gICAgICogV0FBUEkuIFRoZXJlZm9yZSwgdGhpcyBhbmltYXRpb24gbXVzdCBiZSBKUyB0byBlbnN1cmUgaXQgcnVucyBcInVuZGVyXCIgdGhlXG4gICAgICogb3B0aW1pc2VkIGFuaW1hdGlvbi5cbiAgICAgKi9cbiAgICBpZiAoIWlzSGFuZG9mZiAmJiBBY2NlbGVyYXRlZEFuaW1hdGlvbi5zdXBwb3J0cyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gbmV3IEFjY2VsZXJhdGVkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBNYWluVGhyZWFkQW5pbWF0aW9uKG9wdGlvbnMpO1xuICAgIH1cbn07XG5cbi8qKlxuICogRGVjaWRlIHdoZXRoZXIgd2Ugc2hvdWxkIGJsb2NrIHRoaXMgYW5pbWF0aW9uLiBQcmV2aW91c2x5LCB3ZSBhY2hpZXZlZCB0aGlzXG4gKiBqdXN0IGJ5IGNoZWNraW5nIHdoZXRoZXIgdGhlIGtleSB3YXMgbGlzdGVkIGluIHByb3RlY3RlZEtleXMsIGJ1dCB0aGlzXG4gKiBwb3NlZCBwcm9ibGVtcyBpZiBhbiBhbmltYXRpb24gd2FzIHRyaWdnZXJlZCBieSBhZnRlckNoaWxkcmVuIGFuZCBwcm90ZWN0ZWRLZXlzXG4gKiBoYWQgYmVlbiBzZXQgdG8gdHJ1ZSBpbiB0aGUgbWVhbnRpbWUuXG4gKi9cbmZ1bmN0aW9uIHNob3VsZEJsb2NrQW5pbWF0aW9uKHsgcHJvdGVjdGVkS2V5cywgbmVlZHNBbmltYXRpbmcgfSwga2V5KSB7XG4gICAgY29uc3Qgc2hvdWxkQmxvY2sgPSBwcm90ZWN0ZWRLZXlzLmhhc093blByb3BlcnR5KGtleSkgJiYgbmVlZHNBbmltYXRpbmdba2V5XSAhPT0gdHJ1ZTtcbiAgICBuZWVkc0FuaW1hdGluZ1trZXldID0gZmFsc2U7XG4gICAgcmV0dXJuIHNob3VsZEJsb2NrO1xufVxuZnVuY3Rpb24gYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCB0YXJnZXRBbmRUcmFuc2l0aW9uLCB7IGRlbGF5ID0gMCwgdHJhbnNpdGlvbk92ZXJyaWRlLCB0eXBlIH0gPSB7fSkge1xuICAgIHZhciBfYTtcbiAgICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpLCB0cmFuc2l0aW9uRW5kLCAuLi50YXJnZXQgfSA9IHRhcmdldEFuZFRyYW5zaXRpb247XG4gICAgaWYgKHRyYW5zaXRpb25PdmVycmlkZSlcbiAgICAgICAgdHJhbnNpdGlvbiA9IHRyYW5zaXRpb25PdmVycmlkZTtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgYW5pbWF0aW9uVHlwZVN0YXRlID0gdHlwZSAmJlxuICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlICYmXG4gICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuZ2V0U3RhdGUoKVt0eXBlXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0YXJnZXQpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKGtleSwgKF9hID0gdmlzdWFsRWxlbWVudC5sYXRlc3RWYWx1ZXNba2V5XSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogbnVsbCk7XG4gICAgICAgIGNvbnN0IHZhbHVlVGFyZ2V0ID0gdGFyZ2V0W2tleV07XG4gICAgICAgIGlmICh2YWx1ZVRhcmdldCA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAoYW5pbWF0aW9uVHlwZVN0YXRlICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkQmxvY2tBbmltYXRpb24oYW5pbWF0aW9uVHlwZVN0YXRlLCBrZXkpKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdmFsdWVUcmFuc2l0aW9uID0ge1xuICAgICAgICAgICAgZGVsYXksXG4gICAgICAgICAgICAuLi5tb3Rpb25Eb20uZ2V0VmFsdWVUcmFuc2l0aW9uKHRyYW5zaXRpb24gfHwge30sIGtleSksXG4gICAgICAgIH07XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGlzIGlzIHRoZSBmaXJzdCB0aW1lIGEgdmFsdWUgaXMgYmVpbmcgYW5pbWF0ZWQsIGNoZWNrXG4gICAgICAgICAqIHRvIHNlZSBpZiB3ZSdyZSBoYW5kbGluZyBvZmYgZnJvbSBhbiBleGlzdGluZyBhbmltYXRpb24uXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgaXNIYW5kb2ZmID0gZmFsc2U7XG4gICAgICAgIGlmICh3aW5kb3cuTW90aW9uSGFuZG9mZkFuaW1hdGlvbikge1xuICAgICAgICAgICAgY29uc3QgYXBwZWFySWQgPSBnZXRPcHRpbWlzZWRBcHBlYXJJZCh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIGlmIChhcHBlYXJJZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmQW5pbWF0aW9uKGFwcGVhcklkLCBrZXksIGZyYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhcnRUaW1lICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlVHJhbnNpdGlvbi5zdGFydFRpbWUgPSBzdGFydFRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlzSGFuZG9mZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFkZFZhbHVlVG9XaWxsQ2hhbmdlKHZpc3VhbEVsZW1lbnQsIGtleSk7XG4gICAgICAgIHZhbHVlLnN0YXJ0KGFuaW1hdGVNb3Rpb25WYWx1ZShrZXksIHZhbHVlLCB2YWx1ZVRhcmdldCwgdmlzdWFsRWxlbWVudC5zaG91bGRSZWR1Y2VNb3Rpb24gJiYgcG9zaXRpb25hbEtleXMuaGFzKGtleSlcbiAgICAgICAgICAgID8geyB0eXBlOiBmYWxzZSB9XG4gICAgICAgICAgICA6IHZhbHVlVHJhbnNpdGlvbiwgdmlzdWFsRWxlbWVudCwgaXNIYW5kb2ZmKSk7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHZhbHVlLmFuaW1hdGlvbjtcbiAgICAgICAgaWYgKGFuaW1hdGlvbikge1xuICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgUHJvbWlzZS5hbGwoYW5pbWF0aW9ucykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBmcmFtZS51cGRhdGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb25FbmQgJiYgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHRyYW5zaXRpb25FbmQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9ucztcbn1cblxuZnVuY3Rpb24gYW5pbWF0ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9hO1xuICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgdmFyaWFudCwgb3B0aW9ucy50eXBlID09PSBcImV4aXRcIlxuICAgICAgICA/IChfYSA9IHZpc3VhbEVsZW1lbnQucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tXG4gICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICBsZXQgeyB0cmFuc2l0aW9uID0gdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8IHt9IH0gPSByZXNvbHZlZCB8fCB7fTtcbiAgICBpZiAob3B0aW9ucy50cmFuc2l0aW9uT3ZlcnJpZGUpIHtcbiAgICAgICAgdHJhbnNpdGlvbiA9IG9wdGlvbnMudHJhbnNpdGlvbk92ZXJyaWRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGEgdmFyaWFudCwgY3JlYXRlIGEgY2FsbGJhY2sgdGhhdCBydW5zIGl0IGFzIGFuIGFuaW1hdGlvbi5cbiAgICAgKiBPdGhlcndpc2UsIHdlIHJlc29sdmUgYSBQcm9taXNlIGltbWVkaWF0ZWx5IGZvciBhIGNvbXBvc2FibGUgbm8tb3AuXG4gICAgICovXG4gICAgY29uc3QgZ2V0QW5pbWF0aW9uID0gcmVzb2x2ZWRcbiAgICAgICAgPyAoKSA9PiBQcm9taXNlLmFsbChhbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHJlc29sdmVkLCBvcHRpb25zKSlcbiAgICAgICAgOiAoKSA9PiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlIGNoaWxkcmVuLCBjcmVhdGUgYSBjYWxsYmFjayB0aGF0IHJ1bnMgYWxsIHRoZWlyIGFuaW1hdGlvbnMuXG4gICAgICogT3RoZXJ3aXNlLCB3ZSByZXNvbHZlIGEgUHJvbWlzZSBpbW1lZGlhdGVseSBmb3IgYSBjb21wb3NhYmxlIG5vLW9wLlxuICAgICAqL1xuICAgIGNvbnN0IGdldENoaWxkQW5pbWF0aW9ucyA9IHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuICYmIHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemVcbiAgICAgICAgPyAoZm9yd2FyZERlbGF5ID0gMCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCB9ID0gdHJhbnNpdGlvbjtcbiAgICAgICAgICAgIHJldHVybiBhbmltYXRlQ2hpbGRyZW4odmlzdWFsRWxlbWVudCwgdmFyaWFudCwgZGVsYXlDaGlsZHJlbiArIGZvcndhcmREZWxheSwgc3RhZ2dlckNoaWxkcmVuLCBzdGFnZ2VyRGlyZWN0aW9uLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICA6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIC8qKlxuICAgICAqIElmIHRoZSB0cmFuc2l0aW9uIGV4cGxpY2l0bHkgZGVmaW5lcyBhIFwid2hlblwiIG9wdGlvbiwgd2UgbmVlZCB0byByZXNvbHZlIGVpdGhlclxuICAgICAqIHRoaXMgYW5pbWF0aW9uIG9yIGFsbCBjaGlsZHJlbiBhbmltYXRpb25zIGJlZm9yZSBwbGF5aW5nIHRoZSBvdGhlci5cbiAgICAgKi9cbiAgICBjb25zdCB7IHdoZW4gfSA9IHRyYW5zaXRpb247XG4gICAgaWYgKHdoZW4pIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBsYXN0XSA9IHdoZW4gPT09IFwiYmVmb3JlQ2hpbGRyZW5cIlxuICAgICAgICAgICAgPyBbZ2V0QW5pbWF0aW9uLCBnZXRDaGlsZEFuaW1hdGlvbnNdXG4gICAgICAgICAgICA6IFtnZXRDaGlsZEFuaW1hdGlvbnMsIGdldEFuaW1hdGlvbl07XG4gICAgICAgIHJldHVybiBmaXJzdCgpLnRoZW4oKCkgPT4gbGFzdCgpKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChbZ2V0QW5pbWF0aW9uKCksIGdldENoaWxkQW5pbWF0aW9ucyhvcHRpb25zLmRlbGF5KV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFuaW1hdGVDaGlsZHJlbih2aXN1YWxFbGVtZW50LCB2YXJpYW50LCBkZWxheUNoaWxkcmVuID0gMCwgc3RhZ2dlckNoaWxkcmVuID0gMCwgc3RhZ2dlckRpcmVjdGlvbiA9IDEsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgbWF4U3RhZ2dlckR1cmF0aW9uID0gKHZpc3VhbEVsZW1lbnQudmFyaWFudENoaWxkcmVuLnNpemUgLSAxKSAqIHN0YWdnZXJDaGlsZHJlbjtcbiAgICBjb25zdCBnZW5lcmF0ZVN0YWdnZXJEdXJhdGlvbiA9IHN0YWdnZXJEaXJlY3Rpb24gPT09IDFcbiAgICAgICAgPyAoaSA9IDApID0+IGkgKiBzdGFnZ2VyQ2hpbGRyZW5cbiAgICAgICAgOiAoaSA9IDApID0+IG1heFN0YWdnZXJEdXJhdGlvbiAtIGkgKiBzdGFnZ2VyQ2hpbGRyZW47XG4gICAgQXJyYXkuZnJvbSh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbilcbiAgICAgICAgLnNvcnQoc29ydEJ5VHJlZU9yZGVyKVxuICAgICAgICAuZm9yRWFjaCgoY2hpbGQsIGkpID0+IHtcbiAgICAgICAgY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgdmFyaWFudCk7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlVmFyaWFudChjaGlsZCwgdmFyaWFudCwge1xuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIGRlbGF5OiBkZWxheUNoaWxkcmVuICsgZ2VuZXJhdGVTdGFnZ2VyRHVyYXRpb24oaSksXG4gICAgICAgIH0pLnRoZW4oKCkgPT4gY2hpbGQubm90aWZ5KFwiQW5pbWF0aW9uQ29tcGxldGVcIiwgdmFyaWFudCkpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG59XG5mdW5jdGlvbiBzb3J0QnlUcmVlT3JkZXIoYSwgYikge1xuICAgIHJldHVybiBhLnNvcnROb2RlUG9zaXRpb24oYik7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMgPSB7fSkge1xuICAgIHZpc3VhbEVsZW1lbnQubm90aWZ5KFwiQW5pbWF0aW9uU3RhcnRcIiwgZGVmaW5pdGlvbik7XG4gICAgbGV0IGFuaW1hdGlvbjtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICBjb25zdCBhbmltYXRpb25zID0gZGVmaW5pdGlvbi5tYXAoKHZhcmlhbnQpID0+IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIHZhcmlhbnQsIG9wdGlvbnMpKTtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0aW9ucyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGFuaW1hdGlvbiA9IGFuaW1hdGVWYXJpYW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWREZWZpbml0aW9uID0gdHlwZW9mIGRlZmluaXRpb24gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgPyByZXNvbHZlVmFyaWFudCh2aXN1YWxFbGVtZW50LCBkZWZpbml0aW9uLCBvcHRpb25zLmN1c3RvbSlcbiAgICAgICAgICAgIDogZGVmaW5pdGlvbjtcbiAgICAgICAgYW5pbWF0aW9uID0gUHJvbWlzZS5hbGwoYW5pbWF0ZVRhcmdldCh2aXN1YWxFbGVtZW50LCByZXNvbHZlZERlZmluaXRpb24sIG9wdGlvbnMpKTtcbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbi50aGVuKCgpID0+IHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJBbmltYXRpb25Db21wbGV0ZVwiLCBkZWZpbml0aW9uKTtcbiAgICB9KTtcbn1cblxuY29uc3QgbnVtVmFyaWFudFByb3BzID0gdmFyaWFudFByb3BzLmxlbmd0aDtcbmZ1bmN0aW9uIGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgaWYgKCF2aXN1YWxFbGVtZW50LmlzQ29udHJvbGxpbmdWYXJpYW50cykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gdmlzdWFsRWxlbWVudC5wYXJlbnRcbiAgICAgICAgICAgID8gZ2V0VmFyaWFudENvbnRleHQodmlzdWFsRWxlbWVudC5wYXJlbnQpIHx8IHt9XG4gICAgICAgICAgICA6IHt9O1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudC5wcm9wcy5pbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnRleHQuaW5pdGlhbCA9IHZpc3VhbEVsZW1lbnQucHJvcHMuaW5pdGlhbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29udGV4dDtcbiAgICB9XG4gICAgY29uc3QgY29udGV4dCA9IHt9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFyaWFudFByb3BzOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHZhcmlhbnRQcm9wc1tpXTtcbiAgICAgICAgY29uc3QgcHJvcCA9IHZpc3VhbEVsZW1lbnQucHJvcHNbbmFtZV07XG4gICAgICAgIGlmIChpc1ZhcmlhbnRMYWJlbChwcm9wKSB8fCBwcm9wID09PSBmYWxzZSkge1xuICAgICAgICAgICAgY29udGV4dFtuYW1lXSA9IHByb3A7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5cbmNvbnN0IHJldmVyc2VQcmlvcml0eU9yZGVyID0gWy4uLnZhcmlhbnRQcmlvcml0eU9yZGVyXS5yZXZlcnNlKCk7XG5jb25zdCBudW1BbmltYXRpb25UeXBlcyA9IHZhcmlhbnRQcmlvcml0eU9yZGVyLmxlbmd0aDtcbmZ1bmN0aW9uIGFuaW1hdGVMaXN0KHZpc3VhbEVsZW1lbnQpIHtcbiAgICByZXR1cm4gKGFuaW1hdGlvbnMpID0+IFByb21pc2UuYWxsKGFuaW1hdGlvbnMubWFwKCh7IGFuaW1hdGlvbiwgb3B0aW9ucyB9KSA9PiBhbmltYXRlVmlzdWFsRWxlbWVudCh2aXN1YWxFbGVtZW50LCBhbmltYXRpb24sIG9wdGlvbnMpKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVBbmltYXRpb25TdGF0ZSh2aXN1YWxFbGVtZW50KSB7XG4gICAgbGV0IGFuaW1hdGUgPSBhbmltYXRlTGlzdCh2aXN1YWxFbGVtZW50KTtcbiAgICBsZXQgc3RhdGUgPSBjcmVhdGVTdGF0ZSgpO1xuICAgIGxldCBpc0luaXRpYWxSZW5kZXIgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIHJlZHVjZSB0aGUgYW5pbWF0aW9uIGRlZmluaXRpb25zIGZvclxuICAgICAqIGVhY2ggYWN0aXZlIGFuaW1hdGlvbiB0eXBlIGludG8gYW4gb2JqZWN0IG9mIHJlc29sdmVkIHZhbHVlcyBmb3IgaXQuXG4gICAgICovXG4gICAgY29uc3QgYnVpbGRSZXNvbHZlZFR5cGVWYWx1ZXMgPSAodHlwZSkgPT4gKGFjYywgZGVmaW5pdGlvbikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnQodmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbiwgdHlwZSA9PT0gXCJleGl0XCJcbiAgICAgICAgICAgID8gKF9hID0gdmlzdWFsRWxlbWVudC5wcmVzZW5jZUNvbnRleHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jdXN0b21cbiAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICBjb25zdCB7IHRyYW5zaXRpb24sIHRyYW5zaXRpb25FbmQsIC4uLnRhcmdldCB9ID0gcmVzb2x2ZWQ7XG4gICAgICAgICAgICBhY2MgPSB7IC4uLmFjYywgLi4udGFyZ2V0LCAuLi50cmFuc2l0aW9uRW5kIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFjYztcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoaXMganVzdCBhbGxvd3MgdXMgdG8gaW5qZWN0IG1vY2tlZCBhbmltYXRpb24gZnVuY3Rpb25zXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0QW5pbWF0ZUZ1bmN0aW9uKG1ha2VBbmltYXRvcikge1xuICAgICAgICBhbmltYXRlID0gbWFrZUFuaW1hdG9yKHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGVuIHdlIHJlY2VpdmUgbmV3IHByb3BzLCB3ZSBuZWVkIHRvOlxuICAgICAqIDEuIENyZWF0ZSBhIGxpc3Qgb2YgcHJvdGVjdGVkIGtleXMgZm9yIGVhY2ggdHlwZS4gVGhpcyBpcyBhIGRpcmVjdG9yeSBvZlxuICAgICAqICAgIHZhbHVlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IGJlaW5nIFwiaGFuZGxlZFwiIGJ5IHR5cGVzIG9mIGEgaGlnaGVyIHByaW9yaXR5XG4gICAgICogICAgc28gdGhhdCB3aGVuZXZlciBhbiBhbmltYXRpb24gaXMgcGxheWVkIG9mIGEgZ2l2ZW4gdHlwZSwgdGhlc2UgdmFsdWVzIGFyZVxuICAgICAqICAgIHByb3RlY3RlZCBmcm9tIGJlaW5nIGFuaW1hdGVkLlxuICAgICAqIDIuIERldGVybWluZSBpZiBhbiBhbmltYXRpb24gdHlwZSBuZWVkcyBhbmltYXRpbmcuXG4gICAgICogMy4gRGV0ZXJtaW5lIGlmIGFueSB2YWx1ZXMgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSBhIHR5cGUgYW5kIGZpZ3VyZSBvdXRcbiAgICAgKiAgICB3aGF0IHRvIGFuaW1hdGUgdGhvc2UgdG8uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYW5pbWF0ZUNoYW5nZXMoY2hhbmdlZEFjdGl2ZVR5cGUpIHtcbiAgICAgICAgY29uc3QgeyBwcm9wcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgY29uc3QgY29udGV4dCA9IGdldFZhcmlhbnRDb250ZXh0KHZpc3VhbEVsZW1lbnQucGFyZW50KSB8fCB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgbGlzdCBvZiBhbmltYXRpb25zIHRoYXQgd2UnbGwgYnVpbGQgaW50byBhcyB3ZSBpdGVyYXRlIHRocm91Z2ggdGhlIGFuaW1hdGlvblxuICAgICAgICAgKiB0eXBlcy4gVGhpcyB3aWxsIGdldCBleGVjdXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBmdW5jdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEtlZXAgdHJhY2sgb2Ygd2hpY2ggdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLiBUaGVuLCBhcyB3ZSBoaXQgbG93ZXIgcHJpb3JpdHlcbiAgICAgICAgICogYW5pbWF0aW9uIHR5cGVzLCB3ZSBjYW4gY2hlY2sgaWYgdGhleSBjb250YWluIHJlbW92ZWQgdmFsdWVzIGFuZCBhbmltYXRlIHRvIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCByZW1vdmVkS2V5cyA9IG5ldyBTZXQoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgZGljdGlvbmFyeSBvZiBhbGwgZW5jb3VudGVyZWQga2V5cy4gVGhpcyBpcyBhbiBvYmplY3QgdG8gbGV0IHVzIGJ1aWxkIGludG8gYW5kXG4gICAgICAgICAqIGNvcHkgaXQgd2l0aG91dCBpdGVyYXRpb24uIEVhY2ggdGltZSB3ZSBoaXQgYW4gYW5pbWF0aW9uIHR5cGUgd2Ugc2V0IGl0cyBwcm90ZWN0ZWRcbiAgICAgICAgICoga2V5cyAtIHRoZSBrZXlzIGl0cyBub3QgYWxsb3dlZCB0byBhbmltYXRlIC0gdG8gdGhlIGxhdGVzdCB2ZXJzaW9uIG9mIHRoaXMgb2JqZWN0LlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IGVuY291bnRlcmVkS2V5cyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgYSB2YXJpYW50IGhhcyBiZWVuIHJlbW92ZWQgYXQgYSBnaXZlbiBpbmRleCwgYW5kIHRoaXMgY29tcG9uZW50IGlzIGNvbnRyb2xsaW5nXG4gICAgICAgICAqIHZhcmlhbnQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byBlbnN1cmUgbG93ZXItcHJpb3JpdHkgdmFyaWFudHMgYXJlIGZvcmNlZCB0byBhbmltYXRlLlxuICAgICAgICAgKi9cbiAgICAgICAgbGV0IHJlbW92ZWRWYXJpYW50SW5kZXggPSBJbmZpbml0eTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgYW5pbWF0aW9uIHR5cGVzIGluIHJldmVyc2UgcHJpb3JpdHkgb3JkZXIuIEZvciBlYWNoLCB3ZSB3YW50IHRvXG4gICAgICAgICAqIGRldGVjdCB3aGljaCB2YWx1ZXMgaXQncyBoYW5kbGluZyBhbmQgd2hldGhlciBvciBub3QgdGhleSd2ZSBjaGFuZ2VkIChhbmQgdGhlcmVmb3JlXG4gICAgICAgICAqIG5lZWQgdG8gYmUgYW5pbWF0ZWQpLiBJZiBhbnkgdmFsdWVzIGhhdmUgYmVlbiByZW1vdmVkLCB3ZSB3YW50IHRvIGRldGVjdCB0aG9zZSBpblxuICAgICAgICAgKiBsb3dlciBwcmlvcml0eSBwcm9wcyBhbmQgZmxhZyBmb3IgYW5pbWF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BbmltYXRpb25UeXBlczsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gcmV2ZXJzZVByaW9yaXR5T3JkZXJbaV07XG4gICAgICAgICAgICBjb25zdCB0eXBlU3RhdGUgPSBzdGF0ZVt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3AgPSBwcm9wc1t0eXBlXSAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBwcm9wc1t0eXBlXVxuICAgICAgICAgICAgICAgIDogY29udGV4dFt0eXBlXTtcbiAgICAgICAgICAgIGNvbnN0IHByb3BJc1ZhcmlhbnQgPSBpc1ZhcmlhbnRMYWJlbChwcm9wKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyB0eXBlIGhhcyAqanVzdCogY2hhbmdlZCBpc0FjdGl2ZSBzdGF0dXMsIHNldCBhY3RpdmVEZWx0YVxuICAgICAgICAgICAgICogdG8gdGhhdCBzdGF0dXMuIE90aGVyd2lzZSBzZXQgdG8gbnVsbC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgYWN0aXZlRGVsdGEgPSB0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSA/IHR5cGVTdGF0ZS5pc0FjdGl2ZSA6IG51bGw7XG4gICAgICAgICAgICBpZiAoYWN0aXZlRGVsdGEgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHJlbW92ZWRWYXJpYW50SW5kZXggPSBpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIHByb3AgaXMgYW4gaW5oZXJpdGVkIHZhcmlhbnQsIHJhdGhlciB0aGFuIGJlZW4gc2V0IGRpcmVjdGx5IG9uIHRoZVxuICAgICAgICAgICAgICogY29tcG9uZW50IGl0c2VsZiwgd2Ugd2FudCB0byBtYWtlIHN1cmUgd2UgYWxsb3cgdGhlIHBhcmVudCB0byB0cmlnZ2VyIGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETzogQ2FuIHByb2JhYmx5IGNoYW5nZSB0aGlzIHRvIGEgIWlzQ29udHJvbGxpbmdWYXJpYW50cyBjaGVja1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsZXQgaXNJbmhlcml0ZWQgPSBwcm9wID09PSBjb250ZXh0W3R5cGVdICYmXG4gICAgICAgICAgICAgICAgcHJvcCAhPT0gcHJvcHNbdHlwZV0gJiZcbiAgICAgICAgICAgICAgICBwcm9wSXNWYXJpYW50O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNJbmhlcml0ZWQgJiZcbiAgICAgICAgICAgICAgICBpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50Lm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQpIHtcbiAgICAgICAgICAgICAgICBpc0luaGVyaXRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgYWxsIGVuY291bnRlcmVkIGtleXMgc28gZmFyIGFzIHRoZSBwcm90ZWN0ZWQga2V5cyBmb3IgdGhpcyB0eXBlLiBUaGlzIHdpbGxcbiAgICAgICAgICAgICAqIGJlIGFueSBrZXkgdGhhdCBoYXMgYmVlbiBhbmltYXRlZCBvciBvdGhlcndpc2UgaGFuZGxlZCBieSBhY3RpdmUsIGhpZ2hlci1wcmlvcnRpeSB0eXBlcy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXMgPSB7IC4uLmVuY291bnRlcmVkS2V5cyB9O1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgd2UgY2FuIHNraXAgYW5hbHlzaW5nIHRoaXMgcHJvcCBlYXJseVxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgLy8gSWYgaXQgaXNuJ3QgYWN0aXZlIGFuZCBoYXNuJ3QgKmp1c3QqIGJlZW4gc2V0IGFzIGluYWN0aXZlXG4gICAgICAgICAgICAoIXR5cGVTdGF0ZS5pc0FjdGl2ZSAmJiBhY3RpdmVEZWx0YSA9PT0gbnVsbCkgfHxcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3QgYW5kIGRvbid0IGhhdmUgYW55IGRlZmluZWQgcHJvcCBmb3IgdGhpcyBhbmltYXRpb24gdHlwZVxuICAgICAgICAgICAgICAgICghcHJvcCAmJiAhdHlwZVN0YXRlLnByZXZQcm9wKSB8fFxuICAgICAgICAgICAgICAgIC8vIE9yIGlmIHRoZSBwcm9wIGRvZXNuJ3QgZGVmaW5lIGFuIGFuaW1hdGlvblxuICAgICAgICAgICAgICAgIGlzQW5pbWF0aW9uQ29udHJvbHMocHJvcCkgfHxcbiAgICAgICAgICAgICAgICB0eXBlb2YgcHJvcCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXMgd2UgZ28gbG9vayB0aHJvdWdoIHRoZSB2YWx1ZXMgZGVmaW5lZCBvbiB0aGlzIHR5cGUsIGlmIHdlIGRldGVjdFxuICAgICAgICAgICAgICogYSBjaGFuZ2VkIHZhbHVlIG9yIGEgdmFsdWUgdGhhdCB3YXMgcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSwgd2Ugc2V0XG4gICAgICAgICAgICAgKiB0aGlzIHRvIHRydWUgYW5kIGFkZCB0aGlzIHByb3AgdG8gdGhlIGFuaW1hdGlvbiBsaXN0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB2YXJpYW50RGlkQ2hhbmdlID0gY2hlY2tWYXJpYW50c0RpZENoYW5nZSh0eXBlU3RhdGUucHJldlByb3AsIHByb3ApO1xuICAgICAgICAgICAgbGV0IHNob3VsZEFuaW1hdGVUeXBlID0gdmFyaWFudERpZENoYW5nZSB8fFxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG1ha2luZyB0aGlzIHZhcmlhbnQgYWN0aXZlLCB3ZSB3YW50IHRvIGFsd2F5cyBtYWtlIGl0IGFjdGl2ZVxuICAgICAgICAgICAgICAgICh0eXBlID09PSBjaGFuZ2VkQWN0aXZlVHlwZSAmJlxuICAgICAgICAgICAgICAgICAgICB0eXBlU3RhdGUuaXNBY3RpdmUgJiZcbiAgICAgICAgICAgICAgICAgICAgIWlzSW5oZXJpdGVkICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3BJc1ZhcmlhbnQpIHx8XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlZCBhIGhpZ2hlci1wcmlvcml0eSB2YXJpYW50IChpIGlzIGluIHJldmVyc2Ugb3JkZXIpXG4gICAgICAgICAgICAgICAgKGkgPiByZW1vdmVkVmFyaWFudEluZGV4ICYmIHByb3BJc1ZhcmlhbnQpO1xuICAgICAgICAgICAgbGV0IGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFzIGFuaW1hdGlvbnMgY2FuIGJlIHNldCBhcyB2YXJpYW50IGxpc3RzLCB2YXJpYW50cyBvciB0YXJnZXQgb2JqZWN0cywgd2VcbiAgICAgICAgICAgICAqIGNvZXJjZSBldmVyeXRoaW5nIHRvIGFuIGFycmF5IGlmIGl0IGlzbid0IG9uZSBhbHJlYWR5XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGRlZmluaXRpb25MaXN0ID0gQXJyYXkuaXNBcnJheShwcm9wKSA/IHByb3AgOiBbcHJvcF07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEJ1aWxkIGFuIG9iamVjdCBvZiBhbGwgdGhlIHJlc29sdmVkIHZhbHVlcy4gV2UnbGwgdXNlIHRoaXMgaW4gdGhlIHN1YnNlcXVlbnRcbiAgICAgICAgICAgICAqIGFuaW1hdGVDaGFuZ2VzIGNhbGxzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgdmFsdWUgaGFzIGNoYW5nZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGxldCByZXNvbHZlZFZhbHVlcyA9IGRlZmluaXRpb25MaXN0LnJlZHVjZShidWlsZFJlc29sdmVkVHlwZVZhbHVlcyh0eXBlKSwge30pO1xuICAgICAgICAgICAgaWYgKGFjdGl2ZURlbHRhID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICByZXNvbHZlZFZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBOb3cgd2UgbmVlZCB0byBsb29wIHRocm91Z2ggYWxsIHRoZSBrZXlzIGluIHRoZSBwcmV2IHByb3AgYW5kIHRoaXMgcHJvcCxcbiAgICAgICAgICAgICAqIGFuZCBkZWNpZGU6XG4gICAgICAgICAgICAgKiAxLiBJZiB0aGUgdmFsdWUgaGFzIGNoYW5nZWQsIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDIuIElmIGl0IGhhcyBiZWVuIHJlbW92ZWQsIGFuZCBuZWVkcyBhZGRpbmcgdG8gdGhlIHJlbW92ZWRLZXlzIHNldFxuICAgICAgICAgICAgICogMy4gSWYgaXQgaGFzIGJlZW4gcmVtb3ZlZCBpbiBhIGhpZ2hlciBwcmlvcml0eSB0eXBlIGFuZCBuZWVkcyBhbmltYXRpbmdcbiAgICAgICAgICAgICAqIDQuIElmIGl0IGhhc24ndCBiZWVuIHJlbW92ZWQgaW4gYSBoaWdoZXIgcHJpb3JpdHkgYnV0IGhhc24ndCBjaGFuZ2VkLCBhbmRcbiAgICAgICAgICAgICAqICAgIG5lZWRzIGFkZGluZyB0byB0aGUgdHlwZSdzIHByb3RlY3RlZEtleXMgbGlzdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgeyBwcmV2UmVzb2x2ZWRWYWx1ZXMgPSB7fSB9ID0gdHlwZVN0YXRlO1xuICAgICAgICAgICAgY29uc3QgYWxsS2V5cyA9IHtcbiAgICAgICAgICAgICAgICAuLi5wcmV2UmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICAgICAgLi4ucmVzb2x2ZWRWYWx1ZXMsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgbWFya1RvQW5pbWF0ZSA9IChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBzaG91bGRBbmltYXRlVHlwZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZWRSZW1vdmVkVmFsdWVzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR5cGVTdGF0ZS5uZWVkc0FuaW1hdGluZ1trZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zdCBtb3Rpb25WYWx1ZSA9IHZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBpZiAobW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIG1vdGlvblZhbHVlLmxpdmVTdHlsZSA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGFsbEtleXMpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0ID0gcmVzb2x2ZWRWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gcHJldlJlc29sdmVkVmFsdWVzW2tleV07XG4gICAgICAgICAgICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoaXMgd2UgY2FuIGp1c3Qgc2tpcCBhaGVhZFxuICAgICAgICAgICAgICAgIGlmIChlbmNvdW50ZXJlZEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLCB3ZSBwcm9iYWJseSB3YW50IHRvIGFuaW1hdGUgaXQuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgbGV0IHZhbHVlSGFzQ2hhbmdlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChpc0tleWZyYW1lc1RhcmdldChuZXh0KSAmJiBpc0tleWZyYW1lc1RhcmdldChwcmV2KSkge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSAhc2hhbGxvd0NvbXBhcmUobmV4dCwgcHJldik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUhhc0NoYW5nZWQgPSBuZXh0ICE9PSBwcmV2O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodmFsdWVIYXNDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0ICE9PSB1bmRlZmluZWQgJiYgbmV4dCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgbmV4dCBpcyBkZWZpbmVkIGFuZCBkb2Vzbid0IGVxdWFsIHByZXYsIGl0IG5lZWRzIGFuaW1hdGluZ1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya1RvQW5pbWF0ZShrZXkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQncyB1bmRlZmluZWQsIGl0J3MgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgcmVtb3ZlZEtleXMuYWRkKGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobmV4dCAhPT0gdW5kZWZpbmVkICYmIHJlbW92ZWRLZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBuZXh0IGhhc24ndCBjaGFuZ2VkIGFuZCBpdCBpc24ndCB1bmRlZmluZWQsIHdlIHdhbnQgdG8gY2hlY2sgaWYgaXQnc1xuICAgICAgICAgICAgICAgICAgICAgKiBiZWVuIHJlbW92ZWQgYnkgYSBoaWdoZXIgcHJpb3JpdHlcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIG1hcmtUb0FuaW1hdGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiBpdCBoYXNuJ3QgY2hhbmdlZCwgd2UgYWRkIGl0IHRvIHRoZSBsaXN0IG9mIHByb3RlY3RlZCB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIGl0IGRvZXNuJ3QgZ2V0IGFuaW1hdGVkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgdHlwZVN0YXRlLnByb3RlY3RlZEtleXNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIHR5cGVTdGF0ZSBzbyBuZXh0IHRpbWUgYW5pbWF0ZUNoYW5nZXMgaXMgY2FsbGVkIHdlIGNhbiBjb21wYXJlIHRoZVxuICAgICAgICAgICAgICogbGF0ZXN0IHByb3AgYW5kIHJlc29sdmVkVmFsdWVzIHRvIHRoZXNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0eXBlU3RhdGUucHJldlByb3AgPSBwcm9wO1xuICAgICAgICAgICAgdHlwZVN0YXRlLnByZXZSZXNvbHZlZFZhbHVlcyA9IHJlc29sdmVkVmFsdWVzO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodHlwZVN0YXRlLmlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgZW5jb3VudGVyZWRLZXlzID0geyAuLi5lbmNvdW50ZXJlZEtleXMsIC4uLnJlc29sdmVkVmFsdWVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVuZGVyICYmIHZpc3VhbEVsZW1lbnQuYmxvY2tJbml0aWFsQW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBpbmhlcml0ZWQgcHJvcCB3ZSB3YW50IHRvIHNraXAgdGhpcyBhbmltYXRpb25cbiAgICAgICAgICAgICAqIHVubGVzcyB0aGUgaW5oZXJpdGVkIHZhcmlhbnRzIGhhdmVuJ3QgY2hhbmdlZCBvbiB0aGlzIHJlbmRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgd2lsbEFuaW1hdGVWaWFQYXJlbnQgPSBpc0luaGVyaXRlZCAmJiB2YXJpYW50RGlkQ2hhbmdlO1xuICAgICAgICAgICAgY29uc3QgbmVlZHNBbmltYXRpbmcgPSAhd2lsbEFuaW1hdGVWaWFQYXJlbnQgfHwgaGFuZGxlZFJlbW92ZWRWYWx1ZXM7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQW5pbWF0ZVR5cGUgJiYgbmVlZHNBbmltYXRpbmcpIHtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25zLnB1c2goLi4uZGVmaW5pdGlvbkxpc3QubWFwKChhbmltYXRpb24pID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbjogYW5pbWF0aW9uLFxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zOiB7IHR5cGUgfSxcbiAgICAgICAgICAgICAgICB9KSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSBhcmUgc29tZSByZW1vdmVkIHZhbHVlIHRoYXQgaGF2ZW4ndCBiZWVuIGRlYWx0IHdpdGgsXG4gICAgICAgICAqIHdlIG5lZWQgdG8gY3JlYXRlIGEgbmV3IGFuaW1hdGlvbiB0aGF0IGZhbGxzIGJhY2sgZWl0aGVyIHRvIHRoZSB2YWx1ZVxuICAgICAgICAgKiBkZWZpbmVkIGluIHRoZSBzdHlsZSBwcm9wLCBvciB0aGUgbGFzdCByZWFkIHZhbHVlLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHJlbW92ZWRLZXlzLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZhbGxiYWNrQW5pbWF0aW9uID0ge307XG4gICAgICAgICAgICByZW1vdmVkS2V5cy5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWxsYmFja1RhcmdldCA9IHZpc3VhbEVsZW1lbnQuZ2V0QmFzZVRhcmdldChrZXkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlID0gdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChtb3Rpb25WYWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgbW90aW9uVmFsdWUubGl2ZVN0eWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIC0gQG1hdHRncGVycnkgdG8gZmlndXJlIGlmIHdlIHNob3VsZCBkbyBzb21ldGhpbmcgaGVyZVxuICAgICAgICAgICAgICAgIGZhbGxiYWNrQW5pbWF0aW9uW2tleV0gPSBmYWxsYmFja1RhcmdldCAhPT0gbnVsbCAmJiBmYWxsYmFja1RhcmdldCAhPT0gdm9pZCAwID8gZmFsbGJhY2tUYXJnZXQgOiBudWxsO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBhbmltYXRpb25zLnB1c2goeyBhbmltYXRpb246IGZhbGxiYWNrQW5pbWF0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzaG91bGRBbmltYXRlID0gQm9vbGVhbihhbmltYXRpb25zLmxlbmd0aCk7XG4gICAgICAgIGlmIChpc0luaXRpYWxSZW5kZXIgJiZcbiAgICAgICAgICAgIChwcm9wcy5pbml0aWFsID09PSBmYWxzZSB8fCBwcm9wcy5pbml0aWFsID09PSBwcm9wcy5hbmltYXRlKSAmJlxuICAgICAgICAgICAgIXZpc3VhbEVsZW1lbnQubWFudWFsbHlBbmltYXRlT25Nb3VudCkge1xuICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gc2hvdWxkQW5pbWF0ZSA/IGFuaW1hdGUoYW5pbWF0aW9ucykgOiBQcm9taXNlLnJlc29sdmUoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hhbmdlIHdoZXRoZXIgYSBjZXJ0YWluIGFuaW1hdGlvbiB0eXBlIGlzIGFjdGl2ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRBY3RpdmUodHlwZSwgaXNBY3RpdmUpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJZiB0aGUgYWN0aXZlIHN0YXRlIGhhc24ndCBjaGFuZ2VkLCB3ZSBjYW4gc2FmZWx5IGRvIG5vdGhpbmcgaGVyZVxuICAgICAgICBpZiAoc3RhdGVbdHlwZV0uaXNBY3RpdmUgPT09IGlzQWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAvLyBQcm9wYWdhdGUgYWN0aXZlIGNoYW5nZSB0byBjaGlsZHJlblxuICAgICAgICAoX2EgPSB2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmZvckVhY2goKGNoaWxkKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IGNoaWxkLmFuaW1hdGlvblN0YXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0QWN0aXZlKHR5cGUsIGlzQWN0aXZlKTsgfSk7XG4gICAgICAgIHN0YXRlW3R5cGVdLmlzQWN0aXZlID0gaXNBY3RpdmU7XG4gICAgICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBhbmltYXRlQ2hhbmdlcyh0eXBlKTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3RhdGUpIHtcbiAgICAgICAgICAgIHN0YXRlW2tleV0ucHJvdGVjdGVkS2V5cyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlQ2hhbmdlcyxcbiAgICAgICAgc2V0QWN0aXZlLFxuICAgICAgICBzZXRBbmltYXRlRnVuY3Rpb24sXG4gICAgICAgIGdldFN0YXRlOiAoKSA9PiBzdGF0ZSxcbiAgICAgICAgcmVzZXQ6ICgpID0+IHtcbiAgICAgICAgICAgIHN0YXRlID0gY3JlYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIGlzSW5pdGlhbFJlbmRlciA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNoZWNrVmFyaWFudHNEaWRDaGFuZ2UocHJldiwgbmV4dCkge1xuICAgIGlmICh0eXBlb2YgbmV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gbmV4dCAhPT0gcHJldjtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShuZXh0KSkge1xuICAgICAgICByZXR1cm4gIXNoYWxsb3dDb21wYXJlKG5leHQsIHByZXYpO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlU3RhdGUoaXNBY3RpdmUgPSBmYWxzZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlzQWN0aXZlLFxuICAgICAgICBwcm90ZWN0ZWRLZXlzOiB7fSxcbiAgICAgICAgbmVlZHNBbmltYXRpbmc6IHt9LFxuICAgICAgICBwcmV2UmVzb2x2ZWRWYWx1ZXM6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdGF0ZSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbmltYXRlOiBjcmVhdGVUeXBlU3RhdGUodHJ1ZSksXG4gICAgICAgIHdoaWxlSW5WaWV3OiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVIb3ZlcjogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIHdoaWxlVGFwOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVEcmFnOiBjcmVhdGVUeXBlU3RhdGUoKSxcbiAgICAgICAgd2hpbGVGb2N1czogY3JlYXRlVHlwZVN0YXRlKCksXG4gICAgICAgIGV4aXQ6IGNyZWF0ZVR5cGVTdGF0ZSgpLFxuICAgIH07XG59XG5cbmNsYXNzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICAgICAgdGhpcy5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICB9XG4gICAgdXBkYXRlKCkgeyB9XG59XG5cbmNsYXNzIEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICAvKipcbiAgICAgKiBXZSBkeW5hbWljYWxseSBnZW5lcmF0ZSB0aGUgQW5pbWF0aW9uU3RhdGUgbWFuYWdlciBhcyBpdCBjb250YWlucyBhIHJlZmVyZW5jZVxuICAgICAqIHRvIHRoZSB1bmRlcmx5aW5nIGFuaW1hdGlvbiBsaWJyYXJ5LiBXZSBvbmx5IHdhbnQgdG8gbG9hZCB0aGF0IGlmIHdlIGxvYWQgdGhpcyxcbiAgICAgKiBzbyBwZW9wbGUgY2FuIG9wdGlvbmFsbHkgY29kZSBzcGxpdCBpdCBvdXQgdXNpbmcgdGhlIGBtYCBjb21wb25lbnQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBzdXBlcihub2RlKTtcbiAgICAgICAgbm9kZS5hbmltYXRpb25TdGF0ZSB8fCAobm9kZS5hbmltYXRpb25TdGF0ZSA9IGNyZWF0ZUFuaW1hdGlvblN0YXRlKG5vZGUpKTtcbiAgICB9XG4gICAgdXBkYXRlQW5pbWF0aW9uQ29udHJvbHNTdWJzY3JpcHRpb24oKSB7XG4gICAgICAgIGNvbnN0IHsgYW5pbWF0ZSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIGlmIChpc0FuaW1hdGlvbkNvbnRyb2xzKGFuaW1hdGUpKSB7XG4gICAgICAgICAgICB0aGlzLnVubW91bnRDb250cm9scyA9IGFuaW1hdGUuc3Vic2NyaWJlKHRoaXMubm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGFueSBwcm92aWRlZCBBbmltYXRpb25Db250cm9scyB0byB0aGUgY29tcG9uZW50J3MgVmlzdWFsRWxlbWVudFxuICAgICAqL1xuICAgIG1vdW50KCkge1xuICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBhbmltYXRlIH0gPSB0aGlzLm5vZGUuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBhbmltYXRlOiBwcmV2QW5pbWF0ZSB9ID0gdGhpcy5ub2RlLnByZXZQcm9wcyB8fCB7fTtcbiAgICAgICAgaWYgKGFuaW1hdGUgIT09IHByZXZBbmltYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUFuaW1hdGlvbkNvbnRyb2xzU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUucmVzZXQoKTtcbiAgICAgICAgKF9hID0gdGhpcy51bm1vdW50Q29udHJvbHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jYWxsKHRoaXMpO1xuICAgIH1cbn1cblxubGV0IGlkJDIgPSAwO1xuY2xhc3MgRXhpdEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkJDIrKztcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5wcmVzZW5jZUNvbnRleHQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSB9ID0gdGhpcy5ub2RlLnByZXNlbmNlQ29udGV4dDtcbiAgICAgICAgY29uc3QgeyBpc1ByZXNlbnQ6IHByZXZJc1ByZXNlbnQgfSA9IHRoaXMubm9kZS5wcmV2UHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAoIXRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSB8fCBpc1ByZXNlbnQgPT09IHByZXZJc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleGl0QW5pbWF0aW9uID0gdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcImV4aXRcIiwgIWlzUHJlc2VudCk7XG4gICAgICAgIGlmIChvbkV4aXRDb21wbGV0ZSAmJiAhaXNQcmVzZW50KSB7XG4gICAgICAgICAgICBleGl0QW5pbWF0aW9uLnRoZW4oKCkgPT4gb25FeGl0Q29tcGxldGUodGhpcy5pZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB0aGlzLm5vZGUucHJlc2VuY2VDb250ZXh0IHx8IHt9O1xuICAgICAgICBpZiAocmVnaXN0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMudW5tb3VudCA9IHJlZ2lzdGVyKHRoaXMuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVubW91bnQoKSB7IH1cbn1cblxuY29uc3QgYW5pbWF0aW9ucyA9IHtcbiAgICBhbmltYXRpb246IHtcbiAgICAgICAgRmVhdHVyZTogQW5pbWF0aW9uRmVhdHVyZSxcbiAgICB9LFxuICAgIGV4aXQ6IHtcbiAgICAgICAgRmVhdHVyZTogRXhpdEFuaW1hdGlvbkZlYXR1cmUsXG4gICAgfSxcbn07XG5cbmNvbnN0IE1vdGlvbkNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuY29uc3QgY3JlYXRlQXhpc0RlbHRhID0gKCkgPT4gKHtcbiAgICB0cmFuc2xhdGU6IDAsXG4gICAgc2NhbGU6IDEsXG4gICAgb3JpZ2luOiAwLFxuICAgIG9yaWdpblBvaW50OiAwLFxufSk7XG5jb25zdCBjcmVhdGVEZWx0YSA9ICgpID0+ICh7XG4gICAgeDogY3JlYXRlQXhpc0RlbHRhKCksXG4gICAgeTogY3JlYXRlQXhpc0RlbHRhKCksXG59KTtcbmNvbnN0IGNyZWF0ZUF4aXMgPSAoKSA9PiAoeyBtaW46IDAsIG1heDogMCB9KTtcbmNvbnN0IGNyZWF0ZUJveCA9ICgpID0+ICh7XG4gICAgeDogY3JlYXRlQXhpcygpLFxuICAgIHk6IGNyZWF0ZUF4aXMoKSxcbn0pO1xuXG5jb25zdCBTQ0FMRV9QUkVDSVNJT04gPSAwLjAwMDE7XG5jb25zdCBTQ0FMRV9NSU4gPSAxIC0gU0NBTEVfUFJFQ0lTSU9OO1xuY29uc3QgU0NBTEVfTUFYID0gMSArIFNDQUxFX1BSRUNJU0lPTjtcbmNvbnN0IFRSQU5TTEFURV9QUkVDSVNJT04gPSAwLjAxO1xuY29uc3QgVFJBTlNMQVRFX01JTiA9IDAgLSBUUkFOU0xBVEVfUFJFQ0lTSU9OO1xuY29uc3QgVFJBTlNMQVRFX01BWCA9IDAgKyBUUkFOU0xBVEVfUFJFQ0lTSU9OO1xuZnVuY3Rpb24gY2FsY0xlbmd0aChheGlzKSB7XG4gICAgcmV0dXJuIGF4aXMubWF4IC0gYXhpcy5taW47XG59XG5mdW5jdGlvbiBpc05lYXIodmFsdWUsIHRhcmdldCwgbWF4RGlzdGFuY2UpIHtcbiAgICByZXR1cm4gTWF0aC5hYnModmFsdWUgLSB0YXJnZXQpIDw9IG1heERpc3RhbmNlO1xufVxuZnVuY3Rpb24gY2FsY0F4aXNEZWx0YShkZWx0YSwgc291cmNlLCB0YXJnZXQsIG9yaWdpbiA9IDAuNSkge1xuICAgIGRlbHRhLm9yaWdpbiA9IG9yaWdpbjtcbiAgICBkZWx0YS5vcmlnaW5Qb2ludCA9IG1peE51bWJlciQxKHNvdXJjZS5taW4sIHNvdXJjZS5tYXgsIGRlbHRhLm9yaWdpbik7XG4gICAgZGVsdGEuc2NhbGUgPSBjYWxjTGVuZ3RoKHRhcmdldCkgLyBjYWxjTGVuZ3RoKHNvdXJjZSk7XG4gICAgZGVsdGEudHJhbnNsYXRlID1cbiAgICAgICAgbWl4TnVtYmVyJDEodGFyZ2V0Lm1pbiwgdGFyZ2V0Lm1heCwgZGVsdGEub3JpZ2luKSAtIGRlbHRhLm9yaWdpblBvaW50O1xuICAgIGlmICgoZGVsdGEuc2NhbGUgPj0gU0NBTEVfTUlOICYmIGRlbHRhLnNjYWxlIDw9IFNDQUxFX01BWCkgfHxcbiAgICAgICAgaXNOYU4oZGVsdGEuc2NhbGUpKSB7XG4gICAgICAgIGRlbHRhLnNjYWxlID0gMS4wO1xuICAgIH1cbiAgICBpZiAoKGRlbHRhLnRyYW5zbGF0ZSA+PSBUUkFOU0xBVEVfTUlOICYmXG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA8PSBUUkFOU0xBVEVfTUFYKSB8fFxuICAgICAgICBpc05hTihkZWx0YS50cmFuc2xhdGUpKSB7XG4gICAgICAgIGRlbHRhLnRyYW5zbGF0ZSA9IDAuMDtcbiAgICB9XG59XG5mdW5jdGlvbiBjYWxjQm94RGVsdGEoZGVsdGEsIHNvdXJjZSwgdGFyZ2V0LCBvcmlnaW4pIHtcbiAgICBjYWxjQXhpc0RlbHRhKGRlbHRhLngsIHNvdXJjZS54LCB0YXJnZXQueCwgb3JpZ2luID8gb3JpZ2luLm9yaWdpblggOiB1bmRlZmluZWQpO1xuICAgIGNhbGNBeGlzRGVsdGEoZGVsdGEueSwgc291cmNlLnksIHRhcmdldC55LCBvcmlnaW4gPyBvcmlnaW4ub3JpZ2luWSA6IHVuZGVmaW5lZCk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVBeGlzKHRhcmdldCwgcmVsYXRpdmUsIHBhcmVudCkge1xuICAgIHRhcmdldC5taW4gPSBwYXJlbnQubWluICsgcmVsYXRpdmUubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChyZWxhdGl2ZSk7XG59XG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVCb3godGFyZ2V0LCByZWxhdGl2ZSwgcGFyZW50KSB7XG4gICAgY2FsY1JlbGF0aXZlQXhpcyh0YXJnZXQueCwgcmVsYXRpdmUueCwgcGFyZW50LngpO1xuICAgIGNhbGNSZWxhdGl2ZUF4aXModGFyZ2V0LnksIHJlbGF0aXZlLnksIHBhcmVudC55KTtcbn1cbmZ1bmN0aW9uIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQsIGxheW91dCwgcGFyZW50KSB7XG4gICAgdGFyZ2V0Lm1pbiA9IGxheW91dC5taW4gLSBwYXJlbnQubWluO1xuICAgIHRhcmdldC5tYXggPSB0YXJnZXQubWluICsgY2FsY0xlbmd0aChsYXlvdXQpO1xufVxuZnVuY3Rpb24gY2FsY1JlbGF0aXZlUG9zaXRpb24odGFyZ2V0LCBsYXlvdXQsIHBhcmVudCkge1xuICAgIGNhbGNSZWxhdGl2ZUF4aXNQb3NpdGlvbih0YXJnZXQueCwgbGF5b3V0LngsIHBhcmVudC54KTtcbiAgICBjYWxjUmVsYXRpdmVBeGlzUG9zaXRpb24odGFyZ2V0LnksIGxheW91dC55LCBwYXJlbnQueSk7XG59XG5cbi8qKlxuICogQSBsaXN0IG9mIGFsbCB2YWxpZCBNb3Rpb25Qcm9wcy5cbiAqXG4gKiBAcHJpdmF0ZVJlbWFya3NcbiAqIFRoaXMgZG9lc24ndCB0aHJvdyBpZiBhIGBNb3Rpb25Qcm9wYCBuYW1lIGlzIG1pc3NpbmcgLSBpdCBzaG91bGQuXG4gKi9cbmNvbnN0IHZhbGlkTW90aW9uUHJvcHMgPSBuZXcgU2V0KFtcbiAgICBcImFuaW1hdGVcIixcbiAgICBcImV4aXRcIixcbiAgICBcInZhcmlhbnRzXCIsXG4gICAgXCJpbml0aWFsXCIsXG4gICAgXCJzdHlsZVwiLFxuICAgIFwidmFsdWVzXCIsXG4gICAgXCJ2YXJpYW50c1wiLFxuICAgIFwidHJhbnNpdGlvblwiLFxuICAgIFwidHJhbnNmb3JtVGVtcGxhdGVcIixcbiAgICBcImN1c3RvbVwiLFxuICAgIFwiaW5oZXJpdFwiLFxuICAgIFwib25CZWZvcmVMYXlvdXRNZWFzdXJlXCIsXG4gICAgXCJvbkFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJvbkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJvblVwZGF0ZVwiLFxuICAgIFwib25EcmFnU3RhcnRcIixcbiAgICBcIm9uRHJhZ1wiLFxuICAgIFwib25EcmFnRW5kXCIsXG4gICAgXCJvbk1lYXN1cmVEcmFnQ29uc3RyYWludHNcIixcbiAgICBcIm9uRGlyZWN0aW9uTG9ja1wiLFxuICAgIFwib25EcmFnVHJhbnNpdGlvbkVuZFwiLFxuICAgIFwiX2RyYWdYXCIsXG4gICAgXCJfZHJhZ1lcIixcbiAgICBcIm9uSG92ZXJTdGFydFwiLFxuICAgIFwib25Ib3ZlckVuZFwiLFxuICAgIFwib25WaWV3cG9ydEVudGVyXCIsXG4gICAgXCJvblZpZXdwb3J0TGVhdmVcIixcbiAgICBcImdsb2JhbFRhcFRhcmdldFwiLFxuICAgIFwiaWdub3JlU3RyaWN0XCIsXG4gICAgXCJ2aWV3cG9ydFwiLFxuXSk7XG4vKipcbiAqIENoZWNrIHdoZXRoZXIgYSBwcm9wIG5hbWUgaXMgYSB2YWxpZCBgTW90aW9uUHJvcGAga2V5LlxuICpcbiAqIEBwYXJhbSBrZXkgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBjaGVja1xuICogQHJldHVybnMgYHRydWVgIGlzIGtleSBpcyBhIHZhbGlkIGBNb3Rpb25Qcm9wYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRNb3Rpb25Qcm9wKGtleSkge1xuICAgIHJldHVybiAoa2V5LnN0YXJ0c1dpdGgoXCJ3aGlsZVwiKSB8fFxuICAgICAgICAoa2V5LnN0YXJ0c1dpdGgoXCJkcmFnXCIpICYmIGtleSAhPT0gXCJkcmFnZ2FibGVcIikgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJsYXlvdXRcIikgfHxcbiAgICAgICAga2V5LnN0YXJ0c1dpdGgoXCJvblRhcFwiKSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9uUGFuXCIpIHx8XG4gICAgICAgIGtleS5zdGFydHNXaXRoKFwib25MYXlvdXRcIikgfHxcbiAgICAgICAgdmFsaWRNb3Rpb25Qcm9wcy5oYXMoa2V5KSk7XG59XG5cbmxldCBzaG91bGRGb3J3YXJkID0gKGtleSkgPT4gIWlzVmFsaWRNb3Rpb25Qcm9wKGtleSk7XG5mdW5jdGlvbiBsb2FkRXh0ZXJuYWxJc1ZhbGlkUHJvcChpc1ZhbGlkUHJvcCkge1xuICAgIGlmICghaXNWYWxpZFByb3ApXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBFeHBsaWNpdGx5IGZpbHRlciBvdXIgZXZlbnRzXG4gICAgc2hvdWxkRm9yd2FyZCA9IChrZXkpID0+IGtleS5zdGFydHNXaXRoKFwib25cIikgPyAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSA6IGlzVmFsaWRQcm9wKGtleSk7XG59XG4vKipcbiAqIEVtb3Rpb24gYW5kIFN0eWxlZCBDb21wb25lbnRzIGJvdGggYWxsb3cgdXNlcnMgdG8gcGFzcyB0aHJvdWdoIGFyYml0cmFyeSBwcm9wcyB0byB0aGVpciBjb21wb25lbnRzXG4gKiB0byBkeW5hbWljYWxseSBnZW5lcmF0ZSBDU1MuIFRoZXkgYm90aCB1c2UgdGhlIGBAZW1vdGlvbi9pcy1wcm9wLXZhbGlkYCBwYWNrYWdlIHRvIGRldGVybWluZSB3aGljaFxuICogb2YgdGhlc2Ugc2hvdWxkIGJlIHBhc3NlZCB0byB0aGUgdW5kZXJseWluZyBET00gbm9kZS5cbiAqXG4gKiBIb3dldmVyLCB3aGVuIHN0eWxpbmcgYSBNb3Rpb24gY29tcG9uZW50IGBzdHlsZWQobW90aW9uLmRpdilgLCBib3RoIHBhY2thZ2VzIHBhc3MgdGhyb3VnaCAqYWxsKiBwcm9wc1xuICogYXMgaXQncyBzZWVuIGFzIGFuIGFyYml0cmFyeSBjb21wb25lbnQgcmF0aGVyIHRoYW4gYSBET00gbm9kZS4gTW90aW9uIG9ubHkgYWxsb3dzIGFyYml0cmFyeSBwcm9wc1xuICogcGFzc2VkIHRocm91Z2ggdGhlIGBjdXN0b21gIHByb3Agc28gaXQgZG9lc24ndCAqbmVlZCogdGhlIHBheWxvYWQgb3IgY29tcHV0YXRpb25hbCBvdmVyaGVhZCBvZlxuICogYEBlbW90aW9uL2lzLXByb3AtdmFsaWRgLCBob3dldmVyIHRvIGZpeCB0aGlzIHByb2JsZW0gd2UgbmVlZCB0byB1c2UgaXQuXG4gKlxuICogQnkgbWFraW5nIGl0IGFuIG9wdGlvbmFsRGVwZW5kZW5jeSB3ZSBjYW4gb2ZmZXIgdGhpcyBmdW5jdGlvbmFsaXR5IG9ubHkgaW4gdGhlIHNpdHVhdGlvbnMgd2hlcmUgaXQnc1xuICogYWN0dWFsbHkgcmVxdWlyZWQuXG4gKi9cbnRyeSB7XG4gICAgLyoqXG4gICAgICogV2UgYXR0ZW1wdCB0byBpbXBvcnQgdGhpcyBwYWNrYWdlIGJ1dCByZXF1aXJlIHdvbid0IGJlIGRlZmluZWQgaW4gZXNtIGVudmlyb25tZW50cywgaW4gdGhhdCBjYXNlXG4gICAgICogaXNQcm9wVmFsaWQgd2lsbCBoYXZlIHRvIGJlIHByb3ZpZGVkIHZpYSBgTW90aW9uQ29udGV4dGAuIEluIGEgNi4wLjAgdGhpcyBzaG91bGQgcHJvYmFibHkgYmUgcmVtb3ZlZFxuICAgICAqIGluIGZhdm91ciBvZiBleHBsaWNpdCBpbmplY3Rpb24uXG4gICAgICovXG4gICAgbG9hZEV4dGVybmFsSXNWYWxpZFByb3AocmVxdWlyZShcIkBlbW90aW9uL2lzLXByb3AtdmFsaWRcIikuZGVmYXVsdCk7XG59XG5jYXRjaCAoX2EpIHtcbiAgICAvLyBXZSBkb24ndCBuZWVkIHRvIGFjdHVhbGx5IGRvIGFueXRoaW5nIGhlcmUgLSB0aGUgZmFsbGJhY2sgaXMgdGhlIGV4aXN0aW5nIGBpc1Byb3BWYWxpZGAuXG59XG5mdW5jdGlvbiBmaWx0ZXJQcm9wcyhwcm9wcywgaXNEb20sIGZvcndhcmRNb3Rpb25Qcm9wcykge1xuICAgIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICAvKipcbiAgICAgICAgICogdmFsdWVzIGlzIGNvbnNpZGVyZWQgYSB2YWxpZCBwcm9wIGJ5IEVtb3Rpb24sIHNvIGlmIGl0J3MgcHJlc2VudFxuICAgICAgICAgKiB0aGlzIHdpbGwgYmUgcmVuZGVyZWQgb3V0IHRvIHRoZSBET00gdW5sZXNzIGV4cGxpY2l0bHkgZmlsdGVyZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIFdlIGNoZWNrIHRoZSB0eXBlIGFzIGl0IGNvdWxkIGJlIHVzZWQgd2l0aCB0aGUgYGZlQ29sb3JNYXRyaXhgXG4gICAgICAgICAqIGVsZW1lbnQsIHdoaWNoIHdlIHN1cHBvcnQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoa2V5ID09PSBcInZhbHVlc1wiICYmIHR5cGVvZiBwcm9wcy52YWx1ZXMgPT09IFwib2JqZWN0XCIpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgaWYgKHNob3VsZEZvcndhcmQoa2V5KSB8fFxuICAgICAgICAgICAgKGZvcndhcmRNb3Rpb25Qcm9wcyA9PT0gdHJ1ZSAmJiBpc1ZhbGlkTW90aW9uUHJvcChrZXkpKSB8fFxuICAgICAgICAgICAgKCFpc0RvbSAmJiAhaXNWYWxpZE1vdGlvblByb3Aoa2V5KSkgfHxcbiAgICAgICAgICAgIC8vIElmIHRyeWluZyB0byB1c2UgbmF0aXZlIEhUTUwgZHJhZyBldmVudHMsIGZvcndhcmQgZHJhZyBsaXN0ZW5lcnNcbiAgICAgICAgICAgIChwcm9wc1tcImRyYWdnYWJsZVwiXSAmJlxuICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKFwib25EcmFnXCIpKSkge1xuICAgICAgICAgICAgZmlsdGVyZWRQcm9wc1trZXldID1cbiAgICAgICAgICAgICAgICBwcm9wc1trZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWx0ZXJlZFByb3BzO1xufVxuXG4vKipcbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgUHJlc2VuY2VDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcblxuZnVuY3Rpb24gaXNDb250cm9sbGluZ1ZhcmlhbnRzKHByb3BzKSB7XG4gICAgcmV0dXJuIChpc0FuaW1hdGlvbkNvbnRyb2xzKHByb3BzLmFuaW1hdGUpIHx8XG4gICAgICAgIHZhcmlhbnRQcm9wcy5zb21lKChuYW1lKSA9PiBpc1ZhcmlhbnRMYWJlbChwcm9wc1tuYW1lXSkpKTtcbn1cbmZ1bmN0aW9uIGlzVmFyaWFudE5vZGUocHJvcHMpIHtcbiAgICByZXR1cm4gQm9vbGVhbihpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpIHx8IHByb3BzLnZhcmlhbnRzKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgY29uc3RhbnQgdmFsdWUgb3ZlciB0aGUgbGlmZWN5Y2xlIG9mIGEgY29tcG9uZW50LlxuICpcbiAqIEV2ZW4gaWYgYHVzZU1lbW9gIGlzIHByb3ZpZGVkIGFuIGVtcHR5IGFycmF5IGFzIGl0cyBmaW5hbCBhcmd1bWVudCwgaXQgZG9lc24ndCBvZmZlclxuICogYSBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCByZS1ydW4gZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgbGF0ZXIgb24uIEJ5IHVzaW5nIGB1c2VDb25zdGFudGBcbiAqIHlvdSBjYW4gZW5zdXJlIHRoYXQgaW5pdGlhbGlzZXJzIGRvbid0IGV4ZWN1dGUgdHdpY2Ugb3IgbW9yZS5cbiAqL1xuZnVuY3Rpb24gdXNlQ29uc3RhbnQoaW5pdCkge1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBpZiAocmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBpbml0KCk7XG4gICAgfVxuICAgIHJldHVybiByZWYuY3VycmVudDtcbn1cblxuLyoqXG4gKiBJZiB0aGUgcHJvdmlkZWQgdmFsdWUgaXMgYSBNb3Rpb25WYWx1ZSwgdGhpcyByZXR1cm5zIHRoZSBhY3R1YWwgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHRoZSB2YWx1ZSBpdHNlbGZcbiAqXG4gKiBUT0RPOiBSZW1vdmUgYW5kIG1vdmUgdG8gbGlicmFyeVxuICovXG5mdW5jdGlvbiByZXNvbHZlTW90aW9uVmFsdWUodmFsdWUpIHtcbiAgICBjb25zdCB1bndyYXBwZWRWYWx1ZSA9IGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICByZXR1cm4gaXNDdXN0b21WYWx1ZSh1bndyYXBwZWRWYWx1ZSlcbiAgICAgICAgPyB1bndyYXBwZWRWYWx1ZS50b1ZhbHVlKClcbiAgICAgICAgOiB1bndyYXBwZWRWYWx1ZTtcbn1cblxuZnVuY3Rpb24gbWFrZVN0YXRlKHsgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLCBjcmVhdGVSZW5kZXJTdGF0ZSwgb25VcGRhdGUsIH0sIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHtcbiAgICAgICAgbGF0ZXN0VmFsdWVzOiBtYWtlTGF0ZXN0VmFsdWVzKHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQsIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyksXG4gICAgICAgIHJlbmRlclN0YXRlOiBjcmVhdGVSZW5kZXJTdGF0ZSgpLFxuICAgIH07XG4gICAgaWYgKG9uVXBkYXRlKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBvbk1vdW50IHdvcmtzIHdpdGhvdXQgdGhlIFZpc3VhbEVsZW1lbnQgYmVjYXVzZSBpdCBjb3VsZCBiZVxuICAgICAgICAgKiBjYWxsZWQgYmVmb3JlIHRoZSBWaXN1YWxFbGVtZW50IHBheWxvYWQgaGFzIGJlZW4gaHlkcmF0ZWQuXG4gICAgICAgICAqIChlLmcuIGlmIHNvbWVvbmUgaXMgdXNpbmcgbSBjb21wb25lbnRzIDxtLmNpcmNsZSAvPilcbiAgICAgICAgICovXG4gICAgICAgIHN0YXRlLm9uTW91bnQgPSAoaW5zdGFuY2UpID0+IG9uVXBkYXRlKHsgcHJvcHMsIGN1cnJlbnQ6IGluc3RhbmNlLCAuLi5zdGF0ZSB9KTtcbiAgICAgICAgc3RhdGUub25VcGRhdGUgPSAodmlzdWFsRWxlbWVudCkgPT4gb25VcGRhdGUodmlzdWFsRWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiBzdGF0ZTtcbn1cbmNvbnN0IG1ha2VVc2VWaXN1YWxTdGF0ZSA9IChjb25maWcpID0+IChwcm9wcywgaXNTdGF0aWMpID0+IHtcbiAgICBjb25zdCBjb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICBjb25zdCBwcmVzZW5jZUNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgY29uc3QgbWFrZSA9ICgpID0+IG1ha2VTdGF0ZShjb25maWcsIHByb3BzLCBjb250ZXh0LCBwcmVzZW5jZUNvbnRleHQpO1xuICAgIHJldHVybiBpc1N0YXRpYyA/IG1ha2UoKSA6IHVzZUNvbnN0YW50KG1ha2UpO1xufTtcbmZ1bmN0aW9uIG1ha2VMYXRlc3RWYWx1ZXMocHJvcHMsIGNvbnRleHQsIHByZXNlbmNlQ29udGV4dCwgc2NyYXBlTW90aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgdmFsdWVzID0ge307XG4gICAgY29uc3QgbW90aW9uVmFsdWVzID0gc2NyYXBlTW90aW9uVmFsdWVzKHByb3BzLCB7fSk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbW90aW9uVmFsdWVzKSB7XG4gICAgICAgIHZhbHVlc1trZXldID0gcmVzb2x2ZU1vdGlvblZhbHVlKG1vdGlvblZhbHVlc1trZXldKTtcbiAgICB9XG4gICAgbGV0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gcHJvcHM7XG4gICAgY29uc3QgaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgPSBpc0NvbnRyb2xsaW5nVmFyaWFudHMocHJvcHMpO1xuICAgIGNvbnN0IGlzVmFyaWFudE5vZGUkMSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgIGlmIChjb250ZXh0ICYmXG4gICAgICAgIGlzVmFyaWFudE5vZGUkMSAmJlxuICAgICAgICAhaXNDb250cm9sbGluZ1ZhcmlhbnRzJDEgJiZcbiAgICAgICAgcHJvcHMuaW5oZXJpdCAhPT0gZmFsc2UpIHtcbiAgICAgICAgaWYgKGluaXRpYWwgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluaXRpYWwgPSBjb250ZXh0LmluaXRpYWw7XG4gICAgICAgIGlmIChhbmltYXRlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBhbmltYXRlID0gY29udGV4dC5hbmltYXRlO1xuICAgIH1cbiAgICBsZXQgaXNJbml0aWFsQW5pbWF0aW9uQmxvY2tlZCA9IHByZXNlbmNlQ29udGV4dFxuICAgICAgICA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZVxuICAgICAgICA6IGZhbHNlO1xuICAgIGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkIHx8IGluaXRpYWwgPT09IGZhbHNlO1xuICAgIGNvbnN0IHZhcmlhbnRUb1NldCA9IGlzSW5pdGlhbEFuaW1hdGlvbkJsb2NrZWQgPyBhbmltYXRlIDogaW5pdGlhbDtcbiAgICBpZiAodmFyaWFudFRvU2V0ICYmXG4gICAgICAgIHR5cGVvZiB2YXJpYW50VG9TZXQgIT09IFwiYm9vbGVhblwiICYmXG4gICAgICAgICFpc0FuaW1hdGlvbkNvbnRyb2xzKHZhcmlhbnRUb1NldCkpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IEFycmF5LmlzQXJyYXkodmFyaWFudFRvU2V0KSA/IHZhcmlhbnRUb1NldCA6IFt2YXJpYW50VG9TZXRdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc29sdmVkID0gcmVzb2x2ZVZhcmlhbnRGcm9tUHJvcHMocHJvcHMsIGxpc3RbaV0pO1xuICAgICAgICAgICAgaWYgKHJlc29sdmVkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeyB0cmFuc2l0aW9uRW5kLCB0cmFuc2l0aW9uLCAuLi50YXJnZXQgfSA9IHJlc29sdmVkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRhcmdldCkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgdmFsdWVUYXJnZXQgPSB0YXJnZXRba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIFRha2UgZmluYWwga2V5ZnJhbWUgaWYgdGhlIGluaXRpYWwgYW5pbWF0aW9uIGlzIGJsb2NrZWQgYmVjYXVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogd2Ugd2FudCB0byBpbml0aWFsaXNlIGF0IHRoZSBlbmQgb2YgdGhhdCBibG9ja2VkIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBpc0luaXRpYWxBbmltYXRpb25CbG9ja2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZVRhcmdldC5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWVUYXJnZXQgPSB2YWx1ZVRhcmdldFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlVGFyZ2V0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZXNba2V5XSA9IHZhbHVlVGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYW5zaXRpb25FbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzW2tleV0gPSB0cmFuc2l0aW9uRW5kW2tleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG59XG5cbmZ1bmN0aW9uIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zID0geyBwYXNzaXZlOiB0cnVlIH0pIHtcbiAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGhhbmRsZXIpO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0RXZlbnRJbmZvKGV2ZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9pbnQ6IHtcbiAgICAgICAgICAgIHg6IGV2ZW50LnBhZ2VYLFxuICAgICAgICAgICAgeTogZXZlbnQucGFnZVksXG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmNvbnN0IGFkZFBvaW50ZXJJbmZvID0gKGhhbmRsZXIpID0+IHtcbiAgICByZXR1cm4gKGV2ZW50KSA9PiBtb3Rpb25Eb20uaXNQcmltYXJ5UG9pbnRlcihldmVudCkgJiYgaGFuZGxlcihldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpO1xufTtcblxuZnVuY3Rpb24gYWRkUG9pbnRlckV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIGFkZERvbUV2ZW50KHRhcmdldCwgZXZlbnROYW1lLCBhZGRQb2ludGVySW5mbyhoYW5kbGVyKSwgb3B0aW9ucyk7XG59XG5cbmNvbnN0IGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG5cbmZ1bmN0aW9uIHVzZVVubW91bnRFZmZlY3QoY2FsbGJhY2spIHtcbiAgICByZXR1cm4gUmVhY3QudXNlRWZmZWN0KCgpID0+ICgpID0+IGNhbGxiYWNrKCksIFtdKTtcbn1cblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IGlzQnJvd3NlciA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcblxuZnVuY3Rpb24gdXNlSXNNb3VudGVkKCkge1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gZmFsc2U7XG4gICAgICAgIH07XG4gICAgfSwgW10pO1xuICAgIHJldHVybiBpc01vdW50ZWQ7XG59XG5cbmZ1bmN0aW9uIHVzZUZvcmNlVXBkYXRlKCkge1xuICAgIGNvbnN0IGlzTW91bnRlZCA9IHVzZUlzTW91bnRlZCgpO1xuICAgIGNvbnN0IFtmb3JjZWRSZW5kZXJDb3VudCwgc2V0Rm9yY2VkUmVuZGVyQ291bnRdID0gUmVhY3QudXNlU3RhdGUoMCk7XG4gICAgY29uc3QgZm9yY2VSZW5kZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ICYmIHNldEZvcmNlZFJlbmRlckNvdW50KGZvcmNlZFJlbmRlckNvdW50ICsgMSk7XG4gICAgfSwgW2ZvcmNlZFJlbmRlckNvdW50XSk7XG4gICAgLyoqXG4gICAgICogRGVmZXIgdGhpcyB0byB0aGUgZW5kIG9mIHRoZSBuZXh0IGFuaW1hdGlvbiBmcmFtZSBpbiBjYXNlIHRoZXJlIGFyZSBtdWx0aXBsZVxuICAgICAqIHN5bmNocm9ub3VzIGNhbGxzLlxuICAgICAqL1xuICAgIGNvbnN0IGRlZmVycmVkRm9yY2VSZW5kZXIgPSBSZWFjdC51c2VDYWxsYmFjaygoKSA9PiBmcmFtZS5wb3N0UmVuZGVyKGZvcmNlUmVuZGVyKSwgW2ZvcmNlUmVuZGVyXSk7XG4gICAgcmV0dXJuIFtkZWZlcnJlZEZvcmNlUmVuZGVyLCBmb3JjZWRSZW5kZXJDb3VudF07XG59XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBNb3Rpb25Db25maWdDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dCh7XG4gICAgdHJhbnNmb3JtUGFnZVBvaW50OiAocCkgPT4gcCxcbiAgICBpc1N0YXRpYzogZmFsc2UsXG4gICAgcmVkdWNlZE1vdGlvbjogXCJuZXZlclwiLFxufSk7XG5cbi8qKlxuICogTWVhc3VyZW1lbnQgZnVuY3Rpb25hbGl0eSBoYXMgdG8gYmUgd2l0aGluIGEgc2VwYXJhdGUgY29tcG9uZW50XG4gKiB0byBsZXZlcmFnZSBzbmFwc2hvdCBsaWZlY3ljbGUuXG4gKi9cbmNsYXNzIFBvcENoaWxkTWVhc3VyZSBleHRlbmRzIFJlYWN0X19uYW1lc3BhY2UuQ29tcG9uZW50IHtcbiAgICBnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZShwcmV2UHJvcHMpIHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMucHJvcHMuY2hpbGRSZWYuY3VycmVudDtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgcHJldlByb3BzLmlzUHJlc2VudCAmJiAhdGhpcy5wcm9wcy5pc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpemUgPSB0aGlzLnByb3BzLnNpemVSZWYuY3VycmVudDtcbiAgICAgICAgICAgIHNpemUuaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMDtcbiAgICAgICAgICAgIHNpemUud2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDA7XG4gICAgICAgICAgICBzaXplLnRvcCA9IGVsZW1lbnQub2Zmc2V0VG9wO1xuICAgICAgICAgICAgc2l6ZS5sZWZ0ID0gZWxlbWVudC5vZmZzZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXF1aXJlZCB3aXRoIGdldFNuYXBzaG90QmVmb3JlVXBkYXRlIHRvIHN0b3AgUmVhY3QgY29tcGxhaW5pbmcuXG4gICAgICovXG4gICAgY29tcG9uZW50RGlkVXBkYXRlKCkgeyB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5jaGlsZHJlbjtcbiAgICB9XG59XG5mdW5jdGlvbiBQb3BDaGlsZCh7IGNoaWxkcmVuLCBpc1ByZXNlbnQgfSkge1xuICAgIGNvbnN0IGlkID0gUmVhY3QudXNlSWQoKTtcbiAgICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3Qgc2l6ZSA9IFJlYWN0LnVzZVJlZih7XG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICB9KTtcbiAgICBjb25zdCB7IG5vbmNlIH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIC8qKlxuICAgICAqIFdlIGNyZWF0ZSBhbmQgaW5qZWN0IGEgc3R5bGUgYmxvY2sgc28gd2UgY2FuIGFwcGx5IHRoaXMgZXhwbGljaXRcbiAgICAgKiBzaXppbmcgaW4gYSBub24tZGVzdHJ1Y3RpdmUgbWFubmVyIGJ5IGp1c3QgZGVsZXRpbmcgdGhlIHN0eWxlIGJsb2NrLlxuICAgICAqXG4gICAgICogV2UgY2FuJ3QgYXBwbHkgc2l6ZSB2aWEgcmVuZGVyIGFzIHRoZSBtZWFzdXJlbWVudCBoYXBwZW5zXG4gICAgICogaW4gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUgKHBvc3QtcmVuZGVyKSwgbGlrZXdpc2UgaWYgd2UgYXBwbHkgdGhlXG4gICAgICogc3R5bGVzIGRpcmVjdGx5IG9uIHRoZSBET00gbm9kZSwgd2UgbWlnaHQgYmUgb3ZlcndyaXRpbmdcbiAgICAgKiBzdHlsZXMgc2V0IHZpYSB0aGUgc3R5bGUgcHJvcC5cbiAgICAgKi9cbiAgICBSZWFjdC51c2VJbnNlcnRpb25FZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb25zdCB7IHdpZHRoLCBoZWlnaHQsIHRvcCwgbGVmdCB9ID0gc2l6ZS5jdXJyZW50O1xuICAgICAgICBpZiAoaXNQcmVzZW50IHx8ICFyZWYuY3VycmVudCB8fCAhd2lkdGggfHwgIWhlaWdodClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmVmLmN1cnJlbnQuZGF0YXNldC5tb3Rpb25Qb3BJZCA9IGlkO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICAgICAgaWYgKG5vbmNlKVxuICAgICAgICAgICAgc3R5bGUubm9uY2UgPSBub25jZTtcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZSk7XG4gICAgICAgIGlmIChzdHlsZS5zaGVldCkge1xuICAgICAgICAgICAgc3R5bGUuc2hlZXQuaW5zZXJ0UnVsZShgXG4gICAgICAgICAgW2RhdGEtbW90aW9uLXBvcC1pZD1cIiR7aWR9XCJdIHtcbiAgICAgICAgICAgIHBvc2l0aW9uOiBhYnNvbHV0ZSAhaW1wb3J0YW50O1xuICAgICAgICAgICAgd2lkdGg6ICR7d2lkdGh9cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIGhlaWdodDogJHtoZWlnaHR9cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIHRvcDogJHt0b3B9cHggIWltcG9ydGFudDtcbiAgICAgICAgICAgIGxlZnQ6ICR7bGVmdH1weCAhaW1wb3J0YW50O1xuICAgICAgICAgIH1cbiAgICAgICAgYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KFBvcENoaWxkTWVhc3VyZSwgeyBpc1ByZXNlbnQ6IGlzUHJlc2VudCwgY2hpbGRSZWY6IHJlZiwgc2l6ZVJlZjogc2l6ZSwgY2hpbGRyZW46IFJlYWN0X19uYW1lc3BhY2UuY2xvbmVFbGVtZW50KGNoaWxkcmVuLCB7IHJlZiB9KSB9KSk7XG59XG5cbmNvbnN0IFByZXNlbmNlQ2hpbGQgPSAoeyBjaGlsZHJlbiwgaW5pdGlhbCwgaXNQcmVzZW50LCBvbkV4aXRDb21wbGV0ZSwgY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQsIG1vZGUsIH0pID0+IHtcbiAgICBjb25zdCBwcmVzZW5jZUNoaWxkcmVuID0gdXNlQ29uc3RhbnQobmV3Q2hpbGRyZW5NYXApO1xuICAgIGNvbnN0IGlkID0gUmVhY3QudXNlSWQoKTtcbiAgICBjb25zdCBtZW1vaXplZE9uRXhpdENvbXBsZXRlID0gUmVhY3QudXNlQ2FsbGJhY2soKGNoaWxkSWQpID0+IHtcbiAgICAgICAgcHJlc2VuY2VDaGlsZHJlbi5zZXQoY2hpbGRJZCwgdHJ1ZSk7XG4gICAgICAgIGZvciAoY29uc3QgaXNDb21wbGV0ZSBvZiBwcmVzZW5jZUNoaWxkcmVuLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBpZiAoIWlzQ29tcGxldGUpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBjYW4gc3RvcCBzZWFyY2hpbmcgd2hlbiBhbnkgaXMgaW5jb21wbGV0ZVxuICAgICAgICB9XG4gICAgICAgIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgfSwgW3ByZXNlbmNlQ2hpbGRyZW4sIG9uRXhpdENvbXBsZXRlXSk7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgaWQsXG4gICAgICAgIGluaXRpYWwsXG4gICAgICAgIGlzUHJlc2VudCxcbiAgICAgICAgY3VzdG9tLFxuICAgICAgICBvbkV4aXRDb21wbGV0ZTogbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZSxcbiAgICAgICAgcmVnaXN0ZXI6IChjaGlsZElkKSA9PiB7XG4gICAgICAgICAgICBwcmVzZW5jZUNoaWxkcmVuLnNldChjaGlsZElkLCBmYWxzZSk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gcHJlc2VuY2VDaGlsZHJlbi5kZWxldGUoY2hpbGRJZCk7XG4gICAgICAgIH0sXG4gICAgfSksIFxuICAgIC8qKlxuICAgICAqIElmIHRoZSBwcmVzZW5jZSBvZiBhIGNoaWxkIGFmZmVjdHMgdGhlIGxheW91dCBvZiB0aGUgY29tcG9uZW50cyBhcm91bmQgaXQsXG4gICAgICogd2Ugd2FudCB0byBtYWtlIGEgbmV3IGNvbnRleHQgdmFsdWUgdG8gZW5zdXJlIHRoZXkgZ2V0IHJlLXJlbmRlcmVkXG4gICAgICogc28gdGhleSBjYW4gZGV0ZWN0IHRoYXQgbGF5b3V0IGNoYW5nZS5cbiAgICAgKi9cbiAgICBwcmVzZW5jZUFmZmVjdHNMYXlvdXRcbiAgICAgICAgPyBbTWF0aC5yYW5kb20oKSwgbWVtb2l6ZWRPbkV4aXRDb21wbGV0ZV1cbiAgICAgICAgOiBbaXNQcmVzZW50LCBtZW1vaXplZE9uRXhpdENvbXBsZXRlXSk7XG4gICAgUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIHByZXNlbmNlQ2hpbGRyZW4uZm9yRWFjaCgoXywga2V5KSA9PiBwcmVzZW5jZUNoaWxkcmVuLnNldChrZXksIGZhbHNlKSk7XG4gICAgfSwgW2lzUHJlc2VudF0pO1xuICAgIC8qKlxuICAgICAqIElmIHRoZXJlJ3Mgbm8gYG1vdGlvbmAgY29tcG9uZW50cyB0byBmaXJlIGV4aXQgYW5pbWF0aW9ucywgd2Ugd2FudCB0byByZW1vdmUgdGhpc1xuICAgICAqIGNvbXBvbmVudCBpbW1lZGlhdGVseS5cbiAgICAgKi9cbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgICFpc1ByZXNlbnQgJiZcbiAgICAgICAgICAgICFwcmVzZW5jZUNoaWxkcmVuLnNpemUgJiZcbiAgICAgICAgICAgIG9uRXhpdENvbXBsZXRlICYmXG4gICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSgpO1xuICAgIH0sIFtpc1ByZXNlbnRdKTtcbiAgICBpZiAobW9kZSA9PT0gXCJwb3BMYXlvdXRcIikge1xuICAgICAgICBjaGlsZHJlbiA9IGpzeFJ1bnRpbWUuanN4KFBvcENoaWxkLCB7IGlzUHJlc2VudDogaXNQcmVzZW50LCBjaGlsZHJlbjogY2hpbGRyZW4gfSk7XG4gICAgfVxuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goUHJlc2VuY2VDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcbmZ1bmN0aW9uIG5ld0NoaWxkcmVuTWFwKCkge1xuICAgIHJldHVybiBuZXcgTWFwKCk7XG59XG5cbi8qKlxuICogV2hlbiBhIGNvbXBvbmVudCBpcyB0aGUgY2hpbGQgb2YgYEFuaW1hdGVQcmVzZW5jZWAsIGl0IGNhbiB1c2UgYHVzZVByZXNlbmNlYFxuICogdG8gYWNjZXNzIGluZm9ybWF0aW9uIGFib3V0IHdoZXRoZXIgaXQncyBzdGlsbCBwcmVzZW50IGluIHRoZSBSZWFjdCB0cmVlLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlUHJlc2VuY2UgfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZXhwb3J0IGNvbnN0IENvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKClcbiAqXG4gKiAgIHVzZUVmZmVjdCgoKSA9PiB7XG4gKiAgICAgIWlzUHJlc2VudCAmJiBzZXRUaW1lb3V0KHNhZmVUb1JlbW92ZSwgMTAwMClcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogSWYgYGlzUHJlc2VudGAgaXMgYGZhbHNlYCwgaXQgbWVhbnMgdGhhdCBhIGNvbXBvbmVudCBoYXMgYmVlbiByZW1vdmVkIHRoZSB0cmVlLCBidXRcbiAqIGBBbmltYXRlUHJlc2VuY2VgIHdvbid0IHJlYWxseSByZW1vdmUgaXQgdW50aWwgYHNhZmVUb1JlbW92ZWAgaGFzIGJlZW4gY2FsbGVkLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlUHJlc2VuY2Uoc3Vic2NyaWJlID0gdHJ1ZSkge1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCk7XG4gICAgaWYgKGNvbnRleHQgPT09IG51bGwpXG4gICAgICAgIHJldHVybiBbdHJ1ZSwgbnVsbF07XG4gICAgY29uc3QgeyBpc1ByZXNlbnQsIG9uRXhpdENvbXBsZXRlLCByZWdpc3RlciB9ID0gY29udGV4dDtcbiAgICAvLyBJdCdzIHNhZmUgdG8gY2FsbCB0aGUgZm9sbG93aW5nIGhvb2tzIGNvbmRpdGlvbmFsbHkgKGFmdGVyIGFuIGVhcmx5IHJldHVybikgYmVjYXVzZSB0aGUgY29udGV4dCB3aWxsIGFsd2F5c1xuICAgIC8vIGVpdGhlciBiZSBudWxsIG9yIG5vbi1udWxsIGZvciB0aGUgbGlmZXNwYW4gb2YgdGhlIGNvbXBvbmVudC5cbiAgICBjb25zdCBpZCA9IFJlYWN0LnVzZUlkKCk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHN1YnNjcmliZSlcbiAgICAgICAgICAgIHJlZ2lzdGVyKGlkKTtcbiAgICB9LCBbc3Vic2NyaWJlXSk7XG4gICAgY29uc3Qgc2FmZVRvUmVtb3ZlID0gUmVhY3QudXNlQ2FsbGJhY2soKCkgPT4gc3Vic2NyaWJlICYmIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKGlkKSwgW2lkLCBvbkV4aXRDb21wbGV0ZSwgc3Vic2NyaWJlXSk7XG4gICAgcmV0dXJuICFpc1ByZXNlbnQgJiYgb25FeGl0Q29tcGxldGUgPyBbZmFsc2UsIHNhZmVUb1JlbW92ZV0gOiBbdHJ1ZV07XG59XG4vKipcbiAqIFNpbWlsYXIgdG8gYHVzZVByZXNlbmNlYCwgZXhjZXB0IGB1c2VJc1ByZXNlbnRgIHNpbXBseSByZXR1cm5zIHdoZXRoZXIgb3Igbm90IHRoZSBjb21wb25lbnQgaXMgcHJlc2VudC5cbiAqIFRoZXJlIGlzIG5vIGBzYWZlVG9SZW1vdmVgIGZ1bmN0aW9uLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0IHsgdXNlSXNQcmVzZW50IH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IGlzUHJlc2VudCA9IHVzZUlzUHJlc2VudCgpXG4gKlxuICogICB1c2VFZmZlY3QoKCkgPT4ge1xuICogICAgICFpc1ByZXNlbnQgJiYgY29uc29sZS5sb2coXCJJJ3ZlIGJlZW4gcmVtb3ZlZCFcIilcbiAqICAgfSwgW2lzUHJlc2VudF0pXG4gKlxuICogICByZXR1cm4gPGRpdiAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VJc1ByZXNlbnQoKSB7XG4gICAgcmV0dXJuIGlzUHJlc2VudChSZWFjdC51c2VDb250ZXh0KFByZXNlbmNlQ29udGV4dCkpO1xufVxuZnVuY3Rpb24gaXNQcmVzZW50KGNvbnRleHQpIHtcbiAgICByZXR1cm4gY29udGV4dCA9PT0gbnVsbCA/IHRydWUgOiBjb250ZXh0LmlzUHJlc2VudDtcbn1cblxuY29uc3QgZ2V0Q2hpbGRLZXkgPSAoY2hpbGQpID0+IGNoaWxkLmtleSB8fCBcIlwiO1xuZnVuY3Rpb24gb25seUVsZW1lbnRzKGNoaWxkcmVuKSB7XG4gICAgY29uc3QgZmlsdGVyZWQgPSBbXTtcbiAgICAvLyBXZSB1c2UgZm9yRWFjaCBoZXJlIGluc3RlYWQgb2YgbWFwIGFzIG1hcCBtdXRhdGVzIHRoZSBjb21wb25lbnQga2V5IGJ5IHByZXByZW5kaW5nIGAuJGBcbiAgICBSZWFjdC5DaGlsZHJlbi5mb3JFYWNoKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgICAgaWYgKFJlYWN0LmlzVmFsaWRFbGVtZW50KGNoaWxkKSlcbiAgICAgICAgICAgIGZpbHRlcmVkLnB1c2goY2hpbGQpO1xuICAgIH0pO1xuICAgIHJldHVybiBmaWx0ZXJlZDtcbn1cblxuLyoqXG4gKiBgQW5pbWF0ZVByZXNlbmNlYCBlbmFibGVzIHRoZSBhbmltYXRpb24gb2YgY29tcG9uZW50cyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIHRyZWUuXG4gKlxuICogV2hlbiBhZGRpbmcvcmVtb3ZpbmcgbW9yZSB0aGFuIGEgc2luZ2xlIGNoaWxkLCBldmVyeSBjaGlsZCAqKm11c3QqKiBiZSBnaXZlbiBhIHVuaXF1ZSBga2V5YCBwcm9wLlxuICpcbiAqIEFueSBgbW90aW9uYCBjb21wb25lbnRzIHRoYXQgaGF2ZSBhbiBgZXhpdGAgcHJvcGVydHkgZGVmaW5lZCB3aWxsIGFuaW1hdGUgb3V0IHdoZW4gcmVtb3ZlZCBmcm9tXG4gKiB0aGUgdHJlZS5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCB7IG1vdGlvbiwgQW5pbWF0ZVByZXNlbmNlIH0gZnJvbSAnZnJhbWVyLW1vdGlvbidcbiAqXG4gKiBleHBvcnQgY29uc3QgSXRlbXMgPSAoeyBpdGVtcyB9KSA9PiAoXG4gKiAgIDxBbmltYXRlUHJlc2VuY2U+XG4gKiAgICAge2l0ZW1zLm1hcChpdGVtID0+IChcbiAqICAgICAgIDxtb3Rpb24uZGl2XG4gKiAgICAgICAgIGtleT17aXRlbS5pZH1cbiAqICAgICAgICAgaW5pdGlhbD17eyBvcGFjaXR5OiAwIH19XG4gKiAgICAgICAgIGFuaW1hdGU9e3sgb3BhY2l0eTogMSB9fVxuICogICAgICAgICBleGl0PXt7IG9wYWNpdHk6IDAgfX1cbiAqICAgICAgIC8+XG4gKiAgICAgKSl9XG4gKiAgIDwvQW5pbWF0ZVByZXNlbmNlPlxuICogKVxuICogYGBgXG4gKlxuICogWW91IGNhbiBzZXF1ZW5jZSBleGl0IGFuaW1hdGlvbnMgdGhyb3VnaG91dCBhIHRyZWUgdXNpbmcgdmFyaWFudHMuXG4gKlxuICogSWYgYSBjaGlsZCBjb250YWlucyBtdWx0aXBsZSBgbW90aW9uYCBjb21wb25lbnRzIHdpdGggYGV4aXRgIHByb3BzLCBpdCB3aWxsIG9ubHkgdW5tb3VudCB0aGUgY2hpbGRcbiAqIG9uY2UgYWxsIGBtb3Rpb25gIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LiBMaWtld2lzZSwgYW55IGNvbXBvbmVudHMgdXNpbmdcbiAqIGB1c2VQcmVzZW5jZWAgYWxsIG5lZWQgdG8gY2FsbCBgc2FmZVRvUmVtb3ZlYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IEFuaW1hdGVQcmVzZW5jZSA9ICh7IGNoaWxkcmVuLCBjdXN0b20sIGluaXRpYWwgPSB0cnVlLCBvbkV4aXRDb21wbGV0ZSwgcHJlc2VuY2VBZmZlY3RzTGF5b3V0ID0gdHJ1ZSwgbW9kZSA9IFwic3luY1wiLCBwcm9wYWdhdGUgPSBmYWxzZSwgfSkgPT4ge1xuICAgIGNvbnN0IFtpc1BhcmVudFByZXNlbnQsIHNhZmVUb1JlbW92ZV0gPSB1c2VQcmVzZW5jZShwcm9wYWdhdGUpO1xuICAgIC8qKlxuICAgICAqIEZpbHRlciBhbnkgY2hpbGRyZW4gdGhhdCBhcmVuJ3QgUmVhY3RFbGVtZW50cy4gV2UgY2FuIG9ubHkgdHJhY2sgY29tcG9uZW50c1xuICAgICAqIGJldHdlZW4gcmVuZGVycyB3aXRoIGEgcHJvcHMua2V5LlxuICAgICAqL1xuICAgIGNvbnN0IHByZXNlbnRDaGlsZHJlbiA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gb25seUVsZW1lbnRzKGNoaWxkcmVuKSwgW2NoaWxkcmVuXSk7XG4gICAgLyoqXG4gICAgICogVHJhY2sgdGhlIGtleXMgb2YgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIHRvXG4gICAgICogZGV0ZXJtaW5lIHdoaWNoIGNoaWxkcmVuIGFyZSBleGl0aW5nLlxuICAgICAqL1xuICAgIGNvbnN0IHByZXNlbnRLZXlzID0gcHJvcGFnYXRlICYmICFpc1BhcmVudFByZXNlbnQgPyBbXSA6IHByZXNlbnRDaGlsZHJlbi5tYXAoZ2V0Q2hpbGRLZXkpO1xuICAgIC8qKlxuICAgICAqIElmIGBpbml0aWFsPXtmYWxzZX1gIHdlIG9ubHkgd2FudCB0byBwYXNzIHRoaXMgdG8gY29tcG9uZW50cyBpbiB0aGUgZmlyc3QgcmVuZGVyLlxuICAgICAqL1xuICAgIGNvbnN0IGlzSW5pdGlhbFJlbmRlciA9IFJlYWN0LnVzZVJlZih0cnVlKTtcbiAgICAvKipcbiAgICAgKiBBIHJlZiBjb250YWluaW5nIHRoZSBjdXJyZW50bHkgcHJlc2VudCBjaGlsZHJlbi4gV2hlbiBhbGwgZXhpdCBhbmltYXRpb25zXG4gICAgICogYXJlIGNvbXBsZXRlLCB3ZSB1c2UgdGhpcyB0byByZS1yZW5kZXIgdGhlIGNvbXBvbmVudCB3aXRoIHRoZSBsYXRlc3QgY2hpbGRyZW5cbiAgICAgKiAqY29tbWl0dGVkKiByYXRoZXIgdGhhbiB0aGUgbGF0ZXN0IGNoaWxkcmVuICpyZW5kZXJlZCouXG4gICAgICovXG4gICAgY29uc3QgcGVuZGluZ1ByZXNlbnRDaGlsZHJlbiA9IFJlYWN0LnVzZVJlZihwcmVzZW50Q2hpbGRyZW4pO1xuICAgIC8qKlxuICAgICAqIFRyYWNrIHdoaWNoIGV4aXRpbmcgY2hpbGRyZW4gaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LlxuICAgICAqL1xuICAgIGNvbnN0IGV4aXRDb21wbGV0ZSA9IHVzZUNvbnN0YW50KCgpID0+IG5ldyBNYXAoKSk7XG4gICAgLyoqXG4gICAgICogU2F2ZSBjaGlsZHJlbiB0byByZW5kZXIgYXMgUmVhY3Qgc3RhdGUuIFRvIGVuc3VyZSB0aGlzIGNvbXBvbmVudCBpcyBjb25jdXJyZW50LXNhZmUsXG4gICAgICogd2UgY2hlY2sgZm9yIGV4aXRpbmcgY2hpbGRyZW4gdmlhIGFuIGVmZmVjdC5cbiAgICAgKi9cbiAgICBjb25zdCBbZGlmZmVkQ2hpbGRyZW4sIHNldERpZmZlZENoaWxkcmVuXSA9IFJlYWN0LnVzZVN0YXRlKHByZXNlbnRDaGlsZHJlbik7XG4gICAgY29uc3QgW3JlbmRlcmVkQ2hpbGRyZW4sIHNldFJlbmRlcmVkQ2hpbGRyZW5dID0gUmVhY3QudXNlU3RhdGUocHJlc2VudENoaWxkcmVuKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNJbml0aWFsUmVuZGVyLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgcGVuZGluZ1ByZXNlbnRDaGlsZHJlbi5jdXJyZW50ID0gcHJlc2VudENoaWxkcmVuO1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIGNvbXBsZXRlIHN0YXR1cyBvZiBleGl0aW5nIGNoaWxkcmVuLlxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJlZENoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBnZXRDaGlsZEtleShyZW5kZXJlZENoaWxkcmVuW2ldKTtcbiAgICAgICAgICAgIGlmICghcHJlc2VudEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIGlmIChleGl0Q29tcGxldGUuZ2V0KGtleSkgIT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpdENvbXBsZXRlLnNldChrZXksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBleGl0Q29tcGxldGUuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LCBbcmVuZGVyZWRDaGlsZHJlbiwgcHJlc2VudEtleXMubGVuZ3RoLCBwcmVzZW50S2V5cy5qb2luKFwiLVwiKV0pO1xuICAgIGNvbnN0IGV4aXRpbmdDaGlsZHJlbiA9IFtdO1xuICAgIGlmIChwcmVzZW50Q2hpbGRyZW4gIT09IGRpZmZlZENoaWxkcmVuKSB7XG4gICAgICAgIGxldCBuZXh0Q2hpbGRyZW4gPSBbLi4ucHJlc2VudENoaWxkcmVuXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvb3AgdGhyb3VnaCBhbGwgdGhlIGN1cnJlbnRseSByZW5kZXJlZCBjb21wb25lbnRzIGFuZCBkZWNpZGUgd2hpY2hcbiAgICAgICAgICogYXJlIGV4aXRpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNoaWxkID0gcmVuZGVyZWRDaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IGdldENoaWxkS2V5KGNoaWxkKTtcbiAgICAgICAgICAgIGlmICghcHJlc2VudEtleXMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIG5leHRDaGlsZHJlbi5zcGxpY2UoaSwgMCwgY2hpbGQpO1xuICAgICAgICAgICAgICAgIGV4aXRpbmdDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2UncmUgaW4gXCJ3YWl0XCIgbW9kZSwgYW5kIHdlIGhhdmUgZXhpdGluZyBjaGlsZHJlbiwgd2Ugd2FudCB0b1xuICAgICAgICAgKiBvbmx5IHJlbmRlciB0aGVzZSB1bnRpbCB0aGV5J3ZlIGFsbCBleGl0ZWQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobW9kZSA9PT0gXCJ3YWl0XCIgJiYgZXhpdGluZ0NoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgICAgbmV4dENoaWxkcmVuID0gZXhpdGluZ0NoaWxkcmVuO1xuICAgICAgICB9XG4gICAgICAgIHNldFJlbmRlcmVkQ2hpbGRyZW4ob25seUVsZW1lbnRzKG5leHRDaGlsZHJlbikpO1xuICAgICAgICBzZXREaWZmZWRDaGlsZHJlbihwcmVzZW50Q2hpbGRyZW4pO1xuICAgICAgICAvKipcbiAgICAgICAgICogRWFybHkgcmV0dXJuIHRvIGVuc3VyZSBvbmNlIHdlJ3ZlIHNldCBzdGF0ZSB3aXRoIHRoZSBsYXRlc3QgZGlmZmVkXG4gICAgICAgICAqIGNoaWxkcmVuLCB3ZSBjYW4gaW1tZWRpYXRlbHkgcmUtcmVuZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiICYmXG4gICAgICAgIG1vZGUgPT09IFwid2FpdFwiICYmXG4gICAgICAgIHJlbmRlcmVkQ2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICBjb25zb2xlLndhcm4oYFlvdSdyZSBhdHRlbXB0aW5nIHRvIGFuaW1hdGUgbXVsdGlwbGUgY2hpbGRyZW4gd2l0aGluIEFuaW1hdGVQcmVzZW5jZSwgYnV0IGl0cyBtb2RlIGlzIHNldCB0byBcIndhaXRcIi4gVGhpcyB3aWxsIGxlYWQgdG8gb2RkIHZpc3VhbCBiZWhhdmlvdXIuYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHdlJ3ZlIGJlZW4gcHJvdmlkZWQgYSBmb3JjZVJlbmRlciBmdW5jdGlvbiBieSB0aGUgTGF5b3V0R3JvdXBDb250ZXh0LFxuICAgICAqIHdlIGNhbiB1c2UgaXQgdG8gZm9yY2UgYSByZS1yZW5kZXIgYW1vbmdzdCBhbGwgc3Vycm91bmRpbmcgY29tcG9uZW50cyBvbmNlXG4gICAgICogYWxsIGNvbXBvbmVudHMgaGF2ZSBmaW5pc2hlZCBhbmltYXRpbmcgb3V0LlxuICAgICAqL1xuICAgIGNvbnN0IHsgZm9yY2VSZW5kZXIgfSA9IFJlYWN0LnVzZUNvbnRleHQoTGF5b3V0R3JvdXBDb250ZXh0KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KGpzeFJ1bnRpbWUuRnJhZ21lbnQsIHsgY2hpbGRyZW46IHJlbmRlcmVkQ2hpbGRyZW4ubWFwKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gZ2V0Q2hpbGRLZXkoY2hpbGQpO1xuICAgICAgICAgICAgY29uc3QgaXNQcmVzZW50ID0gcHJvcGFnYXRlICYmICFpc1BhcmVudFByZXNlbnRcbiAgICAgICAgICAgICAgICA/IGZhbHNlXG4gICAgICAgICAgICAgICAgOiBwcmVzZW50Q2hpbGRyZW4gPT09IHJlbmRlcmVkQ2hpbGRyZW4gfHxcbiAgICAgICAgICAgICAgICAgICAgcHJlc2VudEtleXMuaW5jbHVkZXMoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IG9uRXhpdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXhpdENvbXBsZXRlLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5zZXQoa2V5LCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGlzRXZlcnlFeGl0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGV4aXRDb21wbGV0ZS5mb3JFYWNoKChpc0V4aXRDb21wbGV0ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRXhpdENvbXBsZXRlKVxuICAgICAgICAgICAgICAgICAgICAgICAgaXNFdmVyeUV4aXRDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmIChpc0V2ZXJ5RXhpdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvcmNlUmVuZGVyID09PSBudWxsIHx8IGZvcmNlUmVuZGVyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICAgICAgICBzZXRSZW5kZXJlZENoaWxkcmVuKHBlbmRpbmdQcmVzZW50Q2hpbGRyZW4uY3VycmVudCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BhZ2F0ZSAmJiAoc2FmZVRvUmVtb3ZlID09PSBudWxsIHx8IHNhZmVUb1JlbW92ZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc2FmZVRvUmVtb3ZlKCkpO1xuICAgICAgICAgICAgICAgICAgICBvbkV4aXRDb21wbGV0ZSAmJiBvbkV4aXRDb21wbGV0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KFByZXNlbmNlQ2hpbGQsIHsgaXNQcmVzZW50OiBpc1ByZXNlbnQsIGluaXRpYWw6ICFpc0luaXRpYWxSZW5kZXIuY3VycmVudCB8fCBpbml0aWFsXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogZmFsc2UsIGN1c3RvbTogaXNQcmVzZW50ID8gdW5kZWZpbmVkIDogY3VzdG9tLCBwcmVzZW5jZUFmZmVjdHNMYXlvdXQ6IHByZXNlbmNlQWZmZWN0c0xheW91dCwgbW9kZTogbW9kZSwgb25FeGl0Q29tcGxldGU6IGlzUHJlc2VudCA/IHVuZGVmaW5lZCA6IG9uRXhpdCwgY2hpbGRyZW46IGNoaWxkIH0sIGtleSkpO1xuICAgICAgICB9KSB9KSk7XG59O1xuXG4vKipcbiAqIE5vdGU6IFN0aWxsIHVzZWQgYnkgY29tcG9uZW50cyBnZW5lcmF0ZWQgYnkgb2xkIHZlcnNpb25zIG9mIEZyYW1lclxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmNvbnN0IERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBhbmltYXRlU2luZ2xlVmFsdWUodmFsdWUsIGtleWZyYW1lcywgb3B0aW9ucykge1xuICAgIGNvbnN0IG1vdGlvblZhbHVlJDEgPSBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogbW90aW9uVmFsdWUodmFsdWUpO1xuICAgIG1vdGlvblZhbHVlJDEuc3RhcnQoYW5pbWF0ZU1vdGlvblZhbHVlKFwiXCIsIG1vdGlvblZhbHVlJDEsIGtleWZyYW1lcywgb3B0aW9ucykpO1xuICAgIHJldHVybiBtb3Rpb25WYWx1ZSQxLmFuaW1hdGlvbjtcbn1cblxuY29uc3Qgd3JhcCA9IChtaW4sIG1heCwgdikgPT4ge1xuICAgIGNvbnN0IHJhbmdlU2l6ZSA9IG1heCAtIG1pbjtcbiAgICByZXR1cm4gKCgoKHYgLSBtaW4pICUgcmFuZ2VTaXplKSArIHJhbmdlU2l6ZSkgJSByYW5nZVNpemUpICsgbWluO1xufTtcblxuZnVuY3Rpb24gZ2V0RWFzaW5nRm9yU2VnbWVudChlYXNpbmcsIGkpIHtcbiAgICByZXR1cm4gaXNFYXNpbmdBcnJheShlYXNpbmcpID8gZWFzaW5nW3dyYXAoMCwgZWFzaW5nLmxlbmd0aCwgaSldIDogZWFzaW5nO1xufVxuXG5mdW5jdGlvbiBpc0RPTUtleWZyYW1lcyhrZXlmcmFtZXMpIHtcbiAgICByZXR1cm4gdHlwZW9mIGtleWZyYW1lcyA9PT0gXCJvYmplY3RcIiAmJiAhQXJyYXkuaXNBcnJheShrZXlmcmFtZXMpO1xufVxuXG5mdW5jdGlvbiByZXNvbHZlU3ViamVjdHMoc3ViamVjdCwga2V5ZnJhbWVzLCBzY29wZSwgc2VsZWN0b3JDYWNoZSkge1xuICAgIGlmICh0eXBlb2Ygc3ViamVjdCA9PT0gXCJzdHJpbmdcIiAmJiBpc0RPTUtleWZyYW1lcyhrZXlmcmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBtb3Rpb25Eb20ucmVzb2x2ZUVsZW1lbnRzKHN1YmplY3QsIHNjb3BlLCBzZWxlY3RvckNhY2hlKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoc3ViamVjdCBpbnN0YW5jZW9mIE5vZGVMaXN0KSB7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHN1YmplY3QpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHN1YmplY3QpKSB7XG4gICAgICAgIHJldHVybiBzdWJqZWN0O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFtzdWJqZWN0XTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJlcGVhdER1cmF0aW9uKGR1cmF0aW9uLCByZXBlYXQsIF9yZXBlYXREZWxheSkge1xuICAgIHJldHVybiBkdXJhdGlvbiAqIChyZXBlYXQgKyAxKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIGFic29sdXRlIG9yIHJlbGF0aXZlIHRpbWUgZGVmaW5pdGlvbiBhbmQgY3VycmVudC9wcmV2IHRpbWUgc3RhdGUgb2YgdGhlIHNlcXVlbmNlLFxuICogY2FsY3VsYXRlIGFuIGFic29sdXRlIHRpbWUgZm9yIHRoZSBuZXh0IGtleWZyYW1lcy5cbiAqL1xuZnVuY3Rpb24gY2FsY05leHRUaW1lKGN1cnJlbnQsIG5leHQsIHByZXYsIGxhYmVscykge1xuICAgIHZhciBfYTtcbiAgICBpZiAodHlwZW9mIG5leHQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIG5leHQ7XG4gICAgfVxuICAgIGVsc2UgaWYgKG5leHQuc3RhcnRzV2l0aChcIi1cIikgfHwgbmV4dC5zdGFydHNXaXRoKFwiK1wiKSkge1xuICAgICAgICByZXR1cm4gTWF0aC5tYXgoMCwgY3VycmVudCArIHBhcnNlRmxvYXQobmV4dCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChuZXh0ID09PSBcIjxcIikge1xuICAgICAgICByZXR1cm4gcHJldjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiAoX2EgPSBsYWJlbHMuZ2V0KG5leHQpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBjdXJyZW50O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZXJhc2VLZXlmcmFtZXMoc2VxdWVuY2UsIHN0YXJ0VGltZSwgZW5kVGltZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qga2V5ZnJhbWUgPSBzZXF1ZW5jZVtpXTtcbiAgICAgICAgaWYgKGtleWZyYW1lLmF0ID4gc3RhcnRUaW1lICYmIGtleWZyYW1lLmF0IDwgZW5kVGltZSkge1xuICAgICAgICAgICAgcmVtb3ZlSXRlbShzZXF1ZW5jZSwga2V5ZnJhbWUpO1xuICAgICAgICAgICAgLy8gSWYgd2UgcmVtb3ZlIHRoaXMgaXRlbSB3ZSBoYXZlIHRvIHB1c2ggdGhlIHBvaW50ZXIgYmFjayBvbmVcbiAgICAgICAgICAgIGktLTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFkZEtleWZyYW1lcyhzZXF1ZW5jZSwga2V5ZnJhbWVzLCBlYXNpbmcsIG9mZnNldCwgc3RhcnRUaW1lLCBlbmRUaW1lKSB7XG4gICAgLyoqXG4gICAgICogRXJhc2UgZXZlcnkgZXhpc3RpbmcgdmFsdWUgYmV0d2VlbiBjdXJyZW50VGltZSBhbmQgdGFyZ2V0VGltZSxcbiAgICAgKiB0aGlzIHdpbGwgZXNzZW50aWFsbHkgc3BsaWNlIHRoaXMgdGltZWxpbmUgaW50byBhbnkgY3VycmVudGx5XG4gICAgICogZGVmaW5lZCBvbmVzLlxuICAgICAqL1xuICAgIGVyYXNlS2V5ZnJhbWVzKHNlcXVlbmNlLCBzdGFydFRpbWUsIGVuZFRpbWUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlcXVlbmNlLnB1c2goe1xuICAgICAgICAgICAgdmFsdWU6IGtleWZyYW1lc1tpXSxcbiAgICAgICAgICAgIGF0OiBtaXhOdW1iZXIkMShzdGFydFRpbWUsIGVuZFRpbWUsIG9mZnNldFtpXSksXG4gICAgICAgICAgICBlYXNpbmc6IGdldEVhc2luZ0ZvclNlZ21lbnQoZWFzaW5nLCBpKSxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFRha2UgYW4gYXJyYXkgb2YgdGltZXMgdGhhdCByZXByZXNlbnQgcmVwZWF0ZWQga2V5ZnJhbWVzLiBGb3IgaW5zdGFuY2VcbiAqIGlmIHdlIGhhdmUgb3JpZ2luYWwgdGltZXMgb2YgWzAsIDAuNSwgMV0gdGhlbiBvdXIgcmVwZWF0ZWQgdGltZXMgd2lsbFxuICogYmUgWzAsIDAuNSwgMSwgMSwgMS41LCAyXS4gTG9vcCBvdmVyIHRoZSB0aW1lcyBhbmQgc2NhbGUgdGhlbSBiYWNrXG4gKiBkb3duIHRvIGEgMC0xIHNjYWxlLlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVUaW1lcyh0aW1lcywgcmVwZWF0KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aW1lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aW1lc1tpXSA9IHRpbWVzW2ldIC8gKHJlcGVhdCArIDEpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZUJ5VGltZShhLCBiKSB7XG4gICAgaWYgKGEuYXQgPT09IGIuYXQpIHtcbiAgICAgICAgaWYgKGEudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgaWYgKGIudmFsdWUgPT09IG51bGwpXG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGEuYXQgLSBiLmF0O1xuICAgIH1cbn1cblxuY29uc3QgZGVmYXVsdFNlZ21lbnRFYXNpbmcgPSBcImVhc2VJbk91dFwiO1xuY29uc3QgTUFYX1JFUEVBVCA9IDIwO1xuZnVuY3Rpb24gY3JlYXRlQW5pbWF0aW9uc0Zyb21TZXF1ZW5jZShzZXF1ZW5jZSwgeyBkZWZhdWx0VHJhbnNpdGlvbiA9IHt9LCAuLi5zZXF1ZW5jZVRyYW5zaXRpb24gfSA9IHt9LCBzY29wZSwgZ2VuZXJhdG9ycykge1xuICAgIGNvbnN0IGRlZmF1bHREdXJhdGlvbiA9IGRlZmF1bHRUcmFuc2l0aW9uLmR1cmF0aW9uIHx8IDAuMztcbiAgICBjb25zdCBhbmltYXRpb25EZWZpbml0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBzZXF1ZW5jZXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgZWxlbWVudENhY2hlID0ge307XG4gICAgY29uc3QgdGltZUxhYmVscyA9IG5ldyBNYXAoKTtcbiAgICBsZXQgcHJldlRpbWUgPSAwO1xuICAgIGxldCBjdXJyZW50VGltZSA9IDA7XG4gICAgbGV0IHRvdGFsRHVyYXRpb24gPSAwO1xuICAgIC8qKlxuICAgICAqIEJ1aWxkIHRoZSB0aW1lbGluZSBieSBtYXBwaW5nIG92ZXIgdGhlIHNlcXVlbmNlIGFycmF5IGFuZCBjb252ZXJ0aW5nXG4gICAgICogdGhlIGRlZmluaXRpb25zIGludG8ga2V5ZnJhbWVzIGFuZCBvZmZzZXRzIHdpdGggYWJzb2x1dGUgdGltZSB2YWx1ZXMuXG4gICAgICogVGhlc2Ugd2lsbCBsYXRlciBnZXQgY29udmVydGVkIGludG8gcmVsYXRpdmUgb2Zmc2V0cyBpbiBhIHNlY29uZCBwYXNzLlxuICAgICAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VxdWVuY2UubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2VnbWVudCA9IHNlcXVlbmNlW2ldO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBpcyBhIHRpbWVsaW5lIGxhYmVsLCBtYXJrIGl0IGFuZCBza2lwIHRoZSByZXN0IG9mIHRoaXMgaXRlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBzZWdtZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aW1lTGFiZWxzLnNldChzZWdtZW50LCBjdXJyZW50VGltZSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzZWdtZW50KSkge1xuICAgICAgICAgICAgdGltZUxhYmVscy5zZXQoc2VnbWVudC5uYW1lLCBjYWxjTmV4dFRpbWUoY3VycmVudFRpbWUsIHNlZ21lbnQuYXQsIHByZXZUaW1lLCB0aW1lTGFiZWxzKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgW3N1YmplY3QsIGtleWZyYW1lcywgdHJhbnNpdGlvbiA9IHt9XSA9IHNlZ21lbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBhIHJlbGF0aXZlIG9yIGFic29sdXRlIHRpbWUgdmFsdWUgaGFzIGJlZW4gc3BlY2lmaWVkIHdlIG5lZWQgdG8gcmVzb2x2ZVxuICAgICAgICAgKiBpdCBpbiByZWxhdGlvbiB0byB0aGUgY3VycmVudFRpbWUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodHJhbnNpdGlvbi5hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjdXJyZW50VGltZSA9IGNhbGNOZXh0VGltZShjdXJyZW50VGltZSwgdHJhbnNpdGlvbi5hdCwgcHJldlRpbWUsIHRpbWVMYWJlbHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBLZWVwIHRyYWNrIG9mIHRoZSBtYXhpbXVtIGR1cmF0aW9uIGluIHRoaXMgZGVmaW5pdGlvbi4gVGhpcyB3aWxsIGJlXG4gICAgICAgICAqIGFwcGxpZWQgdG8gY3VycmVudFRpbWUgb25jZSB0aGUgZGVmaW5pdGlvbiBoYXMgYmVlbiBwYXJzZWQuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgbWF4RHVyYXRpb24gPSAwO1xuICAgICAgICBjb25zdCByZXNvbHZlVmFsdWVTZXF1ZW5jZSA9ICh2YWx1ZUtleWZyYW1lcywgdmFsdWVUcmFuc2l0aW9uLCB2YWx1ZVNlcXVlbmNlLCBlbGVtZW50SW5kZXggPSAwLCBudW1TdWJqZWN0cyA9IDApID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlS2V5ZnJhbWVzQXNMaXN0ID0ga2V5ZnJhbWVzQXNMaXN0KHZhbHVlS2V5ZnJhbWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCB0aW1lcyA9IGRlZmF1bHRPZmZzZXQkMSh2YWx1ZUtleWZyYW1lc0FzTGlzdCksIHR5cGUgPSBcImtleWZyYW1lc1wiLCByZXBlYXQsIHJlcGVhdFR5cGUsIHJlcGVhdERlbGF5ID0gMCwgLi4ucmVtYWluaW5nVHJhbnNpdGlvbiB9ID0gdmFsdWVUcmFuc2l0aW9uO1xuICAgICAgICAgICAgbGV0IHsgZWFzZSA9IGRlZmF1bHRUcmFuc2l0aW9uLmVhc2UgfHwgXCJlYXNlT3V0XCIsIGR1cmF0aW9uIH0gPSB2YWx1ZVRyYW5zaXRpb247XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc29sdmUgc3RhZ2dlcigpIGlmIGRlZmluZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGNhbGN1bGF0ZWREZWxheSA9IHR5cGVvZiBkZWxheSA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgICAgICAgICAgPyBkZWxheShlbGVtZW50SW5kZXgsIG51bVN1YmplY3RzKVxuICAgICAgICAgICAgICAgIDogZGVsYXk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgYW5pbWF0aW9uIHNob3VsZCBhbmQgY2FuIHVzZSBhIHNwcmluZywgZ2VuZXJhdGUgYSBzcHJpbmcgZWFzaW5nIGZ1bmN0aW9uLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBudW1LZXlmcmFtZXMgPSB2YWx1ZUtleWZyYW1lc0FzTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICBjb25zdCBjcmVhdGVHZW5lcmF0b3IgPSBtb3Rpb25Eb20uaXNHZW5lcmF0b3IodHlwZSlcbiAgICAgICAgICAgICAgICA/IHR5cGVcbiAgICAgICAgICAgICAgICA6IGdlbmVyYXRvcnMgPT09IG51bGwgfHwgZ2VuZXJhdG9ycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZ2VuZXJhdG9yc1t0eXBlXTtcbiAgICAgICAgICAgIGlmIChudW1LZXlmcmFtZXMgPD0gMiAmJiBjcmVhdGVHZW5lcmF0b3IpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBBcyB3ZSdyZSBjcmVhdGluZyBhbiBlYXNpbmcgZnVuY3Rpb24gZnJvbSBhIHNwcmluZyxcbiAgICAgICAgICAgICAgICAgKiBpZGVhbGx5IHdlIHdhbnQgdG8gZ2VuZXJhdGUgaXQgdXNpbmcgdGhlIHJlYWwgZGlzdGFuY2VcbiAgICAgICAgICAgICAgICAgKiBiZXR3ZWVuIHRoZSB0d28ga2V5ZnJhbWVzLiBIb3dldmVyIHRoaXMgaXNuJ3QgYWx3YXlzXG4gICAgICAgICAgICAgICAgICogcG9zc2libGUgLSBpbiB0aGVzZSBzaXR1YXRpb25zIHdlIHVzZSAwLTEwMC5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsZXQgYWJzb2x1dGVEZWx0YSA9IDEwMDtcbiAgICAgICAgICAgICAgICBpZiAobnVtS2V5ZnJhbWVzID09PSAyICYmXG4gICAgICAgICAgICAgICAgICAgIGlzTnVtYmVyS2V5ZnJhbWVzQXJyYXkodmFsdWVLZXlmcmFtZXNBc0xpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlbHRhID0gdmFsdWVLZXlmcmFtZXNBc0xpc3RbMV0gLSB2YWx1ZUtleWZyYW1lc0FzTGlzdFswXTtcbiAgICAgICAgICAgICAgICAgICAgYWJzb2x1dGVEZWx0YSA9IE1hdGguYWJzKGRlbHRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3ByaW5nVHJhbnNpdGlvbiA9IHsgLi4ucmVtYWluaW5nVHJhbnNpdGlvbiB9O1xuICAgICAgICAgICAgICAgIGlmIChkdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHNwcmluZ1RyYW5zaXRpb24uZHVyYXRpb24gPSBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHMoZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBzcHJpbmdFYXNpbmcgPSBtb3Rpb25Eb20uY3JlYXRlR2VuZXJhdG9yRWFzaW5nKHNwcmluZ1RyYW5zaXRpb24sIGFic29sdXRlRGVsdGEsIGNyZWF0ZUdlbmVyYXRvcik7XG4gICAgICAgICAgICAgICAgZWFzZSA9IHNwcmluZ0Vhc2luZy5lYXNlO1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gc3ByaW5nRWFzaW5nLmR1cmF0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZHVyYXRpb24gIT09IG51bGwgJiYgZHVyYXRpb24gIT09IHZvaWQgMCA/IGR1cmF0aW9uIDogKGR1cmF0aW9uID0gZGVmYXVsdER1cmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IGN1cnJlbnRUaW1lICsgY2FsY3VsYXRlZERlbGF5O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG9ubHkgb25lIHRpbWUgb2Zmc2V0IG9mIDAsIGZpbGwgaW4gYSBzZWNvbmQgd2l0aCBsZW5ndGggMVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGltZXMubGVuZ3RoID09PSAxICYmIHRpbWVzWzBdID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGltZXNbMV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGaWxsIG91dCBpZiBvZmZzZXQgaWYgZmV3ZXIgb2Zmc2V0cyB0aGFuIGtleWZyYW1lc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSB0aW1lcy5sZW5ndGggLSB2YWx1ZUtleWZyYW1lc0FzTGlzdC5sZW5ndGg7XG4gICAgICAgICAgICByZW1haW5kZXIgPiAwICYmIGZpbGxPZmZzZXQodGltZXMsIHJlbWFpbmRlcik7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIG9ubHkgb25lIHZhbHVlIGhhcyBiZWVuIHNldCwgaWUgWzFdLCBwdXNoIGEgbnVsbCB0byB0aGUgc3RhcnQgb2ZcbiAgICAgICAgICAgICAqIHRoZSBrZXlmcmFtZSBhcnJheS4gVGhpcyB3aWxsIGxldCB1cyBtYXJrIGEga2V5ZnJhbWUgYXQgdGhpcyBwb2ludFxuICAgICAgICAgICAgICogdGhhdCB3aWxsIGxhdGVyIGJlIGh5ZHJhdGVkIHdpdGggdGhlIHByZXZpb3VzIHZhbHVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YWx1ZUtleWZyYW1lc0FzTGlzdC5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgICAgICB2YWx1ZUtleWZyYW1lc0FzTGlzdC51bnNoaWZ0KG51bGwpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBIYW5kbGUgcmVwZWF0IG9wdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHJlcGVhdCkge1xuICAgICAgICAgICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChyZXBlYXQgPCBNQVhfUkVQRUFULCBcIlJlcGVhdCBjb3VudCB0b28gaGlnaCwgbXVzdCBiZSBsZXNzIHRoYW4gMjBcIik7XG4gICAgICAgICAgICAgICAgZHVyYXRpb24gPSBjYWxjdWxhdGVSZXBlYXREdXJhdGlvbihkdXJhdGlvbiwgcmVwZWF0KTtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnaW5hbEtleWZyYW1lcyA9IFsuLi52YWx1ZUtleWZyYW1lc0FzTGlzdF07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxUaW1lcyA9IFsuLi50aW1lc107XG4gICAgICAgICAgICAgICAgZWFzZSA9IEFycmF5LmlzQXJyYXkoZWFzZSkgPyBbLi4uZWFzZV0gOiBbZWFzZV07XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYWxFYXNlID0gWy4uLmVhc2VdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHJlcGVhdEluZGV4ID0gMDsgcmVwZWF0SW5kZXggPCByZXBlYXQ7IHJlcGVhdEluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVLZXlmcmFtZXNBc0xpc3QucHVzaCguLi5vcmlnaW5hbEtleWZyYW1lcyk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGtleWZyYW1lSW5kZXggPSAwOyBrZXlmcmFtZUluZGV4IDwgb3JpZ2luYWxLZXlmcmFtZXMubGVuZ3RoOyBrZXlmcmFtZUluZGV4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVzLnB1c2gob3JpZ2luYWxUaW1lc1trZXlmcmFtZUluZGV4XSArIChyZXBlYXRJbmRleCArIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVhc2UucHVzaChrZXlmcmFtZUluZGV4ID09PSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBcImxpbmVhclwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBnZXRFYXNpbmdGb3JTZWdtZW50KG9yaWdpbmFsRWFzZSwga2V5ZnJhbWVJbmRleCAtIDEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub3JtYWxpemVUaW1lcyh0aW1lcywgcmVwZWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRhcmdldFRpbWUgPSBzdGFydFRpbWUgKyBkdXJhdGlvbjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQWRkIGtleWZyYW1lcywgbWFwcGluZyBvZmZzZXRzIHRvIGFic29sdXRlIHRpbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEtleWZyYW1lcyh2YWx1ZVNlcXVlbmNlLCB2YWx1ZUtleWZyYW1lc0FzTGlzdCwgZWFzZSwgdGltZXMsIHN0YXJ0VGltZSwgdGFyZ2V0VGltZSk7XG4gICAgICAgICAgICBtYXhEdXJhdGlvbiA9IE1hdGgubWF4KGNhbGN1bGF0ZWREZWxheSArIGR1cmF0aW9uLCBtYXhEdXJhdGlvbik7XG4gICAgICAgICAgICB0b3RhbER1cmF0aW9uID0gTWF0aC5tYXgodGFyZ2V0VGltZSwgdG90YWxEdXJhdGlvbik7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHN1YmplY3QpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0U2VxdWVuY2UgPSBnZXRTdWJqZWN0U2VxdWVuY2Uoc3ViamVjdCwgc2VxdWVuY2VzKTtcbiAgICAgICAgICAgIHJlc29sdmVWYWx1ZVNlcXVlbmNlKGtleWZyYW1lcywgdHJhbnNpdGlvbiwgZ2V0VmFsdWVTZXF1ZW5jZShcImRlZmF1bHRcIiwgc3ViamVjdFNlcXVlbmNlKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHJlc29sdmVTdWJqZWN0cyhzdWJqZWN0LCBrZXlmcmFtZXMsIHNjb3BlLCBlbGVtZW50Q2FjaGUpO1xuICAgICAgICAgICAgY29uc3QgbnVtU3ViamVjdHMgPSBzdWJqZWN0cy5sZW5ndGg7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZvciBldmVyeSBlbGVtZW50IGluIHRoaXMgc2VnbWVudCwgcHJvY2VzcyB0aGUgZGVmaW5lZCB2YWx1ZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IHN1YmplY3RJbmRleCA9IDA7IHN1YmplY3RJbmRleCA8IG51bVN1YmplY3RzOyBzdWJqZWN0SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENhc3QgbmVjZXNzYXJ5LCBidXQgd2Uga25vdyB0aGVzZSBhcmUgb2YgdGhpcyB0eXBlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24gPSB0cmFuc2l0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRoaXNTdWJqZWN0ID0gc3ViamVjdHNbc3ViamVjdEluZGV4XTtcbiAgICAgICAgICAgICAgICBjb25zdCBzdWJqZWN0U2VxdWVuY2UgPSBnZXRTdWJqZWN0U2VxdWVuY2UodGhpc1N1YmplY3QsIHNlcXVlbmNlcyk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVWYWx1ZVNlcXVlbmNlKGtleWZyYW1lc1trZXldLCBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSwgZ2V0VmFsdWVTZXF1ZW5jZShrZXksIHN1YmplY3RTZXF1ZW5jZSksIHN1YmplY3RJbmRleCwgbnVtU3ViamVjdHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwcmV2VGltZSA9IGN1cnJlbnRUaW1lO1xuICAgICAgICBjdXJyZW50VGltZSArPSBtYXhEdXJhdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRm9yIGV2ZXJ5IGVsZW1lbnQgYW5kIHZhbHVlIGNvbWJpbmF0aW9uIGNyZWF0ZSBhIG5ldyBhbmltYXRpb24uXG4gICAgICovXG4gICAgc2VxdWVuY2VzLmZvckVhY2goKHZhbHVlU2VxdWVuY2VzLCBlbGVtZW50KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHZhbHVlU2VxdWVuY2VzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZVNlcXVlbmNlID0gdmFsdWVTZXF1ZW5jZXNba2V5XTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXJyYW5nZSBhbGwgdGhlIGtleWZyYW1lcyBpbiBhc2NlbmRpbmcgdGltZSBvcmRlci5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFsdWVTZXF1ZW5jZS5zb3J0KGNvbXBhcmVCeVRpbWUpO1xuICAgICAgICAgICAgY29uc3Qga2V5ZnJhbWVzID0gW107XG4gICAgICAgICAgICBjb25zdCB2YWx1ZU9mZnNldCA9IFtdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVFYXNpbmcgPSBbXTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRm9yIGVhY2gga2V5ZnJhbWUsIHRyYW5zbGF0ZSBhYnNvbHV0ZSB0aW1lcyBpbnRvXG4gICAgICAgICAgICAgKiByZWxhdGl2ZSBvZmZzZXRzIGJhc2VkIG9uIHRoZSB0b3RhbCBkdXJhdGlvbiBvZiB0aGUgdGltZWxpbmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVTZXF1ZW5jZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgYXQsIHZhbHVlLCBlYXNpbmcgfSA9IHZhbHVlU2VxdWVuY2VbaV07XG4gICAgICAgICAgICAgICAga2V5ZnJhbWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhbHVlT2Zmc2V0LnB1c2gobW90aW9uVXRpbHMucHJvZ3Jlc3MoMCwgdG90YWxEdXJhdGlvbiwgYXQpKTtcbiAgICAgICAgICAgICAgICB2YWx1ZUVhc2luZy5wdXNoKGVhc2luZyB8fCBcImVhc2VPdXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSBmaXJzdCBrZXlmcmFtZSBkb2Vzbid0IGxhbmQgb24gb2Zmc2V0OiAwXG4gICAgICAgICAgICAgKiBwcm92aWRlIG9uZSBieSBkdXBsaWNhdGluZyB0aGUgaW5pdGlhbCBrZXlmcmFtZS4gVGhpcyBlbnN1cmVzXG4gICAgICAgICAgICAgKiBpdCBzbmFwcyB0byB0aGUgZmlyc3Qga2V5ZnJhbWUgd2hlbiB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHZhbHVlT2Zmc2V0WzBdICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVPZmZzZXQudW5zaGlmdCgwKTtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMudW5zaGlmdChrZXlmcmFtZXNbMF0pO1xuICAgICAgICAgICAgICAgIHZhbHVlRWFzaW5nLnVuc2hpZnQoZGVmYXVsdFNlZ21lbnRFYXNpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgbGFzdCBrZXlmcmFtZSBkb2Vzbid0IGxhbmQgb24gb2Zmc2V0OiAxXG4gICAgICAgICAgICAgKiBwcm92aWRlIG9uZSB3aXRoIGEgbnVsbCB3aWxkY2FyZCB2YWx1ZS4gVGhpcyB3aWxsIGVuc3VyZSBpdFxuICAgICAgICAgICAgICogc3RheXMgc3RhdGljIHVudGlsIHRoZSBlbmQgb2YgdGhlIGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHZhbHVlT2Zmc2V0W3ZhbHVlT2Zmc2V0Lmxlbmd0aCAtIDFdICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVPZmZzZXQucHVzaCgxKTtcbiAgICAgICAgICAgICAgICBrZXlmcmFtZXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYW5pbWF0aW9uRGVmaW5pdGlvbnMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVmaW5pdGlvbnMuc2V0KGVsZW1lbnQsIHtcbiAgICAgICAgICAgICAgICAgICAga2V5ZnJhbWVzOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbjoge30sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gYW5pbWF0aW9uRGVmaW5pdGlvbnMuZ2V0KGVsZW1lbnQpO1xuICAgICAgICAgICAgZGVmaW5pdGlvbi5rZXlmcmFtZXNba2V5XSA9IGtleWZyYW1lcztcbiAgICAgICAgICAgIGRlZmluaXRpb24udHJhbnNpdGlvbltrZXldID0ge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRUcmFuc2l0aW9uLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiB0b3RhbER1cmF0aW9uLFxuICAgICAgICAgICAgICAgIGVhc2U6IHZhbHVlRWFzaW5nLFxuICAgICAgICAgICAgICAgIHRpbWVzOiB2YWx1ZU9mZnNldCxcbiAgICAgICAgICAgICAgICAuLi5zZXF1ZW5jZVRyYW5zaXRpb24sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuaW1hdGlvbkRlZmluaXRpb25zO1xufVxuZnVuY3Rpb24gZ2V0U3ViamVjdFNlcXVlbmNlKHN1YmplY3QsIHNlcXVlbmNlcykge1xuICAgICFzZXF1ZW5jZXMuaGFzKHN1YmplY3QpICYmIHNlcXVlbmNlcy5zZXQoc3ViamVjdCwge30pO1xuICAgIHJldHVybiBzZXF1ZW5jZXMuZ2V0KHN1YmplY3QpO1xufVxuZnVuY3Rpb24gZ2V0VmFsdWVTZXF1ZW5jZShuYW1lLCBzZXF1ZW5jZXMpIHtcbiAgICBpZiAoIXNlcXVlbmNlc1tuYW1lXSlcbiAgICAgICAgc2VxdWVuY2VzW25hbWVdID0gW107XG4gICAgcmV0dXJuIHNlcXVlbmNlc1tuYW1lXTtcbn1cbmZ1bmN0aW9uIGtleWZyYW1lc0FzTGlzdChrZXlmcmFtZXMpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShrZXlmcmFtZXMpID8ga2V5ZnJhbWVzIDogW2tleWZyYW1lc107XG59XG5mdW5jdGlvbiBnZXRWYWx1ZVRyYW5zaXRpb24odHJhbnNpdGlvbiwga2V5KSB7XG4gICAgcmV0dXJuIHRyYW5zaXRpb24gJiYgdHJhbnNpdGlvbltrZXldXG4gICAgICAgID8ge1xuICAgICAgICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgICAgICAgIC4uLnRyYW5zaXRpb25ba2V5XSxcbiAgICAgICAgfVxuICAgICAgICA6IHsgLi4udHJhbnNpdGlvbiB9O1xufVxuY29uc3QgaXNOdW1iZXIgPSAoa2V5ZnJhbWUpID0+IHR5cGVvZiBrZXlmcmFtZSA9PT0gXCJudW1iZXJcIjtcbmNvbnN0IGlzTnVtYmVyS2V5ZnJhbWVzQXJyYXkgPSAoa2V5ZnJhbWVzKSA9PiBrZXlmcmFtZXMuZXZlcnkoaXNOdW1iZXIpO1xuXG5jb25zdCB2aXN1YWxFbGVtZW50U3RvcmUgPSBuZXcgV2Vha01hcCgpO1xuXG5mdW5jdGlvbiBpc1NWR0VsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50IGluc3RhbmNlb2YgU1ZHRWxlbWVudCAmJiBlbGVtZW50LnRhZ05hbWUgIT09IFwic3ZnXCI7XG59XG5cbmNvbnN0IGZlYXR1cmVQcm9wcyA9IHtcbiAgICBhbmltYXRpb246IFtcbiAgICAgICAgXCJhbmltYXRlXCIsXG4gICAgICAgIFwidmFyaWFudHNcIixcbiAgICAgICAgXCJ3aGlsZUhvdmVyXCIsXG4gICAgICAgIFwid2hpbGVUYXBcIixcbiAgICAgICAgXCJleGl0XCIsXG4gICAgICAgIFwid2hpbGVJblZpZXdcIixcbiAgICAgICAgXCJ3aGlsZUZvY3VzXCIsXG4gICAgICAgIFwid2hpbGVEcmFnXCIsXG4gICAgXSxcbiAgICBleGl0OiBbXCJleGl0XCJdLFxuICAgIGRyYWc6IFtcImRyYWdcIiwgXCJkcmFnQ29udHJvbHNcIl0sXG4gICAgZm9jdXM6IFtcIndoaWxlRm9jdXNcIl0sXG4gICAgaG92ZXI6IFtcIndoaWxlSG92ZXJcIiwgXCJvbkhvdmVyU3RhcnRcIiwgXCJvbkhvdmVyRW5kXCJdLFxuICAgIHRhcDogW1wid2hpbGVUYXBcIiwgXCJvblRhcFwiLCBcIm9uVGFwU3RhcnRcIiwgXCJvblRhcENhbmNlbFwiXSxcbiAgICBwYW46IFtcIm9uUGFuXCIsIFwib25QYW5TdGFydFwiLCBcIm9uUGFuU2Vzc2lvblN0YXJ0XCIsIFwib25QYW5FbmRcIl0sXG4gICAgaW5WaWV3OiBbXCJ3aGlsZUluVmlld1wiLCBcIm9uVmlld3BvcnRFbnRlclwiLCBcIm9uVmlld3BvcnRMZWF2ZVwiXSxcbiAgICBsYXlvdXQ6IFtcImxheW91dFwiLCBcImxheW91dElkXCJdLFxufTtcbmNvbnN0IGZlYXR1cmVEZWZpbml0aW9ucyA9IHt9O1xuZm9yIChjb25zdCBrZXkgaW4gZmVhdHVyZVByb3BzKSB7XG4gICAgZmVhdHVyZURlZmluaXRpb25zW2tleV0gPSB7XG4gICAgICAgIGlzRW5hYmxlZDogKHByb3BzKSA9PiBmZWF0dXJlUHJvcHNba2V5XS5zb21lKChuYW1lKSA9PiAhIXByb3BzW25hbWVdKSxcbiAgICB9O1xufVxuXG4vLyBEb2VzIHRoaXMgZGV2aWNlIHByZWZlciByZWR1Y2VkIG1vdGlvbj8gUmV0dXJucyBgbnVsbGAgc2VydmVyLXNpZGUuXG5jb25zdCBwcmVmZXJzUmVkdWNlZE1vdGlvbiA9IHsgY3VycmVudDogbnVsbCB9O1xuY29uc3QgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyID0geyBjdXJyZW50OiBmYWxzZSB9O1xuXG5mdW5jdGlvbiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gICAgaGFzUmVkdWNlZE1vdGlvbkxpc3RlbmVyLmN1cnJlbnQgPSB0cnVlO1xuICAgIGlmICghaXNCcm93c2VyKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKHdpbmRvdy5tYXRjaE1lZGlhKSB7XG4gICAgICAgIGNvbnN0IG1vdGlvbk1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYShcIihwcmVmZXJzLXJlZHVjZWQtbW90aW9uKVwiKTtcbiAgICAgICAgY29uc3Qgc2V0UmVkdWNlZE1vdGlvblByZWZlcmVuY2VzID0gKCkgPT4gKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQgPSBtb3Rpb25NZWRpYVF1ZXJ5Lm1hdGNoZXMpO1xuICAgICAgICBtb3Rpb25NZWRpYVF1ZXJ5LmFkZExpc3RlbmVyKHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcyk7XG4gICAgICAgIHNldFJlZHVjZWRNb3Rpb25QcmVmZXJlbmNlcygpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcHJlZmVyc1JlZHVjZWRNb3Rpb24uY3VycmVudCA9IGZhbHNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIGxpc3Qgb2YgYWxsIFZhbHVlVHlwZXNcbiAqL1xuY29uc3QgdmFsdWVUeXBlcyA9IFsuLi5kaW1lbnNpb25WYWx1ZVR5cGVzLCBjb2xvciwgY29tcGxleF07XG4vKipcbiAqIFRlc3RzIGEgdmFsdWUgYWdhaW5zdCB0aGUgbGlzdCBvZiBWYWx1ZVR5cGVzXG4gKi9cbmNvbnN0IGZpbmRWYWx1ZVR5cGUgPSAodikgPT4gdmFsdWVUeXBlcy5maW5kKHRlc3RWYWx1ZVR5cGUodikpO1xuXG5mdW5jdGlvbiB1cGRhdGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoZWxlbWVudCwgbmV4dCwgcHJldikge1xuICAgIGZvciAoY29uc3Qga2V5IGluIG5leHQpIHtcbiAgICAgICAgY29uc3QgbmV4dFZhbHVlID0gbmV4dFtrZXldO1xuICAgICAgICBjb25zdCBwcmV2VmFsdWUgPSBwcmV2W2tleV07XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKG5leHRWYWx1ZSkpIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIG1vdGlvbiB2YWx1ZSBmb3VuZCBpbiBwcm9wcyBvciBzdHlsZSwgd2Ugd2FudCB0byBhZGQgaXRcbiAgICAgICAgICAgICAqIHRvIG91ciB2aXN1YWwgZWxlbWVudCdzIG1vdGlvbiB2YWx1ZSBtYXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVsZW1lbnQuYWRkVmFsdWUoa2V5LCBuZXh0VmFsdWUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayB0aGUgdmVyc2lvbiBvZiB0aGUgaW5jb21pbmcgbW90aW9uIHZhbHVlIHdpdGggdGhpcyB2ZXJzaW9uXG4gICAgICAgICAgICAgKiBhbmQgd2FybiBhZ2FpbnN0IG1pc21hdGNoZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gXCJkZXZlbG9wbWVudFwiKSB7XG4gICAgICAgICAgICAgICAgd2Fybk9uY2UobmV4dFZhbHVlLnZlcnNpb24gPT09IFwiMTEuMTguMlwiLCBgQXR0ZW1wdGluZyB0byBtaXggTW90aW9uIHZlcnNpb25zICR7bmV4dFZhbHVlLnZlcnNpb259IHdpdGggMTEuMTguMiBtYXkgbm90IHdvcmsgYXMgZXhwZWN0ZWQuYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNNb3Rpb25WYWx1ZShwcmV2VmFsdWUpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHN3YXBwaW5nIGZyb20gYSBtb3Rpb24gdmFsdWUgdG8gYSBzdGF0aWMgdmFsdWUsXG4gICAgICAgICAgICAgKiBjcmVhdGUgYSBuZXcgbW90aW9uIHZhbHVlIGZyb20gdGhhdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobmV4dFZhbHVlLCB7IG93bmVyOiBlbGVtZW50IH0pKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmV2VmFsdWUgIT09IG5leHRWYWx1ZSkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgZmxhdCB2YWx1ZSB0aGF0IGhhcyBjaGFuZ2VkLCB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZVxuICAgICAgICAgICAgICogb3IgY3JlYXRlIG9uZSBpZiBpdCBkb2Vzbid0IGV4aXN0LiBXZSBvbmx5IHdhbnQgdG8gZG8gdGhpcyBpZiB3ZSdyZVxuICAgICAgICAgICAgICogbm90IGhhbmRsaW5nIHRoZSB2YWx1ZSB3aXRoIG91ciBhbmltYXRpb24gc3RhdGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChlbGVtZW50Lmhhc1ZhbHVlKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gZWxlbWVudC5nZXRWYWx1ZShrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ1ZhbHVlLmxpdmVTdHlsZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ1ZhbHVlLmp1bXAobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWV4aXN0aW5nVmFsdWUuaGFzQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdWYWx1ZS5zZXQobmV4dFZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IGVsZW1lbnQuZ2V0U3RhdGljVmFsdWUoa2V5KTtcbiAgICAgICAgICAgICAgICBlbGVtZW50LmFkZFZhbHVlKGtleSwgbW90aW9uVmFsdWUobGF0ZXN0VmFsdWUgIT09IHVuZGVmaW5lZCA/IGxhdGVzdFZhbHVlIDogbmV4dFZhbHVlLCB7IG93bmVyOiBlbGVtZW50IH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBIYW5kbGUgcmVtb3ZlZCB2YWx1ZXNcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcmV2KSB7XG4gICAgICAgIGlmIChuZXh0W2tleV0gPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGVsZW1lbnQucmVtb3ZlVmFsdWUoa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQ7XG59XG5cbmNvbnN0IHByb3BFdmVudEhhbmRsZXJzID0gW1xuICAgIFwiQW5pbWF0aW9uU3RhcnRcIixcbiAgICBcIkFuaW1hdGlvbkNvbXBsZXRlXCIsXG4gICAgXCJVcGRhdGVcIixcbiAgICBcIkJlZm9yZUxheW91dE1lYXN1cmVcIixcbiAgICBcIkxheW91dE1lYXN1cmVcIixcbiAgICBcIkxheW91dEFuaW1hdGlvblN0YXJ0XCIsXG4gICAgXCJMYXlvdXRBbmltYXRpb25Db21wbGV0ZVwiLFxuXTtcbi8qKlxuICogQSBWaXN1YWxFbGVtZW50IGlzIGFuIGltcGVyYXRpdmUgYWJzdHJhY3Rpb24gYXJvdW5kIFVJIGVsZW1lbnRzIHN1Y2ggYXNcbiAqIEhUTUxFbGVtZW50LCBTVkdFbGVtZW50LCBUaHJlZS5PYmplY3QzRCBldGMuXG4gKi9cbmNsYXNzIFZpc3VhbEVsZW1lbnQge1xuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHRha2VzIFJlYWN0IHByb3BzIGFuZCByZXR1cm5zIGZvdW5kIE1vdGlvblZhbHVlcy4gRm9yIGV4YW1wbGUsIEhUTUxcbiAgICAgKiBNb3Rpb25WYWx1ZXMgd2lsbCBiZSBmb3VuZCB3aXRoaW4gdGhlIHN0eWxlIHByb3AsIHdoZXJlYXMgZm9yIFRocmVlLmpzIHdpdGhpbiBhdHRyaWJ1dGUgYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhpcyBpc24ndCBhbiBhYnN0cmFjdCBtZXRob2QgYXMgaXQgbmVlZHMgY2FsbGluZyBpbiB0aGUgY29uc3RydWN0b3IsIGJ1dCBpdCBpc1xuICAgICAqIGludGVuZGVkIHRvIGJlIG9uZS5cbiAgICAgKi9cbiAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMoX3Byb3BzLCBfcHJldlByb3BzLCBfdmlzdWFsRWxlbWVudCkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKHsgcGFyZW50LCBwcm9wcywgcHJlc2VuY2VDb250ZXh0LCByZWR1Y2VkTW90aW9uQ29uZmlnLCBibG9ja0luaXRpYWxBbmltYXRpb24sIHZpc3VhbFN0YXRlLCB9LCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBjdXJyZW50IHVuZGVybHlpbmcgSW5zdGFuY2UsIGUuZy4gYSBIVE1MRWxlbWVudFxuICAgICAgICAgKiBvciBUaHJlZS5NZXNoIGV0Yy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY3VycmVudCA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHNldCBjb250YWluaW5nIHJlZmVyZW5jZXMgdG8gdGhpcyBWaXN1YWxFbGVtZW50J3MgY2hpbGRyZW4uXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRGV0ZXJtaW5lIHdoYXQgcm9sZSB0aGlzIHZpc3VhbCBlbGVtZW50IHNob3VsZCB0YWtlIGluIHRoZSB2YXJpYW50IHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzVmFyaWFudE5vZGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlY2lkZXMgd2hldGhlciB0aGlzIFZpc3VhbEVsZW1lbnQgc2hvdWxkIGFuaW1hdGUgaW4gcmVkdWNlZCBtb3Rpb25cbiAgICAgICAgICogbW9kZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBjdXJyZW50bHkgc2V0IG9uIGV2ZXJ5IGluZGl2aWR1YWwgVmlzdWFsRWxlbWVudCBidXQgZmVlbHNcbiAgICAgICAgICogbGlrZSBpdCBjb3VsZCBiZSBzZXQgZ2xvYmFsbHkuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiA9IG51bGw7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIG1hcCBvZiBhbGwgbW90aW9uIHZhbHVlcyBhdHRhY2hlZCB0byB0aGlzIHZpc3VhbCBlbGVtZW50LiBNb3Rpb25cbiAgICAgICAgICogdmFsdWVzIGFyZSBzb3VyY2Ugb2YgdHJ1dGggZm9yIGFueSBnaXZlbiBhbmltYXRlZCB2YWx1ZS4gQSBtb3Rpb25cbiAgICAgICAgICogdmFsdWUgbWlnaHQgYmUgcHJvdmlkZWQgZXh0ZXJuYWxseSBieSB0aGUgY29tcG9uZW50IHZpYSBwcm9wcy5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmFsdWVzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLktleWZyYW1lUmVzb2x2ZXIgPSBLZXlmcmFtZVJlc29sdmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2xlYW51cCBmdW5jdGlvbnMgZm9yIGFjdGl2ZSBmZWF0dXJlcyAoaG92ZXIvdGFwL2V4aXQgZXRjKVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5mZWF0dXJlcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQSBtYXAgb2YgZXZlcnkgc3Vic2NyaXB0aW9uIHRoYXQgYmluZHMgdGhlIHByb3ZpZGVkIG9yIGdlbmVyYXRlZFxuICAgICAgICAgKiBtb3Rpb24gdmFsdWVzIG9uQ2hhbmdlIGxpc3RlbmVycyB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcHJldmlvdXNseS1wcm92aWRlZCBtb3Rpb24gdmFsdWVzIGFzIHJldHVybmVkXG4gICAgICAgICAqIGZyb20gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzLiBXZSB1c2UgdGhlIGtleXMgaW4gaGVyZSB0byBkZXRlcm1pbmVcbiAgICAgICAgICogaWYgYW55IG1vdGlvbiB2YWx1ZXMgbmVlZCB0byBiZSByZW1vdmVkIGFmdGVyIHByb3BzIGFyZSB1cGRhdGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcmV2TW90aW9uVmFsdWVzID0ge307XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbiBvYmplY3QgY29udGFpbmluZyBhIFN1YnNjcmlwdGlvbk1hbmFnZXIgZm9yIGVhY2ggYWN0aXZlIGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ldmVudHMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFuIG9iamVjdCBjb250YWluaW5nIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIGZvciBlYWNoIHByb3AgZXZlbnQgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBGb3IgZXhhbXBsZSwgZXZlcnkgXCJVcGRhdGVcIiBldmVudCBjYW4gaGF2ZSBtdWx0aXBsZSBzdWJzY3JpYmVycyB2aWFcbiAgICAgICAgICogVmlzdWFsRWxlbWVudC5vbigpLCBidXQgb25seSBvbmUgb2YgdGhvc2UgY2FuIGJlIGRlZmluZWQgdmlhIHRoZSBvblVwZGF0ZSBwcm9wLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zID0ge307XG4gICAgICAgIHRoaXMubm90aWZ5VXBkYXRlID0gKCkgPT4gdGhpcy5ub3RpZnkoXCJVcGRhdGVcIiwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICB0aGlzLnJlbmRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMudHJpZ2dlckJ1aWxkKCk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckluc3RhbmNlKHRoaXMuY3VycmVudCwgdGhpcy5yZW5kZXJTdGF0ZSwgdGhpcy5wcm9wcy5zdHlsZSwgdGhpcy5wcm9qZWN0aW9uKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5yZW5kZXJTY2hlZHVsZWRBdCA9IDAuMDtcbiAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlciA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHRpbWUubm93KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZW5kZXJTY2hlZHVsZWRBdCA8IG5vdykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyU2NoZWR1bGVkQXQgPSBub3c7XG4gICAgICAgICAgICAgICAgZnJhbWUucmVuZGVyKHRoaXMucmVuZGVyLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHsgbGF0ZXN0VmFsdWVzLCByZW5kZXJTdGF0ZSwgb25VcGRhdGUgfSA9IHZpc3VhbFN0YXRlO1xuICAgICAgICB0aGlzLm9uVXBkYXRlID0gb25VcGRhdGU7XG4gICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzID0gbGF0ZXN0VmFsdWVzO1xuICAgICAgICB0aGlzLmJhc2VUYXJnZXQgPSB7IC4uLmxhdGVzdFZhbHVlcyB9O1xuICAgICAgICB0aGlzLmluaXRpYWxWYWx1ZXMgPSBwcm9wcy5pbml0aWFsID8geyAuLi5sYXRlc3RWYWx1ZXMgfSA6IHt9O1xuICAgICAgICB0aGlzLnJlbmRlclN0YXRlID0gcmVuZGVyU3RhdGU7XG4gICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICB0aGlzLnByb3BzID0gcHJvcHM7XG4gICAgICAgIHRoaXMucHJlc2VuY2VDb250ZXh0ID0gcHJlc2VuY2VDb250ZXh0O1xuICAgICAgICB0aGlzLmRlcHRoID0gcGFyZW50ID8gcGFyZW50LmRlcHRoICsgMSA6IDA7XG4gICAgICAgIHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9IHJlZHVjZWRNb3Rpb25Db25maWc7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuYmxvY2tJbml0aWFsQW5pbWF0aW9uID0gQm9vbGVhbihibG9ja0luaXRpYWxBbmltYXRpb24pO1xuICAgICAgICB0aGlzLmlzQ29udHJvbGxpbmdWYXJpYW50cyA9IGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcyk7XG4gICAgICAgIHRoaXMuaXNWYXJpYW50Tm9kZSA9IGlzVmFyaWFudE5vZGUocHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5pc1ZhcmlhbnROb2RlKSB7XG4gICAgICAgICAgICB0aGlzLnZhcmlhbnRDaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hbnVhbGx5QW5pbWF0ZU9uTW91bnQgPSBCb29sZWFuKHBhcmVudCAmJiBwYXJlbnQuY3VycmVudCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbnkgbW90aW9uIHZhbHVlcyB0aGF0IGFyZSBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB3aGVuIGNyZWF0ZWRcbiAgICAgICAgICogYXJlbid0IHlldCBib3VuZCB0byB0aGUgZWxlbWVudCwgYXMgdGhpcyB3b3VsZCB0ZWNobmljYWxseSBiZSBpbXB1cmUuXG4gICAgICAgICAqIEhvd2V2ZXIsIHdlIGl0ZXJhdGUgdGhyb3VnaCB0aGUgbW90aW9uIHZhbHVlcyBhbmQgc2V0IHRoZW0gdG8gdGhlXG4gICAgICAgICAqIGluaXRpYWwgdmFsdWVzIGZvciB0aGlzIGNvbXBvbmVudC5cbiAgICAgICAgICpcbiAgICAgICAgICogVE9ETzogVGhpcyBpcyBpbXB1cmUgYW5kIHdlIHNob3VsZCBsb29rIGF0IGNoYW5naW5nIHRoaXMgdG8gcnVuIG9uIG1vdW50LlxuICAgICAgICAgKiBEb2luZyBzbyB3aWxsIGJyZWFrIHNvbWUgdGVzdHMgYnV0IHRoaXMgaXNuJ3QgbmVjZXNzYXJpbHkgYSBicmVha2luZyBjaGFuZ2UsXG4gICAgICAgICAqIG1vcmUgYSByZWZsZWN0aW9uIG9mIHRoZSB0ZXN0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyB3aWxsQ2hhbmdlLCAuLi5pbml0aWFsTW90aW9uVmFsdWVzIH0gPSB0aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywge30sIHRoaXMpO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBpbml0aWFsTW90aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluaXRpYWxNb3Rpb25WYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmIGlzTW90aW9uVmFsdWUodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUuc2V0KGxhdGVzdFZhbHVlc1trZXldLCBmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbW91bnQoaW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gaW5zdGFuY2U7XG4gICAgICAgIHZpc3VhbEVsZW1lbnRTdG9yZS5zZXQoaW5zdGFuY2UsIHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5wcm9qZWN0aW9uICYmICF0aGlzLnByb2plY3Rpb24uaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbi5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucGFyZW50ICYmIHRoaXMuaXNWYXJpYW50Tm9kZSAmJiAhdGhpcy5pc0NvbnRyb2xsaW5nVmFyaWFudHMpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlRnJvbVZhcmlhbnRUcmVlID0gdGhpcy5wYXJlbnQuYWRkVmFyaWFudENoaWxkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHRoaXMuYmluZFRvTW90aW9uVmFsdWUoa2V5LCB2YWx1ZSkpO1xuICAgICAgICBpZiAoIWhhc1JlZHVjZWRNb3Rpb25MaXN0ZW5lci5jdXJyZW50KSB7XG4gICAgICAgICAgICBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiA9XG4gICAgICAgICAgICB0aGlzLnJlZHVjZWRNb3Rpb25Db25maWcgPT09IFwibmV2ZXJcIlxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXMucmVkdWNlZE1vdGlvbkNvbmZpZyA9PT0gXCJhbHdheXNcIlxuICAgICAgICAgICAgICAgICAgICA/IHRydWVcbiAgICAgICAgICAgICAgICAgICAgOiBwcmVmZXJzUmVkdWNlZE1vdGlvbi5jdXJyZW50O1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgICAgICB3YXJuT25jZSh0aGlzLnNob3VsZFJlZHVjZU1vdGlvbiAhPT0gdHJ1ZSwgXCJZb3UgaGF2ZSBSZWR1Y2VkIE1vdGlvbiBlbmFibGVkIG9uIHlvdXIgZGV2aWNlLiBBbmltYXRpb25zIG1heSBub3QgYXBwZWFyIGFzIGV4cGVjdGVkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5wYXJlbnQpXG4gICAgICAgICAgICB0aGlzLnBhcmVudC5jaGlsZHJlbi5hZGQodGhpcyk7XG4gICAgICAgIHRoaXMudXBkYXRlKHRoaXMucHJvcHMsIHRoaXMucHJlc2VuY2VDb250ZXh0KTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudFN0b3JlLmRlbGV0ZSh0aGlzLmN1cnJlbnQpO1xuICAgICAgICB0aGlzLnByb2plY3Rpb24gJiYgdGhpcy5wcm9qZWN0aW9uLnVubW91bnQoKTtcbiAgICAgICAgY2FuY2VsRnJhbWUodGhpcy5ub3RpZnlVcGRhdGUpO1xuICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLnJlbmRlcik7XG4gICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmZvckVhY2goKHJlbW92ZSkgPT4gcmVtb3ZlKCkpO1xuICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5jbGVhcigpO1xuICAgICAgICB0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSAmJiB0aGlzLnJlbW92ZUZyb21WYXJpYW50VHJlZSgpO1xuICAgICAgICB0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5jaGlsZHJlbi5kZWxldGUodGhpcyk7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuZXZlbnRzKSB7XG4gICAgICAgICAgICB0aGlzLmV2ZW50c1trZXldLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5mZWF0dXJlcykge1xuICAgICAgICAgICAgY29uc3QgZmVhdHVyZSA9IHRoaXMuZmVhdHVyZXNba2V5XTtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS51bm1vdW50KCk7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5pc01vdW50ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgICBiaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgdGhpcy52YWx1ZVN1YnNjcmlwdGlvbnMuZ2V0KGtleSkoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZUlzVHJhbnNmb3JtID0gdHJhbnNmb3JtUHJvcHMuaGFzKGtleSk7XG4gICAgICAgIGNvbnN0IHJlbW92ZU9uQ2hhbmdlID0gdmFsdWUub24oXCJjaGFuZ2VcIiwgKGxhdGVzdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gbGF0ZXN0VmFsdWU7XG4gICAgICAgICAgICB0aGlzLnByb3BzLm9uVXBkYXRlICYmIGZyYW1lLnByZVJlbmRlcih0aGlzLm5vdGlmeVVwZGF0ZSk7XG4gICAgICAgICAgICBpZiAodmFsdWVJc1RyYW5zZm9ybSAmJiB0aGlzLnByb2plY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb24uaXNUcmFuc2Zvcm1EaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZW1vdmVPblJlbmRlclJlcXVlc3QgPSB2YWx1ZS5vbihcInJlbmRlclJlcXVlc3RcIiwgdGhpcy5zY2hlZHVsZVJlbmRlcik7XG4gICAgICAgIGxldCByZW1vdmVTeW5jQ2hlY2s7XG4gICAgICAgIGlmICh3aW5kb3cuTW90aW9uQ2hlY2tBcHBlYXJTeW5jKSB7XG4gICAgICAgICAgICByZW1vdmVTeW5jQ2hlY2sgPSB3aW5kb3cuTW90aW9uQ2hlY2tBcHBlYXJTeW5jKHRoaXMsIGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLnNldChrZXksICgpID0+IHtcbiAgICAgICAgICAgIHJlbW92ZU9uQ2hhbmdlKCk7XG4gICAgICAgICAgICByZW1vdmVPblJlbmRlclJlcXVlc3QoKTtcbiAgICAgICAgICAgIGlmIChyZW1vdmVTeW5jQ2hlY2spXG4gICAgICAgICAgICAgICAgcmVtb3ZlU3luY0NoZWNrKCk7XG4gICAgICAgICAgICBpZiAodmFsdWUub3duZXIpXG4gICAgICAgICAgICAgICAgdmFsdWUuc3RvcCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc29ydE5vZGVQb3NpdGlvbihvdGhlcikge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlc2Ugbm9kZXMgYXJlbid0IGV2ZW4gb2YgdGhlIHNhbWUgdHlwZSB3ZSBjYW4ndCBjb21wYXJlIHRoZWlyIGRlcHRoLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnQgfHxcbiAgICAgICAgICAgICF0aGlzLnNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbiB8fFxuICAgICAgICAgICAgdGhpcy50eXBlICE9PSBvdGhlci50eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zb3J0SW5zdGFuY2VOb2RlUG9zaXRpb24odGhpcy5jdXJyZW50LCBvdGhlci5jdXJyZW50KTtcbiAgICB9XG4gICAgdXBkYXRlRmVhdHVyZXMoKSB7XG4gICAgICAgIGxldCBrZXkgPSBcImFuaW1hdGlvblwiO1xuICAgICAgICBmb3IgKGtleSBpbiBmZWF0dXJlRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGZlYXR1cmVEZWZpbml0aW9uID0gZmVhdHVyZURlZmluaXRpb25zW2tleV07XG4gICAgICAgICAgICBpZiAoIWZlYXR1cmVEZWZpbml0aW9uKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgY29uc3QgeyBpc0VuYWJsZWQsIEZlYXR1cmU6IEZlYXR1cmVDb25zdHJ1Y3RvciB9ID0gZmVhdHVyZURlZmluaXRpb247XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgZmVhdHVyZSBpcyBlbmFibGVkIGJ1dCBub3QgYWN0aXZlLCBtYWtlIGEgbmV3IGluc3RhbmNlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMuZmVhdHVyZXNba2V5XSAmJlxuICAgICAgICAgICAgICAgIEZlYXR1cmVDb25zdHJ1Y3RvciAmJlxuICAgICAgICAgICAgICAgIGlzRW5hYmxlZCh0aGlzLnByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZXNba2V5XSA9IG5ldyBGZWF0dXJlQ29uc3RydWN0b3IodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgYSBmZWF0dXJlLCBtb3VudCBvciB1cGRhdGUgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVzW2tleV0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmZWF0dXJlID0gdGhpcy5mZWF0dXJlc1trZXldO1xuICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlLmlzTW91bnRlZCkge1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5tb3VudCgpO1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmlzTW91bnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXJCdWlsZCgpIHtcbiAgICAgICAgdGhpcy5idWlsZCh0aGlzLnJlbmRlclN0YXRlLCB0aGlzLmxhdGVzdFZhbHVlcywgdGhpcy5wcm9wcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lYXN1cmUgdGhlIGN1cnJlbnQgdmlld3BvcnQgYm94IHdpdGggb3Igd2l0aG91dCB0cmFuc2Zvcm1zLlxuICAgICAqIE9ubHkgbWVhc3VyZXMgYXhpcy1hbGlnbmVkIGJveGVzLCByb3RhdGUgYW5kIHNrZXcgbXVzdCBiZSBtYW51YWxseVxuICAgICAqIHJlbW92ZWQgd2l0aCBhIHJlLXJlbmRlciB0byB3b3JrLlxuICAgICAqL1xuICAgIG1lYXN1cmVWaWV3cG9ydEJveCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudFxuICAgICAgICAgICAgPyB0aGlzLm1lYXN1cmVJbnN0YW5jZVZpZXdwb3J0Qm94KHRoaXMuY3VycmVudCwgdGhpcy5wcm9wcylcbiAgICAgICAgICAgIDogY3JlYXRlQm94KCk7XG4gICAgfVxuICAgIGdldFN0YXRpY1ZhbHVlKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXRlc3RWYWx1ZXNba2V5XTtcbiAgICB9XG4gICAgc2V0U3RhdGljVmFsdWUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmxhdGVzdFZhbHVlc1trZXldID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZGF0ZSB0aGUgcHJvdmlkZWQgcHJvcHMuIEVuc3VyZSBhbnkgbmV3bHktYWRkZWQgbW90aW9uIHZhbHVlcyBhcmVcbiAgICAgKiBhZGRlZCB0byBvdXIgbWFwLCBvbGQgb25lcyByZW1vdmVkLCBhbmQgbGlzdGVuZXJzIHVwZGF0ZWQuXG4gICAgICovXG4gICAgdXBkYXRlKHByb3BzLCBwcmVzZW5jZUNvbnRleHQpIHtcbiAgICAgICAgaWYgKHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlIHx8IHRoaXMucHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXZQcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICAgIHRoaXMucHJvcHMgPSBwcm9wcztcbiAgICAgICAgdGhpcy5wcmV2UHJlc2VuY2VDb250ZXh0ID0gdGhpcy5wcmVzZW5jZUNvbnRleHQ7XG4gICAgICAgIHRoaXMucHJlc2VuY2VDb250ZXh0ID0gcHJlc2VuY2VDb250ZXh0O1xuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHByb3AgZXZlbnQgaGFuZGxlcnMgaWUgb25BbmltYXRpb25TdGFydCwgb25BbmltYXRpb25Db21wbGV0ZVxuICAgICAgICAgKi9cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcm9wRXZlbnRIYW5kbGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcHJvcEV2ZW50SGFuZGxlcnNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XSgpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnByb3BFdmVudFN1YnNjcmlwdGlvbnNba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVyTmFtZSA9IChcIm9uXCIgKyBrZXkpO1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXIgPSBwcm9wc1tsaXN0ZW5lck5hbWVdO1xuICAgICAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wRXZlbnRTdWJzY3JpcHRpb25zW2tleV0gPSB0aGlzLm9uKGtleSwgbGlzdGVuZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucHJldk1vdGlvblZhbHVlcyA9IHVwZGF0ZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyh0aGlzLCB0aGlzLnNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgdGhpcy5wcmV2UHJvcHMsIHRoaXMpLCB0aGlzLnByZXZNb3Rpb25WYWx1ZXMpO1xuICAgICAgICBpZiAodGhpcy5oYW5kbGVDaGlsZE1vdGlvblZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUNoaWxkTW90aW9uVmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uVXBkYXRlICYmIHRoaXMub25VcGRhdGUodGhpcyk7XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgdmFyaWFudCBkZWZpbml0aW9uIHdpdGggYSBnaXZlbiBuYW1lLlxuICAgICAqL1xuICAgIGdldFZhcmlhbnQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy52YXJpYW50cyA/IHRoaXMucHJvcHMudmFyaWFudHNbbmFtZV0gOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlZmluZWQgZGVmYXVsdCB0cmFuc2l0aW9uIG9uIHRoaXMgY29tcG9uZW50LlxuICAgICAqL1xuICAgIGdldERlZmF1bHRUcmFuc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy50cmFuc2l0aW9uO1xuICAgIH1cbiAgICBnZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb3BzLnRyYW5zZm9ybVBhZ2VQb2ludDtcbiAgICB9XG4gICAgZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc1ZhcmlhbnROb2RlXG4gICAgICAgICAgICA/IHRoaXNcbiAgICAgICAgICAgIDogdGhpcy5wYXJlbnRcbiAgICAgICAgICAgICAgICA/IHRoaXMucGFyZW50LmdldENsb3Nlc3RWYXJpYW50Tm9kZSgpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIGNoaWxkIHZpc3VhbCBlbGVtZW50IHRvIG91ciBzZXQgb2YgY2hpbGRyZW4uXG4gICAgICovXG4gICAgYWRkVmFyaWFudENoaWxkKGNoaWxkKSB7XG4gICAgICAgIGNvbnN0IGNsb3Nlc3RWYXJpYW50Tm9kZSA9IHRoaXMuZ2V0Q2xvc2VzdFZhcmlhbnROb2RlKCk7XG4gICAgICAgIGlmIChjbG9zZXN0VmFyaWFudE5vZGUpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RWYXJpYW50Tm9kZS52YXJpYW50Q2hpbGRyZW4gJiZcbiAgICAgICAgICAgICAgICBjbG9zZXN0VmFyaWFudE5vZGUudmFyaWFudENoaWxkcmVuLmFkZChjaGlsZCk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4gY2xvc2VzdFZhcmlhbnROb2RlLnZhcmlhbnRDaGlsZHJlbi5kZWxldGUoY2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG1vdGlvbiB2YWx1ZSBhbmQgYmluZCBpdCB0byB0aGlzIHZpc3VhbCBlbGVtZW50LlxuICAgICAqL1xuICAgIGFkZFZhbHVlKGtleSwgdmFsdWUpIHtcbiAgICAgICAgLy8gUmVtb3ZlIGV4aXN0aW5nIHZhbHVlIGlmIGl0IGV4aXN0c1xuICAgICAgICBjb25zdCBleGlzdGluZ1ZhbHVlID0gdGhpcy52YWx1ZXMuZ2V0KGtleSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPT0gZXhpc3RpbmdWYWx1ZSkge1xuICAgICAgICAgICAgaWYgKGV4aXN0aW5nVmFsdWUpXG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVWYWx1ZShrZXkpO1xuICAgICAgICAgICAgdGhpcy5iaW5kVG9Nb3Rpb25WYWx1ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gPSB2YWx1ZS5nZXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBtb3Rpb24gdmFsdWUgYW5kIHVuYmluZCBhbnkgYWN0aXZlIHN1YnNjcmlwdGlvbnMuXG4gICAgICovXG4gICAgcmVtb3ZlVmFsdWUoa2V5KSB7XG4gICAgICAgIHRoaXMudmFsdWVzLmRlbGV0ZShrZXkpO1xuICAgICAgICBjb25zdCB1bnN1YnNjcmliZSA9IHRoaXMudmFsdWVTdWJzY3JpcHRpb25zLmdldChrZXkpO1xuICAgICAgICBpZiAodW5zdWJzY3JpYmUpIHtcbiAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlU3Vic2NyaXB0aW9ucy5kZWxldGUoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5sYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgdGhpcy5yZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHRoaXMucmVuZGVyU3RhdGUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIHdlIGhhdmUgYSBtb3Rpb24gdmFsdWUgZm9yIHRoaXMga2V5XG4gICAgICovXG4gICAgaGFzVmFsdWUoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZhbHVlcy5oYXMoa2V5KTtcbiAgICB9XG4gICAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMucHJvcHMudmFsdWVzICYmIHRoaXMucHJvcHMudmFsdWVzW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3BzLnZhbHVlc1trZXldO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMudmFsdWVzLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiBkZWZhdWx0VmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBtb3Rpb25WYWx1ZShkZWZhdWx0VmFsdWUgPT09IG51bGwgPyB1bmRlZmluZWQgOiBkZWZhdWx0VmFsdWUsIHsgb3duZXI6IHRoaXMgfSk7XG4gICAgICAgICAgICB0aGlzLmFkZFZhbHVlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgd2UncmUgdHJ5aW5nIHRvIGFuaW1hdGUgdG8gYSBwcmV2aW91c2x5IHVuZW5jb3VudGVyZWQgdmFsdWUsXG4gICAgICogd2UgbmVlZCB0byBjaGVjayBmb3IgaXQgaW4gb3VyIHN0YXRlIGFuZCBhcyBhIGxhc3QgcmVzb3J0IHJlYWQgaXRcbiAgICAgKiBkaXJlY3RseSBmcm9tIHRoZSBpbnN0YW5jZSAod2hpY2ggbWlnaHQgaGF2ZSBwZXJmb3JtYW5jZSBpbXBsaWNhdGlvbnMpLlxuICAgICAqL1xuICAgIHJlYWRWYWx1ZShrZXksIHRhcmdldCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGxldCB2YWx1ZSA9IHRoaXMubGF0ZXN0VmFsdWVzW2tleV0gIT09IHVuZGVmaW5lZCB8fCAhdGhpcy5jdXJyZW50XG4gICAgICAgICAgICA/IHRoaXMubGF0ZXN0VmFsdWVzW2tleV1cbiAgICAgICAgICAgIDogKF9hID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IHRoaXMucmVhZFZhbHVlRnJvbUluc3RhbmNlKHRoaXMuY3VycmVudCwga2V5LCB0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCAmJiB2YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIChpc051bWVyaWNhbFN0cmluZyh2YWx1ZSkgfHwgaXNaZXJvVmFsdWVTdHJpbmcodmFsdWUpKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBudW1iZXIgcmVhZCBhcyBhIHN0cmluZywgaWUgXCIwXCIgb3IgXCIyMDBcIiwgY29udmVydCBpdCB0byBhIG51bWJlclxuICAgICAgICAgICAgICAgIHZhbHVlID0gcGFyc2VGbG9hdCh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICghZmluZFZhbHVlVHlwZSh2YWx1ZSkgJiYgY29tcGxleC50ZXN0KHRhcmdldCkpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldEFuaW1hdGFibGVOb25lKGtleSwgdGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0QmFzZVRhcmdldChrZXksIGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGlzTW90aW9uVmFsdWUodmFsdWUpID8gdmFsdWUuZ2V0KCkgOiB2YWx1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBiYXNlIHRhcmdldCB0byBsYXRlciBhbmltYXRlIGJhY2sgdG8uIFRoaXMgaXMgY3VycmVudGx5XG4gICAgICogb25seSBoeWRyYXRlZCBvbiBjcmVhdGlvbiBhbmQgd2hlbiB3ZSBmaXJzdCByZWFkIGEgdmFsdWUuXG4gICAgICovXG4gICAgc2V0QmFzZVRhcmdldChrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuYmFzZVRhcmdldFtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgdGhlIGJhc2UgdGFyZ2V0IGZvciBhIHZhbHVlIHRoYXRzIGJlZW4gcmVtb3ZlZCBmcm9tIGFsbCBhbmltYXRpb25cbiAgICAgKiBwcm9wcy5cbiAgICAgKi9cbiAgICBnZXRCYXNlVGFyZ2V0KGtleSkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgaW5pdGlhbCB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgbGV0IHZhbHVlRnJvbUluaXRpYWw7XG4gICAgICAgIGlmICh0eXBlb2YgaW5pdGlhbCA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgaW5pdGlhbCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc3QgdmFyaWFudCA9IHJlc29sdmVWYXJpYW50RnJvbVByb3BzKHRoaXMucHJvcHMsIGluaXRpYWwsIChfYSA9IHRoaXMucHJlc2VuY2VDb250ZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY3VzdG9tKTtcbiAgICAgICAgICAgIGlmICh2YXJpYW50KSB7XG4gICAgICAgICAgICAgICAgdmFsdWVGcm9tSW5pdGlhbCA9IHZhcmlhbnRba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyB2YWx1ZSBzdGlsbCBleGlzdHMgaW4gdGhlIGN1cnJlbnQgaW5pdGlhbCB2YXJpYW50LCByZWFkIHRoYXQuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoaW5pdGlhbCAmJiB2YWx1ZUZyb21Jbml0aWFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZUZyb21Jbml0aWFsO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBbHRlcm5hdGl2ZWx5LCBpZiB0aGlzIFZpc3VhbEVsZW1lbnQgY29uZmlnIGhhcyBkZWZpbmVkIGEgZ2V0QmFzZVRhcmdldFxuICAgICAgICAgKiBzbyB3ZSBjYW4gcmVhZCB0aGUgdmFsdWUgZnJvbSBhbiBhbHRlcm5hdGl2ZSBzb3VyY2UsIHRyeSB0aGF0LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRCYXNlVGFyZ2V0RnJvbVByb3BzKHRoaXMucHJvcHMsIGtleSk7XG4gICAgICAgIGlmICh0YXJnZXQgIT09IHVuZGVmaW5lZCAmJiAhaXNNb3Rpb25WYWx1ZSh0YXJnZXQpKVxuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHRoZSB2YWx1ZSB3YXMgaW5pdGlhbGx5IGRlZmluZWQgb24gaW5pdGlhbCwgYnV0IGl0IGRvZXNuJ3QgYW55IG1vcmUsXG4gICAgICAgICAqIHJldHVybiB1bmRlZmluZWQuIE90aGVyd2lzZSByZXR1cm4gdGhlIHZhbHVlIGFzIGluaXRpYWxseSByZWFkIGZyb20gdGhlIERPTS5cbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiB0aGlzLmluaXRpYWxWYWx1ZXNba2V5XSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB2YWx1ZUZyb21Jbml0aWFsID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHRoaXMuYmFzZVRhcmdldFtrZXldO1xuICAgIH1cbiAgICBvbihldmVudE5hbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXSA9IG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW2V2ZW50TmFtZV0uYWRkKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgbm90aWZ5KGV2ZW50TmFtZSwgLi4uYXJncykge1xuICAgICAgICBpZiAodGhpcy5ldmVudHNbZXZlbnROYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudHNbZXZlbnROYW1lXS5ub3RpZnkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmNsYXNzIERPTVZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5LZXlmcmFtZVJlc29sdmVyID0gRE9NS2V5ZnJhbWVzUmVzb2x2ZXI7XG4gICAgfVxuICAgIHNvcnRJbnN0YW5jZU5vZGVQb3NpdGlvbihhLCBiKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjb21wYXJlRG9jdW1lbnRQb3NpdGlvbiByZXR1cm5zIGEgYml0bWFzaywgYnkgdXNpbmcgdGhlIGJpdHdpc2UgJlxuICAgICAgICAgKiB3ZSdyZSByZXR1cm5pbmcgdHJ1ZSBpZiAyIGluIHRoYXQgYml0bWFzayBpcyBzZXQgdG8gdHJ1ZS4gMiBpcyBzZXRcbiAgICAgICAgICogdG8gdHJ1ZSBpZiBiIHByZWNlZWRzIGEuXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDIgPyAxIDogLTE7XG4gICAgfVxuICAgIGdldEJhc2VUYXJnZXRGcm9tUHJvcHMocHJvcHMsIGtleSkge1xuICAgICAgICByZXR1cm4gcHJvcHMuc3R5bGVcbiAgICAgICAgICAgID8gcHJvcHMuc3R5bGVba2V5XVxuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIHJlbW92ZVZhbHVlRnJvbVJlbmRlclN0YXRlKGtleSwgeyB2YXJzLCBzdHlsZSB9KSB7XG4gICAgICAgIGRlbGV0ZSB2YXJzW2tleV07XG4gICAgICAgIGRlbGV0ZSBzdHlsZVtrZXldO1xuICAgIH1cbiAgICBoYW5kbGVDaGlsZE1vdGlvblZhbHVlKCkge1xuICAgICAgICBpZiAodGhpcy5jaGlsZFN1YnNjcmlwdGlvbikge1xuICAgICAgICAgICAgdGhpcy5jaGlsZFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuY2hpbGRTdWJzY3JpcHRpb247XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gdGhpcy5wcm9wcztcbiAgICAgICAgaWYgKGlzTW90aW9uVmFsdWUoY2hpbGRyZW4pKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkU3Vic2NyaXB0aW9uID0gY2hpbGRyZW4ub24oXCJjaGFuZ2VcIiwgKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50LnRleHRDb250ZW50ID0gYCR7bGF0ZXN0fWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogUHJvdmlkZWQgYSB2YWx1ZSBhbmQgYSBWYWx1ZVR5cGUsIHJldHVybnMgdGhlIHZhbHVlIGFzIHRoYXQgdmFsdWUgdHlwZS5cbiAqL1xuY29uc3QgZ2V0VmFsdWVBc1R5cGUgPSAodmFsdWUsIHR5cGUpID0+IHtcbiAgICByZXR1cm4gdHlwZSAmJiB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCJcbiAgICAgICAgPyB0eXBlLnRyYW5zZm9ybSh2YWx1ZSlcbiAgICAgICAgOiB2YWx1ZTtcbn07XG5cbmNvbnN0IHRyYW5zbGF0ZUFsaWFzID0ge1xuICAgIHg6IFwidHJhbnNsYXRlWFwiLFxuICAgIHk6IFwidHJhbnNsYXRlWVwiLFxuICAgIHo6IFwidHJhbnNsYXRlWlwiLFxuICAgIHRyYW5zZm9ybVBlcnNwZWN0aXZlOiBcInBlcnNwZWN0aXZlXCIsXG59O1xuY29uc3QgbnVtVHJhbnNmb3JtcyA9IHRyYW5zZm9ybVByb3BPcmRlci5sZW5ndGg7XG4vKipcbiAqIEJ1aWxkIGEgQ1NTIHRyYW5zZm9ybSBzdHlsZSBmcm9tIGluZGl2aWR1YWwgeC95L3NjYWxlIGV0YyBwcm9wZXJ0aWVzLlxuICpcbiAqIFRoaXMgb3V0cHV0cyB3aXRoIGEgZGVmYXVsdCBvcmRlciBvZiB0cmFuc2Zvcm1zL3NjYWxlcy9yb3RhdGlvbnMsIHRoaXMgY2FuIGJlIGN1c3RvbWlzZWQgYnlcbiAqIHByb3ZpZGluZyBhIHRyYW5zZm9ybVRlbXBsYXRlIGZ1bmN0aW9uLlxuICovXG5mdW5jdGlvbiBidWlsZFRyYW5zZm9ybShsYXRlc3RWYWx1ZXMsIHRyYW5zZm9ybSwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAvLyBUaGUgdHJhbnNmb3JtIHN0cmluZyB3ZSdyZSBnb2luZyB0byBidWlsZCBpbnRvLlxuICAgIGxldCB0cmFuc2Zvcm1TdHJpbmcgPSBcIlwiO1xuICAgIGxldCB0cmFuc2Zvcm1Jc0RlZmF1bHQgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIExvb3Agb3ZlciBhbGwgcG9zc2libGUgdHJhbnNmb3JtcyBpbiBvcmRlciwgYWRkaW5nIHRoZSBvbmVzIHRoYXRcbiAgICAgKiBhcmUgcHJlc2VudCB0byB0aGUgdHJhbnNmb3JtIHN0cmluZy5cbiAgICAgKi9cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVRyYW5zZm9ybXM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXkgPSB0cmFuc2Zvcm1Qcm9wT3JkZXJbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbGF0ZXN0VmFsdWVzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCB2YWx1ZUlzRGVmYXVsdCA9IHRydWU7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlSXNEZWZhdWx0ID0gdmFsdWUgPT09IChrZXkuc3RhcnRzV2l0aChcInNjYWxlXCIpID8gMSA6IDApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVJc0RlZmF1bHQgPSBwYXJzZUZsb2F0KHZhbHVlKSA9PT0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbHVlSXNEZWZhdWx0IHx8IHRyYW5zZm9ybVRlbXBsYXRlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUFzVHlwZSA9IGdldFZhbHVlQXNUeXBlKHZhbHVlLCBudW1iZXJWYWx1ZVR5cGVzW2tleV0pO1xuICAgICAgICAgICAgaWYgKCF2YWx1ZUlzRGVmYXVsdCkge1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUlzRGVmYXVsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybU5hbWUgPSB0cmFuc2xhdGVBbGlhc1trZXldIHx8IGtleTtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgKz0gYCR7dHJhbnNmb3JtTmFtZX0oJHt2YWx1ZUFzVHlwZX0pIGA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1ba2V5XSA9IHZhbHVlQXNUeXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHRyYW5zZm9ybVN0cmluZyA9IHRyYW5zZm9ybVN0cmluZy50cmltKCk7XG4gICAgLy8gSWYgd2UgaGF2ZSBhIGN1c3RvbSBgdHJhbnNmb3JtYCB0ZW1wbGF0ZSwgcGFzcyBvdXIgdHJhbnNmb3JtIHZhbHVlcyBhbmRcbiAgICAvLyBnZW5lcmF0ZWQgdHJhbnNmb3JtU3RyaW5nIHRvIHRoYXQgYmVmb3JlIHJldHVybmluZ1xuICAgIGlmICh0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgICAgICB0cmFuc2Zvcm1TdHJpbmcgPSB0cmFuc2Zvcm1UZW1wbGF0ZSh0cmFuc2Zvcm0sIHRyYW5zZm9ybUlzRGVmYXVsdCA/IFwiXCIgOiB0cmFuc2Zvcm1TdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0cmFuc2Zvcm1Jc0RlZmF1bHQpIHtcbiAgICAgICAgdHJhbnNmb3JtU3RyaW5nID0gXCJub25lXCI7XG4gICAgfVxuICAgIHJldHVybiB0cmFuc2Zvcm1TdHJpbmc7XG59XG5cbmZ1bmN0aW9uIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0VmFsdWVzLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIGNvbnN0IHsgc3R5bGUsIHZhcnMsIHRyYW5zZm9ybU9yaWdpbiB9ID0gc3RhdGU7XG4gICAgLy8gVHJhY2sgd2hldGhlciB3ZSBlbmNvdW50ZXIgYW55IHRyYW5zZm9ybSBvciB0cmFuc2Zvcm1PcmlnaW4gdmFsdWVzLlxuICAgIGxldCBoYXNUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICBsZXQgaGFzVHJhbnNmb3JtT3JpZ2luID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogTG9vcCBvdmVyIGFsbCBvdXIgbGF0ZXN0IGFuaW1hdGVkIHZhbHVlcyBhbmQgZGVjaWRlIHdoZXRoZXIgdG8gaGFuZGxlIHRoZW1cbiAgICAgKiBhcyBhIHN0eWxlIG9yIENTUyB2YXJpYWJsZS5cbiAgICAgKlxuICAgICAqIFRyYW5zZm9ybXMgYW5kIHRyYW5zZm9ybSBvcmlnaW5zIGFyZSBrZXB0IHNlcGFyYXRlbHkgZm9yIGZ1cnRoZXIgcHJvY2Vzc2luZy5cbiAgICAgKi9cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBsYXRlc3RWYWx1ZXMpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBsYXRlc3RWYWx1ZXNba2V5XTtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGlzIGlzIGEgdHJhbnNmb3JtLCBmbGFnIHRvIGVuYWJsZSBmdXJ0aGVyIHRyYW5zZm9ybSBwcm9jZXNzaW5nXG4gICAgICAgICAgICBoYXNUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNDU1NWYXJpYWJsZU5hbWUoa2V5KSkge1xuICAgICAgICAgICAgdmFyc1trZXldID0gdmFsdWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHZhbHVlIHRvIGl0cyBkZWZhdWx0IHZhbHVlIHR5cGUsIGllIDAgLT4gXCIwcHhcIlxuICAgICAgICAgICAgY29uc3QgdmFsdWVBc1R5cGUgPSBnZXRWYWx1ZUFzVHlwZSh2YWx1ZSwgbnVtYmVyVmFsdWVUeXBlc1trZXldKTtcbiAgICAgICAgICAgIGlmIChrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSkge1xuICAgICAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSB0cmFuc2Zvcm0gb3JpZ2luLCBmbGFnIGFuZCBlbmFibGUgZnVydGhlciB0cmFuc2Zvcm0tb3JpZ2luIHByb2Nlc3NpbmdcbiAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm1PcmlnaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbltrZXldID1cbiAgICAgICAgICAgICAgICAgICAgdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZVtrZXldID0gdmFsdWVBc1R5cGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFsYXRlc3RWYWx1ZXMudHJhbnNmb3JtKSB7XG4gICAgICAgIGlmIChoYXNUcmFuc2Zvcm0gfHwgdHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGJ1aWxkVHJhbnNmb3JtKGxhdGVzdFZhbHVlcywgc3RhdGUudHJhbnNmb3JtLCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3R5bGUudHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgcHJldmlvdXNseSBjcmVhdGVkIGEgdHJhbnNmb3JtIGJ1dCBjdXJyZW50bHkgZG9uJ3QgaGF2ZSBhbnksXG4gICAgICAgICAgICAgKiByZXNldCB0cmFuc2Zvcm0gc3R5bGUgdG8gbm9uZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3R5bGUudHJhbnNmb3JtID0gXCJub25lXCI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGQgYSB0cmFuc2Zvcm1PcmlnaW4gc3R5bGUuIFVzZXMgdGhlIHNhbWUgZGVmYXVsdHMgYXMgdGhlIGJyb3dzZXIgZm9yXG4gICAgICogdW5kZWZpbmVkIG9yaWdpbnMuXG4gICAgICovXG4gICAgaWYgKGhhc1RyYW5zZm9ybU9yaWdpbikge1xuICAgICAgICBjb25zdCB7IG9yaWdpblggPSBcIjUwJVwiLCBvcmlnaW5ZID0gXCI1MCVcIiwgb3JpZ2luWiA9IDAsIH0gPSB0cmFuc2Zvcm1PcmlnaW47XG4gICAgICAgIHN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IGAke29yaWdpblh9ICR7b3JpZ2luWX0gJHtvcmlnaW5afWA7XG4gICAgfVxufVxuXG5jb25zdCBkYXNoS2V5cyA9IHtcbiAgICBvZmZzZXQ6IFwic3Ryb2tlLWRhc2hvZmZzZXRcIixcbiAgICBhcnJheTogXCJzdHJva2UtZGFzaGFycmF5XCIsXG59O1xuY29uc3QgY2FtZWxLZXlzID0ge1xuICAgIG9mZnNldDogXCJzdHJva2VEYXNob2Zmc2V0XCIsXG4gICAgYXJyYXk6IFwic3Ryb2tlRGFzaGFycmF5XCIsXG59O1xuLyoqXG4gKiBCdWlsZCBTVkcgcGF0aCBwcm9wZXJ0aWVzLiBVc2VzIHRoZSBwYXRoJ3MgbWVhc3VyZWQgbGVuZ3RoIHRvIGNvbnZlcnRcbiAqIG91ciBjdXN0b20gcGF0aExlbmd0aCwgcGF0aFNwYWNpbmcgYW5kIHBhdGhPZmZzZXQgaW50byBzdHJva2UtZGFzaG9mZnNldFxuICogYW5kIHN0cm9rZS1kYXNoYXJyYXkgYXR0cmlidXRlcy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGlzIG11dGF0aXZlIHRvIHJlZHVjZSBwZXItZnJhbWUgR0MuXG4gKi9cbmZ1bmN0aW9uIGJ1aWxkU1ZHUGF0aChhdHRycywgbGVuZ3RoLCBzcGFjaW5nID0gMSwgb2Zmc2V0ID0gMCwgdXNlRGFzaENhc2UgPSB0cnVlKSB7XG4gICAgLy8gTm9ybWFsaXNlIHBhdGggbGVuZ3RoIGJ5IHNldHRpbmcgU1ZHIGF0dHJpYnV0ZSBwYXRoTGVuZ3RoIHRvIDFcbiAgICBhdHRycy5wYXRoTGVuZ3RoID0gMTtcbiAgICAvLyBXZSB1c2UgZGFzaCBjYXNlIHdoZW4gc2V0dGluZyBhdHRyaWJ1dGVzIGRpcmVjdGx5IHRvIHRoZSBET00gbm9kZSBhbmQgY2FtZWwgY2FzZVxuICAgIC8vIHdoZW4gZGVmaW5pbmcgcHJvcHMgb24gYSBSZWFjdCBjb21wb25lbnQuXG4gICAgY29uc3Qga2V5cyA9IHVzZURhc2hDYXNlID8gZGFzaEtleXMgOiBjYW1lbEtleXM7XG4gICAgLy8gQnVpbGQgdGhlIGRhc2ggb2Zmc2V0XG4gICAgYXR0cnNba2V5cy5vZmZzZXRdID0gcHgudHJhbnNmb3JtKC1vZmZzZXQpO1xuICAgIC8vIEJ1aWxkIHRoZSBkYXNoIGFycmF5XG4gICAgY29uc3QgcGF0aExlbmd0aCA9IHB4LnRyYW5zZm9ybShsZW5ndGgpO1xuICAgIGNvbnN0IHBhdGhTcGFjaW5nID0gcHgudHJhbnNmb3JtKHNwYWNpbmcpO1xuICAgIGF0dHJzW2tleXMuYXJyYXldID0gYCR7cGF0aExlbmd0aH0gJHtwYXRoU3BhY2luZ31gO1xufVxuXG5mdW5jdGlvbiBjYWxjT3JpZ2luJDEob3JpZ2luLCBvZmZzZXQsIHNpemUpIHtcbiAgICByZXR1cm4gdHlwZW9mIG9yaWdpbiA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IG9yaWdpblxuICAgICAgICA6IHB4LnRyYW5zZm9ybShvZmZzZXQgKyBzaXplICogb3JpZ2luKTtcbn1cbi8qKlxuICogVGhlIFNWRyB0cmFuc2Zvcm0gb3JpZ2luIGRlZmF1bHRzIGFyZSBkaWZmZXJlbnQgdG8gQ1NTIGFuZCBpcyBsZXNzIGludHVpdGl2ZSxcbiAqIHNvIHdlIHVzZSB0aGUgbWVhc3VyZWQgZGltZW5zaW9ucyBvZiB0aGUgU1ZHIHRvIHJlY29uY2lsZSB0aGVzZS5cbiAqL1xuZnVuY3Rpb24gY2FsY1NWR1RyYW5zZm9ybU9yaWdpbihkaW1lbnNpb25zLCBvcmlnaW5YLCBvcmlnaW5ZKSB7XG4gICAgY29uc3QgcHhPcmlnaW5YID0gY2FsY09yaWdpbiQxKG9yaWdpblgsIGRpbWVuc2lvbnMueCwgZGltZW5zaW9ucy53aWR0aCk7XG4gICAgY29uc3QgcHhPcmlnaW5ZID0gY2FsY09yaWdpbiQxKG9yaWdpblksIGRpbWVuc2lvbnMueSwgZGltZW5zaW9ucy5oZWlnaHQpO1xuICAgIHJldHVybiBgJHtweE9yaWdpblh9ICR7cHhPcmlnaW5ZfWA7XG59XG5cbi8qKlxuICogQnVpbGQgU1ZHIHZpc3VhbCBhdHRyYnV0ZXMsIGxpa2UgY3ggYW5kIHN0eWxlLnRyYW5zZm9ybVxuICovXG5mdW5jdGlvbiBidWlsZFNWR0F0dHJzKHN0YXRlLCB7IGF0dHJYLCBhdHRyWSwgYXR0clNjYWxlLCBvcmlnaW5YLCBvcmlnaW5ZLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZyA9IDEsIHBhdGhPZmZzZXQgPSAwLCBcbi8vIFRoaXMgaXMgb2JqZWN0IGNyZWF0aW9uLCB3aGljaCB3ZSB0cnkgdG8gYXZvaWQgcGVyLWZyYW1lLlxuLi4ubGF0ZXN0IH0sIGlzU1ZHVGFnLCB0cmFuc2Zvcm1UZW1wbGF0ZSkge1xuICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgbGF0ZXN0LCB0cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgLyoqXG4gICAgICogRm9yIHN2ZyB0YWdzIHdlIGp1c3Qgd2FudCB0byBtYWtlIHN1cmUgdmlld0JveCBpcyBhbmltYXRhYmxlIGFuZCB0cmVhdCBhbGwgdGhlIHN0eWxlc1xuICAgICAqIGFzIG5vcm1hbCBIVE1MIHRhZ3MuXG4gICAgICovXG4gICAgaWYgKGlzU1ZHVGFnKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zdHlsZS52aWV3Qm94KSB7XG4gICAgICAgICAgICBzdGF0ZS5hdHRycy52aWV3Qm94ID0gc3RhdGUuc3R5bGUudmlld0JveDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN0YXRlLmF0dHJzID0gc3RhdGUuc3R5bGU7XG4gICAgc3RhdGUuc3R5bGUgPSB7fTtcbiAgICBjb25zdCB7IGF0dHJzLCBzdHlsZSwgZGltZW5zaW9ucyB9ID0gc3RhdGU7XG4gICAgLyoqXG4gICAgICogSG93ZXZlciwgd2UgYXBwbHkgdHJhbnNmb3JtcyBhcyBDU1MgdHJhbnNmb3Jtcy4gU28gaWYgd2UgZGV0ZWN0IGEgdHJhbnNmb3JtIHdlIHRha2UgaXQgZnJvbSBhdHRyc1xuICAgICAqIGFuZCBjb3B5IGl0IGludG8gc3R5bGUuXG4gICAgICovXG4gICAgaWYgKGF0dHJzLnRyYW5zZm9ybSkge1xuICAgICAgICBpZiAoZGltZW5zaW9ucylcbiAgICAgICAgICAgIHN0eWxlLnRyYW5zZm9ybSA9IGF0dHJzLnRyYW5zZm9ybTtcbiAgICAgICAgZGVsZXRlIGF0dHJzLnRyYW5zZm9ybTtcbiAgICB9XG4gICAgLy8gUGFyc2UgdHJhbnNmb3JtT3JpZ2luXG4gICAgaWYgKGRpbWVuc2lvbnMgJiZcbiAgICAgICAgKG9yaWdpblggIT09IHVuZGVmaW5lZCB8fCBvcmlnaW5ZICE9PSB1bmRlZmluZWQgfHwgc3R5bGUudHJhbnNmb3JtKSkge1xuICAgICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjYWxjU1ZHVHJhbnNmb3JtT3JpZ2luKGRpbWVuc2lvbnMsIG9yaWdpblggIT09IHVuZGVmaW5lZCA/IG9yaWdpblggOiAwLjUsIG9yaWdpblkgIT09IHVuZGVmaW5lZCA/IG9yaWdpblkgOiAwLjUpO1xuICAgIH1cbiAgICAvLyBSZW5kZXIgYXR0clgvYXR0clkvYXR0clNjYWxlIGFzIGF0dHJpYnV0ZXNcbiAgICBpZiAoYXR0clggIT09IHVuZGVmaW5lZClcbiAgICAgICAgYXR0cnMueCA9IGF0dHJYO1xuICAgIGlmIChhdHRyWSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy55ID0gYXR0clk7XG4gICAgaWYgKGF0dHJTY2FsZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICBhdHRycy5zY2FsZSA9IGF0dHJTY2FsZTtcbiAgICAvLyBCdWlsZCBTVkcgcGF0aCBpZiBvbmUgaGFzIGJlZW4gZGVmaW5lZFxuICAgIGlmIChwYXRoTGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYnVpbGRTVkdQYXRoKGF0dHJzLCBwYXRoTGVuZ3RoLCBwYXRoU3BhY2luZywgcGF0aE9mZnNldCwgZmFsc2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBIHNldCBvZiBhdHRyaWJ1dGUgbmFtZXMgdGhhdCBhcmUgYWx3YXlzIHJlYWQvd3JpdHRlbiBhcyBjYW1lbCBjYXNlLlxuICovXG5jb25zdCBjYW1lbENhc2VBdHRyaWJ1dGVzID0gbmV3IFNldChbXG4gICAgXCJiYXNlRnJlcXVlbmN5XCIsXG4gICAgXCJkaWZmdXNlQ29uc3RhbnRcIixcbiAgICBcImtlcm5lbE1hdHJpeFwiLFxuICAgIFwia2VybmVsVW5pdExlbmd0aFwiLFxuICAgIFwia2V5U3BsaW5lc1wiLFxuICAgIFwia2V5VGltZXNcIixcbiAgICBcImxpbWl0aW5nQ29uZUFuZ2xlXCIsXG4gICAgXCJtYXJrZXJIZWlnaHRcIixcbiAgICBcIm1hcmtlcldpZHRoXCIsXG4gICAgXCJudW1PY3RhdmVzXCIsXG4gICAgXCJ0YXJnZXRYXCIsXG4gICAgXCJ0YXJnZXRZXCIsXG4gICAgXCJzdXJmYWNlU2NhbGVcIixcbiAgICBcInNwZWN1bGFyQ29uc3RhbnRcIixcbiAgICBcInNwZWN1bGFyRXhwb25lbnRcIixcbiAgICBcInN0ZERldmlhdGlvblwiLFxuICAgIFwidGFibGVWYWx1ZXNcIixcbiAgICBcInZpZXdCb3hcIixcbiAgICBcImdyYWRpZW50VHJhbnNmb3JtXCIsXG4gICAgXCJwYXRoTGVuZ3RoXCIsXG4gICAgXCJzdGFydE9mZnNldFwiLFxuICAgIFwidGV4dExlbmd0aFwiLFxuICAgIFwibGVuZ3RoQWRqdXN0XCIsXG5dKTtcblxuY29uc3QgaXNTVkdUYWcgPSAodGFnKSA9PiB0eXBlb2YgdGFnID09PSBcInN0cmluZ1wiICYmIHRhZy50b0xvd2VyQ2FzZSgpID09PSBcInN2Z1wiO1xuXG5mdW5jdGlvbiByZW5kZXJIVE1MKGVsZW1lbnQsIHsgc3R5bGUsIHZhcnMgfSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSwgcHJvamVjdGlvbiAmJiBwcm9qZWN0aW9uLmdldFByb2plY3Rpb25TdHlsZXMoc3R5bGVQcm9wKSk7XG4gICAgLy8gTG9vcCBvdmVyIGFueSBDU1MgdmFyaWFibGVzIGFuZCBhc3NpZ24gdGhvc2UuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gdmFycykge1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFyc1trZXldKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlclNWRyhlbGVtZW50LCByZW5kZXJTdGF0ZSwgX3N0eWxlUHJvcCwgcHJvamVjdGlvbikge1xuICAgIHJlbmRlckhUTUwoZWxlbWVudCwgcmVuZGVyU3RhdGUsIHVuZGVmaW5lZCwgcHJvamVjdGlvbik7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVuZGVyU3RhdGUuYXR0cnMpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoIWNhbWVsQ2FzZUF0dHJpYnV0ZXMuaGFzKGtleSkgPyBjYW1lbFRvRGFzaChrZXkpIDoga2V5LCByZW5kZXJTdGF0ZS5hdHRyc1trZXldKTtcbiAgICB9XG59XG5cbmNvbnN0IHNjYWxlQ29ycmVjdG9ycyA9IHt9O1xuZnVuY3Rpb24gYWRkU2NhbGVDb3JyZWN0b3IoY29ycmVjdG9ycykge1xuICAgIE9iamVjdC5hc3NpZ24oc2NhbGVDb3JyZWN0b3JzLCBjb3JyZWN0b3JzKTtcbn1cblxuZnVuY3Rpb24gaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHsgbGF5b3V0LCBsYXlvdXRJZCB9KSB7XG4gICAgcmV0dXJuICh0cmFuc2Zvcm1Qcm9wcy5oYXMoa2V5KSB8fFxuICAgICAgICBrZXkuc3RhcnRzV2l0aChcIm9yaWdpblwiKSB8fFxuICAgICAgICAoKGxheW91dCB8fCBsYXlvdXRJZCAhPT0gdW5kZWZpbmVkKSAmJlxuICAgICAgICAgICAgKCEhc2NhbGVDb3JyZWN0b3JzW2tleV0gfHwga2V5ID09PSBcIm9wYWNpdHlcIikpKTtcbn1cblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzJDEocHJvcHMsIHByZXZQcm9wcywgdmlzdWFsRWxlbWVudCkge1xuICAgIHZhciBfYTtcbiAgICBjb25zdCB7IHN0eWxlIH0gPSBwcm9wcztcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzdHlsZSkge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShzdHlsZVtrZXldKSB8fFxuICAgICAgICAgICAgKHByZXZQcm9wcy5zdHlsZSAmJlxuICAgICAgICAgICAgICAgIGlzTW90aW9uVmFsdWUocHJldlByb3BzLnN0eWxlW2tleV0pKSB8fFxuICAgICAgICAgICAgaXNGb3JjZWRNb3Rpb25WYWx1ZShrZXksIHByb3BzKSB8fFxuICAgICAgICAgICAgKChfYSA9IHZpc3VhbEVsZW1lbnQgPT09IG51bGwgfHwgdmlzdWFsRWxlbWVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmlzdWFsRWxlbWVudC5nZXRWYWx1ZShrZXkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGl2ZVN0eWxlKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZXNba2V5XSA9IHN0eWxlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5ld1ZhbHVlcztcbn1cblxuZnVuY3Rpb24gc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICBjb25zdCBuZXdWYWx1ZXMgPSBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHMkMShwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBwcm9wcykge1xuICAgICAgICBpZiAoaXNNb3Rpb25WYWx1ZShwcm9wc1trZXldKSB8fFxuICAgICAgICAgICAgaXNNb3Rpb25WYWx1ZShwcmV2UHJvcHNba2V5XSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEtleSA9IHRyYW5zZm9ybVByb3BPcmRlci5pbmRleE9mKGtleSkgIT09IC0xXG4gICAgICAgICAgICAgICAgPyBcImF0dHJcIiArIGtleS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIGtleS5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAgICAgICA6IGtleTtcbiAgICAgICAgICAgIG5ld1ZhbHVlc1t0YXJnZXRLZXldID0gcHJvcHNba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWVzO1xufVxuXG5jbGFzcyBTVkdWaXN1YWxFbGVtZW50IGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwic3ZnXCI7XG4gICAgICAgIHRoaXMuaXNTVkdUYWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5tZWFzdXJlSW5zdGFuY2VWaWV3cG9ydEJveCA9IGNyZWF0ZUJveDtcbiAgICB9XG4gICAgZ2V0QmFzZVRhcmdldEZyb21Qcm9wcyhwcm9wcywga2V5KSB7XG4gICAgICAgIHJldHVybiBwcm9wc1trZXldO1xuICAgIH1cbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoaW5zdGFuY2UsIGtleSkge1xuICAgICAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRUeXBlID0gZ2V0RGVmYXVsdFZhbHVlVHlwZShrZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRUeXBlID8gZGVmYXVsdFR5cGUuZGVmYXVsdCB8fCAwIDogMDtcbiAgICAgICAgfVxuICAgICAgICBrZXkgPSAhY2FtZWxDYXNlQXR0cmlidXRlcy5oYXMoa2V5KSA/IGNhbWVsVG9EYXNoKGtleSkgOiBrZXk7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZS5nZXRBdHRyaWJ1dGUoa2V5KTtcbiAgICB9XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyhwcm9wcywgcHJldlByb3BzLCB2aXN1YWxFbGVtZW50KTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRTVkdBdHRycyhyZW5kZXJTdGF0ZSwgbGF0ZXN0VmFsdWVzLCB0aGlzLmlzU1ZHVGFnLCBwcm9wcy50cmFuc2Zvcm1UZW1wbGF0ZSk7XG4gICAgfVxuICAgIHJlbmRlckluc3RhbmNlKGluc3RhbmNlLCByZW5kZXJTdGF0ZSwgc3R5bGVQcm9wLCBwcm9qZWN0aW9uKSB7XG4gICAgICAgIHJlbmRlclNWRyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUsIHN0eWxlUHJvcCwgcHJvamVjdGlvbik7XG4gICAgfVxuICAgIG1vdW50KGluc3RhbmNlKSB7XG4gICAgICAgIHRoaXMuaXNTVkdUYWcgPSBpc1NWR1RhZyhpbnN0YW5jZS50YWdOYW1lKTtcbiAgICAgICAgc3VwZXIubW91bnQoaW5zdGFuY2UpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBCb3VuZGluZyBib3hlcyB0ZW5kIHRvIGJlIGRlZmluZWQgYXMgdG9wLCBsZWZ0LCByaWdodCwgYm90dG9tLiBGb3IgdmFyaW91cyBvcGVyYXRpb25zXG4gKiBpdCdzIGVhc2llciB0byBjb25zaWRlciBlYWNoIGF4aXMgaW5kaXZpZHVhbGx5LiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBib3VuZGluZyBib3hcbiAqIGFzIGEgbWFwIG9mIHNpbmdsZS1heGlzIG1pbi9tYXggdmFsdWVzLlxuICovXG5mdW5jdGlvbiBjb252ZXJ0Qm91bmRpbmdCb3hUb0JveCh7IHRvcCwgbGVmdCwgcmlnaHQsIGJvdHRvbSwgfSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHsgbWluOiBsZWZ0LCBtYXg6IHJpZ2h0IH0sXG4gICAgICAgIHk6IHsgbWluOiB0b3AsIG1heDogYm90dG9tIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KHsgeCwgeSB9KSB7XG4gICAgcmV0dXJuIHsgdG9wOiB5Lm1pbiwgcmlnaHQ6IHgubWF4LCBib3R0b206IHkubWF4LCBsZWZ0OiB4Lm1pbiB9O1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgVHJhbnNmb3JtUG9pbnQgZnVuY3Rpb24gdG8gYSBib3VuZGluZyBib3guIFRyYW5zZm9ybVBvaW50IGlzIHVzdWFsbHkgYSBmdW5jdGlvblxuICogcHJvdmlkZWQgYnkgRnJhbWVyIHRvIGFsbG93IG1lYXN1cmVkIHBvaW50cyB0byBiZSBjb3JyZWN0ZWQgZm9yIGRldmljZSBzY2FsaW5nLiBUaGlzIGlzIHVzZWRcbiAqIHdoZW4gbWVhc3VyaW5nIERPTSBlbGVtZW50cyBhbmQgRE9NIGV2ZW50IHBvaW50cy5cbiAqL1xuZnVuY3Rpb24gdHJhbnNmb3JtQm94UG9pbnRzKHBvaW50LCB0cmFuc2Zvcm1Qb2ludCkge1xuICAgIGlmICghdHJhbnNmb3JtUG9pbnQpXG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICBjb25zdCB0b3BMZWZ0ID0gdHJhbnNmb3JtUG9pbnQoeyB4OiBwb2ludC5sZWZ0LCB5OiBwb2ludC50b3AgfSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSB0cmFuc2Zvcm1Qb2ludCh7IHg6IHBvaW50LnJpZ2h0LCB5OiBwb2ludC5ib3R0b20gfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdG9wOiB0b3BMZWZ0LnksXG4gICAgICAgIGxlZnQ6IHRvcExlZnQueCxcbiAgICAgICAgYm90dG9tOiBib3R0b21SaWdodC55LFxuICAgICAgICByaWdodDogYm90dG9tUmlnaHQueCxcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHtcbiAgICByZXR1cm4gc2NhbGUgPT09IHVuZGVmaW5lZCB8fCBzY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGhhc1NjYWxlKHsgc2NhbGUsIHNjYWxlWCwgc2NhbGVZIH0pIHtcbiAgICByZXR1cm4gKCFpc0lkZW50aXR5U2NhbGUoc2NhbGUpIHx8XG4gICAgICAgICFpc0lkZW50aXR5U2NhbGUoc2NhbGVYKSB8fFxuICAgICAgICAhaXNJZGVudGl0eVNjYWxlKHNjYWxlWSkpO1xufVxuZnVuY3Rpb24gaGFzVHJhbnNmb3JtKHZhbHVlcykge1xuICAgIHJldHVybiAoaGFzU2NhbGUodmFsdWVzKSB8fFxuICAgICAgICBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHx8XG4gICAgICAgIHZhbHVlcy56IHx8XG4gICAgICAgIHZhbHVlcy5yb3RhdGUgfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVggfHxcbiAgICAgICAgdmFsdWVzLnJvdGF0ZVkgfHxcbiAgICAgICAgdmFsdWVzLnNrZXdYIHx8XG4gICAgICAgIHZhbHVlcy5za2V3WSk7XG59XG5mdW5jdGlvbiBoYXMyRFRyYW5zbGF0ZSh2YWx1ZXMpIHtcbiAgICByZXR1cm4gaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueCkgfHwgaXMyRFRyYW5zbGF0ZSh2YWx1ZXMueSk7XG59XG5mdW5jdGlvbiBpczJEVHJhbnNsYXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICYmIHZhbHVlICE9PSBcIjAlXCI7XG59XG5cbi8qKlxuICogU2NhbGVzIGEgcG9pbnQgYmFzZWQgb24gYSBmYWN0b3IgYW5kIGFuIG9yaWdpblBvaW50XG4gKi9cbmZ1bmN0aW9uIHNjYWxlUG9pbnQocG9pbnQsIHNjYWxlLCBvcmlnaW5Qb2ludCkge1xuICAgIGNvbnN0IGRpc3RhbmNlRnJvbU9yaWdpbiA9IHBvaW50IC0gb3JpZ2luUG9pbnQ7XG4gICAgY29uc3Qgc2NhbGVkID0gc2NhbGUgKiBkaXN0YW5jZUZyb21PcmlnaW47XG4gICAgcmV0dXJuIG9yaWdpblBvaW50ICsgc2NhbGVkO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGEgcG9pbnRcbiAqL1xuZnVuY3Rpb24gYXBwbHlQb2ludERlbHRhKHBvaW50LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBpZiAoYm94U2NhbGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBzY2FsZVBvaW50KHBvaW50LCBzY2FsZSwgb3JpZ2luUG9pbnQpICsgdHJhbnNsYXRlO1xufVxuLyoqXG4gKiBBcHBsaWVzIGEgdHJhbnNsYXRlL3NjYWxlIGRlbHRhIHRvIGFuIGF4aXNcbiAqL1xuZnVuY3Rpb24gYXBwbHlBeGlzRGVsdGEoYXhpcywgdHJhbnNsYXRlID0gMCwgc2NhbGUgPSAxLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpIHtcbiAgICBheGlzLm1pbiA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1pbiwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbiAgICBheGlzLm1heCA9IGFwcGx5UG9pbnREZWx0YShheGlzLm1heCwgdHJhbnNsYXRlLCBzY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbGllcyBhIHRyYW5zbGF0ZS9zY2FsZSBkZWx0YSB0byBhIGJveFxuICovXG5mdW5jdGlvbiBhcHBseUJveERlbHRhKGJveCwgeyB4LCB5IH0pIHtcbiAgICBhcHBseUF4aXNEZWx0YShib3gueCwgeC50cmFuc2xhdGUsIHguc2NhbGUsIHgub3JpZ2luUG9pbnQpO1xuICAgIGFwcGx5QXhpc0RlbHRhKGJveC55LCB5LnRyYW5zbGF0ZSwgeS5zY2FsZSwgeS5vcmlnaW5Qb2ludCk7XG59XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUlOID0gMC45OTk5OTk5OTk5OTk7XG5jb25zdCBUUkVFX1NDQUxFX1NOQVBfTUFYID0gMS4wMDAwMDAwMDAwMDAxO1xuLyoqXG4gKiBBcHBseSBhIHRyZWUgb2YgZGVsdGFzIHRvIGEgYm94LiBXZSBkbyB0aGlzIHRvIGNhbGN1bGF0ZSB0aGUgZWZmZWN0IG9mIGFsbCB0aGUgdHJhbnNmb3Jtc1xuICogaW4gYSB0cmVlIHVwb24gb3VyIGJveCBiZWZvcmUgdGhlbiBjYWxjdWxhdGluZyBob3cgdG8gcHJvamVjdCBpdCBpbnRvIG91ciBkZXNpcmVkIHZpZXdwb3J0LXJlbGF0aXZlIGJveFxuICpcbiAqIFRoaXMgaXMgdGhlIGZpbmFsIG5lc3RlZCBsb29wIHdpdGhpbiB1cGRhdGVMYXlvdXREZWx0YSBmb3IgZnV0dXJlIHJlZmFjdG9yaW5nXG4gKi9cbmZ1bmN0aW9uIGFwcGx5VHJlZURlbHRhcyhib3gsIHRyZWVTY2FsZSwgdHJlZVBhdGgsIGlzU2hhcmVkVHJhbnNpdGlvbiA9IGZhbHNlKSB7XG4gICAgY29uc3QgdHJlZUxlbmd0aCA9IHRyZWVQYXRoLmxlbmd0aDtcbiAgICBpZiAoIXRyZWVMZW5ndGgpXG4gICAgICAgIHJldHVybjtcbiAgICAvLyBSZXNldCB0aGUgdHJlZVNjYWxlXG4gICAgdHJlZVNjYWxlLnggPSB0cmVlU2NhbGUueSA9IDE7XG4gICAgbGV0IG5vZGU7XG4gICAgbGV0IGRlbHRhO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJlZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIG5vZGUgPSB0cmVlUGF0aFtpXTtcbiAgICAgICAgZGVsdGEgPSBub2RlLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFByZWZlciB0byByZW1vdmUgdGhpcywgYnV0IGN1cnJlbnRseSB3ZSBoYXZlIG1vdGlvbiBjb21wb25lbnRzIHdpdGhcbiAgICAgICAgICogZGlzcGxheTogY29udGVudHMgaW4gRnJhbWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlICYmXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnByb3BzLnN0eWxlLmRpc3BsYXkgPT09IFwiY29udGVudHNcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzU2hhcmVkVHJhbnNpdGlvbiAmJlxuICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgbm9kZS5zY3JvbGwgJiZcbiAgICAgICAgICAgIG5vZGUgIT09IG5vZGUucm9vdCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwge1xuICAgICAgICAgICAgICAgIHg6IC1ub2RlLnNjcm9sbC5vZmZzZXQueCxcbiAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwub2Zmc2V0LnksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGVsdGEpIHtcbiAgICAgICAgICAgIC8vIEluY29wb3JhdGUgZWFjaCBhbmNlc3RvcidzIHNjYWxlIGludG8gYSBjdWxtdWxhdGl2ZSB0cmVlU2NhbGUgZm9yIHRoaXMgY29tcG9uZW50XG4gICAgICAgICAgICB0cmVlU2NhbGUueCAqPSBkZWx0YS54LnNjYWxlO1xuICAgICAgICAgICAgdHJlZVNjYWxlLnkgKj0gZGVsdGEueS5zY2FsZTtcbiAgICAgICAgICAgIC8vIEFwcGx5IGVhY2ggYW5jZXN0b3IncyBjYWxjdWxhdGVkIGRlbHRhIGludG8gdGhpcyBjb21wb25lbnQncyByZWNvcmRlZCBsYXlvdXQgYm94XG4gICAgICAgICAgICBhcHBseUJveERlbHRhKGJveCwgZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc1NoYXJlZFRyYW5zaXRpb24gJiYgaGFzVHJhbnNmb3JtKG5vZGUubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgdHJhbnNmb3JtQm94KGJveCwgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNuYXAgdHJlZSBzY2FsZSBiYWNrIHRvIDEgaWYgaXQncyB3aXRoaW4gYSBub24tcGVyY2VpdmFibGUgdGhyZXNob2xkLlxuICAgICAqIFRoaXMgd2lsbCBoZWxwIHJlZHVjZSB1c2VsZXNzIHNjYWxlcyBnZXR0aW5nIHJlbmRlcmVkLlxuICAgICAqL1xuICAgIGlmICh0cmVlU2NhbGUueCA8IFRSRUVfU0NBTEVfU05BUF9NQVggJiZcbiAgICAgICAgdHJlZVNjYWxlLnggPiBUUkVFX1NDQUxFX1NOQVBfTUlOKSB7XG4gICAgICAgIHRyZWVTY2FsZS54ID0gMS4wO1xuICAgIH1cbiAgICBpZiAodHJlZVNjYWxlLnkgPCBUUkVFX1NDQUxFX1NOQVBfTUFYICYmXG4gICAgICAgIHRyZWVTY2FsZS55ID4gVFJFRV9TQ0FMRV9TTkFQX01JTikge1xuICAgICAgICB0cmVlU2NhbGUueSA9IDEuMDtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2xhdGVBeGlzKGF4aXMsIGRpc3RhbmNlKSB7XG4gICAgYXhpcy5taW4gPSBheGlzLm1pbiArIGRpc3RhbmNlO1xuICAgIGF4aXMubWF4ID0gYXhpcy5tYXggKyBkaXN0YW5jZTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYW4gYXhpcyBmcm9tIHRoZSBsYXRlc3QgcmVzb2x2ZWQgbW90aW9uIHZhbHVlcy5cbiAqIFRoaXMgZnVuY3Rpb24gYmFzaWNhbGx5IGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBhIGZsYXQgbW90aW9uIHZhbHVlIG1hcFxuICogYW5kIGFwcGx5QXhpc0RlbHRhXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUF4aXMoYXhpcywgYXhpc1RyYW5zbGF0ZSwgYXhpc1NjYWxlLCBib3hTY2FsZSwgYXhpc09yaWdpbiA9IDAuNSkge1xuICAgIGNvbnN0IG9yaWdpblBvaW50ID0gbWl4TnVtYmVyJDEoYXhpcy5taW4sIGF4aXMubWF4LCBheGlzT3JpZ2luKTtcbiAgICAvLyBBcHBseSB0aGUgYXhpcyBkZWx0YSB0byB0aGUgZmluYWwgYXhpc1xuICAgIGFwcGx5QXhpc0RlbHRhKGF4aXMsIGF4aXNUcmFuc2xhdGUsIGF4aXNTY2FsZSwgb3JpZ2luUG9pbnQsIGJveFNjYWxlKTtcbn1cbi8qKlxuICogQXBwbHkgYSB0cmFuc2Zvcm0gdG8gYSBib3ggZnJvbSB0aGUgbGF0ZXN0IHJlc29sdmVkIG1vdGlvbiB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIHRyYW5zZm9ybUJveChib3gsIHRyYW5zZm9ybSkge1xuICAgIHRyYW5zZm9ybUF4aXMoYm94LngsIHRyYW5zZm9ybS54LCB0cmFuc2Zvcm0uc2NhbGVYLCB0cmFuc2Zvcm0uc2NhbGUsIHRyYW5zZm9ybS5vcmlnaW5YKTtcbiAgICB0cmFuc2Zvcm1BeGlzKGJveC55LCB0cmFuc2Zvcm0ueSwgdHJhbnNmb3JtLnNjYWxlWSwgdHJhbnNmb3JtLnNjYWxlLCB0cmFuc2Zvcm0ub3JpZ2luWSk7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUG9pbnQpIHtcbiAgICByZXR1cm4gY29udmVydEJvdW5kaW5nQm94VG9Cb3godHJhbnNmb3JtQm94UG9pbnRzKGluc3RhbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLCB0cmFuc2Zvcm1Qb2ludCkpO1xufVxuZnVuY3Rpb24gbWVhc3VyZVBhZ2VCb3goZWxlbWVudCwgcm9vdFByb2plY3Rpb25Ob2RlLCB0cmFuc2Zvcm1QYWdlUG9pbnQpIHtcbiAgICBjb25zdCB2aWV3cG9ydEJveCA9IG1lYXN1cmVWaWV3cG9ydEJveChlbGVtZW50LCB0cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgIGNvbnN0IHsgc2Nyb2xsIH0gPSByb290UHJvamVjdGlvbk5vZGU7XG4gICAgaWYgKHNjcm9sbCkge1xuICAgICAgICB0cmFuc2xhdGVBeGlzKHZpZXdwb3J0Qm94LngsIHNjcm9sbC5vZmZzZXQueCk7XG4gICAgICAgIHRyYW5zbGF0ZUF4aXModmlld3BvcnRCb3gueSwgc2Nyb2xsLm9mZnNldC55KTtcbiAgICB9XG4gICAgcmV0dXJuIHZpZXdwb3J0Qm94O1xufVxuXG5mdW5jdGlvbiBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkge1xuICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbn1cbmNsYXNzIEhUTUxWaXN1YWxFbGVtZW50IGV4dGVuZHMgRE9NVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMudHlwZSA9IFwiaHRtbFwiO1xuICAgICAgICB0aGlzLnJlbmRlckluc3RhbmNlID0gcmVuZGVySFRNTDtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWZhdWx0VHlwZSA9IGdldERlZmF1bHRWYWx1ZVR5cGUoa2V5KTtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0VHlwZSA/IGRlZmF1bHRUeXBlLmRlZmF1bHQgfHwgMCA6IDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGluc3RhbmNlKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gKGlzQ1NTVmFyaWFibGVOYW1lKGtleSlcbiAgICAgICAgICAgICAgICA/IGNvbXB1dGVkU3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShrZXkpXG4gICAgICAgICAgICAgICAgOiBjb21wdXRlZFN0eWxlW2tleV0pIHx8IDA7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUudHJpbSgpIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goaW5zdGFuY2UsIHsgdHJhbnNmb3JtUGFnZVBvaW50IH0pIHtcbiAgICAgICAgcmV0dXJuIG1lYXN1cmVWaWV3cG9ydEJveChpbnN0YW5jZSwgdHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgcHJvcHMpIHtcbiAgICAgICAgYnVpbGRIVE1MU3R5bGVzKHJlbmRlclN0YXRlLCBsYXRlc3RWYWx1ZXMsIHByb3BzLnRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICB9XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxKHByb3BzLCBwcmV2UHJvcHMsIHZpc3VhbEVsZW1lbnQpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNPYmplY3RLZXkoa2V5LCBvYmplY3QpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iamVjdDtcbn1cbmNsYXNzIE9iamVjdFZpc3VhbEVsZW1lbnQgZXh0ZW5kcyBWaXN1YWxFbGVtZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy50eXBlID0gXCJvYmplY3RcIjtcbiAgICB9XG4gICAgcmVhZFZhbHVlRnJvbUluc3RhbmNlKGluc3RhbmNlLCBrZXkpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0S2V5KGtleSwgaW5zdGFuY2UpKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGluc3RhbmNlW2tleV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZW1vdmVWYWx1ZUZyb21SZW5kZXJTdGF0ZShrZXksIHJlbmRlclN0YXRlKSB7XG4gICAgICAgIGRlbGV0ZSByZW5kZXJTdGF0ZS5vdXRwdXRba2V5XTtcbiAgICB9XG4gICAgbWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3goKSB7XG4gICAgICAgIHJldHVybiBjcmVhdGVCb3goKTtcbiAgICB9XG4gICAgYnVpbGQocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcykge1xuICAgICAgICBPYmplY3QuYXNzaWduKHJlbmRlclN0YXRlLm91dHB1dCwgbGF0ZXN0VmFsdWVzKTtcbiAgICB9XG4gICAgcmVuZGVySW5zdGFuY2UoaW5zdGFuY2UsIHsgb3V0cHV0IH0pIHtcbiAgICAgICAgT2JqZWN0LmFzc2lnbihpbnN0YW5jZSwgb3V0cHV0KTtcbiAgICB9XG4gICAgc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURPTVZpc3VhbEVsZW1lbnQoZWxlbWVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlbmNlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICB2aXN1YWxTdGF0ZToge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm06IHt9LFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybU9yaWdpbjoge30sXG4gICAgICAgICAgICAgICAgc3R5bGU6IHt9LFxuICAgICAgICAgICAgICAgIHZhcnM6IHt9LFxuICAgICAgICAgICAgICAgIGF0dHJzOiB7fSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYXRlc3RWYWx1ZXM6IHt9LFxuICAgICAgICB9LFxuICAgIH07XG4gICAgY29uc3Qgbm9kZSA9IGlzU1ZHRWxlbWVudChlbGVtZW50KVxuICAgICAgICA/IG5ldyBTVkdWaXN1YWxFbGVtZW50KG9wdGlvbnMpXG4gICAgICAgIDogbmV3IEhUTUxWaXN1YWxFbGVtZW50KG9wdGlvbnMpO1xuICAgIG5vZGUubW91bnQoZWxlbWVudCk7XG4gICAgdmlzdWFsRWxlbWVudFN0b3JlLnNldChlbGVtZW50LCBub2RlKTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZU9iamVjdFZpc3VhbEVsZW1lbnQoc3ViamVjdCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHByZXNlbmNlQ29udGV4dDogbnVsbCxcbiAgICAgICAgcHJvcHM6IHt9LFxuICAgICAgICB2aXN1YWxTdGF0ZToge1xuICAgICAgICAgICAgcmVuZGVyU3RhdGU6IHtcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHt9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhdGVzdFZhbHVlczoge30sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBjb25zdCBub2RlID0gbmV3IE9iamVjdFZpc3VhbEVsZW1lbnQob3B0aW9ucyk7XG4gICAgbm9kZS5tb3VudChzdWJqZWN0KTtcbiAgICB2aXN1YWxFbGVtZW50U3RvcmUuc2V0KHN1YmplY3QsIG5vZGUpO1xufVxuXG5mdW5jdGlvbiBpc1NpbmdsZVZhbHVlKHN1YmplY3QsIGtleWZyYW1lcykge1xuICAgIHJldHVybiAoaXNNb3Rpb25WYWx1ZShzdWJqZWN0KSB8fFxuICAgICAgICB0eXBlb2Ygc3ViamVjdCA9PT0gXCJudW1iZXJcIiB8fFxuICAgICAgICAodHlwZW9mIHN1YmplY3QgPT09IFwic3RyaW5nXCIgJiYgIWlzRE9NS2V5ZnJhbWVzKGtleWZyYW1lcykpKTtcbn1cbi8qKlxuICogSW1wbGVtZW50YXRpb25cbiAqL1xuZnVuY3Rpb24gYW5pbWF0ZVN1YmplY3Qoc3ViamVjdCwga2V5ZnJhbWVzLCBvcHRpb25zLCBzY29wZSkge1xuICAgIGNvbnN0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICBpZiAoaXNTaW5nbGVWYWx1ZShzdWJqZWN0LCBrZXlmcmFtZXMpKSB7XG4gICAgICAgIGFuaW1hdGlvbnMucHVzaChhbmltYXRlU2luZ2xlVmFsdWUoc3ViamVjdCwgaXNET01LZXlmcmFtZXMoa2V5ZnJhbWVzKVxuICAgICAgICAgICAgPyBrZXlmcmFtZXMuZGVmYXVsdCB8fCBrZXlmcmFtZXNcbiAgICAgICAgICAgIDoga2V5ZnJhbWVzLCBvcHRpb25zID8gb3B0aW9ucy5kZWZhdWx0IHx8IG9wdGlvbnMgOiBvcHRpb25zKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBzdWJqZWN0cyA9IHJlc29sdmVTdWJqZWN0cyhzdWJqZWN0LCBrZXlmcmFtZXMsIHNjb3BlKTtcbiAgICAgICAgY29uc3QgbnVtU3ViamVjdHMgPSBzdWJqZWN0cy5sZW5ndGg7XG4gICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChCb29sZWFuKG51bVN1YmplY3RzKSwgXCJObyB2YWxpZCBlbGVtZW50cyBwcm92aWRlZC5cIik7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3ViamVjdHM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdGhpc1N1YmplY3QgPSBzdWJqZWN0c1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGNyZWF0ZVZpc3VhbEVsZW1lbnQgPSB0aGlzU3ViamVjdCBpbnN0YW5jZW9mIEVsZW1lbnRcbiAgICAgICAgICAgICAgICA/IGNyZWF0ZURPTVZpc3VhbEVsZW1lbnRcbiAgICAgICAgICAgICAgICA6IGNyZWF0ZU9iamVjdFZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnRTdG9yZS5oYXModGhpc1N1YmplY3QpKSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlVmlzdWFsRWxlbWVudCh0aGlzU3ViamVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2aXN1YWxFbGVtZW50ID0gdmlzdWFsRWxlbWVudFN0b3JlLmdldCh0aGlzU3ViamVjdCk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2l0aW9uID0geyAuLi5vcHRpb25zIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc29sdmUgc3RhZ2dlciBmdW5jdGlvbiBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKFwiZGVsYXlcIiBpbiB0cmFuc2l0aW9uICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIHRyYW5zaXRpb24uZGVsYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHRyYW5zaXRpb24uZGVsYXkgPSB0cmFuc2l0aW9uLmRlbGF5KGksIG51bVN1YmplY3RzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaCguLi5hbmltYXRlVGFyZ2V0KHZpc3VhbEVsZW1lbnQsIHsgLi4ua2V5ZnJhbWVzLCB0cmFuc2l0aW9uIH0sIHt9KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVTZXF1ZW5jZShzZXF1ZW5jZSwgb3B0aW9ucywgc2NvcGUpIHtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgY29uc3QgYW5pbWF0aW9uRGVmaW5pdGlvbnMgPSBjcmVhdGVBbmltYXRpb25zRnJvbVNlcXVlbmNlKHNlcXVlbmNlLCBvcHRpb25zLCBzY29wZSwgeyBzcHJpbmcgfSk7XG4gICAgYW5pbWF0aW9uRGVmaW5pdGlvbnMuZm9yRWFjaCgoeyBrZXlmcmFtZXMsIHRyYW5zaXRpb24gfSwgc3ViamVjdCkgPT4ge1xuICAgICAgICBhbmltYXRpb25zLnB1c2goLi4uYW5pbWF0ZVN1YmplY3Qoc3ViamVjdCwga2V5ZnJhbWVzLCB0cmFuc2l0aW9uKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFuaW1hdGlvbnM7XG59XG5cbmZ1bmN0aW9uIGlzU2VxdWVuY2UodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuc29tZShBcnJheS5pc0FycmF5KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBhbmltYXRpb24gZnVuY3Rpb24gdGhhdCBpcyBvcHRpb25hbGx5IHNjb3BlZFxuICogdG8gYSBzcGVjaWZpYyBlbGVtZW50LlxuICovXG5mdW5jdGlvbiBjcmVhdGVTY29wZWRBbmltYXRlKHNjb3BlKSB7XG4gICAgLyoqXG4gICAgICogSW1wbGVtZW50YXRpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzY29wZWRBbmltYXRlKHN1YmplY3RPclNlcXVlbmNlLCBvcHRpb25zT3JLZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGFuaW1hdGlvbnMgPSBbXTtcbiAgICAgICAgaWYgKGlzU2VxdWVuY2Uoc3ViamVjdE9yU2VxdWVuY2UpKSB7XG4gICAgICAgICAgICBhbmltYXRpb25zID0gYW5pbWF0ZVNlcXVlbmNlKHN1YmplY3RPclNlcXVlbmNlLCBvcHRpb25zT3JLZXlmcmFtZXMsIHNjb3BlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMgPSBhbmltYXRlU3ViamVjdChzdWJqZWN0T3JTZXF1ZW5jZSwgb3B0aW9uc09yS2V5ZnJhbWVzLCBvcHRpb25zLCBzY29wZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gbmV3IG1vdGlvbkRvbS5Hcm91cFBsYXliYWNrQ29udHJvbHMoYW5pbWF0aW9ucyk7XG4gICAgICAgIGlmIChzY29wZSkge1xuICAgICAgICAgICAgc2NvcGUuYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHNjb3BlZEFuaW1hdGU7XG59XG5jb25zdCBhbmltYXRlID0gY3JlYXRlU2NvcGVkQW5pbWF0ZSgpO1xuXG5mdW5jdGlvbiBzZXRDU1NWYXIoZWxlbWVudCwgbmFtZSwgdmFsdWUpIHtcbiAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KGAtLSR7bmFtZX1gLCB2YWx1ZSk7XG59XG5mdW5jdGlvbiBzZXRTdHlsZShlbGVtZW50LCBuYW1lLCB2YWx1ZSkge1xuICAgIGVsZW1lbnQuc3R5bGVbbmFtZV0gPSB2YWx1ZTtcbn1cblxuY29uc3Qgc3VwcG9ydHNQYXJ0aWFsS2V5ZnJhbWVzID0gLypAX19QVVJFX18qLyBtb3Rpb25VdGlscy5tZW1vKCgpID0+IHtcbiAgICB0cnkge1xuICAgICAgICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLmFuaW1hdGUoeyBvcGFjaXR5OiBbMV0gfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59KTtcblxuY29uc3Qgc3RhdGUgPSBuZXcgV2Vha01hcCgpO1xuZnVuY3Rpb24gaHlkcmF0ZUtleWZyYW1lcyh2YWx1ZU5hbWUsIGtleWZyYW1lcywgcmVhZCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5ZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXlmcmFtZXNbaV0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGtleWZyYW1lc1tpXSA9IGkgPT09IDAgPyByZWFkKCkgOiBrZXlmcmFtZXNbaSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ZnJhbWVzW2ldID09PSBcIm51bWJlclwiICYmXG4gICAgICAgICAgICBicm93c2VyTnVtYmVyVmFsdWVUeXBlc1t2YWx1ZU5hbWVdKSB7XG4gICAgICAgICAgICBrZXlmcmFtZXNbaV0gPSBicm93c2VyTnVtYmVyVmFsdWVUeXBlc1t2YWx1ZU5hbWVdLnRyYW5zZm9ybShrZXlmcmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghc3VwcG9ydHNQYXJ0aWFsS2V5ZnJhbWVzKCkgJiYga2V5ZnJhbWVzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAga2V5ZnJhbWVzLnVuc2hpZnQocmVhZCgpKTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0RWFzaW5nID0gXCJlYXNlT3V0XCI7XG5mdW5jdGlvbiBnZXRFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCkge1xuICAgIGNvbnN0IGFuaW1hdGlvblN0YXRlID0gc3RhdGUuZ2V0KGVsZW1lbnQpIHx8IG5ldyBNYXAoKTtcbiAgICBzdGF0ZS5zZXQoZWxlbWVudCwgYW5pbWF0aW9uU3RhdGUpO1xuICAgIHJldHVybiBzdGF0ZS5nZXQoZWxlbWVudCk7XG59XG5jbGFzcyBOYXRpdmVBbmltYXRpb24gZXh0ZW5kcyBtb3Rpb25Eb20uTmF0aXZlQW5pbWF0aW9uQ29udHJvbHMge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIHZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgaXNDU1NWYXIgPSB2YWx1ZU5hbWUuc3RhcnRzV2l0aChcIi0tXCIpO1xuICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQodHlwZW9mIG9wdGlvbnMudHlwZSAhPT0gXCJzdHJpbmdcIiwgYGFuaW1hdGVNaW5pIGRvZXNuJ3Qgc3VwcG9ydCBcInR5cGVcIiBhcyBhIHN0cmluZy4gRGlkIHlvdSBtZWFuIHRvIGltcG9ydCB7IHNwcmluZyB9IGZyb20gXCJmcmFtZXItbW90aW9uXCI/YCk7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nQW5pbWF0aW9uID0gZ2V0RWxlbWVudEFuaW1hdGlvblN0YXRlKGVsZW1lbnQpLmdldCh2YWx1ZU5hbWUpO1xuICAgICAgICBleGlzdGluZ0FuaW1hdGlvbiAmJiBleGlzdGluZ0FuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgIGNvbnN0IHJlYWRJbml0aWFsS2V5ZnJhbWUgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWVOYW1lLnN0YXJ0c1dpdGgoXCItLVwiKVxuICAgICAgICAgICAgICAgID8gZWxlbWVudC5zdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKHZhbHVlTmFtZSlcbiAgICAgICAgICAgICAgICA6IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpW3ZhbHVlTmFtZV07XG4gICAgICAgIH07XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZUtleWZyYW1lcykpIHtcbiAgICAgICAgICAgIHZhbHVlS2V5ZnJhbWVzID0gW3ZhbHVlS2V5ZnJhbWVzXTtcbiAgICAgICAgfVxuICAgICAgICBoeWRyYXRlS2V5ZnJhbWVzKHZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXMsIHJlYWRJbml0aWFsS2V5ZnJhbWUpO1xuICAgICAgICAvLyBUT0RPOiBSZXBsYWNlIHRoaXMgd2l0aCB0b1N0cmluZygpP1xuICAgICAgICBpZiAobW90aW9uRG9tLmlzR2VuZXJhdG9yKG9wdGlvbnMudHlwZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGdlbmVyYXRvck9wdGlvbnMgPSBtb3Rpb25Eb20uY3JlYXRlR2VuZXJhdG9yRWFzaW5nKG9wdGlvbnMsIDEwMCwgb3B0aW9ucy50eXBlKTtcbiAgICAgICAgICAgIG9wdGlvbnMuZWFzZSA9IG1vdGlvbkRvbS5zdXBwb3J0c0xpbmVhckVhc2luZygpXG4gICAgICAgICAgICAgICAgPyBnZW5lcmF0b3JPcHRpb25zLmVhc2VcbiAgICAgICAgICAgICAgICA6IGRlZmF1bHRFYXNpbmc7XG4gICAgICAgICAgICBvcHRpb25zLmR1cmF0aW9uID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKGdlbmVyYXRvck9wdGlvbnMuZHVyYXRpb24pO1xuICAgICAgICAgICAgb3B0aW9ucy50eXBlID0gXCJrZXlmcmFtZXNcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZWFzZSA9IG9wdGlvbnMuZWFzZSB8fCBkZWZhdWx0RWFzaW5nO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRmluaXNoID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zZXRWYWx1ZShlbGVtZW50LCB2YWx1ZU5hbWUsIGdldEZpbmFsS2V5ZnJhbWUodmFsdWVLZXlmcmFtZXMsIG9wdGlvbnMpKTtcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsKCk7XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVGaW5pc2hlZFByb21pc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5pdCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUgPSBpc0NTU1ZhciA/IHNldENTU1ZhciA6IHNldFN0eWxlO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgICAgIHRoaXMudXBkYXRlRmluaXNoZWRQcm9taXNlKCk7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbGVtZW50U3RhdGUgPSBzdGF0ZS5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgZWxlbWVudFN0YXRlICYmIGVsZW1lbnRTdGF0ZS5kZWxldGUodmFsdWVOYW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH07XG4gICAgICAgIGlmICghc3VwcG9ydHNXYWFwaSgpKSB7XG4gICAgICAgICAgICBzdXBlcigpO1xuICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgb25GaW5pc2goKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN1cGVyKHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgdmFsdWVOYW1lLCB2YWx1ZUtleWZyYW1lcywgb3B0aW9ucykpO1xuICAgICAgICAgICAgaW5pdCgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuYXV0b3BsYXkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb24ucGF1c2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uLm9uZmluaXNoID0gb25GaW5pc2g7XG4gICAgICAgICAgICBnZXRFbGVtZW50QW5pbWF0aW9uU3RhdGUoZWxlbWVudCkuc2V0KHZhbHVlTmFtZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSByZXR1cm5lZCBhbmltYXRpb24gdG8gYmUgYXdhaXRlZCBvciBwcm9taXNlLWNoYWluZWQuIEN1cnJlbnRseVxuICAgICAqIHJlc29sdmVzIHdoZW4gdGhlIGFuaW1hdGlvbiBmaW5pc2hlcyBhdCBhbGwgYnV0IGluIGEgZnV0dXJlIHVwZGF0ZSBjb3VsZC9zaG91bGRcbiAgICAgKiByZWplY3QgaWYgaXRzIGNhbmNlbHMuXG4gICAgICovXG4gICAgdGhlbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudEZpbmlzaGVkUHJvbWlzZS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICAgIHVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50RmluaXNoZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUZpbmlzaGVkUHJvbWlzZSA9IHJlc29sdmU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwbGF5KCkge1xuICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gXCJmaW5pc2hlZFwiKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUZpbmlzaGVkUHJvbWlzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLnBsYXkoKTtcbiAgICB9XG4gICAgY2FuY2VsKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUFuaW1hdGlvbigpO1xuICAgICAgICBzdXBlci5jYW5jZWwoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGFuaW1hdGVFbGVtZW50cyhlbGVtZW50T3JTZWxlY3Rvciwga2V5ZnJhbWVzLCBvcHRpb25zLCBzY29wZSkge1xuICAgIGNvbnN0IGVsZW1lbnRzID0gbW90aW9uRG9tLnJlc29sdmVFbGVtZW50cyhlbGVtZW50T3JTZWxlY3Rvciwgc2NvcGUpO1xuICAgIGNvbnN0IG51bUVsZW1lbnRzID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIG1vdGlvblV0aWxzLmludmFyaWFudChCb29sZWFuKG51bUVsZW1lbnRzKSwgXCJObyB2YWxpZCBlbGVtZW50IHByb3ZpZGVkLlwiKTtcbiAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1FbGVtZW50czsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBlbGVtZW50c1tpXTtcbiAgICAgICAgY29uc3QgZWxlbWVudFRyYW5zaXRpb24gPSB7IC4uLm9wdGlvbnMgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlc29sdmUgc3RhZ2dlciBmdW5jdGlvbiBpZiBwcm92aWRlZC5cbiAgICAgICAgICovXG4gICAgICAgIGlmICh0eXBlb2YgZWxlbWVudFRyYW5zaXRpb24uZGVsYXkgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZWxlbWVudFRyYW5zaXRpb24uZGVsYXkgPSBlbGVtZW50VHJhbnNpdGlvbi5kZWxheShpLCBudW1FbGVtZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCB2YWx1ZU5hbWUgaW4ga2V5ZnJhbWVzKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUtleWZyYW1lcyA9IGtleWZyYW1lc1t2YWx1ZU5hbWVdO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLm1vdGlvbkRvbS5nZXRWYWx1ZVRyYW5zaXRpb24oZWxlbWVudFRyYW5zaXRpb24sIHZhbHVlTmFtZSksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFsdWVPcHRpb25zLmR1cmF0aW9uID0gdmFsdWVPcHRpb25zLmR1cmF0aW9uXG4gICAgICAgICAgICAgICAgPyBtb3Rpb25VdGlscy5zZWNvbmRzVG9NaWxsaXNlY29uZHModmFsdWVPcHRpb25zLmR1cmF0aW9uKVxuICAgICAgICAgICAgICAgIDogdmFsdWVPcHRpb25zLmR1cmF0aW9uO1xuICAgICAgICAgICAgdmFsdWVPcHRpb25zLmRlbGF5ID0gbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHZhbHVlT3B0aW9ucy5kZWxheSB8fCAwKTtcbiAgICAgICAgICAgIGFuaW1hdGlvbnMucHVzaChuZXcgTmF0aXZlQW5pbWF0aW9uKGVsZW1lbnQsIHZhbHVlTmFtZSwgdmFsdWVLZXlmcmFtZXMsIHZhbHVlT3B0aW9ucykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhbmltYXRpb25zO1xufVxuXG5jb25zdCBjcmVhdGVTY29wZWRXYWFwaUFuaW1hdGUgPSAoc2NvcGUpID0+IHtcbiAgICBmdW5jdGlvbiBzY29wZWRBbmltYXRlKGVsZW1lbnRPclNlbGVjdG9yLCBrZXlmcmFtZXMsIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBtb3Rpb25Eb20uR3JvdXBQbGF5YmFja0NvbnRyb2xzKGFuaW1hdGVFbGVtZW50cyhlbGVtZW50T3JTZWxlY3Rvciwga2V5ZnJhbWVzLCBvcHRpb25zLCBzY29wZSkpO1xuICAgIH1cbiAgICByZXR1cm4gc2NvcGVkQW5pbWF0ZTtcbn07XG5jb25zdCBhbmltYXRlTWluaSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlU2NvcGVkV2FhcGlBbmltYXRlKCk7XG5cbmZ1bmN0aW9uIG9ic2VydmVUaW1lbGluZSh1cGRhdGUsIHRpbWVsaW5lKSB7XG4gICAgbGV0IHByZXZQcm9ncmVzcztcbiAgICBjb25zdCBvbkZyYW1lID0gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnRUaW1lIH0gPSB0aW1lbGluZTtcbiAgICAgICAgY29uc3QgcGVyY2VudGFnZSA9IGN1cnJlbnRUaW1lID09PSBudWxsID8gMCA6IGN1cnJlbnRUaW1lLnZhbHVlO1xuICAgICAgICBjb25zdCBwcm9ncmVzcyA9IHBlcmNlbnRhZ2UgLyAxMDA7XG4gICAgICAgIGlmIChwcmV2UHJvZ3Jlc3MgIT09IHByb2dyZXNzKSB7XG4gICAgICAgICAgICB1cGRhdGUocHJvZ3Jlc3MpO1xuICAgICAgICB9XG4gICAgICAgIHByZXZQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgIH07XG4gICAgZnJhbWUudXBkYXRlKG9uRnJhbWUsIHRydWUpO1xuICAgIHJldHVybiAoKSA9PiBjYW5jZWxGcmFtZShvbkZyYW1lKTtcbn1cblxuY29uc3QgcmVzaXplSGFuZGxlcnMgPSBuZXcgV2Vha01hcCgpO1xubGV0IG9ic2VydmVyO1xuZnVuY3Rpb24gZ2V0RWxlbWVudFNpemUodGFyZ2V0LCBib3JkZXJCb3hTaXplKSB7XG4gICAgaWYgKGJvcmRlckJveFNpemUpIHtcbiAgICAgICAgY29uc3QgeyBpbmxpbmVTaXplLCBibG9ja1NpemUgfSA9IGJvcmRlckJveFNpemVbMF07XG4gICAgICAgIHJldHVybiB7IHdpZHRoOiBpbmxpbmVTaXplLCBoZWlnaHQ6IGJsb2NrU2l6ZSB9O1xuICAgIH1cbiAgICBlbHNlIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBTVkdFbGVtZW50ICYmIFwiZ2V0QkJveFwiIGluIHRhcmdldCkge1xuICAgICAgICByZXR1cm4gdGFyZ2V0LmdldEJCb3goKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB3aWR0aDogdGFyZ2V0Lm9mZnNldFdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiB0YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIG5vdGlmeVRhcmdldCh7IHRhcmdldCwgY29udGVudFJlY3QsIGJvcmRlckJveFNpemUsIH0pIHtcbiAgICB2YXIgX2E7XG4gICAgKF9hID0gcmVzaXplSGFuZGxlcnMuZ2V0KHRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb3JFYWNoKChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGhhbmRsZXIoe1xuICAgICAgICAgICAgdGFyZ2V0LFxuICAgICAgICAgICAgY29udGVudFNpemU6IGNvbnRlbnRSZWN0LFxuICAgICAgICAgICAgZ2V0IHNpemUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldEVsZW1lbnRTaXplKHRhcmdldCwgYm9yZGVyQm94U2l6ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIG5vdGlmeUFsbChlbnRyaWVzKSB7XG4gICAgZW50cmllcy5mb3JFYWNoKG5vdGlmeVRhcmdldCk7XG59XG5mdW5jdGlvbiBjcmVhdGVSZXNpemVPYnNlcnZlcigpIHtcbiAgICBpZiAodHlwZW9mIFJlc2l6ZU9ic2VydmVyID09PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICByZXR1cm47XG4gICAgb2JzZXJ2ZXIgPSBuZXcgUmVzaXplT2JzZXJ2ZXIobm90aWZ5QWxsKTtcbn1cbmZ1bmN0aW9uIHJlc2l6ZUVsZW1lbnQodGFyZ2V0LCBoYW5kbGVyKSB7XG4gICAgaWYgKCFvYnNlcnZlcilcbiAgICAgICAgY3JlYXRlUmVzaXplT2JzZXJ2ZXIoKTtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1vdGlvbkRvbS5yZXNvbHZlRWxlbWVudHModGFyZ2V0KTtcbiAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgIGxldCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgIGlmICghZWxlbWVudEhhbmRsZXJzKSB7XG4gICAgICAgICAgICBlbGVtZW50SGFuZGxlcnMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICByZXNpemVIYW5kbGVycy5zZXQoZWxlbWVudCwgZWxlbWVudEhhbmRsZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50SGFuZGxlcnMuYWRkKGhhbmRsZXIpO1xuICAgICAgICBvYnNlcnZlciA9PT0gbnVsbCB8fCBvYnNlcnZlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KTtcbiAgICB9KTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBlbGVtZW50cy5mb3JFYWNoKChlbGVtZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbGVtZW50SGFuZGxlcnMgPSByZXNpemVIYW5kbGVycy5nZXQoZWxlbWVudCk7XG4gICAgICAgICAgICBlbGVtZW50SGFuZGxlcnMgPT09IG51bGwgfHwgZWxlbWVudEhhbmRsZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlbGVtZW50SGFuZGxlcnMuZGVsZXRlKGhhbmRsZXIpO1xuICAgICAgICAgICAgaWYgKCEoZWxlbWVudEhhbmRsZXJzID09PSBudWxsIHx8IGVsZW1lbnRIYW5kbGVycyA9PT0gdm9pZCAwID8gdm9pZCAwIDogZWxlbWVudEhhbmRsZXJzLnNpemUpKSB7XG4gICAgICAgICAgICAgICAgb2JzZXJ2ZXIgPT09IG51bGwgfHwgb2JzZXJ2ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9ic2VydmVyLnVub2JzZXJ2ZShlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cblxuY29uc3Qgd2luZG93Q2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IHdpbmRvd1Jlc2l6ZUhhbmRsZXI7XG5mdW5jdGlvbiBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCkge1xuICAgIHdpbmRvd1Jlc2l6ZUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHNpemUgPSB7XG4gICAgICAgICAgICB3aWR0aDogd2luZG93LmlubmVyV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHdpbmRvdy5pbm5lckhlaWdodCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW5mbyA9IHtcbiAgICAgICAgICAgIHRhcmdldDogd2luZG93LFxuICAgICAgICAgICAgc2l6ZSxcbiAgICAgICAgICAgIGNvbnRlbnRTaXplOiBzaXplLFxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3dDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IGNhbGxiYWNrKGluZm8pKTtcbiAgICB9O1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHdpbmRvd1Jlc2l6ZUhhbmRsZXIpO1xufVxuZnVuY3Rpb24gcmVzaXplV2luZG93KGNhbGxiYWNrKSB7XG4gICAgd2luZG93Q2FsbGJhY2tzLmFkZChjYWxsYmFjayk7XG4gICAgaWYgKCF3aW5kb3dSZXNpemVIYW5kbGVyKVxuICAgICAgICBjcmVhdGVXaW5kb3dSZXNpemVIYW5kbGVyKCk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgd2luZG93Q2FsbGJhY2tzLmRlbGV0ZShjYWxsYmFjayk7XG4gICAgICAgIGlmICghd2luZG93Q2FsbGJhY2tzLnNpemUgJiYgd2luZG93UmVzaXplSGFuZGxlcikge1xuICAgICAgICAgICAgd2luZG93UmVzaXplSGFuZGxlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIHJlc2l6ZShhLCBiKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBhID09PSBcImZ1bmN0aW9uXCIgPyByZXNpemVXaW5kb3coYSkgOiByZXNpemVFbGVtZW50KGEsIGIpO1xufVxuXG4vKipcbiAqIEEgdGltZSBpbiBtaWxsaXNlY29uZHMsIGJleW9uZCB3aGljaCB3ZSBjb25zaWRlciB0aGUgc2Nyb2xsIHZlbG9jaXR5IHRvIGJlIDAuXG4gKi9cbmNvbnN0IG1heEVsYXBzZWQgPSA1MDtcbmNvbnN0IGNyZWF0ZUF4aXNJbmZvID0gKCkgPT4gKHtcbiAgICBjdXJyZW50OiAwLFxuICAgIG9mZnNldDogW10sXG4gICAgcHJvZ3Jlc3M6IDAsXG4gICAgc2Nyb2xsTGVuZ3RoOiAwLFxuICAgIHRhcmdldE9mZnNldDogMCxcbiAgICB0YXJnZXRMZW5ndGg6IDAsXG4gICAgY29udGFpbmVyTGVuZ3RoOiAwLFxuICAgIHZlbG9jaXR5OiAwLFxufSk7XG5jb25zdCBjcmVhdGVTY3JvbGxJbmZvID0gKCkgPT4gKHtcbiAgICB0aW1lOiAwLFxuICAgIHg6IGNyZWF0ZUF4aXNJbmZvKCksXG4gICAgeTogY3JlYXRlQXhpc0luZm8oKSxcbn0pO1xuY29uc3Qga2V5cyA9IHtcbiAgICB4OiB7XG4gICAgICAgIGxlbmd0aDogXCJXaWR0aFwiLFxuICAgICAgICBwb3NpdGlvbjogXCJMZWZ0XCIsXG4gICAgfSxcbiAgICB5OiB7XG4gICAgICAgIGxlbmd0aDogXCJIZWlnaHRcIixcbiAgICAgICAgcG9zaXRpb246IFwiVG9wXCIsXG4gICAgfSxcbn07XG5mdW5jdGlvbiB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBheGlzTmFtZSwgaW5mbywgdGltZSkge1xuICAgIGNvbnN0IGF4aXMgPSBpbmZvW2F4aXNOYW1lXTtcbiAgICBjb25zdCB7IGxlbmd0aCwgcG9zaXRpb24gfSA9IGtleXNbYXhpc05hbWVdO1xuICAgIGNvbnN0IHByZXYgPSBheGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgcHJldlRpbWUgPSBpbmZvLnRpbWU7XG4gICAgYXhpcy5jdXJyZW50ID0gZWxlbWVudFtgc2Nyb2xsJHtwb3NpdGlvbn1gXTtcbiAgICBheGlzLnNjcm9sbExlbmd0aCA9IGVsZW1lbnRbYHNjcm9sbCR7bGVuZ3RofWBdIC0gZWxlbWVudFtgY2xpZW50JHtsZW5ndGh9YF07XG4gICAgYXhpcy5vZmZzZXQubGVuZ3RoID0gMDtcbiAgICBheGlzLm9mZnNldFswXSA9IDA7XG4gICAgYXhpcy5vZmZzZXRbMV0gPSBheGlzLnNjcm9sbExlbmd0aDtcbiAgICBheGlzLnByb2dyZXNzID0gbW90aW9uVXRpbHMucHJvZ3Jlc3MoMCwgYXhpcy5zY3JvbGxMZW5ndGgsIGF4aXMuY3VycmVudCk7XG4gICAgY29uc3QgZWxhcHNlZCA9IHRpbWUgLSBwcmV2VGltZTtcbiAgICBheGlzLnZlbG9jaXR5ID1cbiAgICAgICAgZWxhcHNlZCA+IG1heEVsYXBzZWRcbiAgICAgICAgICAgID8gMFxuICAgICAgICAgICAgOiB2ZWxvY2l0eVBlclNlY29uZChheGlzLmN1cnJlbnQgLSBwcmV2LCBlbGFwc2VkKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZVNjcm9sbEluZm8oZWxlbWVudCwgaW5mbywgdGltZSkge1xuICAgIHVwZGF0ZUF4aXNJbmZvKGVsZW1lbnQsIFwieFwiLCBpbmZvLCB0aW1lKTtcbiAgICB1cGRhdGVBeGlzSW5mbyhlbGVtZW50LCBcInlcIiwgaW5mbywgdGltZSk7XG4gICAgaW5mby50aW1lID0gdGltZTtcbn1cblxuZnVuY3Rpb24gY2FsY0luc2V0KGVsZW1lbnQsIGNvbnRhaW5lcikge1xuICAgIGNvbnN0IGluc2V0ID0geyB4OiAwLCB5OiAwIH07XG4gICAgbGV0IGN1cnJlbnQgPSBlbGVtZW50O1xuICAgIHdoaWxlIChjdXJyZW50ICYmIGN1cnJlbnQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICBpbnNldC54ICs9IGN1cnJlbnQub2Zmc2V0TGVmdDtcbiAgICAgICAgICAgIGluc2V0LnkgKz0gY3VycmVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgICBjdXJyZW50ID0gY3VycmVudC5vZmZzZXRQYXJlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY3VycmVudC50YWdOYW1lID09PSBcInN2Z1wiKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXNuJ3QgYW4gaWRlYWwgYXBwcm9hY2ggdG8gbWVhc3VyaW5nIHRoZSBvZmZzZXQgb2YgPHN2ZyAvPiB0YWdzLlxuICAgICAgICAgICAgICogSXQgd291bGQgYmUgcHJlZmVyYWJsZSwgZ2l2ZW4gdGhleSBiZWhhdmUgbGlrZSBIVE1MRWxlbWVudHMgaW4gbW9zdCB3YXlzXG4gICAgICAgICAgICAgKiB0byB1c2Ugb2Zmc2V0TGVmdC9Ub3AuIEJ1dCB0aGVzZSBkb24ndCBleGlzdCBvbiA8c3ZnIC8+LiBMaWtld2lzZSB3ZVxuICAgICAgICAgICAgICogY2FuJ3QgdXNlIC5nZXRCQm94KCkgbGlrZSBtb3N0IFNWRyBlbGVtZW50cyBhcyB0aGVzZSBwcm92aWRlIHRoZSBvZmZzZXRcbiAgICAgICAgICAgICAqIHJlbGF0aXZlIHRvIHRoZSBTVkcgaXRzZWxmLCB3aGljaCBmb3IgPHN2ZyAvPiBpcyB1c3VhbGx5IDB4MC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3Qgc3ZnQm91bmRpbmdCb3ggPSBjdXJyZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICAgICAgY3VycmVudCA9IGN1cnJlbnQucGFyZW50RWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IHBhcmVudEJvdW5kaW5nQm94ID0gY3VycmVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIGluc2V0LnggKz0gc3ZnQm91bmRpbmdCb3gubGVmdCAtIHBhcmVudEJvdW5kaW5nQm94LmxlZnQ7XG4gICAgICAgICAgICBpbnNldC55ICs9IHN2Z0JvdW5kaW5nQm94LnRvcCAtIHBhcmVudEJvdW5kaW5nQm94LnRvcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjdXJyZW50IGluc3RhbmNlb2YgU1ZHR3JhcGhpY3NFbGVtZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7IHgsIHkgfSA9IGN1cnJlbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgaW5zZXQueCArPSB4O1xuICAgICAgICAgICAgaW5zZXQueSArPSB5O1xuICAgICAgICAgICAgbGV0IHN2ZyA9IG51bGw7XG4gICAgICAgICAgICBsZXQgcGFyZW50ID0gY3VycmVudC5wYXJlbnROb2RlO1xuICAgICAgICAgICAgd2hpbGUgKCFzdmcpIHtcbiAgICAgICAgICAgICAgICBpZiAocGFyZW50LnRhZ05hbWUgPT09IFwic3ZnXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3ZnID0gcGFyZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50ID0gc3ZnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2V0O1xufVxuXG5jb25zdCBuYW1lZEVkZ2VzID0ge1xuICAgIHN0YXJ0OiAwLFxuICAgIGNlbnRlcjogMC41LFxuICAgIGVuZDogMSxcbn07XG5mdW5jdGlvbiByZXNvbHZlRWRnZShlZGdlLCBsZW5ndGgsIGluc2V0ID0gMCkge1xuICAgIGxldCBkZWx0YSA9IDA7XG4gICAgLyoqXG4gICAgICogSWYgd2UgaGF2ZSB0aGlzIGVkZ2UgZGVmaW5lZCBhcyBhIHByZXNldCwgcmVwbGFjZSB0aGUgZGVmaW5pdGlvblxuICAgICAqIHdpdGggdGhlIG51bWVyaWNhbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBpZiAoZWRnZSBpbiBuYW1lZEVkZ2VzKSB7XG4gICAgICAgIGVkZ2UgPSBuYW1lZEVkZ2VzW2VkZ2VdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGUgdW5pdCB2YWx1ZXNcbiAgICAgKi9cbiAgICBpZiAodHlwZW9mIGVkZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgYXNOdW1iZXIgPSBwYXJzZUZsb2F0KGVkZ2UpO1xuICAgICAgICBpZiAoZWRnZS5lbmRzV2l0aChcInB4XCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IGFzTnVtYmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVkZ2UuZW5kc1dpdGgoXCIlXCIpKSB7XG4gICAgICAgICAgICBlZGdlID0gYXNOdW1iZXIgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZ3XCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChhc051bWJlciAvIDEwMCkgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZWRnZS5lbmRzV2l0aChcInZoXCIpKSB7XG4gICAgICAgICAgICBkZWx0YSA9IChhc051bWJlciAvIDEwMCkgKiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZWRnZSA9IGFzTnVtYmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIHRoZSBlZGdlIGlzIGRlZmluZWQgYXMgYSBudW1iZXIsIGhhbmRsZSBhcyBhIHByb2dyZXNzIHZhbHVlLlxuICAgICAqL1xuICAgIGlmICh0eXBlb2YgZWRnZSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBkZWx0YSA9IGxlbmd0aCAqIGVkZ2U7XG4gICAgfVxuICAgIHJldHVybiBpbnNldCArIGRlbHRhO1xufVxuXG5jb25zdCBkZWZhdWx0T2Zmc2V0ID0gWzAsIDBdO1xuZnVuY3Rpb24gcmVzb2x2ZU9mZnNldChvZmZzZXQsIGNvbnRhaW5lckxlbmd0aCwgdGFyZ2V0TGVuZ3RoLCB0YXJnZXRJbnNldCkge1xuICAgIGxldCBvZmZzZXREZWZpbml0aW9uID0gQXJyYXkuaXNBcnJheShvZmZzZXQpID8gb2Zmc2V0IDogZGVmYXVsdE9mZnNldDtcbiAgICBsZXQgdGFyZ2V0UG9pbnQgPSAwO1xuICAgIGxldCBjb250YWluZXJQb2ludCA9IDA7XG4gICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIHByb3ZpZGVkIG9mZnNldDogWzAsIDAuNSwgMV0gdGhlbiBlYWNoIG51bWJlciB4IHNob3VsZCBiZWNvbWVcbiAgICAgICAgICogW3gsIHhdLCBzbyB3ZSBkZWZhdWx0IHRvIHRoZSBiZWhhdmlvdXIgb2YgbWFwcGluZyAwID0+IDAgb2YgYm90aCB0YXJnZXRcbiAgICAgICAgICogYW5kIGNvbnRhaW5lciBldGMuXG4gICAgICAgICAqL1xuICAgICAgICBvZmZzZXREZWZpbml0aW9uID0gW29mZnNldCwgb2Zmc2V0XTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIG9mZnNldCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBvZmZzZXQgPSBvZmZzZXQudHJpbSgpO1xuICAgICAgICBpZiAob2Zmc2V0LmluY2x1ZGVzKFwiIFwiKSkge1xuICAgICAgICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IG9mZnNldC5zcGxpdChcIiBcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3JlIHByb3ZpZGVkIGEgZGVmaW5pdGlvbiBsaWtlIFwiMTAwcHhcIiB0aGVuIHdlIHdhbnQgdG8gYXBwbHlcbiAgICAgICAgICAgICAqIHRoYXQgb25seSB0byB0aGUgdG9wIG9mIHRoZSB0YXJnZXQgcG9pbnQsIGxlYXZpbmcgdGhlIGNvbnRhaW5lciBhdCAwLlxuICAgICAgICAgICAgICogV2hlcmVhcyBhIG5hbWVkIG9mZnNldCBsaWtlIFwiZW5kXCIgc2hvdWxkIGJlIGFwcGxpZWQgdG8gYm90aC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb2Zmc2V0RGVmaW5pdGlvbiA9IFtvZmZzZXQsIG5hbWVkRWRnZXNbb2Zmc2V0XSA/IG9mZnNldCA6IGAwYF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGFyZ2V0UG9pbnQgPSByZXNvbHZlRWRnZShvZmZzZXREZWZpbml0aW9uWzBdLCB0YXJnZXRMZW5ndGgsIHRhcmdldEluc2V0KTtcbiAgICBjb250YWluZXJQb2ludCA9IHJlc29sdmVFZGdlKG9mZnNldERlZmluaXRpb25bMV0sIGNvbnRhaW5lckxlbmd0aCk7XG4gICAgcmV0dXJuIHRhcmdldFBvaW50IC0gY29udGFpbmVyUG9pbnQ7XG59XG5cbmNvbnN0IFNjcm9sbE9mZnNldCA9IHtcbiAgICBFbnRlcjogW1xuICAgICAgICBbMCwgMV0sXG4gICAgICAgIFsxLCAxXSxcbiAgICBdLFxuICAgIEV4aXQ6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMSwgMF0sXG4gICAgXSxcbiAgICBBbnk6IFtcbiAgICAgICAgWzEsIDBdLFxuICAgICAgICBbMCwgMV0sXG4gICAgXSxcbiAgICBBbGw6IFtcbiAgICAgICAgWzAsIDBdLFxuICAgICAgICBbMSwgMV0sXG4gICAgXSxcbn07XG5cbmNvbnN0IHBvaW50ID0geyB4OiAwLCB5OiAwIH07XG5mdW5jdGlvbiBnZXRUYXJnZXRTaXplKHRhcmdldCkge1xuICAgIHJldHVybiBcImdldEJCb3hcIiBpbiB0YXJnZXQgJiYgdGFyZ2V0LnRhZ05hbWUgIT09IFwic3ZnXCJcbiAgICAgICAgPyB0YXJnZXQuZ2V0QkJveCgpXG4gICAgICAgIDogeyB3aWR0aDogdGFyZ2V0LmNsaWVudFdpZHRoLCBoZWlnaHQ6IHRhcmdldC5jbGllbnRIZWlnaHQgfTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVPZmZzZXRzKGNvbnRhaW5lciwgaW5mbywgb3B0aW9ucykge1xuICAgIGNvbnN0IHsgb2Zmc2V0OiBvZmZzZXREZWZpbml0aW9uID0gU2Nyb2xsT2Zmc2V0LkFsbCB9ID0gb3B0aW9ucztcbiAgICBjb25zdCB7IHRhcmdldCA9IGNvbnRhaW5lciwgYXhpcyA9IFwieVwiIH0gPSBvcHRpb25zO1xuICAgIGNvbnN0IGxlbmd0aExhYmVsID0gYXhpcyA9PT0gXCJ5XCIgPyBcImhlaWdodFwiIDogXCJ3aWR0aFwiO1xuICAgIGNvbnN0IGluc2V0ID0gdGFyZ2V0ICE9PSBjb250YWluZXIgPyBjYWxjSW5zZXQodGFyZ2V0LCBjb250YWluZXIpIDogcG9pbnQ7XG4gICAgLyoqXG4gICAgICogTWVhc3VyZSB0aGUgdGFyZ2V0IGFuZCBjb250YWluZXIuIElmIHRoZXkncmUgdGhlIHNhbWUgdGhpbmcgdGhlbiB3ZVxuICAgICAqIHVzZSB0aGUgY29udGFpbmVyJ3Mgc2Nyb2xsV2lkdGgvSGVpZ2h0IGFzIHRoZSB0YXJnZXQsIGZyb20gdGhlcmVcbiAgICAgKiBhbGwgb3RoZXIgY2FsY3VsYXRpb25zIGNhbiByZW1haW4gdGhlIHNhbWUuXG4gICAgICovXG4gICAgY29uc3QgdGFyZ2V0U2l6ZSA9IHRhcmdldCA9PT0gY29udGFpbmVyXG4gICAgICAgID8geyB3aWR0aDogY29udGFpbmVyLnNjcm9sbFdpZHRoLCBoZWlnaHQ6IGNvbnRhaW5lci5zY3JvbGxIZWlnaHQgfVxuICAgICAgICA6IGdldFRhcmdldFNpemUodGFyZ2V0KTtcbiAgICBjb25zdCBjb250YWluZXJTaXplID0ge1xuICAgICAgICB3aWR0aDogY29udGFpbmVyLmNsaWVudFdpZHRoLFxuICAgICAgICBoZWlnaHQ6IGNvbnRhaW5lci5jbGllbnRIZWlnaHQsXG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgbGVuZ3RoIG9mIHRoZSByZXNvbHZlZCBvZmZzZXQgYXJyYXkgcmF0aGVyIHRoYW4gY3JlYXRpbmcgYSBuZXcgb25lLlxuICAgICAqIFRPRE86IE1vcmUgcmV1c2FibGUgZGF0YSBzdHJ1Y3R1cmVzIGZvciB0YXJnZXRTaXplL2NvbnRhaW5lclNpemUgd291bGQgYWxzbyBiZSBnb29kLlxuICAgICAqL1xuICAgIGluZm9bYXhpc10ub2Zmc2V0Lmxlbmd0aCA9IDA7XG4gICAgLyoqXG4gICAgICogUG9wdWxhdGUgdGhlIG9mZnNldCBhcnJheSBieSByZXNvbHZpbmcgdGhlIHVzZXIncyBvZmZzZXQgZGVmaW5pdGlvbiBpbnRvXG4gICAgICogYSBsaXN0IG9mIHBpeGVsIHNjcm9sbCBvZmZldHMuXG4gICAgICovXG4gICAgbGV0IGhhc0NoYW5nZWQgPSAhaW5mb1theGlzXS5pbnRlcnBvbGF0ZTtcbiAgICBjb25zdCBudW1PZmZzZXRzID0gb2Zmc2V0RGVmaW5pdGlvbi5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1PZmZzZXRzOyBpKyspIHtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gcmVzb2x2ZU9mZnNldChvZmZzZXREZWZpbml0aW9uW2ldLCBjb250YWluZXJTaXplW2xlbmd0aExhYmVsXSwgdGFyZ2V0U2l6ZVtsZW5ndGhMYWJlbF0sIGluc2V0W2F4aXNdKTtcbiAgICAgICAgaWYgKCFoYXNDaGFuZ2VkICYmIG9mZnNldCAhPT0gaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzW2ldKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvW2F4aXNdLm9mZnNldFtpXSA9IG9mZnNldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSWYgdGhlIHBpeGVsIHNjcm9sbCBvZmZzZXRzIGhhdmUgY2hhbmdlZCwgY3JlYXRlIGEgbmV3IGludGVycG9sYXRvciBmdW5jdGlvblxuICAgICAqIHRvIG1hcCBzY3JvbGwgdmFsdWUgaW50byBhIHByb2dyZXNzLlxuICAgICAqL1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICAgIGluZm9bYXhpc10uaW50ZXJwb2xhdGUgPSBpbnRlcnBvbGF0ZShpbmZvW2F4aXNdLm9mZnNldCwgZGVmYXVsdE9mZnNldCQxKG9mZnNldERlZmluaXRpb24pLCB7IGNsYW1wOiBmYWxzZSB9KTtcbiAgICAgICAgaW5mb1theGlzXS5pbnRlcnBvbGF0b3JPZmZzZXRzID0gWy4uLmluZm9bYXhpc10ub2Zmc2V0XTtcbiAgICB9XG4gICAgaW5mb1theGlzXS5wcm9ncmVzcyA9IGNsYW1wKDAsIDEsIGluZm9bYXhpc10uaW50ZXJwb2xhdGUoaW5mb1theGlzXS5jdXJyZW50KSk7XG59XG5cbmZ1bmN0aW9uIG1lYXN1cmUoY29udGFpbmVyLCB0YXJnZXQgPSBjb250YWluZXIsIGluZm8pIHtcbiAgICAvKipcbiAgICAgKiBGaW5kIGluc2V0IG9mIHRhcmdldCB3aXRoaW4gc2Nyb2xsYWJsZSBjb250YWluZXJcbiAgICAgKi9cbiAgICBpbmZvLngudGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICBpbmZvLnkudGFyZ2V0T2Zmc2V0ID0gMDtcbiAgICBpZiAodGFyZ2V0ICE9PSBjb250YWluZXIpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB0YXJnZXQ7XG4gICAgICAgIHdoaWxlIChub2RlICYmIG5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgaW5mby54LnRhcmdldE9mZnNldCArPSBub2RlLm9mZnNldExlZnQ7XG4gICAgICAgICAgICBpbmZvLnkudGFyZ2V0T2Zmc2V0ICs9IG5vZGUub2Zmc2V0VG9wO1xuICAgICAgICAgICAgbm9kZSA9IG5vZGUub2Zmc2V0UGFyZW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIGluZm8ueC50YXJnZXRMZW5ndGggPVxuICAgICAgICB0YXJnZXQgPT09IGNvbnRhaW5lciA/IHRhcmdldC5zY3JvbGxXaWR0aCA6IHRhcmdldC5jbGllbnRXaWR0aDtcbiAgICBpbmZvLnkudGFyZ2V0TGVuZ3RoID1cbiAgICAgICAgdGFyZ2V0ID09PSBjb250YWluZXIgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IDogdGFyZ2V0LmNsaWVudEhlaWdodDtcbiAgICBpbmZvLnguY29udGFpbmVyTGVuZ3RoID0gY29udGFpbmVyLmNsaWVudFdpZHRoO1xuICAgIGluZm8ueS5jb250YWluZXJMZW5ndGggPSBjb250YWluZXIuY2xpZW50SGVpZ2h0O1xuICAgIC8qKlxuICAgICAqIEluIGRldmVsb3BtZW50IG1vZGUgZW5zdXJlIHNjcm9sbCBjb250YWluZXJzIGFyZW4ndCBwb3NpdGlvbjogc3RhdGljIGFzIHRoaXMgbWFrZXNcbiAgICAgKiBpdCBkaWZmaWN1bHQgdG8gbWVhc3VyZSB0aGVpciByZWxhdGl2ZSBwb3NpdGlvbnMuXG4gICAgICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICBpZiAoY29udGFpbmVyICYmIHRhcmdldCAmJiB0YXJnZXQgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgd2Fybk9uY2UoZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpLnBvc2l0aW9uICE9PSBcInN0YXRpY1wiLCBcIlBsZWFzZSBlbnN1cmUgdGhhdCB0aGUgY29udGFpbmVyIGhhcyBhIG5vbi1zdGF0aWMgcG9zaXRpb24sIGxpa2UgJ3JlbGF0aXZlJywgJ2ZpeGVkJywgb3IgJ2Fic29sdXRlJyB0byBlbnN1cmUgc2Nyb2xsIG9mZnNldCBpcyBjYWxjdWxhdGVkIGNvcnJlY3RseS5cIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVPblNjcm9sbEhhbmRsZXIoZWxlbWVudCwgb25TY3JvbGwsIGluZm8sIG9wdGlvbnMgPSB7fSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1lYXN1cmU6ICgpID0+IG1lYXN1cmUoZWxlbWVudCwgb3B0aW9ucy50YXJnZXQsIGluZm8pLFxuICAgICAgICB1cGRhdGU6ICh0aW1lKSA9PiB7XG4gICAgICAgICAgICB1cGRhdGVTY3JvbGxJbmZvKGVsZW1lbnQsIGluZm8sIHRpbWUpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMub2Zmc2V0IHx8IG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZU9mZnNldHMoZWxlbWVudCwgaW5mbywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG5vdGlmeTogKCkgPT4gb25TY3JvbGwoaW5mbyksXG4gICAgfTtcbn1cblxuY29uc3Qgc2Nyb2xsTGlzdGVuZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IHJlc2l6ZUxpc3RlbmVycyA9IG5ldyBXZWFrTWFwKCk7XG5jb25zdCBvblNjcm9sbEhhbmRsZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGdldEV2ZW50VGFyZ2V0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCA/IHdpbmRvdyA6IGVsZW1lbnQ7XG5mdW5jdGlvbiBzY3JvbGxJbmZvKG9uU2Nyb2xsLCB7IGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBsZXQgY29udGFpbmVySGFuZGxlcnMgPSBvblNjcm9sbEhhbmRsZXJzLmdldChjb250YWluZXIpO1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgb25TY3JvbGwgaGFuZGxlcnMgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgICAqIElmIG9uZSBpc24ndCBmb3VuZCwgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIWNvbnRhaW5lckhhbmRsZXJzKSB7XG4gICAgICAgIGNvbnRhaW5lckhhbmRsZXJzID0gbmV3IFNldCgpO1xuICAgICAgICBvblNjcm9sbEhhbmRsZXJzLnNldChjb250YWluZXIsIGNvbnRhaW5lckhhbmRsZXJzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IG9uU2Nyb2xsIGhhbmRsZXIgZm9yIHRoZSBwcm92aWRlZCBjYWxsYmFjay5cbiAgICAgKi9cbiAgICBjb25zdCBpbmZvID0gY3JlYXRlU2Nyb2xsSW5mbygpO1xuICAgIGNvbnN0IGNvbnRhaW5lckhhbmRsZXIgPSBjcmVhdGVPblNjcm9sbEhhbmRsZXIoY29udGFpbmVyLCBvblNjcm9sbCwgaW5mbywgb3B0aW9ucyk7XG4gICAgY29udGFpbmVySGFuZGxlcnMuYWRkKGNvbnRhaW5lckhhbmRsZXIpO1xuICAgIC8qKlxuICAgICAqIENoZWNrIGlmIHRoZXJlJ3MgYSBzY3JvbGwgZXZlbnQgbGlzdGVuZXIgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgICAqIElmIG5vdCwgY3JlYXRlIG9uZS5cbiAgICAgKi9cbiAgICBpZiAoIXNjcm9sbExpc3RlbmVycy5oYXMoY29udGFpbmVyKSkge1xuICAgICAgICBjb25zdCBtZWFzdXJlQWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIubWVhc3VyZSgpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB1cGRhdGVBbGwgPSAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGhhbmRsZXIgb2YgY29udGFpbmVySGFuZGxlcnMpIHtcbiAgICAgICAgICAgICAgICBoYW5kbGVyLnVwZGF0ZShmcmFtZURhdGEudGltZXN0YW1wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm90aWZ5QWxsID0gKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBoYW5kbGVyIG9mIGNvbnRhaW5lckhhbmRsZXJzKVxuICAgICAgICAgICAgICAgIGhhbmRsZXIubm90aWZ5KCk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgZnJhbWUucmVhZChtZWFzdXJlQWxsLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBmcmFtZS5yZWFkKHVwZGF0ZUFsbCwgZmFsc2UsIHRydWUpO1xuICAgICAgICAgICAgZnJhbWUudXBkYXRlKG5vdGlmeUFsbCwgZmFsc2UsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICBzY3JvbGxMaXN0ZW5lcnMuc2V0KGNvbnRhaW5lciwgbGlzdGVuZXIpO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRFdmVudFRhcmdldChjb250YWluZXIpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBsaXN0ZW5lciwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuICAgICAgICBpZiAoY29udGFpbmVyICE9PSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJlc2l6ZUxpc3RlbmVycy5zZXQoY29udGFpbmVyLCByZXNpemUoY29udGFpbmVyLCBsaXN0ZW5lcikpO1xuICAgICAgICB9XG4gICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGxpc3RlbmVyLCB7IHBhc3NpdmU6IHRydWUgfSk7XG4gICAgfVxuICAgIGNvbnN0IGxpc3RlbmVyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICAgIGZyYW1lLnJlYWQobGlzdGVuZXIsIGZhbHNlLCB0cnVlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNhbmNlbEZyYW1lKGxpc3RlbmVyKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIGlmIHdlIGV2ZW4gaGF2ZSBhbnkgaGFuZGxlcnMgZm9yIHRoaXMgY29udGFpbmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgY3VycmVudEhhbmRsZXJzID0gb25TY3JvbGxIYW5kbGVycy5nZXQoY29udGFpbmVyKTtcbiAgICAgICAgaWYgKCFjdXJyZW50SGFuZGxlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGN1cnJlbnRIYW5kbGVycy5kZWxldGUoY29udGFpbmVySGFuZGxlcik7XG4gICAgICAgIGlmIChjdXJyZW50SGFuZGxlcnMuc2l6ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIG5vIG1vcmUgaGFuZGxlcnMsIHJlbW92ZSB0aGUgc2Nyb2xsIGxpc3RlbmVyIHRvby5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHNjcm9sbExpc3RlbmVyID0gc2Nyb2xsTGlzdGVuZXJzLmdldChjb250YWluZXIpO1xuICAgICAgICBzY3JvbGxMaXN0ZW5lcnMuZGVsZXRlKGNvbnRhaW5lcik7XG4gICAgICAgIGlmIChzY3JvbGxMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2V0RXZlbnRUYXJnZXQoY29udGFpbmVyKS5yZW1vdmVFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIHNjcm9sbExpc3RlbmVyKTtcbiAgICAgICAgICAgIChfYSA9IHJlc2l6ZUxpc3RlbmVycy5nZXQoY29udGFpbmVyKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hKCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInJlc2l6ZVwiLCBzY3JvbGxMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBzY3JvbGxUaW1lbGluZUZhbGxiYWNrKHsgc291cmNlLCBjb250YWluZXIsIGF4aXMgPSBcInlcIiwgfSkge1xuICAgIC8vIFN1cHBvcnQgbGVnYWN5IHNvdXJjZSBhcmd1bWVudC4gRGVwcmVjYXRlIGxhdGVyLlxuICAgIGlmIChzb3VyY2UpXG4gICAgICAgIGNvbnRhaW5lciA9IHNvdXJjZTtcbiAgICAvLyBTY3JvbGxUaW1lbGluZSByZWNvcmRzIHByb2dyZXNzIGFzIGEgcGVyY2VudGFnZSBDU1NVbml0VmFsdWVcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IHsgdmFsdWU6IDAgfTtcbiAgICBjb25zdCBjYW5jZWwgPSBzY3JvbGxJbmZvKChpbmZvKSA9PiB7XG4gICAgICAgIGN1cnJlbnRUaW1lLnZhbHVlID0gaW5mb1theGlzXS5wcm9ncmVzcyAqIDEwMDtcbiAgICB9LCB7IGNvbnRhaW5lciwgYXhpcyB9KTtcbiAgICByZXR1cm4geyBjdXJyZW50VGltZSwgY2FuY2VsIH07XG59XG5jb25zdCB0aW1lbGluZUNhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0VGltZWxpbmUoeyBzb3VyY2UsIGNvbnRhaW5lciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCwgYXhpcyA9IFwieVwiLCB9ID0ge30pIHtcbiAgICAvLyBTdXBwb3J0IGxlZ2FjeSBzb3VyY2UgYXJndW1lbnQuIERlcHJlY2F0ZSBsYXRlci5cbiAgICBpZiAoc291cmNlKVxuICAgICAgICBjb250YWluZXIgPSBzb3VyY2U7XG4gICAgaWYgKCF0aW1lbGluZUNhY2hlLmhhcyhjb250YWluZXIpKSB7XG4gICAgICAgIHRpbWVsaW5lQ2FjaGUuc2V0KGNvbnRhaW5lciwge30pO1xuICAgIH1cbiAgICBjb25zdCBlbGVtZW50Q2FjaGUgPSB0aW1lbGluZUNhY2hlLmdldChjb250YWluZXIpO1xuICAgIGlmICghZWxlbWVudENhY2hlW2F4aXNdKSB7XG4gICAgICAgIGVsZW1lbnRDYWNoZVtheGlzXSA9IG1vdGlvbkRvbS5zdXBwb3J0c1Njcm9sbFRpbWVsaW5lKClcbiAgICAgICAgICAgID8gbmV3IFNjcm9sbFRpbWVsaW5lKHsgc291cmNlOiBjb250YWluZXIsIGF4aXMgfSlcbiAgICAgICAgICAgIDogc2Nyb2xsVGltZWxpbmVGYWxsYmFjayh7IHNvdXJjZTogY29udGFpbmVyLCBheGlzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudENhY2hlW2F4aXNdO1xufVxuLyoqXG4gKiBJZiB0aGUgb25TY3JvbGwgZnVuY3Rpb24gaGFzIHR3byBhcmd1bWVudHMsIGl0J3MgZXhwZWN0aW5nXG4gKiBtb3JlIHNwZWNpZmljIGluZm9ybWF0aW9uIGFib3V0IHRoZSBzY3JvbGwgZnJvbSBzY3JvbGxJbmZvLlxuICovXG5mdW5jdGlvbiBpc09uU2Nyb2xsV2l0aEluZm8ob25TY3JvbGwpIHtcbiAgICByZXR1cm4gb25TY3JvbGwubGVuZ3RoID09PSAyO1xufVxuLyoqXG4gKiBDdXJyZW50bHksIHdlIG9ubHkgc3VwcG9ydCBlbGVtZW50IHRyYWNraW5nIHdpdGggYHNjcm9sbEluZm9gLCB0aG91Z2ggaW5cbiAqIHRoZSBmdXR1cmUgd2UgY2FuIGFsc28gb2ZmZXIgVmlld1RpbWVsaW5lIHN1cHBvcnQuXG4gKi9cbmZ1bmN0aW9uIG5lZWRzRWxlbWVudFRyYWNraW5nKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gb3B0aW9ucyAmJiAob3B0aW9ucy50YXJnZXQgfHwgb3B0aW9ucy5vZmZzZXQpO1xufVxuZnVuY3Rpb24gc2Nyb2xsRnVuY3Rpb24ob25TY3JvbGwsIG9wdGlvbnMpIHtcbiAgICBpZiAoaXNPblNjcm9sbFdpdGhJbmZvKG9uU2Nyb2xsKSB8fCBuZWVkc0VsZW1lbnRUcmFja2luZyhvcHRpb25zKSkge1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW5mbygoaW5mbykgPT4ge1xuICAgICAgICAgICAgb25TY3JvbGwoaW5mb1tvcHRpb25zLmF4aXNdLnByb2dyZXNzLCBpbmZvKTtcbiAgICAgICAgfSwgb3B0aW9ucyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZVRpbWVsaW5lKG9uU2Nyb2xsLCBnZXRUaW1lbGluZShvcHRpb25zKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsQW5pbWF0aW9uKGFuaW1hdGlvbiwgb3B0aW9ucykge1xuICAgIGFuaW1hdGlvbi5mbGF0dGVuKCk7XG4gICAgaWYgKG5lZWRzRWxlbWVudFRyYWNraW5nKG9wdGlvbnMpKSB7XG4gICAgICAgIGFuaW1hdGlvbi5wYXVzZSgpO1xuICAgICAgICByZXR1cm4gc2Nyb2xsSW5mbygoaW5mbykgPT4ge1xuICAgICAgICAgICAgYW5pbWF0aW9uLnRpbWUgPSBhbmltYXRpb24uZHVyYXRpb24gKiBpbmZvW29wdGlvbnMuYXhpc10ucHJvZ3Jlc3M7XG4gICAgICAgIH0sIG9wdGlvbnMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgdGltZWxpbmUgPSBnZXRUaW1lbGluZShvcHRpb25zKTtcbiAgICAgICAgaWYgKGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSkge1xuICAgICAgICAgICAgcmV0dXJuIGFuaW1hdGlvbi5hdHRhY2hUaW1lbGluZSh0aW1lbGluZSwgKHZhbHVlQW5pbWF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFsdWVBbmltYXRpb24ucGF1c2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gb2JzZXJ2ZVRpbWVsaW5lKChwcm9ncmVzcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZUFuaW1hdGlvbi50aW1lID0gdmFsdWVBbmltYXRpb24uZHVyYXRpb24gKiBwcm9ncmVzcztcbiAgICAgICAgICAgICAgICB9LCB0aW1lbGluZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBtb3Rpb25VdGlscy5ub29wO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gc2Nyb2xsKG9uU2Nyb2xsLCB7IGF4aXMgPSBcInlcIiwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBjb25zdCBvcHRpb25zV2l0aERlZmF1bHRzID0geyBheGlzLCAuLi5vcHRpb25zIH07XG4gICAgcmV0dXJuIHR5cGVvZiBvblNjcm9sbCA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gc2Nyb2xsRnVuY3Rpb24ob25TY3JvbGwsIG9wdGlvbnNXaXRoRGVmYXVsdHMpXG4gICAgICAgIDogc2Nyb2xsQW5pbWF0aW9uKG9uU2Nyb2xsLCBvcHRpb25zV2l0aERlZmF1bHRzKTtcbn1cblxuY29uc3QgdGhyZXNob2xkcyA9IHtcbiAgICBzb21lOiAwLFxuICAgIGFsbDogMSxcbn07XG5mdW5jdGlvbiBpblZpZXcoZWxlbWVudE9yU2VsZWN0b3IsIG9uU3RhcnQsIHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiB9ID0ge30pIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IG1vdGlvbkRvbS5yZXNvbHZlRWxlbWVudHMoZWxlbWVudE9yU2VsZWN0b3IpO1xuICAgIGNvbnN0IGFjdGl2ZUludGVyc2VjdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IG9uSW50ZXJzZWN0aW9uQ2hhbmdlID0gKGVudHJpZXMpID0+IHtcbiAgICAgICAgZW50cmllcy5mb3JFYWNoKChlbnRyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb25FbmQgPSBhY3RpdmVJbnRlcnNlY3Rpb25zLmdldChlbnRyeS50YXJnZXQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGVyZSdzIG5vIGNoYW5nZSB0byB0aGUgaW50ZXJzZWN0aW9uLCB3ZSBkb24ndCBuZWVkIHRvXG4gICAgICAgICAgICAgKiBkbyBhbnl0aGluZyBoZXJlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZW50cnkuaXNJbnRlcnNlY3RpbmcgPT09IEJvb2xlYW4ob25FbmQpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGlmIChlbnRyeS5pc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5ld09uRW5kID0gb25TdGFydChlbnRyeSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuZXdPbkVuZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdGl2ZUludGVyc2VjdGlvbnMuc2V0KGVudHJ5LnRhcmdldCwgbmV3T25FbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgb2JzZXJ2ZXIudW5vYnNlcnZlKGVudHJ5LnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIG9uRW5kID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChlbnRyeSk7XG4gICAgICAgICAgICAgICAgYWN0aXZlSW50ZXJzZWN0aW9ucy5kZWxldGUoZW50cnkudGFyZ2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvYnNlcnZlciA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihvbkludGVyc2VjdGlvbkNoYW5nZSwge1xuICAgICAgICByb290LFxuICAgICAgICByb290TWFyZ2luLFxuICAgICAgICB0aHJlc2hvbGQ6IHR5cGVvZiBhbW91bnQgPT09IFwibnVtYmVyXCIgPyBhbW91bnQgOiB0aHJlc2hvbGRzW2Ftb3VudF0sXG4gICAgfSk7XG4gICAgZWxlbWVudHMuZm9yRWFjaCgoZWxlbWVudCkgPT4gb2JzZXJ2ZXIub2JzZXJ2ZShlbGVtZW50KSk7XG4gICAgcmV0dXJuICgpID0+IG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbn1cblxuZnVuY3Rpb24gc3RlcHMobnVtU3RlcHMsIGRpcmVjdGlvbiA9IFwiZW5kXCIpIHtcbiAgICByZXR1cm4gKHByb2dyZXNzKSA9PiB7XG4gICAgICAgIHByb2dyZXNzID1cbiAgICAgICAgICAgIGRpcmVjdGlvbiA9PT0gXCJlbmRcIlxuICAgICAgICAgICAgICAgID8gTWF0aC5taW4ocHJvZ3Jlc3MsIDAuOTk5KVxuICAgICAgICAgICAgICAgIDogTWF0aC5tYXgocHJvZ3Jlc3MsIDAuMDAxKTtcbiAgICAgICAgY29uc3QgZXhwYW5kZWQgPSBwcm9ncmVzcyAqIG51bVN0ZXBzO1xuICAgICAgICBjb25zdCByb3VuZGVkID0gZGlyZWN0aW9uID09PSBcImVuZFwiID8gTWF0aC5mbG9vcihleHBhbmRlZCkgOiBNYXRoLmNlaWwoZXhwYW5kZWQpO1xuICAgICAgICByZXR1cm4gY2xhbXAoMCwgMSwgcm91bmRlZCAvIG51bVN0ZXBzKTtcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBnZXRPcmlnaW5JbmRleChmcm9tLCB0b3RhbCkge1xuICAgIGlmIChmcm9tID09PSBcImZpcnN0XCIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBsYXN0SW5kZXggPSB0b3RhbCAtIDE7XG4gICAgICAgIHJldHVybiBmcm9tID09PSBcImxhc3RcIiA/IGxhc3RJbmRleCA6IGxhc3RJbmRleCAvIDI7XG4gICAgfVxufVxuZnVuY3Rpb24gc3RhZ2dlcihkdXJhdGlvbiA9IDAuMSwgeyBzdGFydERlbGF5ID0gMCwgZnJvbSA9IDAsIGVhc2UgfSA9IHt9KSB7XG4gICAgcmV0dXJuIChpLCB0b3RhbCkgPT4ge1xuICAgICAgICBjb25zdCBmcm9tSW5kZXggPSB0eXBlb2YgZnJvbSA9PT0gXCJudW1iZXJcIiA/IGZyb20gOiBnZXRPcmlnaW5JbmRleChmcm9tLCB0b3RhbCk7XG4gICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMoZnJvbUluZGV4IC0gaSk7XG4gICAgICAgIGxldCBkZWxheSA9IGR1cmF0aW9uICogZGlzdGFuY2U7XG4gICAgICAgIGlmIChlYXNlKSB7XG4gICAgICAgICAgICBjb25zdCBtYXhEZWxheSA9IHRvdGFsICogZHVyYXRpb247XG4gICAgICAgICAgICBjb25zdCBlYXNpbmdGdW5jdGlvbiA9IGVhc2luZ0RlZmluaXRpb25Ub0Z1bmN0aW9uKGVhc2UpO1xuICAgICAgICAgICAgZGVsYXkgPSBlYXNpbmdGdW5jdGlvbihkZWxheSAvIG1heERlbGF5KSAqIG1heERlbGF5O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdGFydERlbGF5ICsgZGVsYXk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBUaW1lb3V0IGRlZmluZWQgaW4gbXNcbiAqL1xuZnVuY3Rpb24gZGVsYXkoY2FsbGJhY2ssIHRpbWVvdXQpIHtcbiAgICBjb25zdCBzdGFydCA9IHRpbWUubm93KCk7XG4gICAgY29uc3QgY2hlY2tFbGFwc2VkID0gKHsgdGltZXN0YW1wIH0pID0+IHtcbiAgICAgICAgY29uc3QgZWxhcHNlZCA9IHRpbWVzdGFtcCAtIHN0YXJ0O1xuICAgICAgICBpZiAoZWxhcHNlZCA+PSB0aW1lb3V0KSB7XG4gICAgICAgICAgICBjYW5jZWxGcmFtZShjaGVja0VsYXBzZWQpO1xuICAgICAgICAgICAgY2FsbGJhY2soZWxhcHNlZCAtIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmcmFtZS5yZWFkKGNoZWNrRWxhcHNlZCwgdHJ1ZSk7XG4gICAgcmV0dXJuICgpID0+IGNhbmNlbEZyYW1lKGNoZWNrRWxhcHNlZCk7XG59XG5cbmNvbnN0IGRpc3RhbmNlID0gKGEsIGIpID0+IE1hdGguYWJzKGEgLSBiKTtcbmZ1bmN0aW9uIGRpc3RhbmNlMkQoYSwgYikge1xuICAgIC8vIE11bHRpLWRpbWVuc2lvbmFsXG4gICAgY29uc3QgeERlbHRhID0gZGlzdGFuY2UoYS54LCBiLngpO1xuICAgIGNvbnN0IHlEZWx0YSA9IGRpc3RhbmNlKGEueSwgYi55KTtcbiAgICByZXR1cm4gTWF0aC5zcXJ0KHhEZWx0YSAqKiAyICsgeURlbHRhICoqIDIpO1xufVxuXG5jb25zdCBpc0N1c3RvbVZhbHVlVHlwZSA9ICh2KSA9PiB7XG4gICAgcmV0dXJuIHYgJiYgdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdi5taXg7XG59O1xuY29uc3QgZ2V0TWl4ZXIgPSAodikgPT4gKGlzQ3VzdG9tVmFsdWVUeXBlKHYpID8gdi5taXggOiB1bmRlZmluZWQpO1xuZnVuY3Rpb24gdHJhbnNmb3JtKC4uLmFyZ3MpIHtcbiAgICBjb25zdCB1c2VJbW1lZGlhdGUgPSAhQXJyYXkuaXNBcnJheShhcmdzWzBdKTtcbiAgICBjb25zdCBhcmdPZmZzZXQgPSB1c2VJbW1lZGlhdGUgPyAwIDogLTE7XG4gICAgY29uc3QgaW5wdXRWYWx1ZSA9IGFyZ3NbMCArIGFyZ09mZnNldF07XG4gICAgY29uc3QgaW5wdXRSYW5nZSA9IGFyZ3NbMSArIGFyZ09mZnNldF07XG4gICAgY29uc3Qgb3V0cHV0UmFuZ2UgPSBhcmdzWzIgKyBhcmdPZmZzZXRdO1xuICAgIGNvbnN0IG9wdGlvbnMgPSBhcmdzWzMgKyBhcmdPZmZzZXRdO1xuICAgIGNvbnN0IGludGVycG9sYXRvciA9IGludGVycG9sYXRlKGlucHV0UmFuZ2UsIG91dHB1dFJhbmdlLCB7XG4gICAgICAgIG1peGVyOiBnZXRNaXhlcihvdXRwdXRSYW5nZVswXSksXG4gICAgICAgIC4uLm9wdGlvbnMsXG4gICAgfSk7XG4gICAgcmV0dXJuIHVzZUltbWVkaWF0ZSA/IGludGVycG9sYXRvcihpbnB1dFZhbHVlKSA6IGludGVycG9sYXRvcjtcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZFxuICpcbiAqIEltcG9ydCBhcyBgZnJhbWVgIGluc3RlYWQuXG4gKi9cbmNvbnN0IHN5bmMgPSBmcmFtZTtcbi8qKlxuICogQGRlcHJlY2F0ZWRcbiAqXG4gKiBVc2UgY2FuY2VsRnJhbWUoY2FsbGJhY2spIGluc3RlYWQuXG4gKi9cbmNvbnN0IGNhbmNlbFN5bmMgPSBzdGVwc09yZGVyLnJlZHVjZSgoYWNjLCBrZXkpID0+IHtcbiAgICBhY2Nba2V5XSA9IChwcm9jZXNzKSA9PiBjYW5jZWxGcmFtZShwcm9jZXNzKTtcbiAgICByZXR1cm4gYWNjO1xufSwge30pO1xuXG5jb25zdCB7IHNjaGVkdWxlOiBtaWNyb3Rhc2ssIGNhbmNlbDogY2FuY2VsTWljcm90YXNrIH0gPSBjcmVhdGVSZW5kZXJCYXRjaGVyKHF1ZXVlTWljcm90YXNrLCBmYWxzZSk7XG5cbmNvbnN0IGNvbXBhcmVCeURlcHRoID0gKGEsIGIpID0+IGEuZGVwdGggLSBiLmRlcHRoO1xuXG5jbGFzcyBGbGF0VHJlZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gZmFsc2U7XG4gICAgfVxuICAgIGFkZChjaGlsZCkge1xuICAgICAgICBhZGRVbmlxdWVJdGVtKHRoaXMuY2hpbGRyZW4sIGNoaWxkKTtcbiAgICAgICAgdGhpcy5pc0RpcnR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgcmVtb3ZlKGNoaWxkKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5jaGlsZHJlbiwgY2hpbGQpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSB0cnVlO1xuICAgIH1cbiAgICBmb3JFYWNoKGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuaXNEaXJ0eSAmJiB0aGlzLmNoaWxkcmVuLnNvcnQoY29tcGFyZUJ5RGVwdGgpO1xuICAgICAgICB0aGlzLmlzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGNhbGxiYWNrKTtcbiAgICB9XG59XG5cbmNvbnN0IGJvcmRlcnMgPSBbXCJUb3BMZWZ0XCIsIFwiVG9wUmlnaHRcIiwgXCJCb3R0b21MZWZ0XCIsIFwiQm90dG9tUmlnaHRcIl07XG5jb25zdCBudW1Cb3JkZXJzID0gYm9yZGVycy5sZW5ndGg7XG5jb25zdCBhc051bWJlciA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gcGFyc2VGbG9hdCh2YWx1ZSkgOiB2YWx1ZTtcbmNvbnN0IGlzUHggPSAodmFsdWUpID0+IHR5cGVvZiB2YWx1ZSA9PT0gXCJudW1iZXJcIiB8fCBweC50ZXN0KHZhbHVlKTtcbmZ1bmN0aW9uIG1peFZhbHVlcyh0YXJnZXQsIGZvbGxvdywgbGVhZCwgcHJvZ3Jlc3MsIHNob3VsZENyb3NzZmFkZU9wYWNpdHksIGlzT25seU1lbWJlcikge1xuICAgIGlmIChzaG91bGRDcm9zc2ZhZGVPcGFjaXR5KSB7XG4gICAgICAgIHRhcmdldC5vcGFjaXR5ID0gbWl4TnVtYmVyJDEoMCwgXG4gICAgICAgIC8vIFRPRE8gUmVpbnN0YXRlIHRoaXMgaWYgb25seSBjaGlsZFxuICAgICAgICBsZWFkLm9wYWNpdHkgIT09IHVuZGVmaW5lZCA/IGxlYWQub3BhY2l0eSA6IDEsIGVhc2VDcm9zc2ZhZGVJbihwcm9ncmVzcykpO1xuICAgICAgICB0YXJnZXQub3BhY2l0eUV4aXQgPSBtaXhOdW1iZXIkMShmb2xsb3cub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gZm9sbG93Lm9wYWNpdHkgOiAxLCAwLCBlYXNlQ3Jvc3NmYWRlT3V0KHByb2dyZXNzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzT25seU1lbWJlcikge1xuICAgICAgICB0YXJnZXQub3BhY2l0eSA9IG1peE51bWJlciQxKGZvbGxvdy5vcGFjaXR5ICE9PSB1bmRlZmluZWQgPyBmb2xsb3cub3BhY2l0eSA6IDEsIGxlYWQub3BhY2l0eSAhPT0gdW5kZWZpbmVkID8gbGVhZC5vcGFjaXR5IDogMSwgcHJvZ3Jlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaXggYm9yZGVyIHJhZGl1c1xuICAgICAqL1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtQm9yZGVyczsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGJvcmRlckxhYmVsID0gYGJvcmRlciR7Ym9yZGVyc1tpXX1SYWRpdXNgO1xuICAgICAgICBsZXQgZm9sbG93UmFkaXVzID0gZ2V0UmFkaXVzKGZvbGxvdywgYm9yZGVyTGFiZWwpO1xuICAgICAgICBsZXQgbGVhZFJhZGl1cyA9IGdldFJhZGl1cyhsZWFkLCBib3JkZXJMYWJlbCk7XG4gICAgICAgIGlmIChmb2xsb3dSYWRpdXMgPT09IHVuZGVmaW5lZCAmJiBsZWFkUmFkaXVzID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgZm9sbG93UmFkaXVzIHx8IChmb2xsb3dSYWRpdXMgPSAwKTtcbiAgICAgICAgbGVhZFJhZGl1cyB8fCAobGVhZFJhZGl1cyA9IDApO1xuICAgICAgICBjb25zdCBjYW5NaXggPSBmb2xsb3dSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGxlYWRSYWRpdXMgPT09IDAgfHxcbiAgICAgICAgICAgIGlzUHgoZm9sbG93UmFkaXVzKSA9PT0gaXNQeChsZWFkUmFkaXVzKTtcbiAgICAgICAgaWYgKGNhbk1peCkge1xuICAgICAgICAgICAgdGFyZ2V0W2JvcmRlckxhYmVsXSA9IE1hdGgubWF4KG1peE51bWJlciQxKGFzTnVtYmVyKGZvbGxvd1JhZGl1cyksIGFzTnVtYmVyKGxlYWRSYWRpdXMpLCBwcm9ncmVzcyksIDApO1xuICAgICAgICAgICAgaWYgKHBlcmNlbnQudGVzdChsZWFkUmFkaXVzKSB8fCBwZXJjZW50LnRlc3QoZm9sbG93UmFkaXVzKSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtib3JkZXJMYWJlbF0gKz0gXCIlXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0YXJnZXRbYm9yZGVyTGFiZWxdID0gbGVhZFJhZGl1cztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNaXggcm90YXRpb25cbiAgICAgKi9cbiAgICBpZiAoZm9sbG93LnJvdGF0ZSB8fCBsZWFkLnJvdGF0ZSkge1xuICAgICAgICB0YXJnZXQucm90YXRlID0gbWl4TnVtYmVyJDEoZm9sbG93LnJvdGF0ZSB8fCAwLCBsZWFkLnJvdGF0ZSB8fCAwLCBwcm9ncmVzcyk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0UmFkaXVzKHZhbHVlcywgcmFkaXVzTmFtZSkge1xuICAgIHJldHVybiB2YWx1ZXNbcmFkaXVzTmFtZV0gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHZhbHVlc1tyYWRpdXNOYW1lXVxuICAgICAgICA6IHZhbHVlcy5ib3JkZXJSYWRpdXM7XG59XG4vLyAvKipcbi8vICAqIFdlIG9ubHkgd2FudCB0byBtaXggdGhlIGJhY2tncm91bmQgY29sb3IgaWYgdGhlcmUncyBhIGZvbGxvdyBlbGVtZW50XG4vLyAgKiB0aGF0IHdlJ3JlIG5vdCBjcm9zc2ZhZGluZyBvcGFjaXR5IGJldHdlZW4uIEZvciBpbnN0YW5jZSB3aXRoIHN3aXRjaFxuLy8gICogQW5pbWF0ZVNoYXJlZExheW91dCBhbmltYXRpb25zLCB0aGlzIGhlbHBzIHRoZSBpbGx1c2lvbiBvZiBhIGNvbnRpbnVvdXNcbi8vICAqIGVsZW1lbnQgYmVpbmcgYW5pbWF0ZWQgYnV0IGFsc28gY3V0cyBkb3duIG9uIHRoZSBudW1iZXIgb2YgcGFpbnRzIHRyaWdnZXJlZFxuLy8gICogZm9yIGVsZW1lbnRzIHdoZXJlIG9wYWNpdHkgaXMgZG9pbmcgdGhhdCB3b3JrIGZvciB1cy5cbi8vICAqL1xuLy8gaWYgKFxuLy8gICAgICFoYXNGb2xsb3dFbGVtZW50ICYmXG4vLyAgICAgbGF0ZXN0TGVhZFZhbHVlcy5iYWNrZ3JvdW5kQ29sb3IgJiZcbi8vICAgICBsYXRlc3RGb2xsb3dWYWx1ZXMuYmFja2dyb3VuZENvbG9yXG4vLyApIHtcbi8vICAgICAvKipcbi8vICAgICAgKiBUaGlzIGlzbid0IGlkZWFsIHBlcmZvcm1hbmNlLXdpc2UgYXMgbWl4Q29sb3IgaXMgY3JlYXRpbmcgYSBuZXcgZnVuY3Rpb24gZXZlcnkgZnJhbWUuXG4vLyAgICAgICogV2UgY291bGQgcHJvYmFibHkgY3JlYXRlIGEgbWl4ZXIgdGhhdCBydW5zIGF0IHRoZSBzdGFydCBvZiB0aGUgYW5pbWF0aW9uIGJ1dFxuLy8gICAgICAqIHRoZSBpZGVhIGJlaGluZCB0aGUgY3Jvc3NmYWRlciBpcyB0aGF0IGl0IHJ1bnMgZHluYW1pY2FsbHkgYmV0d2VlbiB0d28gcG90ZW50aWFsbHlcbi8vICAgICAgKiBjaGFuZ2luZyB0YXJnZXRzIChpZSBvcGFjaXR5IG9yIGJvcmRlclJhZGl1cyBtYXkgYmUgYW5pbWF0aW5nIGluZGVwZW5kZW50bHkgdmlhIHZhcmlhbnRzKVxuLy8gICAgICAqL1xuLy8gICAgIGxlYWRTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBmb2xsb3dTdGF0ZS5iYWNrZ3JvdW5kQ29sb3IgPSBtaXhDb2xvcihcbi8vICAgICAgICAgbGF0ZXN0Rm9sbG93VmFsdWVzLmJhY2tncm91bmRDb2xvciBhcyBzdHJpbmcsXG4vLyAgICAgICAgIGxhdGVzdExlYWRWYWx1ZXMuYmFja2dyb3VuZENvbG9yIGFzIHN0cmluZ1xuLy8gICAgICkocClcbi8vIH1cbmNvbnN0IGVhc2VDcm9zc2ZhZGVJbiA9IC8qQF9fUFVSRV9fKi8gY29tcHJlc3MoMCwgMC41LCBjaXJjT3V0KTtcbmNvbnN0IGVhc2VDcm9zc2ZhZGVPdXQgPSAvKkBfX1BVUkVfXyovIGNvbXByZXNzKDAuNSwgMC45NSwgbW90aW9uVXRpbHMubm9vcCk7XG5mdW5jdGlvbiBjb21wcmVzcyhtaW4sIG1heCwgZWFzaW5nKSB7XG4gICAgcmV0dXJuIChwKSA9PiB7XG4gICAgICAgIC8vIENvdWxkIHJlcGxhY2UgaWZzIHdpdGggY2xhbXBcbiAgICAgICAgaWYgKHAgPCBtaW4pXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgaWYgKHAgPiBtYXgpXG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgcmV0dXJuIGVhc2luZyhtb3Rpb25VdGlscy5wcm9ncmVzcyhtaW4sIG1heCwgcCkpO1xuICAgIH07XG59XG5cbi8qKlxuICogUmVzZXQgYW4gYXhpcyB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5QXhpc0ludG8oYXhpcywgb3JpZ2luQXhpcykge1xuICAgIGF4aXMubWluID0gb3JpZ2luQXhpcy5taW47XG4gICAgYXhpcy5tYXggPSBvcmlnaW5BeGlzLm1heDtcbn1cbi8qKlxuICogUmVzZXQgYSBib3ggdG8gdGhlIHByb3ZpZGVkIG9yaWdpbiBib3guXG4gKlxuICogVGhpcyBpcyBhIG11dGF0aXZlIG9wZXJhdGlvbi5cbiAqL1xuZnVuY3Rpb24gY29weUJveEludG8oYm94LCBvcmlnaW5Cb3gpIHtcbiAgICBjb3B5QXhpc0ludG8oYm94LngsIG9yaWdpbkJveC54KTtcbiAgICBjb3B5QXhpc0ludG8oYm94LnksIG9yaWdpbkJveC55KTtcbn1cbi8qKlxuICogUmVzZXQgYSBkZWx0YSB0byB0aGUgcHJvdmlkZWQgb3JpZ2luIGJveC5cbiAqXG4gKiBUaGlzIGlzIGEgbXV0YXRpdmUgb3BlcmF0aW9uLlxuICovXG5mdW5jdGlvbiBjb3B5QXhpc0RlbHRhSW50byhkZWx0YSwgb3JpZ2luRGVsdGEpIHtcbiAgICBkZWx0YS50cmFuc2xhdGUgPSBvcmlnaW5EZWx0YS50cmFuc2xhdGU7XG4gICAgZGVsdGEuc2NhbGUgPSBvcmlnaW5EZWx0YS5zY2FsZTtcbiAgICBkZWx0YS5vcmlnaW5Qb2ludCA9IG9yaWdpbkRlbHRhLm9yaWdpblBvaW50O1xuICAgIGRlbHRhLm9yaWdpbiA9IG9yaWdpbkRlbHRhLm9yaWdpbjtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYSBkZWx0YSBmcm9tIGEgcG9pbnQuIFRoaXMgaXMgZXNzZW50aWFsbHkgdGhlIHN0ZXBzIG9mIGFwcGx5UG9pbnREZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZVBvaW50RGVsdGEocG9pbnQsIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSkge1xuICAgIHBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBwb2ludCA9IHNjYWxlUG9pbnQocG9pbnQsIDEgLyBzY2FsZSwgb3JpZ2luUG9pbnQpO1xuICAgIGlmIChib3hTY2FsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBvaW50ID0gc2NhbGVQb2ludChwb2ludCwgMSAvIGJveFNjYWxlLCBvcmlnaW5Qb2ludCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbn1cbi8qKlxuICogUmVtb3ZlIGEgZGVsdGEgZnJvbSBhbiBheGlzLiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNEZWx0YSBpbiByZXZlcnNlXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUF4aXNEZWx0YShheGlzLCB0cmFuc2xhdGUgPSAwLCBzY2FsZSA9IDEsIG9yaWdpbiA9IDAuNSwgYm94U2NhbGUsIG9yaWdpbkF4aXMgPSBheGlzLCBzb3VyY2VBeGlzID0gYXhpcykge1xuICAgIGlmIChwZXJjZW50LnRlc3QodHJhbnNsYXRlKSkge1xuICAgICAgICB0cmFuc2xhdGUgPSBwYXJzZUZsb2F0KHRyYW5zbGF0ZSk7XG4gICAgICAgIGNvbnN0IHJlbGF0aXZlUHJvZ3Jlc3MgPSBtaXhOdW1iZXIkMShzb3VyY2VBeGlzLm1pbiwgc291cmNlQXhpcy5tYXgsIHRyYW5zbGF0ZSAvIDEwMCk7XG4gICAgICAgIHRyYW5zbGF0ZSA9IHJlbGF0aXZlUHJvZ3Jlc3MgLSBzb3VyY2VBeGlzLm1pbjtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB0cmFuc2xhdGUgIT09IFwibnVtYmVyXCIpXG4gICAgICAgIHJldHVybjtcbiAgICBsZXQgb3JpZ2luUG9pbnQgPSBtaXhOdW1iZXIkMShvcmlnaW5BeGlzLm1pbiwgb3JpZ2luQXhpcy5tYXgsIG9yaWdpbik7XG4gICAgaWYgKGF4aXMgPT09IG9yaWdpbkF4aXMpXG4gICAgICAgIG9yaWdpblBvaW50IC09IHRyYW5zbGF0ZTtcbiAgICBheGlzLm1pbiA9IHJlbW92ZVBvaW50RGVsdGEoYXhpcy5taW4sIHRyYW5zbGF0ZSwgc2NhbGUsIG9yaWdpblBvaW50LCBib3hTY2FsZSk7XG4gICAgYXhpcy5tYXggPSByZW1vdmVQb2ludERlbHRhKGF4aXMubWF4LCB0cmFuc2xhdGUsIHNjYWxlLCBvcmlnaW5Qb2ludCwgYm94U2NhbGUpO1xufVxuLyoqXG4gKiBSZW1vdmUgYSB0cmFuc2Zvcm1zIGZyb20gYW4gYXhpcy4gVGhpcyBpcyBlc3NlbnRpYWxseSB0aGUgc3RlcHMgb2YgYXBwbHlBeGlzVHJhbnNmb3JtcyBpbiByZXZlcnNlXG4gKiBhbmQgYWN0cyBhcyBhIGJyaWRnZSBiZXR3ZWVuIG1vdGlvbiB2YWx1ZXMgYW5kIHJlbW92ZUF4aXNEZWx0YVxuICovXG5mdW5jdGlvbiByZW1vdmVBeGlzVHJhbnNmb3JtcyhheGlzLCB0cmFuc2Zvcm1zLCBba2V5LCBzY2FsZUtleSwgb3JpZ2luS2V5XSwgb3JpZ2luLCBzb3VyY2VBeGlzKSB7XG4gICAgcmVtb3ZlQXhpc0RlbHRhKGF4aXMsIHRyYW5zZm9ybXNba2V5XSwgdHJhbnNmb3Jtc1tzY2FsZUtleV0sIHRyYW5zZm9ybXNbb3JpZ2luS2V5XSwgdHJhbnNmb3Jtcy5zY2FsZSwgb3JpZ2luLCBzb3VyY2VBeGlzKTtcbn1cbi8qKlxuICogVGhlIG5hbWVzIG9mIHRoZSBtb3Rpb24gdmFsdWVzIHdlIHdhbnQgdG8gYXBwbHkgYXMgdHJhbnNsYXRpb24sIHNjYWxlIGFuZCBvcmlnaW4uXG4gKi9cbmNvbnN0IHhLZXlzID0gW1wieFwiLCBcInNjYWxlWFwiLCBcIm9yaWdpblhcIl07XG5jb25zdCB5S2V5cyA9IFtcInlcIiwgXCJzY2FsZVlcIiwgXCJvcmlnaW5ZXCJdO1xuLyoqXG4gKiBSZW1vdmUgYSB0cmFuc2Zvcm1zIGZyb20gYW4gYm94LiBUaGlzIGlzIGVzc2VudGlhbGx5IHRoZSBzdGVwcyBvZiBhcHBseUF4aXNCb3ggaW4gcmV2ZXJzZVxuICogYW5kIGFjdHMgYXMgYSBicmlkZ2UgYmV0d2VlbiBtb3Rpb24gdmFsdWVzIGFuZCByZW1vdmVBeGlzRGVsdGFcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlQm94VHJhbnNmb3Jtcyhib3gsIHRyYW5zZm9ybXMsIG9yaWdpbkJveCwgc291cmNlQm94KSB7XG4gICAgcmVtb3ZlQXhpc1RyYW5zZm9ybXMoYm94LngsIHRyYW5zZm9ybXMsIHhLZXlzLCBvcmlnaW5Cb3ggPyBvcmlnaW5Cb3gueCA6IHVuZGVmaW5lZCwgc291cmNlQm94ID8gc291cmNlQm94LnggOiB1bmRlZmluZWQpO1xuICAgIHJlbW92ZUF4aXNUcmFuc2Zvcm1zKGJveC55LCB0cmFuc2Zvcm1zLCB5S2V5cywgb3JpZ2luQm94ID8gb3JpZ2luQm94LnkgOiB1bmRlZmluZWQsIHNvdXJjZUJveCA/IHNvdXJjZUJveC55IDogdW5kZWZpbmVkKTtcbn1cblxuZnVuY3Rpb24gaXNBeGlzRGVsdGFaZXJvKGRlbHRhKSB7XG4gICAgcmV0dXJuIGRlbHRhLnRyYW5zbGF0ZSA9PT0gMCAmJiBkZWx0YS5zY2FsZSA9PT0gMTtcbn1cbmZ1bmN0aW9uIGlzRGVsdGFaZXJvKGRlbHRhKSB7XG4gICAgcmV0dXJuIGlzQXhpc0RlbHRhWmVybyhkZWx0YS54KSAmJiBpc0F4aXNEZWx0YVplcm8oZGVsdGEueSk7XG59XG5mdW5jdGlvbiBheGlzRXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW4gPT09IGIubWluICYmIGEubWF4ID09PSBiLm1heDtcbn1cbmZ1bmN0aW9uIGJveEVxdWFscyhhLCBiKSB7XG4gICAgcmV0dXJuIGF4aXNFcXVhbHMoYS54LCBiLngpICYmIGF4aXNFcXVhbHMoYS55LCBiLnkpO1xufVxuZnVuY3Rpb24gYXhpc0VxdWFsc1JvdW5kZWQoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5yb3VuZChhLm1pbikgPT09IE1hdGgucm91bmQoYi5taW4pICYmXG4gICAgICAgIE1hdGgucm91bmQoYS5tYXgpID09PSBNYXRoLnJvdW5kKGIubWF4KSk7XG59XG5mdW5jdGlvbiBib3hFcXVhbHNSb3VuZGVkKGEsIGIpIHtcbiAgICByZXR1cm4gYXhpc0VxdWFsc1JvdW5kZWQoYS54LCBiLngpICYmIGF4aXNFcXVhbHNSb3VuZGVkKGEueSwgYi55KTtcbn1cbmZ1bmN0aW9uIGFzcGVjdFJhdGlvKGJveCkge1xuICAgIHJldHVybiBjYWxjTGVuZ3RoKGJveC54KSAvIGNhbGNMZW5ndGgoYm94LnkpO1xufVxuZnVuY3Rpb24gYXhpc0RlbHRhRXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gKGEudHJhbnNsYXRlID09PSBiLnRyYW5zbGF0ZSAmJlxuICAgICAgICBhLnNjYWxlID09PSBiLnNjYWxlICYmXG4gICAgICAgIGEub3JpZ2luUG9pbnQgPT09IGIub3JpZ2luUG9pbnQpO1xufVxuXG5jbGFzcyBOb2RlU3RhY2sge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMgPSBbXTtcbiAgICB9XG4gICAgYWRkKG5vZGUpIHtcbiAgICAgICAgYWRkVW5pcXVlSXRlbSh0aGlzLm1lbWJlcnMsIG5vZGUpO1xuICAgICAgICBub2RlLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgfVxuICAgIHJlbW92ZShub2RlKSB7XG4gICAgICAgIHJlbW92ZUl0ZW0odGhpcy5tZW1iZXJzLCBub2RlKTtcbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMucHJldkxlYWQpIHtcbiAgICAgICAgICAgIHRoaXMucHJldkxlYWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5vZGUgPT09IHRoaXMubGVhZCkge1xuICAgICAgICAgICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLm1lbWJlcnNbdGhpcy5tZW1iZXJzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9tb3RlKHByZXZMZWFkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZWxlZ2F0ZShub2RlKSB7XG4gICAgICAgIGNvbnN0IGluZGV4T2ZOb2RlID0gdGhpcy5tZW1iZXJzLmZpbmRJbmRleCgobWVtYmVyKSA9PiBub2RlID09PSBtZW1iZXIpO1xuICAgICAgICBpZiAoaW5kZXhPZk5vZGUgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBuZXh0IHByb2plY3Rpb24gbm9kZSB0aGF0IGlzIHByZXNlbnRcbiAgICAgICAgICovXG4gICAgICAgIGxldCBwcmV2TGVhZDtcbiAgICAgICAgZm9yIChsZXQgaSA9IGluZGV4T2ZOb2RlOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3QgbWVtYmVyID0gdGhpcy5tZW1iZXJzW2ldO1xuICAgICAgICAgICAgaWYgKG1lbWJlci5pc1ByZXNlbnQgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcHJldkxlYWQgPSBtZW1iZXI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICB0aGlzLnByb21vdGUocHJldkxlYWQpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcHJvbW90ZShub2RlLCBwcmVzZXJ2ZUZvbGxvd09wYWNpdHkpIHtcbiAgICAgICAgY29uc3QgcHJldkxlYWQgPSB0aGlzLmxlYWQ7XG4gICAgICAgIGlmIChub2RlID09PSBwcmV2TGVhZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5wcmV2TGVhZCA9IHByZXZMZWFkO1xuICAgICAgICB0aGlzLmxlYWQgPSBub2RlO1xuICAgICAgICBub2RlLnNob3coKTtcbiAgICAgICAgaWYgKHByZXZMZWFkKSB7XG4gICAgICAgICAgICBwcmV2TGVhZC5pbnN0YW5jZSAmJiBwcmV2TGVhZC5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tID0gcHJldkxlYWQ7XG4gICAgICAgICAgICBpZiAocHJlc2VydmVGb2xsb3dPcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZXN1bWVGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocHJldkxlYWQuc25hcHNob3QpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNuYXBzaG90ID0gcHJldkxlYWQuc25hcHNob3Q7XG4gICAgICAgICAgICAgICAgbm9kZS5zbmFwc2hvdC5sYXRlc3RWYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICBwcmV2TGVhZC5hbmltYXRpb25WYWx1ZXMgfHwgcHJldkxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUucm9vdCAmJiBub2RlLnJvb3QuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgIG5vZGUuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGNyb3NzZmFkZSB9ID0gbm9kZS5vcHRpb25zO1xuICAgICAgICAgICAgaWYgKGNyb3NzZmFkZSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBwcmV2TGVhZC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE86XG4gICAgICAgICAgICAgKiAgIC0gVGVzdCBib3JkZXIgcmFkaXVzIHdoZW4gcHJldmlvdXMgbm9kZSB3YXMgZGVsZXRlZFxuICAgICAgICAgICAgICogICAtIGJveFNoYWRvdyBtaXhpbmdcbiAgICAgICAgICAgICAqICAgLSBTaGFyZWQgYmV0d2VlbiBlbGVtZW50IEEgaW4gc2Nyb2xsZWQgY29udGFpbmVyIGFuZCBlbGVtZW50IEIgKHNjcm9sbCBzdGF5cyB0aGUgc2FtZSBvciBjaGFuZ2VzKVxuICAgICAgICAgICAgICogICAtIFNoYXJlZCBiZXR3ZWVuIGVsZW1lbnQgQSBpbiB0cmFuc2Zvcm1lZCBjb250YWluZXIgYW5kIGVsZW1lbnQgQiAodHJhbnNmb3JtIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAgIC0gU2hhcmVkIGJldHdlZW4gZWxlbWVudCBBIGluIHNjcm9sbGVkIHBhZ2UgYW5kIGVsZW1lbnQgQiAoc2Nyb2xsIHN0YXlzIHRoZSBzYW1lIG9yIGNoYW5nZXMpXG4gICAgICAgICAgICAgKiAtLS1cbiAgICAgICAgICAgICAqICAgLSBDcm9zc2ZhZGUgb3BhY2l0eSBvZiByb290IG5vZGVzXG4gICAgICAgICAgICAgKiAgIC0gbGF5b3V0SWQgY2hhbmdlcyBhZnRlciBhbmltYXRpb25cbiAgICAgICAgICAgICAqICAgLSBsYXlvdXRJZCBjaGFuZ2VzIG1pZCBhbmltYXRpb25cbiAgICAgICAgICAgICAqL1xuICAgICAgICB9XG4gICAgfVxuICAgIGV4aXRBbmltYXRpb25Db21wbGV0ZSgpIHtcbiAgICAgICAgdGhpcy5tZW1iZXJzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgb3B0aW9ucywgcmVzdW1pbmdGcm9tIH0gPSBub2RlO1xuICAgICAgICAgICAgb3B0aW9ucy5vbkV4aXRDb21wbGV0ZSAmJiBvcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICBpZiAocmVzdW1pbmdGcm9tKSB7XG4gICAgICAgICAgICAgICAgcmVzdW1pbmdGcm9tLm9wdGlvbnMub25FeGl0Q29tcGxldGUgJiZcbiAgICAgICAgICAgICAgICAgICAgcmVzdW1pbmdGcm9tLm9wdGlvbnMub25FeGl0Q29tcGxldGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNjaGVkdWxlUmVuZGVyKCkge1xuICAgICAgICB0aGlzLm1lbWJlcnMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgbm9kZS5pbnN0YW5jZSAmJiBub2RlLnNjaGVkdWxlUmVuZGVyKGZhbHNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyIGFueSBsZWFkcyB0aGF0IGhhdmUgYmVlbiByZW1vdmVkIHRoaXMgcmVuZGVyIHRvIHByZXZlbnQgdGhlbSBmcm9tIGJlaW5nXG4gICAgICogdXNlZCBpbiBmdXR1cmUgYW5pbWF0aW9ucyBhbmQgdG8gcHJldmVudCBtZW1vcnkgbGVha3NcbiAgICAgKi9cbiAgICByZW1vdmVMZWFkU25hcHNob3QoKSB7XG4gICAgICAgIGlmICh0aGlzLmxlYWQgJiYgdGhpcy5sZWFkLnNuYXBzaG90KSB7XG4gICAgICAgICAgICB0aGlzLmxlYWQuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybShkZWx0YSwgdHJlZVNjYWxlLCBsYXRlc3RUcmFuc2Zvcm0pIHtcbiAgICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgdHJhbnNsYXRpb25zIHdlIHVzZSB0byBjYWxjdWxhdGUgYXJlIGFsd2F5cyByZWxhdGl2ZSB0byB0aGUgdmlld3BvcnQgY29vcmRpbmF0ZSBzcGFjZS5cbiAgICAgKiBCdXQgd2hlbiB3ZSBhcHBseSBzY2FsZXMsIHdlIGFsc28gc2NhbGUgdGhlIGNvb3JkaW5hdGUgc3BhY2Ugb2YgYW4gZWxlbWVudCBhbmQgaXRzIGNoaWxkcmVuLlxuICAgICAqIEZvciBpbnN0YW5jZSBpZiB3ZSBoYXZlIGEgdHJlZVNjYWxlICh0aGUgY3VsbWluYXRpb24gb2YgYWxsIHBhcmVudCBzY2FsZXMpIG9mIDAuNSBhbmQgd2UgbmVlZFxuICAgICAqIHRvIG1vdmUgYW4gZWxlbWVudCAxMDAgcGl4ZWxzLCB3ZSBhY3R1YWxseSBuZWVkIHRvIG1vdmUgaXQgMjAwIGluIHdpdGhpbiB0aGF0IHNjYWxlZCBzcGFjZS5cbiAgICAgKi9cbiAgICBjb25zdCB4VHJhbnNsYXRlID0gZGVsdGEueC50cmFuc2xhdGUgLyB0cmVlU2NhbGUueDtcbiAgICBjb25zdCB5VHJhbnNsYXRlID0gZGVsdGEueS50cmFuc2xhdGUgLyB0cmVlU2NhbGUueTtcbiAgICBjb25zdCB6VHJhbnNsYXRlID0gKGxhdGVzdFRyYW5zZm9ybSA9PT0gbnVsbCB8fCBsYXRlc3RUcmFuc2Zvcm0gPT09IHZvaWQgMCA/IHZvaWQgMCA6IGxhdGVzdFRyYW5zZm9ybS56KSB8fCAwO1xuICAgIGlmICh4VHJhbnNsYXRlIHx8IHlUcmFuc2xhdGUgfHwgelRyYW5zbGF0ZSkge1xuICAgICAgICB0cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt4VHJhbnNsYXRlfXB4LCAke3lUcmFuc2xhdGV9cHgsICR7elRyYW5zbGF0ZX1weCkgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvbiBmb3IgdGhlIHRyZWUgdHJhbnNmb3JtLlxuICAgICAqIFRoaXMgd2lsbCBhcHBseSBzY2FsZSB0byB0aGUgc2NyZWVuLW9yaWVudGF0ZWQgYXhlcy5cbiAgICAgKi9cbiAgICBpZiAodHJlZVNjYWxlLnggIT09IDEgfHwgdHJlZVNjYWxlLnkgIT09IDEpIHtcbiAgICAgICAgdHJhbnNmb3JtICs9IGBzY2FsZSgkezEgLyB0cmVlU2NhbGUueH0sICR7MSAvIHRyZWVTY2FsZS55fSkgYDtcbiAgICB9XG4gICAgaWYgKGxhdGVzdFRyYW5zZm9ybSkge1xuICAgICAgICBjb25zdCB7IHRyYW5zZm9ybVBlcnNwZWN0aXZlLCByb3RhdGUsIHJvdGF0ZVgsIHJvdGF0ZVksIHNrZXdYLCBza2V3WSB9ID0gbGF0ZXN0VHJhbnNmb3JtO1xuICAgICAgICBpZiAodHJhbnNmb3JtUGVyc3BlY3RpdmUpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gPSBgcGVyc3BlY3RpdmUoJHt0cmFuc2Zvcm1QZXJzcGVjdGl2ZX1weCkgJHt0cmFuc2Zvcm19YDtcbiAgICAgICAgaWYgKHJvdGF0ZSlcbiAgICAgICAgICAgIHRyYW5zZm9ybSArPSBgcm90YXRlKCR7cm90YXRlfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVgpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVgoJHtyb3RhdGVYfWRlZykgYDtcbiAgICAgICAgaWYgKHJvdGF0ZVkpXG4gICAgICAgICAgICB0cmFuc2Zvcm0gKz0gYHJvdGF0ZVkoJHtyb3RhdGVZfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdYKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WCgke3NrZXdYfWRlZykgYDtcbiAgICAgICAgaWYgKHNrZXdZKVxuICAgICAgICAgICAgdHJhbnNmb3JtICs9IGBza2V3WSgke3NrZXdZfWRlZykgYDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwbHkgc2NhbGUgdG8gbWF0Y2ggdGhlIHNpemUgb2YgdGhlIGVsZW1lbnQgdG8gdGhlIHNpemUgd2Ugd2FudCBpdC5cbiAgICAgKiBUaGlzIHdpbGwgYXBwbHkgc2NhbGUgdG8gdGhlIGVsZW1lbnQtb3JpZW50YXRlZCBheGVzLlxuICAgICAqL1xuICAgIGNvbnN0IGVsZW1lbnRTY2FsZVggPSBkZWx0YS54LnNjYWxlICogdHJlZVNjYWxlLng7XG4gICAgY29uc3QgZWxlbWVudFNjYWxlWSA9IGRlbHRhLnkuc2NhbGUgKiB0cmVlU2NhbGUueTtcbiAgICBpZiAoZWxlbWVudFNjYWxlWCAhPT0gMSB8fCBlbGVtZW50U2NhbGVZICE9PSAxKSB7XG4gICAgICAgIHRyYW5zZm9ybSArPSBgc2NhbGUoJHtlbGVtZW50U2NhbGVYfSwgJHtlbGVtZW50U2NhbGVZfSlgO1xuICAgIH1cbiAgICByZXR1cm4gdHJhbnNmb3JtIHx8IFwibm9uZVwiO1xufVxuXG5mdW5jdGlvbiBlYWNoQXhpcyhjYWxsYmFjaykge1xuICAgIHJldHVybiBbY2FsbGJhY2soXCJ4XCIpLCBjYWxsYmFjayhcInlcIildO1xufVxuXG4vKipcbiAqIFRoaXMgc2hvdWxkIG9ubHkgZXZlciBiZSBtb2RpZmllZCBvbiB0aGUgY2xpZW50IG90aGVyd2lzZSBpdCdsbFxuICogcGVyc2lzdCB0aHJvdWdoIHNlcnZlciByZXF1ZXN0cy4gSWYgd2UgbmVlZCBpbnN0YW5jZWQgc3RhdGVzIHdlXG4gKiBjb3VsZCBsYXp5LWluaXQgdmlhIHJvb3QuXG4gKi9cbmNvbnN0IGdsb2JhbFByb2plY3Rpb25TdGF0ZSA9IHtcbiAgICAvKipcbiAgICAgKiBHbG9iYWwgZmxhZyBhcyB0byB3aGV0aGVyIHRoZSB0cmVlIGhhcyBhbmltYXRlZCBzaW5jZSB0aGUgbGFzdCB0aW1lXG4gICAgICogd2UgcmVzaXplZCB0aGUgd2luZG93XG4gICAgICovXG4gICAgaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZTogdHJ1ZSxcbiAgICAvKipcbiAgICAgKiBXZSBzZXQgdGhpcyB0byB0cnVlIG9uY2UsIG9uIHRoZSBmaXJzdCB1cGRhdGUuIEFueSBub2RlcyBhZGRlZCB0byB0aGUgdHJlZSBiZXlvbmQgdGhhdFxuICAgICAqIHVwZGF0ZSB3aWxsIGJlIGdpdmVuIGEgYGRhdGEtcHJvamVjdGlvbi1pZGAgYXR0cmlidXRlLlxuICAgICAqL1xuICAgIGhhc0V2ZXJVcGRhdGVkOiBmYWxzZSxcbn07XG5cbmNvbnN0IG1ldHJpY3MgPSB7XG4gICAgdHlwZTogXCJwcm9qZWN0aW9uRnJhbWVcIixcbiAgICB0b3RhbE5vZGVzOiAwLFxuICAgIHJlc29sdmVkVGFyZ2V0RGVsdGFzOiAwLFxuICAgIHJlY2FsY3VsYXRlZFByb2plY3Rpb246IDAsXG59O1xuY29uc3QgaXNEZWJ1ZyA9IHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgJiYgd2luZG93Lk1vdGlvbkRlYnVnICE9PSB1bmRlZmluZWQ7XG5jb25zdCB0cmFuc2Zvcm1BeGVzID0gW1wiXCIsIFwiWFwiLCBcIllcIiwgXCJaXCJdO1xuY29uc3QgaGlkZGVuVmlzaWJpbGl0eSA9IHsgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiB9O1xuLyoqXG4gKiBXZSB1c2UgMTAwMCBhcyB0aGUgYW5pbWF0aW9uIHRhcmdldCBhcyAwLTEwMDAgbWFwcyBiZXR0ZXIgdG8gcGl4ZWxzIHRoYW4gMC0xXG4gKiB3aGljaCBoYXMgYSBub3RpY2VhYmxlIGRpZmZlcmVuY2UgaW4gc3ByaW5nIGFuaW1hdGlvbnNcbiAqL1xuY29uc3QgYW5pbWF0aW9uVGFyZ2V0ID0gMTAwMDtcbmxldCBpZCQxID0gMDtcbmZ1bmN0aW9uIHJlc2V0RGlzdG9ydGluZ1RyYW5zZm9ybShrZXksIHZpc3VhbEVsZW1lbnQsIHZhbHVlcywgc2hhcmVkQW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgY29uc3QgeyBsYXRlc3RWYWx1ZXMgfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgLy8gUmVjb3JkIHRoZSBkaXN0b3J0aW5nIHRyYW5zZm9ybSBhbmQgdGhlbiB0ZW1wb3JhcmlseSBzZXQgaXQgdG8gMFxuICAgIGlmIChsYXRlc3RWYWx1ZXNba2V5XSkge1xuICAgICAgICB2YWx1ZXNba2V5XSA9IGxhdGVzdFZhbHVlc1trZXldO1xuICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgMCk7XG4gICAgICAgIGlmIChzaGFyZWRBbmltYXRpb25WYWx1ZXMpIHtcbiAgICAgICAgICAgIHNoYXJlZEFuaW1hdGlvblZhbHVlc1trZXldID0gMDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGNhbmNlbFRyZWVPcHRpbWlzZWRUcmFuc2Zvcm1BbmltYXRpb25zKHByb2plY3Rpb25Ob2RlKSB7XG4gICAgcHJvamVjdGlvbk5vZGUuaGFzQ2hlY2tlZE9wdGltaXNlZEFwcGVhciA9IHRydWU7XG4gICAgaWYgKHByb2plY3Rpb25Ob2RlLnJvb3QgPT09IHByb2plY3Rpb25Ob2RlKVxuICAgICAgICByZXR1cm47XG4gICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSBwcm9qZWN0aW9uTm9kZS5vcHRpb25zO1xuICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIGNvbnN0IGFwcGVhcklkID0gZ2V0T3B0aW1pc2VkQXBwZWFySWQodmlzdWFsRWxlbWVudCk7XG4gICAgaWYgKHdpbmRvdy5Nb3Rpb25IYXNPcHRpbWlzZWRBbmltYXRpb24oYXBwZWFySWQsIFwidHJhbnNmb3JtXCIpKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5b3V0LCBsYXlvdXRJZCB9ID0gcHJvamVjdGlvbk5vZGUub3B0aW9ucztcbiAgICAgICAgd2luZG93Lk1vdGlvbkNhbmNlbE9wdGltaXNlZEFuaW1hdGlvbihhcHBlYXJJZCwgXCJ0cmFuc2Zvcm1cIiwgZnJhbWUsICEobGF5b3V0IHx8IGxheW91dElkKSk7XG4gICAgfVxuICAgIGNvbnN0IHsgcGFyZW50IH0gPSBwcm9qZWN0aW9uTm9kZTtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuaGFzQ2hlY2tlZE9wdGltaXNlZEFwcGVhcikge1xuICAgICAgICBjYW5jZWxUcmVlT3B0aW1pc2VkVHJhbnNmb3JtQW5pbWF0aW9ucyhwYXJlbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNyZWF0ZVByb2plY3Rpb25Ob2RlJDEoeyBhdHRhY2hSZXNpemVMaXN0ZW5lciwgZGVmYXVsdFBhcmVudCwgbWVhc3VyZVNjcm9sbCwgY2hlY2tJc1Njcm9sbFJvb3QsIHJlc2V0VHJhbnNmb3JtLCB9KSB7XG4gICAgcmV0dXJuIGNsYXNzIFByb2plY3Rpb25Ob2RlIHtcbiAgICAgICAgY29uc3RydWN0b3IobGF0ZXN0VmFsdWVzID0ge30sIHBhcmVudCA9IGRlZmF1bHRQYXJlbnQgPT09IG51bGwgfHwgZGVmYXVsdFBhcmVudCA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGVmYXVsdFBhcmVudCgpKSB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgdW5pcXVlIElEIGdlbmVyYXRlZCBmb3IgZXZlcnkgcHJvamVjdGlvbiBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlkID0gaWQkMSsrO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBbiBpZCB0aGF0IHJlcHJlc2VudHMgYSB1bmlxdWUgc2Vzc2lvbiBpbnN0aWdhdGVkIGJ5IHN0YXJ0VXBkYXRlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvbklkID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQSBTZXQgY29udGFpbmluZyBhbGwgdGhpcyBjb21wb25lbnQncyBjaGlsZHJlbi4gVGhpcyBpcyB1c2VkIHRvIGl0ZXJhdGVcbiAgICAgICAgICAgICAqIHRocm91Z2ggdGhlIGNoaWxkcmVuLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE86IFRoaXMgY291bGQgYmUgZmFzdGVyIHRvIGl0ZXJhdGUgYXMgYSBmbGF0IGFycmF5IHN0b3JlZCBvbiB0aGUgcm9vdCBub2RlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcHRpb25zIGZvciB0aGUgbm9kZS4gV2UgdXNlIHRoaXMgdG8gY29uZmlndXJlIHdoYXQga2luZCBvZiBsYXlvdXQgYW5pbWF0aW9uc1xuICAgICAgICAgICAgICogd2Ugc2hvdWxkIHBlcmZvcm0gKGlmIGFueSkuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHt9O1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBXZSB1c2UgdGhpcyB0byBkZXRlY3Qgd2hlbiBpdHMgc2FmZSB0byBzaHV0IGRvd24gcGFydCBvZiBhIHByb2plY3Rpb24gdHJlZS5cbiAgICAgICAgICAgICAqIFdlIGhhdmUgdG8ga2VlcCBwcm9qZWN0aW5nIGNoaWxkcmVuIGZvciBzY2FsZSBjb3JyZWN0aW9uIGFuZCByZWxhdGl2ZSBwcm9qZWN0aW9uXG4gICAgICAgICAgICAgKiB1bnRpbCBhbGwgdGhlaXIgcGFyZW50cyBzdG9wIHBlcmZvcm1pbmcgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzQW5pbWF0aW9uQmxvY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgd2UgdGhpbmsgdGhpcyBsYXlvdXQgaGFzIGJlZW4gY2hhbmdlZC4gV2UgY2FuJ3QgYWx3YXlzIGtub3cgdGhpcyxcbiAgICAgICAgICAgICAqIGN1cnJlbnRseSB3ZSBzZXQgaXQgdG8gdHJ1ZSBldmVyeSB0aW1lIGEgY29tcG9uZW50IHJlbmRlcnMsIG9yIGlmIGl0IGhhcyBhIGxheW91dERlcGVuZGVuY3lcbiAgICAgICAgICAgICAqIGlmIHRoYXQgaGFzIGNoYW5nZWQgYmV0d2VlbiByZW5kZXJzLiBBZGRpdGlvbmFsbHksIGNvbXBvbmVudHMgY2FuIGJlIGdyb3VwZWQgYnkgTGF5b3V0R3JvdXBcbiAgICAgICAgICAgICAqIGFuZCBpZiBvbmUgbm9kZSBpcyBkaXJ0aWVkLCB0aGV5IGFsbCBhcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgd2UgdGhpbmsgdGhlIHByb2plY3Rpb24gY2FsY3VsYXRpb25zIGZvciB0aGlzIG5vZGUgbmVlZHNcbiAgICAgICAgICAgICAqIHJlY2FsY3VsYXRpbmcgYXMgYSByZXN1bHQgb2YgYW4gdXBkYXRlZCB0cmFuc2Zvcm0gb3IgbGF5b3V0IGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1Byb2plY3Rpb25EaXJ0eSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgaWYgdGhlIGxheW91dCAqb3IqIHRyYW5zZm9ybSBoYXMgY2hhbmdlZC4gVGhpcyB0aGVuIGdldHMgcHJvcGFnYXRlZFxuICAgICAgICAgICAgICogdGhyb3VnaG91dCB0aGUgcHJvamVjdGlvbiB0cmVlLCBmb3JjaW5nIGFueSBlbGVtZW50IGJlbG93IHRvIHJlY2FsY3VsYXRlIG9uIHRoZSBuZXh0IGZyYW1lLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZsYWcgdHJhbnNmb3JtIGRpcnR5LiBUaGlzIGdldHMgcHJvcGFnYXRlZCB0aHJvdWdob3V0IHRoZSB3aG9sZSB0cmVlIGJ1dCBpcyBvbmx5XG4gICAgICAgICAgICAgKiByZXNwZWN0ZWQgYnkgc2hhcmVkIG5vZGVzLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNmb3JtRGlydHkgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQmxvY2sgbGF5b3V0IHVwZGF0ZXMgZm9yIGluc3RhbnQgbGF5b3V0IHRyYW5zaXRpb25zIHRocm91Z2hvdXQgdGhlIHRyZWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgdG8gdHJ1ZSBiZXR3ZWVuIHRoZSBzdGFydCBvZiB0aGUgZmlyc3QgYHdpbGxVcGRhdGVgIGNhbGwgYW5kIHRoZSBlbmQgb2YgdGhlIGBkaWRVcGRhdGVgXG4gICAgICAgICAgICAgKiBjYWxsLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhbiBTVkcgZWxlbWVudCB3ZSBjdXJyZW50bHkgZGlzYWJsZSBwcm9qZWN0aW9uIHRyYW5zZm9ybXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5pc1NWRyA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFnIHRvIHRydWUgKGR1cmluZyBwcm9tb3Rpb24pIGlmIGEgbm9kZSBkb2luZyBhbiBpbnN0YW50IGxheW91dCB0cmFuc2l0aW9uIG5lZWRzIHRvIHJlc2V0XG4gICAgICAgICAgICAgKiBpdHMgcHJvamVjdGlvbiBzdHlsZXMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBGbGFncyB3aGV0aGVyIHRoaXMgbm9kZSBzaG91bGQgaGF2ZSBpdHMgdHJhbnNmb3JtIHJlc2V0IHByaW9yIHRvIG1lYXN1cmluZy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSA9IGZhbHNlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdG9yZSB3aGV0aGVyIHRoaXMgbm9kZSBoYXMgYmVlbiBjaGVja2VkIGZvciBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnMuIEFzXG4gICAgICAgICAgICAgKiBlZmZlY3RzIGZpcmUgYm90dG9tLXVwLCBhbmQgd2Ugd2FudCB0byBsb29rIHVwIHRoZSB0cmVlIGZvciBhcHBlYXIgYW5pbWF0aW9ucyxcbiAgICAgICAgICAgICAqIHRoaXMgbWFrZXMgc3VyZSB3ZSBvbmx5IGNoZWNrIGVhY2ggcGF0aCBvbmNlLCBzdG9wcGluZyBhdCBub2RlcyB0aGF0XG4gICAgICAgICAgICAgKiBoYXZlIGFscmVhZHkgYmVlbiBjaGVja2VkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLmhhc0NoZWNrZWRPcHRpbWlzZWRBcHBlYXIgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgY2FsY3VsYXRlZCBjb250ZXh0dWFsL2FjY3VtdWxhdGVkL3RyZWUgc2NhbGUuXG4gICAgICAgICAgICAgKiBUaGlzIHdpbGwgYmUgdXNlZCB0byBzY2FsZSBjYWxjdWxjYXRlZCBwcm9qZWN0aW9uIHRyYW5zZm9ybXMsIGFzIHRoZXNlIGFyZVxuICAgICAgICAgICAgICogY2FsY3VsYXRlZCBpbiBzY3JlZW4tc3BhY2UgYnV0IG5lZWQgdG8gYmUgc2NhbGVkIGZvciBlbGVtZW50cyB0byBsYXlvdXRseVxuICAgICAgICAgICAgICogbWFrZSBpdCB0byB0aGVpciBjYWxjdWxhdGVkIGRlc3RpbmF0aW9ucy5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUT0RPOiBMYXp5LWluaXRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy50cmVlU2NhbGUgPSB7IHg6IDEsIHk6IDEgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgdGhpcy5oYXNUcmVlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIE5vdGU6IEN1cnJlbnRseSBvbmx5IHJ1bm5pbmcgb24gcm9vdCBub2RlXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9ICgpID0+IHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tVcGRhdGVGYWlsZWQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNVcGRhdGluZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckFsbFNuYXBzaG90cygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRoaXMgaXMgYSBtdWx0aS1zdGVwIHByb2Nlc3MgYXMgc2hhcmVkIG5vZGVzIG1pZ2h0IGJlIG9mIGRpZmZlcmVudCBkZXB0aHMuIE5vZGVzXG4gICAgICAgICAgICAgKiBhcmUgc29ydGVkIGJ5IGRlcHRoIG9yZGVyLCBzbyB3ZSBuZWVkIHRvIHJlc29sdmUgdGhlIGVudGlyZSB0cmVlIGJlZm9yZSBtb3ZpbmcgdG9cbiAgICAgICAgICAgICAqIHRoZSBuZXh0IHN0ZXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudXBkYXRlUHJvamVjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBSZXNldCBkZWJ1ZyBjb3VudHMuIE1hbnVhbGx5IHJlc2V0dGluZyByYXRoZXIgdGhhbiBjcmVhdGluZyBhIG5ld1xuICAgICAgICAgICAgICAgICAqIG9iamVjdCBlYWNoIGZyYW1lLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChpc0RlYnVnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1ldHJpY3MudG90YWxOb2RlcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnJlc29sdmVkVGFyZ2V0RGVsdGFzID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLnJlY2FsY3VsYXRlZFByb2plY3Rpb24gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2gocHJvcGFnYXRlRGlydHlOb2Rlcyk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc29sdmVUYXJnZXREZWx0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNhbGNQcm9qZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYW5EaXJ0eU5vZGVzKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuTW90aW9uRGVidWcucmVjb3JkKG1ldHJpY3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEZyYW1lIGNhbGN1bGF0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9IDAuMDtcbiAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gMDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2hhcmVkIGxheW91dFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBUT0RPIE9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcyA9IGxhdGVzdFZhbHVlcztcbiAgICAgICAgICAgIHRoaXMucm9vdCA9IHBhcmVudCA/IHBhcmVudC5yb290IHx8IHBhcmVudCA6IHRoaXM7XG4gICAgICAgICAgICB0aGlzLnBhdGggPSBwYXJlbnQgPyBbLi4ucGFyZW50LnBhdGgsIHBhcmVudF0gOiBbXTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICAgICAgICAgICAgdGhpcy5kZXB0aCA9IHBhcmVudCA/IHBhcmVudC5kZXB0aCArIDEgOiAwO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGhbaV0uc2hvdWxkUmVzZXRUcmFuc2Zvcm0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucm9vdCA9PT0gdGhpcylcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzID0gbmV3IEZsYXRUcmVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBoYW5kbGVyKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuZXZlbnRIYW5kbGVycy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50SGFuZGxlcnMuc2V0KG5hbWUsIG5ldyBTdWJzY3JpcHRpb25NYW5hZ2VyKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRIYW5kbGVycy5nZXQobmFtZSkuYWRkKGhhbmRsZXIpO1xuICAgICAgICB9XG4gICAgICAgIG5vdGlmeUxpc3RlbmVycyhuYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgICAgICBjb25zdCBzdWJzY3JpcHRpb25NYW5hZ2VyID0gdGhpcy5ldmVudEhhbmRsZXJzLmdldChuYW1lKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbk1hbmFnZXIgJiYgc3Vic2NyaXB0aW9uTWFuYWdlci5ub3RpZnkoLi4uYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgaGFzTGlzdGVuZXJzKG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmV2ZW50SGFuZGxlcnMuaGFzKG5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaWZlY3ljbGVzXG4gICAgICAgICAqL1xuICAgICAgICBtb3VudChpbnN0YW5jZSwgaXNMYXlvdXREaXJ0eSA9IHRoaXMucm9vdC5oYXNUcmVlQW5pbWF0ZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluc3RhbmNlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNTVkcgPSBpc1NWR0VsZW1lbnQoaW5zdGFuY2UpO1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXRJZCwgbGF5b3V0LCB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiAhdmlzdWFsRWxlbWVudC5jdXJyZW50KSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuYWRkKHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuY2hpbGRyZW4uYWRkKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGlzTGF5b3V0RGlydHkgJiYgKGxheW91dCB8fCBsYXlvdXRJZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF0dGFjaFJlc2l6ZUxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgbGV0IGNhbmNlbERlbGF5O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc2l6ZVVuYmxvY2tVcGRhdGUgPSAoKSA9PiAodGhpcy5yb290LnVwZGF0ZUJsb2NrZWRCeVJlc2l6ZSA9IGZhbHNlKTtcbiAgICAgICAgICAgICAgICBhdHRhY2hSZXNpemVMaXN0ZW5lcihpbnN0YW5jZSwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvb3QudXBkYXRlQmxvY2tlZEJ5UmVzaXplID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRGVsYXkgJiYgY2FuY2VsRGVsYXkoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FuY2VsRGVsYXkgPSBkZWxheShyZXNpemVVbmJsb2NrVXBkYXRlLCAyNTApO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0FuaW1hdGVkU2luY2VSZXNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdsb2JhbFByb2plY3Rpb25TdGF0ZS5oYXNBbmltYXRlZFNpbmNlUmVzaXplID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goZmluaXNoQW5pbWF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnJlZ2lzdGVyU2hhcmVkTm9kZShsYXlvdXRJZCwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBPbmx5IHJlZ2lzdGVyIHRoZSBoYW5kbGVyIGlmIGl0IHJlcXVpcmVzIGxheW91dCBhbmltYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZSAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgKGxheW91dElkIHx8IGxheW91dCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKHsgZGVsdGEsIGhhc0xheW91dENoYW5nZWQsIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZCwgbGF5b3V0OiBuZXdMYXlvdXQsIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNUcmVlQW5pbWF0aW9uQmxvY2tlZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogQ2hlY2sgaGVyZSBpZiBhbiBhbmltYXRpb24gZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGxheW91dFRyYW5zaXRpb24gPSB0aGlzLm9wdGlvbnMudHJhbnNpdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5nZXREZWZhdWx0VHJhbnNpdGlvbigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBvbkxheW91dEFuaW1hdGlvblN0YXJ0LCBvbkxheW91dEFuaW1hdGlvbkNvbXBsZXRlLCB9ID0gdmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICogVGhlIHRhcmdldCBsYXlvdXQgb2YgdGhlIGVsZW1lbnQgbWlnaHQgc3RheSB0aGUgc2FtZSxcbiAgICAgICAgICAgICAgICAgICAgICogYnV0IGl0cyBwb3NpdGlvbiByZWxhdGl2ZSB0byBpdHMgcGFyZW50IGhhcyBjaGFuZ2VkLlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2hhbmdlZCA9ICF0aGlzLnRhcmdldExheW91dCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgIWJveEVxdWFsc1JvdW5kZWQodGhpcy50YXJnZXRMYXlvdXQsIG5ld0xheW91dCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1JlbGF0aXZlVGFyZ2V0Q2hhbmdlZDtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBsYXlvdXQgaGFzbid0IHNlZW1lZCB0byBoYXZlIGNoYW5nZWQsIGl0IG1pZ2h0IGJlIHRoYXQgdGhlXG4gICAgICAgICAgICAgICAgICAgICAqIGVsZW1lbnQgaXMgdmlzdWFsbHkgaW4gdGhlIHNhbWUgcGxhY2UgaW4gdGhlIGRvY3VtZW50IGJ1dCBpdHMgcG9zaXRpb25cbiAgICAgICAgICAgICAgICAgICAgICogcmVsYXRpdmUgdG8gaXRzIHBhcmVudCBoYXMgaW5kZWVkIGNoYW5nZWQuIFNvIGhlcmUgd2UgY2hlY2sgZm9yIHRoYXQuXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gIWhhc0xheW91dENoYW5nZWQgJiYgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dFJvb3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzLnJlc3VtZUZyb20gJiYgdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgKGhhc0xheW91dENoYW5nZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAodGFyZ2V0Q2hhbmdlZCB8fCAhdGhpcy5jdXJyZW50QW5pbWF0aW9uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9IHRoaXMucmVzdW1lRnJvbTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5yZXN1bWluZ0Zyb20gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEFuaW1hdGlvbk9yaWdpbihkZWx0YSwgaGFzT25seVJlbGF0aXZlVGFyZ2V0Q2hhbmdlZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLm1vdGlvbkRvbS5nZXRWYWx1ZVRyYW5zaXRpb24obGF5b3V0VHJhbnNpdGlvbiwgXCJsYXlvdXRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25QbGF5OiBvbkxheW91dEFuaW1hdGlvblN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6IG9uTGF5b3V0QW5pbWF0aW9uQ29tcGxldGUsXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpc3VhbEVsZW1lbnQuc2hvdWxkUmVkdWNlTW90aW9uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLmRlbGF5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb25PcHRpb25zLnR5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24oYW5pbWF0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIElmIHRoZSBsYXlvdXQgaGFzbid0IGNoYW5nZWQgYW5kIHdlIGhhdmUgYW4gYW5pbWF0aW9uIHRoYXQgaGFzbid0IHN0YXJ0ZWQgeWV0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICogZmluaXNoIGl0IGltbWVkaWF0ZWx5LiBPdGhlcndpc2UgaXQgd2lsbCBiZSBhbmltYXRpbmcgZnJvbSBhIGxvY2F0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiB0aGF0IHdhcyBwcm9iYWJseSBuZXZlciBjb21taXRlZCB0byBzY3JlZW4gYW5kIGxvb2sgbGlrZSBhIGp1bXB5IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFoYXNMYXlvdXRDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluaXNoQW5pbWF0aW9uKHRoaXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNMZWFkKCkgJiYgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXRMYXlvdXQgPSBuZXdMYXlvdXQ7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5sYXlvdXRJZCAmJiB0aGlzLndpbGxVcGRhdGUoKTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5ub2Rlcy5yZW1vdmUodGhpcyk7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHN0YWNrICYmIHN0YWNrLnJlbW92ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmNoaWxkcmVuLmRlbGV0ZSh0aGlzKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5jZWxGcmFtZSh0aGlzLnVwZGF0ZVByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIC8vIG9ubHkgb24gdGhlIHJvb3RcbiAgICAgICAgYmxvY2tVcGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZU1hbnVhbGx5QmxvY2tlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdW5ibG9ja1VwZGF0ZSgpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaXNVcGRhdGVCbG9ja2VkKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlTWFudWFsbHlCbG9ja2VkIHx8IHRoaXMudXBkYXRlQmxvY2tlZEJ5UmVzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuaXNBbmltYXRpb25CbG9ja2VkIHx8XG4gICAgICAgICAgICAgICAgKHRoaXMucGFyZW50ICYmIHRoaXMucGFyZW50LmlzVHJlZUFuaW1hdGlvbkJsb2NrZWQoKSkgfHxcbiAgICAgICAgICAgICAgICBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG9ubHkgcnVubmluZyBvbiByb290IG5vZGVcbiAgICAgICAgc3RhcnRVcGRhdGUoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5pc1VwZGF0ZUJsb2NrZWQoKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5ub2RlcyAmJiB0aGlzLm5vZGVzLmZvckVhY2gocmVzZXRTa2V3QW5kUm90YXRpb24pO1xuICAgICAgICAgICAgdGhpcy5hbmltYXRpb25JZCsrO1xuICAgICAgICB9XG4gICAgICAgIGdldFRyYW5zZm9ybVRlbXBsYXRlKCkge1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gdmlzdWFsRWxlbWVudCAmJiB2aXN1YWxFbGVtZW50LmdldFByb3BzKCkudHJhbnNmb3JtVGVtcGxhdGU7XG4gICAgICAgIH1cbiAgICAgICAgd2lsbFVwZGF0ZShzaG91bGROb3RpZnlMaXN0ZW5lcnMgPSB0cnVlKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3QuaGFzVHJlZUFuaW1hdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QuaXNVcGRhdGVCbG9ja2VkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25FeGl0Q29tcGxldGUgJiYgdGhpcy5vcHRpb25zLm9uRXhpdENvbXBsZXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBydW5uaW5nIG9wdGltaXNlZCBhcHBlYXIgYW5pbWF0aW9ucyB0aGVuIHRoZXNlIG11c3QgYmVcbiAgICAgICAgICAgICAqIGNhbmNlbGxlZCBiZWZvcmUgbWVhc3VyaW5nIHRoZSBET00uIFRoaXMgaXMgc28gd2UgY2FuIG1lYXN1cmVcbiAgICAgICAgICAgICAqIHRoZSB0cnVlIGxheW91dCBvZiB0aGUgZWxlbWVudCByYXRoZXIgdGhhbiB0aGUgV0FBUEkgYW5pbWF0aW9uXG4gICAgICAgICAgICAgKiB3aGljaCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnkgdGhlIHJlc2V0U2tld0FuZFJvdGF0ZSBzdGVwLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE5vdGU6IFRoaXMgaXMgYSBET00gd3JpdGUuIFdvcnN0IGNhc2Ugc2NlbmFyaW8gaXMgdGhpcyBpcyBzYW5kd2ljaGVkXG4gICAgICAgICAgICAgKiBiZXR3ZWVuIG90aGVyIHNuYXBzaG90IHJlYWRzIHdoaWNoIHdpbGwgY2F1c2UgdW5uZWNlc3Nhcnkgc3R5bGUgcmVjYWxjdWxhdGlvbnMuXG4gICAgICAgICAgICAgKiBUaGlzIGhhcyB0byBoYXBwZW4gaGVyZSB0aG91Z2gsIGFzIHdlIGRvbid0IHlldCBrbm93IHdoaWNoIG5vZGVzIHdpbGwgbmVlZFxuICAgICAgICAgICAgICogc25hcHNob3RzIGluIHN0YXJ0VXBkYXRlKCksIGJ1dCB3ZSBvbmx5IHdhbnQgdG8gY2FuY2VsIG9wdGltaXNlZCBhbmltYXRpb25zXG4gICAgICAgICAgICAgKiBpZiBhIGxheW91dCBhbmltYXRpb24gbWVhc3VyZW1lbnQgaXMgYWN0dWFsbHkgZ29pbmcgdG8gYmUgYWZmZWN0ZWQgYnkgdGhlbS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHdpbmRvdy5Nb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24gJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5oYXNDaGVja2VkT3B0aW1pc2VkQXBwZWFyKSB7XG4gICAgICAgICAgICAgICAgY2FuY2VsVHJlZU9wdGltaXNlZFRyYW5zZm9ybUFuaW1hdGlvbnModGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhdGhpcy5yb290LmlzVXBkYXRpbmcgJiYgdGhpcy5yb290LnN0YXJ0VXBkYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5pc0xheW91dERpcnR5KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNMYXlvdXREaXJ0eSA9IHRydWU7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgbm9kZS5zaG91bGRSZXNldFRyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoXCJzbmFwc2hvdFwiKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS53aWxsVXBkYXRlKGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZCA9PT0gdW5kZWZpbmVkICYmICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSB0aGlzLmdldFRyYW5zZm9ybVRlbXBsYXRlKCk7XG4gICAgICAgICAgICB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgc2hvdWxkTm90aWZ5TGlzdGVuZXJzICYmIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwid2lsbFVwZGF0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGUoKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlV2FzQmxvY2tlZCA9IHRoaXMuaXNVcGRhdGVCbG9ja2VkKCk7XG4gICAgICAgICAgICAvLyBXaGVuIGRvaW5nIGFuIGluc3RhbnQgdHJhbnNpdGlvbiwgd2Ugc2tpcCB0aGUgbGF5b3V0IHVwZGF0ZSxcbiAgICAgICAgICAgIC8vIGJ1dCBzaG91bGQgc3RpbGwgY2xlYW4gdXAgdGhlIG1lYXN1cmVtZW50cyBzbyB0aGF0IHRoZSBuZXh0XG4gICAgICAgICAgICAvLyBzbmFwc2hvdCBjb3VsZCBiZSB0YWtlbiBjb3JyZWN0bHkuXG4gICAgICAgICAgICBpZiAodXBkYXRlV2FzQmxvY2tlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMudW5ibG9ja1VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJBbGxTbmFwc2hvdHMoKTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5pc1VwZGF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKGNsZWFySXNMYXlvdXREaXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKHJlc2V0VHJhbnNmb3JtU3R5bGUpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWFkID09PT09PT09PT09PT09PT09PVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAvLyBVcGRhdGUgbGF5b3V0IG1lYXN1cmVtZW50cyBvZiB1cGRhdGVkIGNoaWxkcmVuXG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2godXBkYXRlTGF5b3V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogV3JpdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgLy8gTm90aWZ5IGxpc3RlbmVycyB0aGF0IHRoZSBsYXlvdXQgaXMgdXBkYXRlZFxuICAgICAgICAgICAgdGhpcy5ub2Rlcy5mb3JFYWNoKG5vdGlmeUxheW91dFVwZGF0ZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQWxsU25hcHNob3RzKCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1hbnVhbGx5IGZsdXNoIGFueSBwZW5kaW5nIHVwZGF0ZXMuIElkZWFsbHlcbiAgICAgICAgICAgICAqIHdlIGNvdWxkIGxlYXZlIHRoaXMgdG8gdGhlIGZvbGxvd2luZyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgYnV0IHRoaXMgc2VlbXNcbiAgICAgICAgICAgICAqIHRvIGxlYXZlIGEgZmxhc2ggb2YgaW5jb3JyZWN0bHkgc3R5bGVkIGNvbnRlbnQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHRpbWUubm93KCk7XG4gICAgICAgICAgICBmcmFtZURhdGEuZGVsdGEgPSBjbGFtcCgwLCAxMDAwIC8gNjAsIG5vdyAtIGZyYW1lRGF0YS50aW1lc3RhbXApO1xuICAgICAgICAgICAgZnJhbWVEYXRhLnRpbWVzdGFtcCA9IG5vdztcbiAgICAgICAgICAgIGZyYW1lRGF0YS5pc1Byb2Nlc3NpbmcgPSB0cnVlO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy51cGRhdGUucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy5wcmVSZW5kZXIucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVTdGVwcy5yZW5kZXIucHJvY2VzcyhmcmFtZURhdGEpO1xuICAgICAgICAgICAgZnJhbWVEYXRhLmlzUHJvY2Vzc2luZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGRpZFVwZGF0ZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy51cGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgbWljcm90YXNrLnJlYWQodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJBbGxTbmFwc2hvdHMoKSB7XG4gICAgICAgICAgICB0aGlzLm5vZGVzLmZvckVhY2goY2xlYXJTbmFwc2hvdCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJlZE5vZGVzLmZvckVhY2gocmVtb3ZlTGVhZFNuYXBzaG90cyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NoZWR1bGVVcGRhdGVQcm9qZWN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnByb2plY3Rpb25VcGRhdGVTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGZyYW1lLnByZVJlbmRlcih0aGlzLnVwZGF0ZVByb2plY3Rpb24sIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzY2hlZHVsZUNoZWNrQWZ0ZXJVbm1vdW50KCkge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGUgdW5tb3VudGluZyBub2RlIGlzIGluIGEgbGF5b3V0R3JvdXAgYW5kIGRpZCB0cmlnZ2VyIGEgd2lsbFVwZGF0ZSxcbiAgICAgICAgICAgICAqIHdlIG1hbnVhbGx5IGNhbGwgZGlkVXBkYXRlIHRvIGdpdmUgYSBjaGFuY2UgdG8gdGhlIHNpYmxpbmdzIHRvIGFuaW1hdGUuXG4gICAgICAgICAgICAgKiBPdGhlcndpc2UsIGNsZWFudXAgYWxsIHNuYXBzaG90cyB0byBwcmV2ZW50cyBmdXR1cmUgbm9kZXMgZnJvbSByZXVzaW5nIHRoZW0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb290LmNoZWNrVXBkYXRlRmFpbGVkKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSBtZWFzdXJlbWVudHNcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZVNuYXBzaG90KCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc25hcHNob3QgfHwgIXRoaXMuaW5zdGFuY2UpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHRoaXMubWVhc3VyZSgpO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUxheW91dCgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBUT0RPOiBJbmNvcnBvcmF0ZSBpbnRvIGEgZm9yd2FyZGVkIHNjcm9sbCBvZmZzZXRcbiAgICAgICAgICAgIHRoaXMudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLm9wdGlvbnMuYWx3YXlzTWVhc3VyZUxheW91dCAmJiB0aGlzLmlzTGVhZCgpKSAmJlxuICAgICAgICAgICAgICAgICF0aGlzLmlzTGF5b3V0RGlydHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdoZW4gYSBub2RlIGlzIG1vdW50ZWQsIGl0IHNpbXBseSByZXN1bWVzIGZyb20gdGhlIHByZXZMZWFkJ3NcbiAgICAgICAgICAgICAqIHNuYXBzaG90IGluc3RlYWQgb2YgdGFraW5nIGEgbmV3IG9uZSwgYnV0IHRoZSBhbmNlc3RvcnMgc2Nyb2xsXG4gICAgICAgICAgICAgKiBtaWdodCBoYXZlIHVwZGF0ZWQgd2hpbGUgdGhlIHByZXZMZWFkIGlzIHVubW91bnRlZC4gV2UgbmVlZCB0b1xuICAgICAgICAgICAgICogdXBkYXRlIHRoZSBzY3JvbGwgYWdhaW4gdG8gbWFrZSBzdXJlIHRoZSBsYXlvdXQgd2UgbWVhc3VyZSBpc1xuICAgICAgICAgICAgICogdXAgdG8gZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1lRnJvbSAmJiAhdGhpcy5yZXN1bWVGcm9tLmluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2TGF5b3V0ID0gdGhpcy5sYXlvdXQ7XG4gICAgICAgICAgICB0aGlzLmxheW91dCA9IHRoaXMubWVhc3VyZShmYWxzZSk7XG4gICAgICAgICAgICB0aGlzLmxheW91dENvcnJlY3RlZCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgdGhpcy5pc0xheW91dERpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLnByb2plY3Rpb25EZWx0YSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5TGlzdGVuZXJzKFwibWVhc3VyZVwiLCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJMYXlvdXRNZWFzdXJlXCIsIHRoaXMubGF5b3V0LmxheW91dEJveCwgcHJldkxheW91dCA/IHByZXZMYXlvdXQubGF5b3V0Qm94IDogdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVTY3JvbGwocGhhc2UgPSBcIm1lYXN1cmVcIikge1xuICAgICAgICAgICAgbGV0IG5lZWRzTWVhc3VyZW1lbnQgPSBCb29sZWFuKHRoaXMub3B0aW9ucy5sYXlvdXRTY3JvbGwgJiYgdGhpcy5pbnN0YW5jZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5zY3JvbGwgJiZcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbC5hbmltYXRpb25JZCA9PT0gdGhpcy5yb290LmFuaW1hdGlvbklkICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGwucGhhc2UgPT09IHBoYXNlKSB7XG4gICAgICAgICAgICAgICAgbmVlZHNNZWFzdXJlbWVudCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5lZWRzTWVhc3VyZW1lbnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpc1Jvb3QgPSBjaGVja0lzU2Nyb2xsUm9vdCh0aGlzLmluc3RhbmNlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uSWQ6IHRoaXMucm9vdC5hbmltYXRpb25JZCxcbiAgICAgICAgICAgICAgICAgICAgcGhhc2UsXG4gICAgICAgICAgICAgICAgICAgIGlzUm9vdCxcbiAgICAgICAgICAgICAgICAgICAgb2Zmc2V0OiBtZWFzdXJlU2Nyb2xsKHRoaXMuaW5zdGFuY2UpLFxuICAgICAgICAgICAgICAgICAgICB3YXNSb290OiB0aGlzLnNjcm9sbCA/IHRoaXMuc2Nyb2xsLmlzUm9vdCA6IGlzUm9vdCxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc2V0VHJhbnNmb3JtKCkge1xuICAgICAgICAgICAgaWYgKCFyZXNldFRyYW5zZm9ybSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBpc1Jlc2V0UmVxdWVzdGVkID0gdGhpcy5pc0xheW91dERpcnR5IHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zaG91bGRSZXNldFRyYW5zZm9ybSB8fFxuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5hbHdheXNNZWFzdXJlTGF5b3V0O1xuICAgICAgICAgICAgY29uc3QgaGFzUHJvamVjdGlvbiA9IHRoaXMucHJvamVjdGlvbkRlbHRhICYmICFpc0RlbHRhWmVybyh0aGlzLnByb2plY3Rpb25EZWx0YSk7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZSA9IHRoaXMuZ2V0VHJhbnNmb3JtVGVtcGxhdGUoKTtcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUodGhpcy5sYXRlc3RWYWx1ZXMsIFwiXCIpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCB0cmFuc2Zvcm1UZW1wbGF0ZUhhc0NoYW5nZWQgPSB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlICE9PSB0aGlzLnByZXZUcmFuc2Zvcm1UZW1wbGF0ZVZhbHVlO1xuICAgICAgICAgICAgaWYgKGlzUmVzZXRSZXF1ZXN0ZWQgJiZcbiAgICAgICAgICAgICAgICAoaGFzUHJvamVjdGlvbiB8fFxuICAgICAgICAgICAgICAgICAgICBoYXNUcmFuc2Zvcm0odGhpcy5sYXRlc3RWYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zZm9ybVRlbXBsYXRlSGFzQ2hhbmdlZCkpIHtcbiAgICAgICAgICAgICAgICByZXNldFRyYW5zZm9ybSh0aGlzLmluc3RhbmNlLCB0cmFuc2Zvcm1UZW1wbGF0ZVZhbHVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3VsZFJlc2V0VHJhbnNmb3JtID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmUocmVtb3ZlVHJhbnNmb3JtID0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgcGFnZUJveCA9IHRoaXMubWVhc3VyZVBhZ2VCb3goKTtcbiAgICAgICAgICAgIGxldCBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZUVsZW1lbnRTY3JvbGwocGFnZUJveCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE1lYXN1cmVtZW50cyB0YWtlbiBkdXJpbmcgdGhlIHByZS1yZW5kZXIgc3RhZ2VcbiAgICAgICAgICAgICAqIHN0aWxsIGhhdmUgdHJhbnNmb3JtcyBhcHBsaWVkIHNvIHdlIHJlbW92ZSB0aGVtXG4gICAgICAgICAgICAgKiB2aWEgY2FsY3VsYXRpb24uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChyZW1vdmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgICAgICAgICBsYXlvdXRCb3ggPSB0aGlzLnJlbW92ZVRyYW5zZm9ybShsYXlvdXRCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm91bmRCb3gobGF5b3V0Qm94KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9uSWQ6IHRoaXMucm9vdC5hbmltYXRpb25JZCxcbiAgICAgICAgICAgICAgICBtZWFzdXJlZEJveDogcGFnZUJveCxcbiAgICAgICAgICAgICAgICBsYXlvdXRCb3gsXG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzOiB7fSxcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMuaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIG1lYXN1cmVQYWdlQm94KCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50IH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgY29uc3QgYm94ID0gdmlzdWFsRWxlbWVudC5tZWFzdXJlVmlld3BvcnRCb3goKTtcbiAgICAgICAgICAgIGNvbnN0IHdhc0luU2Nyb2xsUm9vdCA9ICgoX2EgPSB0aGlzLnNjcm9sbCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLndhc1Jvb3QpIHx8IHRoaXMucGF0aC5zb21lKGNoZWNrTm9kZVdhc1Njcm9sbFJvb3QpO1xuICAgICAgICAgICAgaWYgKCF3YXNJblNjcm9sbFJvb3QpIHtcbiAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdmlld3BvcnQgc2Nyb2xsIHRvIGdpdmUgcGFnZS1yZWxhdGl2ZSBjb29yZGluYXRlc1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgc2Nyb2xsIH0gPSB0aGlzLnJvb3Q7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC54LCBzY3JvbGwub2Zmc2V0LngpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveC55LCBzY3JvbGwub2Zmc2V0LnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBib3g7XG4gICAgICAgIH1cbiAgICAgICAgcmVtb3ZlRWxlbWVudFNjcm9sbChib3gpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIGNvbnN0IGJveFdpdGhvdXRTY3JvbGwgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvcHlCb3hJbnRvKGJveFdpdGhvdXRTY3JvbGwsIGJveCk7XG4gICAgICAgICAgICBpZiAoKF9hID0gdGhpcy5zY3JvbGwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS53YXNSb290KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFBlcmZvcm1hbmNlIFRPRE86IEtlZXAgYSBjdW11bGF0aXZlIHNjcm9sbCBvZmZzZXQgZG93biB0aGUgdHJlZVxuICAgICAgICAgICAgICogcmF0aGVyIHRoYW4gbG9vcCBiYWNrIHVwIHRoZSBwYXRoLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMucGF0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLnBhdGhbaV07XG4gICAgICAgICAgICAgICAgY29uc3QgeyBzY3JvbGwsIG9wdGlvbnMgfSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUgIT09IHRoaXMucm9vdCAmJiBzY3JvbGwgJiYgb3B0aW9ucy5sYXlvdXRTY3JvbGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICAgICAqIElmIHRoaXMgaXMgYSBuZXcgc2Nyb2xsIHJvb3QsIHdlIHdhbnQgdG8gcmVtb3ZlIGFsbCBwcmV2aW91cyBzY3JvbGxzXG4gICAgICAgICAgICAgICAgICAgICAqIGZyb20gdGhlIHZpZXdwb3J0IGJveC5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGwud2FzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8oYm94V2l0aG91dFNjcm9sbCwgYm94KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGVBeGlzKGJveFdpdGhvdXRTY3JvbGwueCwgc2Nyb2xsLm9mZnNldC54KTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlQXhpcyhib3hXaXRob3V0U2Nyb2xsLnksIHNjcm9sbC5vZmZzZXQueSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRTY3JvbGw7XG4gICAgICAgIH1cbiAgICAgICAgYXBwbHlUcmFuc2Zvcm0oYm94LCB0cmFuc2Zvcm1Pbmx5ID0gZmFsc2UpIHtcbiAgICAgICAgICAgIGNvbnN0IHdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byh3aXRoVHJhbnNmb3JtcywgYm94KTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5wYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHRoaXMucGF0aFtpXTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zZm9ybU9ubHkgJiZcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5vcHRpb25zLmxheW91dFNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlLnNjcm9sbCAmJlxuICAgICAgICAgICAgICAgICAgICBub2RlICE9PSBub2RlLnJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNmb3JtQm94KHdpdGhUcmFuc2Zvcm1zLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB4OiAtbm9kZS5zY3JvbGwub2Zmc2V0LngsXG4gICAgICAgICAgICAgICAgICAgICAgICB5OiAtbm9kZS5zY3JvbGwub2Zmc2V0LnksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybShub2RlLmxhdGVzdFZhbHVlcykpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIHRyYW5zZm9ybUJveCh3aXRoVHJhbnNmb3Jtcywgbm9kZS5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1Cb3god2l0aFRyYW5zZm9ybXMsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB3aXRoVHJhbnNmb3JtcztcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVUcmFuc2Zvcm0oYm94KSB7XG4gICAgICAgICAgICBjb25zdCBib3hXaXRob3V0VHJhbnNmb3JtID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICBjb3B5Qm94SW50byhib3hXaXRob3V0VHJhbnNmb3JtLCBib3gpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gdGhpcy5wYXRoW2ldO1xuICAgICAgICAgICAgICAgIGlmICghbm9kZS5pbnN0YW5jZSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgaWYgKCFoYXNUcmFuc2Zvcm0obm9kZS5sYXRlc3RWYWx1ZXMpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBoYXNTY2FsZShub2RlLmxhdGVzdFZhbHVlcykgJiYgbm9kZS51cGRhdGVTbmFwc2hvdCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvdXJjZUJveCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVCb3ggPSBub2RlLm1lYXN1cmVQYWdlQm94KCk7XG4gICAgICAgICAgICAgICAgY29weUJveEludG8oc291cmNlQm94LCBub2RlQm94KTtcbiAgICAgICAgICAgICAgICByZW1vdmVCb3hUcmFuc2Zvcm1zKGJveFdpdGhvdXRUcmFuc2Zvcm0sIG5vZGUubGF0ZXN0VmFsdWVzLCBub2RlLnNuYXBzaG90ID8gbm9kZS5zbmFwc2hvdC5sYXlvdXRCb3ggOiB1bmRlZmluZWQsIHNvdXJjZUJveCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzVHJhbnNmb3JtKHRoaXMubGF0ZXN0VmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHJlbW92ZUJveFRyYW5zZm9ybXMoYm94V2l0aG91dFRyYW5zZm9ybSwgdGhpcy5sYXRlc3RWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGJveFdpdGhvdXRUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgc2V0VGFyZ2V0RGVsdGEoZGVsdGEpIHtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0RGVsdGEgPSBkZWx0YTtcbiAgICAgICAgICAgIHRoaXMucm9vdC5zY2hlZHVsZVVwZGF0ZVByb2plY3Rpb24oKTtcbiAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHNldE9wdGlvbnMob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIGNyb3NzZmFkZTogb3B0aW9ucy5jcm9zc2ZhZGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMuY3Jvc3NmYWRlIDogdHJ1ZSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJNZWFzdXJlbWVudHMoKSB7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMubGF5b3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5zbmFwc2hvdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMucHJldlRyYW5zZm9ybVRlbXBsYXRlVmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlUGFyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHBhcmVudCB0YXJnZXQgaXNuJ3QgdXAtdG8tZGF0ZSwgZm9yY2UgaXQgdG8gdXBkYXRlLlxuICAgICAgICAgICAgICogVGhpcyBpcyBhbiB1bmZvcnR1bmF0ZSBkZS1vcHRpbWlzYXRpb24gYXMgaXQgbWVhbnMgYW55IHVwZGF0aW5nIHJlbGF0aXZlXG4gICAgICAgICAgICAgKiBwcm9qZWN0aW9uIHdpbGwgY2F1c2UgYWxsIHRoZSByZWxhdGl2ZSBwYXJlbnRzIHRvIHJlY2FsY3VsYXRlIGJhY2tcbiAgICAgICAgICAgICAqIHVwIHRoZSB0cmVlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVBhcmVudC5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgIT09XG4gICAgICAgICAgICAgICAgZnJhbWVEYXRhLnRpbWVzdGFtcCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQucmVzb2x2ZVRhcmdldERlbHRhKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc29sdmVUYXJnZXREZWx0YShmb3JjZVJlY2FsY3VsYXRpb24gPSBmYWxzZSkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPbmNlIHRoZSBkaXJ0eSBzdGF0dXMgb2Ygbm9kZXMgaGFzIGJlZW4gc3ByZWFkIHRocm91Z2ggdGhlIHRyZWUsIHdlIGFsc29cbiAgICAgICAgICAgICAqIG5lZWQgdG8gY2hlY2sgaWYgd2UgaGF2ZSBhIHNoYXJlZCBub2RlIG9mIGEgZGlmZmVyZW50IGRlcHRoIHRoYXQgaGFzIGl0c2VsZlxuICAgICAgICAgICAgICogYmVlbiBkaXJ0aWVkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICB0aGlzLmlzUHJvamVjdGlvbkRpcnR5IHx8ICh0aGlzLmlzUHJvamVjdGlvbkRpcnR5ID0gbGVhZC5pc1Byb2plY3Rpb25EaXJ0eSk7XG4gICAgICAgICAgICB0aGlzLmlzVHJhbnNmb3JtRGlydHkgfHwgKHRoaXMuaXNUcmFuc2Zvcm1EaXJ0eSA9IGxlYWQuaXNUcmFuc2Zvcm1EaXJ0eSk7XG4gICAgICAgICAgICB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5IHx8ICh0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5ID0gbGVhZC5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSk7XG4gICAgICAgICAgICBjb25zdCBpc1NoYXJlZCA9IEJvb2xlYW4odGhpcy5yZXN1bWluZ0Zyb20pIHx8IHRoaXMgIT09IGxlYWQ7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFdlIGRvbid0IHVzZSB0cmFuc2Zvcm0gZm9yIHRoaXMgc3RlcCBvZiBwcm9jZXNzaW5nIHNvIHdlIGRvbid0XG4gICAgICAgICAgICAgKiBuZWVkIHRvIGNoZWNrIHdoZXRoZXIgYW55IG5vZGVzIGhhdmUgY2hhbmdlZCB0cmFuc2Zvcm0uXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGNhblNraXAgPSAhKGZvcmNlUmVjYWxjdWxhdGlvbiB8fFxuICAgICAgICAgICAgICAgIChpc1NoYXJlZCAmJiB0aGlzLmlzU2hhcmVkUHJvamVjdGlvbkRpcnR5KSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9qZWN0aW9uRGlydHkgfHxcbiAgICAgICAgICAgICAgICAoKF9hID0gdGhpcy5wYXJlbnQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pc1Byb2plY3Rpb25EaXJ0eSkgfHxcbiAgICAgICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCB8fFxuICAgICAgICAgICAgICAgIHRoaXMucm9vdC51cGRhdGVCbG9ja2VkQnlSZXNpemUpO1xuICAgICAgICAgICAgaWYgKGNhblNraXApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgeyBsYXlvdXQsIGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gbGF5b3V0LCB3ZSBjYW4ndCBwZXJmb3JtIHByb2plY3Rpb24sIHNvIGVhcmx5IHJldHVyblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLnJlc29sdmVkUmVsYXRpdmVUYXJnZXRBdCA9IGZyYW1lRGF0YS50aW1lc3RhbXA7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGRvbid0IGhhdmUgYSB0YXJnZXREZWx0YSBidXQgZG8gaGF2ZSBhIGxheW91dCwgd2UgY2FuIGF0dGVtcHQgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgICogYSByZWxhdGl2ZVBhcmVudC4gVGhpcyB3aWxsIGFsbG93IGEgY29tcG9uZW50IHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICogZXZlbiBpZiBubyBhbmltYXRpb24gaGFzIHN0YXJ0ZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghdGhpcy50YXJnZXREZWx0YSAmJiAhdGhpcy5yZWxhdGl2ZVRhcmdldCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlUGFyZW50ID0gdGhpcy5nZXRDbG9zZXN0UHJvamVjdGluZ1BhcmVudCgpO1xuICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudCAmJlxuICAgICAgICAgICAgICAgICAgICByZWxhdGl2ZVBhcmVudC5sYXlvdXQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25Qcm9ncmVzcyAhPT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gcmVsYXRpdmVQYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZm9yY2VSZWxhdGl2ZVBhcmVudFRvUmVzb2x2ZVRhcmdldCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24odGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCByZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlIGhhdmUgbm8gcmVsYXRpdmUgdGFyZ2V0IG9yIG5vIHRhcmdldCBkZWx0YSBvdXIgdGFyZ2V0IGlzbid0IHZhbGlkXG4gICAgICAgICAgICAgKiBmb3IgdGhpcyBmcmFtZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlVGFyZ2V0ICYmICF0aGlzLnRhcmdldERlbHRhKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTGF6eS1pbml0IHRhcmdldCBkYXRhIHN0cnVjdHVyZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoIXRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHdlJ3ZlIGdvdCBhIHJlbGF0aXZlIGJveCBmb3IgdGhpcyBjb21wb25lbnQsIHJlc29sdmUgaXQgaW50byBhIHRhcmdldCByZWxhdGl2ZSB0byB0aGUgcGFyZW50LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gJiZcbiAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ICYmXG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZvcmNlUmVsYXRpdmVQYXJlbnRUb1Jlc29sdmVUYXJnZXQoKTtcbiAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVCb3godGhpcy50YXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB3ZSd2ZSBvbmx5IGdvdCBhIHRhcmdldERlbHRhLCByZXNvbHZlIGl0IGludG8gYSB0YXJnZXRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMudGFyZ2V0RGVsdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogVGhpcyBpcyBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgZnJhbWVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50YXJnZXQgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb3B5Qm94SW50byh0aGlzLnRhcmdldCwgdGhpcy5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXBwbHlCb3hEZWx0YSh0aGlzLnRhcmdldCwgdGhpcy50YXJnZXREZWx0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiBubyB0YXJnZXQsIHVzZSBvd24gbGF5b3V0IGFzIHRhcmdldFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGNvcHlCb3hJbnRvKHRoaXMudGFyZ2V0LCB0aGlzLmxheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSd2ZSBiZWVuIHRvbGQgdG8gYXR0ZW1wdCB0byByZXNvbHZlIGEgcmVsYXRpdmUgdGFyZ2V0LCBkbyBzby5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuYXR0ZW1wdFRvUmVzb2x2ZVJlbGF0aXZlVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRlbXB0VG9SZXNvbHZlUmVsYXRpdmVUYXJnZXQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IHRoaXMuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgQm9vbGVhbihyZWxhdGl2ZVBhcmVudC5yZXN1bWluZ0Zyb20pID09PVxuICAgICAgICAgICAgICAgICAgICAgICAgQm9vbGVhbih0aGlzLnJlc3VtaW5nRnJvbSkgJiZcbiAgICAgICAgICAgICAgICAgICAgIXJlbGF0aXZlUGFyZW50Lm9wdGlvbnMubGF5b3V0U2Nyb2xsICYmXG4gICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlUGFyZW50LnRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgPSByZWxhdGl2ZVBhcmVudDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mb3JjZVJlbGF0aXZlUGFyZW50VG9SZXNvbHZlVGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbiA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbih0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luLCB0aGlzLnRhcmdldCwgcmVsYXRpdmVQYXJlbnQudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8odGhpcy5yZWxhdGl2ZVRhcmdldCwgdGhpcy5yZWxhdGl2ZVRhcmdldE9yaWdpbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlUGFyZW50ID0gdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluY3JlYXNlIGRlYnVnIGNvdW50ZXIgZm9yIHJlc29sdmVkIHRhcmdldCBkZWx0YXNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGlzRGVidWcpIHtcbiAgICAgICAgICAgICAgICBtZXRyaWNzLnJlc29sdmVkVGFyZ2V0RGVsdGFzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucGFyZW50IHx8XG4gICAgICAgICAgICAgICAgaGFzU2NhbGUodGhpcy5wYXJlbnQubGF0ZXN0VmFsdWVzKSB8fFxuICAgICAgICAgICAgICAgIGhhczJEVHJhbnNsYXRlKHRoaXMucGFyZW50LmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGFyZW50LmlzUHJvamVjdGluZygpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50LmdldENsb3Nlc3RQcm9qZWN0aW5nUGFyZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaXNQcm9qZWN0aW5nKCkge1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oKHRoaXMucmVsYXRpdmVUYXJnZXQgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnRhcmdldERlbHRhIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheW91dFJvb3QpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5sYXlvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGNQcm9qZWN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgY29uc3QgbGVhZCA9IHRoaXMuZ2V0TGVhZCgpO1xuICAgICAgICAgICAgY29uc3QgaXNTaGFyZWQgPSBCb29sZWFuKHRoaXMucmVzdW1pbmdGcm9tKSB8fCB0aGlzICE9PSBsZWFkO1xuICAgICAgICAgICAgbGV0IGNhblNraXAgPSB0cnVlO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGEgbm9ybWFsIGxheW91dCBhbmltYXRpb24gYW5kIG5laXRoZXIgdGhpcyBub2RlIG5vciBpdHMgbmVhcmVzdCBwcm9qZWN0aW5nXG4gICAgICAgICAgICAgKiBpcyBkaXJ0eSB0aGVuIHdlIGNhbid0IHNraXAuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICh0aGlzLmlzUHJvamVjdGlvbkRpcnR5IHx8ICgoX2EgPSB0aGlzLnBhcmVudCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmlzUHJvamVjdGlvbkRpcnR5KSkge1xuICAgICAgICAgICAgICAgIGNhblNraXAgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBpcyBhIHNoYXJlZCBsYXlvdXQgYW5pbWF0aW9uIGFuZCB0aGlzIG5vZGUncyBzaGFyZWQgcHJvamVjdGlvbiBpcyBkaXJ0eSB0aGVuXG4gICAgICAgICAgICAgKiB3ZSBjYW4ndCBza2lwLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNTaGFyZWQgJiZcbiAgICAgICAgICAgICAgICAodGhpcy5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSB8fCB0aGlzLmlzVHJhbnNmb3JtRGlydHkpKSB7XG4gICAgICAgICAgICAgICAgY2FuU2tpcCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSBoYXZlIHJlc29sdmVkIHRoZSB0YXJnZXQgdGhpcyBmcmFtZSB3ZSBtdXN0IHJlY2FsY3VsYXRlIHRoZVxuICAgICAgICAgICAgICogcHJvamVjdGlvbiB0byBlbnN1cmUgaXQgdmlzdWFsbHkgcmVwcmVzZW50cyB0aGUgaW50ZXJuYWwgY2FsY3VsYXRpb25zLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5yZXNvbHZlZFJlbGF0aXZlVGFyZ2V0QXQgPT09IGZyYW1lRGF0YS50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBjYW5Ta2lwID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FuU2tpcClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dCwgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhpcyBzZWN0aW9uIG9mIHRoZSB0cmVlIGlzbid0IGFuaW1hdGluZyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGRlbGV0ZSBvdXIgdGFyZ2V0IHNvdXJjZXMgZm9yIHRoZSBmb2xsb3dpbmcgZnJhbWUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMuaXNUcmVlQW5pbWF0aW5nID0gQm9vbGVhbigodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNUcmVlQW5pbWF0aW5nKSB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEFuaW1hdGlvbiB8fFxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNUcmVlQW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50YXJnZXREZWx0YSA9IHRoaXMucmVsYXRpdmVUYXJnZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMubGF5b3V0IHx8ICEobGF5b3V0IHx8IGxheW91dElkKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlc2V0IHRoZSBjb3JyZWN0ZWQgYm94IHdpdGggdGhlIGxhdGVzdCB2YWx1ZXMgZnJvbSBib3gsIGFzIHdlJ3JlIHRoZW4gZ29pbmdcbiAgICAgICAgICAgICAqIHRvIHBlcmZvcm0gbXV0YXRpdmUgb3BlcmF0aW9ucyBvbiBpdC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29weUJveEludG8odGhpcy5sYXlvdXRDb3JyZWN0ZWQsIHRoaXMubGF5b3V0LmxheW91dEJveCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlY29yZCBwcmV2aW91cyB0cmVlIHNjYWxlcyBiZWZvcmUgdXBkYXRpbmcuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVYID0gdGhpcy50cmVlU2NhbGUueDtcbiAgICAgICAgICAgIGNvbnN0IHByZXZUcmVlU2NhbGVZID0gdGhpcy50cmVlU2NhbGUueTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgYWxsIHRoZSBwYXJlbnQgZGVsdGFzIHRvIHRoaXMgYm94IHRvIHByb2R1Y2UgdGhlIGNvcnJlY3RlZCBib3guIFRoaXNcbiAgICAgICAgICAgICAqIGlzIHRoZSBsYXlvdXQgYm94LCBhcyBpdCB3aWxsIGFwcGVhciBvbiBzY3JlZW4gYXMgYSByZXN1bHQgb2YgdGhlIHRyYW5zZm9ybXMgb2YgaXRzIHBhcmVudHMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFwcGx5VHJlZURlbHRhcyh0aGlzLmxheW91dENvcnJlY3RlZCwgdGhpcy50cmVlU2NhbGUsIHRoaXMucGF0aCwgaXNTaGFyZWQpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB0aGlzIGxheWVyIG5lZWRzIHRvIHBlcmZvcm0gc2NhbGUgY29ycmVjdGlvbiBidXQgZG9lc24ndCBoYXZlIGEgdGFyZ2V0LFxuICAgICAgICAgICAgICogdXNlIHRoZSBsYXlvdXQgYXMgdGhlIHRhcmdldC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKGxlYWQubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgIWxlYWQudGFyZ2V0ICYmXG4gICAgICAgICAgICAgICAgKHRoaXMudHJlZVNjYWxlLnggIT09IDEgfHwgdGhpcy50cmVlU2NhbGUueSAhPT0gMSkpIHtcbiAgICAgICAgICAgICAgICBsZWFkLnRhcmdldCA9IGxlYWQubGF5b3V0LmxheW91dEJveDtcbiAgICAgICAgICAgICAgICBsZWFkLnRhcmdldFdpdGhUcmFuc2Zvcm1zID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHRhcmdldCB9ID0gbGVhZDtcbiAgICAgICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhIHRhcmdldCB0byBwcm9qZWN0IGludG8sIGJ1dCB3ZSB3ZXJlIHByZXZpb3VzbHlcbiAgICAgICAgICAgICAgICAgKiBwcm9qZWN0aW5nLCB3ZSB3YW50IHRvIHJlbW92ZSB0aGUgc3RvcmVkIHRyYW5zZm9ybSBhbmQgc2NoZWR1bGVcbiAgICAgICAgICAgICAgICAgKiBhIHJlbmRlciB0byBlbnN1cmUgdGhlIGVsZW1lbnRzIHJlZmxlY3QgdGhlIHJlbW92ZWQgdHJhbnNmb3JtLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aW9uRGVsdGFzKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnByb2plY3Rpb25EZWx0YSB8fCAhdGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jcmVhdGVQcm9qZWN0aW9uRGVsdGFzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb3B5QXhpc0RlbHRhSW50byh0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueCwgdGhpcy5wcm9qZWN0aW9uRGVsdGEueCk7XG4gICAgICAgICAgICAgICAgY29weUF4aXNEZWx0YUludG8odGhpcy5wcmV2UHJvamVjdGlvbkRlbHRhLnksIHRoaXMucHJvamVjdGlvbkRlbHRhLnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBVcGRhdGUgdGhlIGRlbHRhIGJldHdlZW4gdGhlIGNvcnJlY3RlZCBib3ggYW5kIHRoZSB0YXJnZXQgYm94IGJlZm9yZSB1c2VyLXNldCB0cmFuc2Zvcm1zIHdlcmUgYXBwbGllZC5cbiAgICAgICAgICAgICAqIFRoaXMgd2lsbCBhbGxvdyB1cyB0byBjYWxjdWxhdGUgdGhlIGNvcnJlY3RlZCBib3JkZXJSYWRpdXMgYW5kIGJveFNoYWRvdyB0byBjb21wZW5zYXRlXG4gICAgICAgICAgICAgKiBmb3Igb3VyIGxheW91dCByZXByb2plY3Rpb24sIGJ1dCBzdGlsbCBhbGxvdyB0aGVtIHRvIGJlIHNjYWxlZCBjb3JyZWN0bHkgYnkgdGhlIHVzZXIuXG4gICAgICAgICAgICAgKiBJdCBtaWdodCBiZSB0aGF0IHRvIHNpbXBsaWZ5IHRoaXMgd2UgbWF5IHdhbnQgdG8gYWNjZXB0IHRoYXQgdXNlci1zZXQgc2NhbGUgaXMgYWxzbyBjb3JyZWN0ZWRcbiAgICAgICAgICAgICAqIGFuZCB3ZSB3b3VsZG4ndCBoYXZlIHRvIGtlZXAgYW5kIGNhbGMgYm90aCBkZWx0YXMsIE9SIHdlIGNvdWxkIHN1cHBvcnQgYSB1c2VyIHNldHRpbmdcbiAgICAgICAgICAgICAqIHRvIGFsbG93IHBlb3BsZSB0byBjaG9vc2Ugd2hldGhlciB0aGVzZSBzdHlsZXMgYXJlIGNvcnJlY3RlZCBiYXNlZCBvbiBqdXN0IHRoZVxuICAgICAgICAgICAgICogbGF5b3V0IHJlcHJvamVjdGlvbiBvciB0aGUgZmluYWwgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGEsIHRoaXMubGF5b3V0Q29ycmVjdGVkLCB0YXJnZXQsIHRoaXMubGF0ZXN0VmFsdWVzKTtcbiAgICAgICAgICAgIGlmICh0aGlzLnRyZWVTY2FsZS54ICE9PSBwcmV2VHJlZVNjYWxlWCB8fFxuICAgICAgICAgICAgICAgIHRoaXMudHJlZVNjYWxlLnkgIT09IHByZXZUcmVlU2NhbGVZIHx8XG4gICAgICAgICAgICAgICAgIWF4aXNEZWx0YUVxdWFscyh0aGlzLnByb2plY3Rpb25EZWx0YS54LCB0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEueCkgfHxcbiAgICAgICAgICAgICAgICAhYXhpc0RlbHRhRXF1YWxzKHRoaXMucHJvamVjdGlvbkRlbHRhLnksIHRoaXMucHJldlByb2plY3Rpb25EZWx0YS55KSkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzUHJvamVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJwcm9qZWN0aW9uVXBkYXRlXCIsIHRhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEluY3JlYXNlIGRlYnVnIGNvdW50ZXIgZm9yIHJlY2FsY3VsYXRlZCBwcm9qZWN0aW9uc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICAgICAgICAgIG1ldHJpY3MucmVjYWxjdWxhdGVkUHJvamVjdGlvbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGUoKSB7XG4gICAgICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gVE9ETzogU2NoZWR1bGUgcmVuZGVyXG4gICAgICAgIH1cbiAgICAgICAgc2hvdygpIHtcbiAgICAgICAgICAgIHRoaXMuaXNWaXNpYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIC8vIFRPRE86IFNjaGVkdWxlIHJlbmRlclxuICAgICAgICB9XG4gICAgICAgIHNjaGVkdWxlUmVuZGVyKG5vdGlmeUFsbCA9IHRydWUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIChfYSA9IHRoaXMub3B0aW9ucy52aXN1YWxFbGVtZW50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgIGlmIChub3RpZnlBbGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgICAgICBzdGFjayAmJiBzdGFjay5zY2hlZHVsZVJlbmRlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucmVzdW1pbmdGcm9tICYmICF0aGlzLnJlc3VtaW5nRnJvbS5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNyZWF0ZVByb2plY3Rpb25EZWx0YXMoKSB7XG4gICAgICAgICAgICB0aGlzLnByZXZQcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgdGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtID0gY3JlYXRlRGVsdGEoKTtcbiAgICAgICAgfVxuICAgICAgICBzZXRBbmltYXRpb25PcmlnaW4oZGVsdGEsIGhhc09ubHlSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSBmYWxzZSkge1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3QgPSB0aGlzLnNuYXBzaG90O1xuICAgICAgICAgICAgY29uc3Qgc25hcHNob3RMYXRlc3RWYWx1ZXMgPSBzbmFwc2hvdFxuICAgICAgICAgICAgICAgID8gc25hcHNob3QubGF0ZXN0VmFsdWVzXG4gICAgICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgICAgIGNvbnN0IG1peGVkVmFsdWVzID0geyAuLi50aGlzLmxhdGVzdFZhbHVlcyB9O1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJlbGF0aXZlUGFyZW50IHx8XG4gICAgICAgICAgICAgICAgIXRoaXMucmVsYXRpdmVQYXJlbnQub3B0aW9ucy5sYXlvdXRSb290KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVRhcmdldCA9IHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmF0dGVtcHRUb1Jlc29sdmVSZWxhdGl2ZVRhcmdldCA9ICFoYXNPbmx5UmVsYXRpdmVUYXJnZXRDaGFuZ2VkO1xuICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVMYXlvdXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgIGNvbnN0IHNuYXBzaG90U291cmNlID0gc25hcHNob3QgPyBzbmFwc2hvdC5zb3VyY2UgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRTb3VyY2UgPSB0aGlzLmxheW91dCA/IHRoaXMubGF5b3V0LnNvdXJjZSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGNvbnN0IGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uID0gc25hcHNob3RTb3VyY2UgIT09IGxheW91dFNvdXJjZTtcbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgY29uc3QgaXNPbmx5TWVtYmVyID0gIXN0YWNrIHx8IHN0YWNrLm1lbWJlcnMubGVuZ3RoIDw9IDE7XG4gICAgICAgICAgICBjb25zdCBzaG91bGRDcm9zc2ZhZGVPcGFjaXR5ID0gQm9vbGVhbihpc1NoYXJlZExheW91dEFuaW1hdGlvbiAmJlxuICAgICAgICAgICAgICAgICFpc09ubHlNZW1iZXIgJiZcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuY3Jvc3NmYWRlID09PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgIXRoaXMucGF0aC5zb21lKGhhc09wYWNpdHlDcm9zc2ZhZGUpKTtcbiAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uUHJvZ3Jlc3MgPSAwO1xuICAgICAgICAgICAgbGV0IHByZXZSZWxhdGl2ZVRhcmdldDtcbiAgICAgICAgICAgIHRoaXMubWl4VGFyZ2V0RGVsdGEgPSAobGF0ZXN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvZ3Jlc3MgPSBsYXRlc3QgLyAxMDAwO1xuICAgICAgICAgICAgICAgIG1peEF4aXNEZWx0YSh0YXJnZXREZWx0YS54LCBkZWx0YS54LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgbWl4QXhpc0RlbHRhKHRhcmdldERlbHRhLnksIGRlbHRhLnksIHByb2dyZXNzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFRhcmdldERlbHRhKHRhcmdldERlbHRhKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWxhdGl2ZVRhcmdldCAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbGF0aXZlVGFyZ2V0T3JpZ2luICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVsYXRpdmVQYXJlbnQgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsY1JlbGF0aXZlUG9zaXRpb24ocmVsYXRpdmVMYXlvdXQsIHRoaXMubGF5b3V0LmxheW91dEJveCwgdGhpcy5yZWxhdGl2ZVBhcmVudC5sYXlvdXQubGF5b3V0Qm94KTtcbiAgICAgICAgICAgICAgICAgICAgbWl4Qm94KHRoaXMucmVsYXRpdmVUYXJnZXQsIHRoaXMucmVsYXRpdmVUYXJnZXRPcmlnaW4sIHJlbGF0aXZlTGF5b3V0LCBwcm9ncmVzcyk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBJZiB0aGlzIGlzIGFuIHVuY2hhbmdlZCByZWxhdGl2ZSB0YXJnZXQgd2UgY2FuIGNvbnNpZGVyIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBwcm9qZWN0aW9uIG5vdCBkaXJ0eS5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcmV2UmVsYXRpdmVUYXJnZXQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGJveEVxdWFscyh0aGlzLnJlbGF0aXZlVGFyZ2V0LCBwcmV2UmVsYXRpdmVUYXJnZXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmlzUHJvamVjdGlvbkRpcnR5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmV2UmVsYXRpdmVUYXJnZXQpXG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2UmVsYXRpdmVUYXJnZXQgPSBjcmVhdGVCb3goKTtcbiAgICAgICAgICAgICAgICAgICAgY29weUJveEludG8ocHJldlJlbGF0aXZlVGFyZ2V0LCB0aGlzLnJlbGF0aXZlVGFyZ2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGlzU2hhcmVkTGF5b3V0QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzID0gbWl4ZWRWYWx1ZXM7XG4gICAgICAgICAgICAgICAgICAgIG1peFZhbHVlcyhtaXhlZFZhbHVlcywgc25hcHNob3RMYXRlc3RWYWx1ZXMsIHRoaXMubGF0ZXN0VmFsdWVzLCBwcm9ncmVzcywgc2hvdWxkQ3Jvc3NmYWRlT3BhY2l0eSwgaXNPbmx5TWVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yb290LnNjaGVkdWxlVXBkYXRlUHJvamVjdGlvbigpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVSZW5kZXIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFuaW1hdGlvblByb2dyZXNzID0gcHJvZ3Jlc3M7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSh0aGlzLm9wdGlvbnMubGF5b3V0Um9vdCA/IDEwMDAgOiAwKTtcbiAgICAgICAgfVxuICAgICAgICBzdGFydEFuaW1hdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeUxpc3RlbmVycyhcImFuaW1hdGlvblN0YXJ0XCIpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uICYmIHRoaXMuY3VycmVudEFuaW1hdGlvbi5zdG9wKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20gJiYgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLmN1cnJlbnRBbmltYXRpb24uc3RvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZ0FuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgIGNhbmNlbEZyYW1lKHRoaXMucGVuZGluZ0FuaW1hdGlvbik7XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTdGFydCB0aGUgYW5pbWF0aW9uIGluIHRoZSBuZXh0IGZyYW1lIHRvIGhhdmUgYSBmcmFtZSB3aXRoIHByb2dyZXNzIDAsXG4gICAgICAgICAgICAgKiB3aGVyZSB0aGUgdGFyZ2V0IGlzIHRoZSBzYW1lIGFzIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydGVkLCBzbyB3ZSBjYW5cbiAgICAgICAgICAgICAqIGNhbGN1bGF0ZSB0aGUgcmVsYXRpdmUgcG9zaXRpb25zIGNvcnJlY3RseSBmb3IgaW5zdGFudCB0cmFuc2l0aW9ucy5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gZnJhbWUudXBkYXRlKCgpID0+IHtcbiAgICAgICAgICAgICAgICBnbG9iYWxQcm9qZWN0aW9uU3RhdGUuaGFzQW5pbWF0ZWRTaW5jZVJlc2l6ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID0gYW5pbWF0ZVNpbmdsZVZhbHVlKDAsIGFuaW1hdGlvblRhcmdldCwge1xuICAgICAgICAgICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICBvblVwZGF0ZTogKGxhdGVzdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YShsYXRlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5vblVwZGF0ZSAmJiBvcHRpb25zLm9uVXBkYXRlKGxhdGVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG9uQ29tcGxldGU6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25Db21wbGV0ZSAmJiBvcHRpb25zLm9uQ29tcGxldGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bWluZ0Zyb20uY3VycmVudEFuaW1hdGlvbiA9IHRoaXMuY3VycmVudEFuaW1hdGlvbjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nQW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29tcGxldGVBbmltYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN1bWluZ0Zyb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbS5jdXJyZW50QW5pbWF0aW9uID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzdW1pbmdGcm9tLnByZXNlcnZlT3BhY2l0eSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHN0YWNrID0gdGhpcy5nZXRTdGFjaygpO1xuICAgICAgICAgICAgc3RhY2sgJiYgc3RhY2suZXhpdEFuaW1hdGlvbkNvbXBsZXRlKCk7XG4gICAgICAgICAgICB0aGlzLnJlc3VtaW5nRnJvbSA9XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uID1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hbmltYXRpb25WYWx1ZXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlMaXN0ZW5lcnMoXCJhbmltYXRpb25Db21wbGV0ZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBmaW5pc2hBbmltYXRpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50QW5pbWF0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5taXhUYXJnZXREZWx0YSAmJiB0aGlzLm1peFRhcmdldERlbHRhKGFuaW1hdGlvblRhcmdldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tcGxldGVBbmltYXRpb24oKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxlYWQgPSB0aGlzLmdldExlYWQoKTtcbiAgICAgICAgICAgIGxldCB7IHRhcmdldFdpdGhUcmFuc2Zvcm1zLCB0YXJnZXQsIGxheW91dCwgbGF0ZXN0VmFsdWVzIH0gPSBsZWFkO1xuICAgICAgICAgICAgaWYgKCF0YXJnZXRXaXRoVHJhbnNmb3JtcyB8fCAhdGFyZ2V0IHx8ICFsYXlvdXQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBJZiB3ZSdyZSBvbmx5IGFuaW1hdGluZyBwb3NpdGlvbiwgYW5kIHRoaXMgZWxlbWVudCBpc24ndCB0aGUgbGVhZCBlbGVtZW50LFxuICAgICAgICAgICAgICogdGhlbiBpbnN0ZWFkIG9mIHByb2plY3RpbmcgaW50byB0aGUgbGVhZCBib3ggd2UgaW5zdGVhZCB3YW50IHRvIGNhbGN1bGF0ZVxuICAgICAgICAgICAgICogYSBuZXcgdGFyZ2V0IHRoYXQgYWxpZ25zIHRoZSB0d28gYm94ZXMgYnV0IG1haW50YWlucyB0aGUgbGF5b3V0IHNoYXBlLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcyAhPT0gbGVhZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMubGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgbGF5b3V0ICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seSh0aGlzLm9wdGlvbnMuYW5pbWF0aW9uVHlwZSwgdGhpcy5sYXlvdXQubGF5b3V0Qm94LCBsYXlvdXQubGF5b3V0Qm94KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMudGFyZ2V0IHx8IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHhMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC54KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueC5taW4gPSBsZWFkLnRhcmdldC54Lm1pbjtcbiAgICAgICAgICAgICAgICB0YXJnZXQueC5tYXggPSB0YXJnZXQueC5taW4gKyB4TGVuZ3RoO1xuICAgICAgICAgICAgICAgIGNvbnN0IHlMZW5ndGggPSBjYWxjTGVuZ3RoKHRoaXMubGF5b3V0LmxheW91dEJveC55KTtcbiAgICAgICAgICAgICAgICB0YXJnZXQueS5taW4gPSBsZWFkLnRhcmdldC55Lm1pbjtcbiAgICAgICAgICAgICAgICB0YXJnZXQueS5tYXggPSB0YXJnZXQueS5taW4gKyB5TGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29weUJveEludG8odGFyZ2V0V2l0aFRyYW5zZm9ybXMsIHRhcmdldCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEFwcGx5IHRoZSBsYXRlc3QgdXNlci1zZXQgdHJhbnNmb3JtcyB0byB0aGUgdGFyZ2V0Qm94IHRvIHByb2R1Y2UgdGhlIHRhcmdldEJveEZpbmFsLlxuICAgICAgICAgICAgICogVGhpcyBpcyB0aGUgZmluYWwgYm94IHRoYXQgd2Ugd2lsbCB0aGVuIHByb2plY3QgaW50byBieSBjYWxjdWxhdGluZyBhIHRyYW5zZm9ybSBkZWx0YSBhbmRcbiAgICAgICAgICAgICAqIGFwcGx5aW5nIGl0IHRvIHRoZSBjb3JyZWN0ZWQgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB0cmFuc2Zvcm1Cb3godGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVwZGF0ZSB0aGUgZGVsdGEgYmV0d2VlbiB0aGUgY29ycmVjdGVkIGJveCBhbmQgdGhlIGZpbmFsIHRhcmdldCBib3gsIGFmdGVyXG4gICAgICAgICAgICAgKiB1c2VyLXNldCB0cmFuc2Zvcm1zIGFyZSBhcHBsaWVkIHRvIGl0LiBUaGlzIHdpbGwgYmUgdXNlZCBieSB0aGUgcmVuZGVyZXIgdG9cbiAgICAgICAgICAgICAqIGNyZWF0ZSBhIHRyYW5zZm9ybSBzdHlsZSB0aGF0IHdpbGwgcmVwcm9qZWN0IHRoZSBlbGVtZW50IGZyb20gaXRzIGxheW91dCBsYXlvdXRcbiAgICAgICAgICAgICAqIGludG8gdGhlIGRlc2lyZWQgYm91bmRpbmcgYm94LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjYWxjQm94RGVsdGEodGhpcy5wcm9qZWN0aW9uRGVsdGFXaXRoVHJhbnNmb3JtLCB0aGlzLmxheW91dENvcnJlY3RlZCwgdGFyZ2V0V2l0aFRyYW5zZm9ybXMsIGxhdGVzdFZhbHVlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVnaXN0ZXJTaGFyZWROb2RlKGxheW91dElkLCBub2RlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2hhcmVkTm9kZXMuaGFzKGxheW91dElkKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhcmVkTm9kZXMuc2V0KGxheW91dElkLCBuZXcgTm9kZVN0YWNrKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgICAgICBzdGFjay5hZGQobm9kZSk7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSBub2RlLm9wdGlvbnMuaW5pdGlhbFByb21vdGlvbkNvbmZpZztcbiAgICAgICAgICAgIG5vZGUucHJvbW90ZSh7XG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbjogY29uZmlnID8gY29uZmlnLnRyYW5zaXRpb24gOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgcHJlc2VydmVGb2xsb3dPcGFjaXR5OiBjb25maWcgJiYgY29uZmlnLnNob3VsZFByZXNlcnZlRm9sbG93T3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICA/IGNvbmZpZy5zaG91bGRQcmVzZXJ2ZUZvbGxvd09wYWNpdHkobm9kZSlcbiAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpc0xlYWQoKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIHJldHVybiBzdGFjayA/IHN0YWNrLmxlYWQgPT09IHRoaXMgOiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGdldExlYWQoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoKF9hID0gdGhpcy5nZXRTdGFjaygpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVhZCkgfHwgdGhpcyA6IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UHJldkxlYWQoKSB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBjb25zdCB7IGxheW91dElkIH0gPSB0aGlzLm9wdGlvbnM7XG4gICAgICAgICAgICByZXR1cm4gbGF5b3V0SWQgPyAoX2EgPSB0aGlzLmdldFN0YWNrKCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wcmV2TGVhZCA6IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBnZXRTdGFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGF5b3V0SWQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmIChsYXlvdXRJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LnNoYXJlZE5vZGVzLmdldChsYXlvdXRJZCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbW90ZSh7IG5lZWRzUmVzZXQsIHRyYW5zaXRpb24sIHByZXNlcnZlRm9sbG93T3BhY2l0eSwgfSA9IHt9KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFjayA9IHRoaXMuZ2V0U3RhY2soKTtcbiAgICAgICAgICAgIGlmIChzdGFjaylcbiAgICAgICAgICAgICAgICBzdGFjay5wcm9tb3RlKHRoaXMsIHByZXNlcnZlRm9sbG93T3BhY2l0eSk7XG4gICAgICAgICAgICBpZiAobmVlZHNSZXNldCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvamVjdGlvbkRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRoaXMubmVlZHNSZXNldCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNpdGlvbilcbiAgICAgICAgICAgICAgICB0aGlzLnNldE9wdGlvbnMoeyB0cmFuc2l0aW9uIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlbGVnYXRlKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSB0aGlzLmdldFN0YWNrKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhY2sucmVsZWdhdGUodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmVzZXRTa2V3QW5kUm90YXRpb24oKSB7XG4gICAgICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQgfSA9IHRoaXMub3B0aW9ucztcbiAgICAgICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBJZiB0aGVyZSdzIG5vIGRldGVjdGVkIHNrZXcgb3Igcm90YXRpb24gdmFsdWVzLCB3ZSBjYW4gZWFybHkgcmV0dXJuIHdpdGhvdXQgYSBmb3JjZWQgcmVuZGVyLlxuICAgICAgICAgICAgbGV0IGhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQW4gdW5yb2xsZWQgY2hlY2sgZm9yIHJvdGF0aW9uIHZhbHVlcy4gTW9zdCBlbGVtZW50cyBkb24ndCBoYXZlIGFueSByb3RhdGlvbiBhbmRcbiAgICAgICAgICAgICAqIHNraXBwaW5nIHRoZSBuZXN0ZWQgbG9vcCBhbmQgbmV3IG9iamVjdCBjcmVhdGlvbiBpcyA1MCUgZmFzdGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCB7IGxhdGVzdFZhbHVlcyB9ID0gdmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMueiB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGUgfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMucm90YXRlWCB8fFxuICAgICAgICAgICAgICAgIGxhdGVzdFZhbHVlcy5yb3RhdGVZIHx8XG4gICAgICAgICAgICAgICAgbGF0ZXN0VmFsdWVzLnJvdGF0ZVogfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMuc2tld1ggfHxcbiAgICAgICAgICAgICAgICBsYXRlc3RWYWx1ZXMuc2tld1kpIHtcbiAgICAgICAgICAgICAgICBoYXNEaXN0b3J0aW5nVHJhbnNmb3JtID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZXJlJ3Mgbm8gZGlzdG9ydGluZyB2YWx1ZXMsIHdlIGRvbid0IG5lZWQgdG8gZG8gYW55IG1vcmUuXG4gICAgICAgICAgICBpZiAoIWhhc0Rpc3RvcnRpbmdUcmFuc2Zvcm0pXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVzZXRWYWx1ZXMgPSB7fTtcbiAgICAgICAgICAgIGlmIChsYXRlc3RWYWx1ZXMueikge1xuICAgICAgICAgICAgICAgIHJlc2V0RGlzdG9ydGluZ1RyYW5zZm9ybShcInpcIiwgdmlzdWFsRWxlbWVudCwgcmVzZXRWYWx1ZXMsIHRoaXMuYW5pbWF0aW9uVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENoZWNrIHRoZSBza2V3IGFuZCByb3RhdGUgdmFsdWUgb2YgYWxsIGF4ZXMgYW5kIHJlc2V0IHRvIDBcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdHJhbnNmb3JtQXhlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHJlc2V0RGlzdG9ydGluZ1RyYW5zZm9ybShgcm90YXRlJHt0cmFuc2Zvcm1BeGVzW2ldfWAsIHZpc3VhbEVsZW1lbnQsIHJlc2V0VmFsdWVzLCB0aGlzLmFuaW1hdGlvblZhbHVlcyk7XG4gICAgICAgICAgICAgICAgcmVzZXREaXN0b3J0aW5nVHJhbnNmb3JtKGBza2V3JHt0cmFuc2Zvcm1BeGVzW2ldfWAsIHZpc3VhbEVsZW1lbnQsIHJlc2V0VmFsdWVzLCB0aGlzLmFuaW1hdGlvblZhbHVlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGb3JjZSBhIHJlbmRlciBvZiB0aGlzIGVsZW1lbnQgdG8gYXBwbHkgdGhlIHRyYW5zZm9ybSB3aXRoIGFsbCBza2V3cyBhbmQgcm90YXRpb25zXG4gICAgICAgICAgICAvLyBzZXQgdG8gMC5cbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQucmVuZGVyKCk7XG4gICAgICAgICAgICAvLyBQdXQgYmFjayBhbGwgdGhlIHZhbHVlcyB3ZSByZXNldFxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gcmVzZXRWYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNldFN0YXRpY1ZhbHVlKGtleSwgcmVzZXRWYWx1ZXNba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW5pbWF0aW9uVmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYW5pbWF0aW9uVmFsdWVzW2tleV0gPSByZXNldFZhbHVlc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIGEgcmVuZGVyIGZvciB0aGUgbmV4dCBmcmFtZS4gVGhpcyBlbnN1cmVzIHdlIHdvbid0IHZpc3VhbGx5XG4gICAgICAgICAgICAvLyBzZWUgdGhlIGVsZW1lbnQgd2l0aCB0aGUgcmVzZXQgcm90YXRlIHZhbHVlIGFwcGxpZWQuXG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LnNjaGVkdWxlUmVuZGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2V0UHJvamVjdGlvblN0eWxlcyhzdHlsZVByb3ApIHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgdGhpcy5pc1NWRylcbiAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoaWRkZW5WaXNpYmlsaXR5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgIHZpc2liaWxpdHk6IFwiXCIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtVGVtcGxhdGUgPSB0aGlzLmdldFRyYW5zZm9ybVRlbXBsYXRlKCk7XG4gICAgICAgICAgICBpZiAodGhpcy5uZWVkc1Jlc2V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZWVkc1Jlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy5wb2ludGVyRXZlbnRzID1cbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgICAgICAgICA/IHRyYW5zZm9ybVRlbXBsYXRlKHRoaXMubGF0ZXN0VmFsdWVzLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBsZWFkID0gdGhpcy5nZXRMZWFkKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJvamVjdGlvbkRlbHRhIHx8ICF0aGlzLmxheW91dCB8fCAhbGVhZC50YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbXB0eVN0eWxlcyA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5b3V0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhdGVzdFZhbHVlcy5vcGFjaXR5ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHRoaXMubGF0ZXN0VmFsdWVzLm9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IDE7XG4gICAgICAgICAgICAgICAgICAgIGVtcHR5U3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZU1vdGlvblZhbHVlKHN0eWxlUHJvcCA9PT0gbnVsbCB8fCBzdHlsZVByb3AgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHN0eWxlUHJvcC5wb2ludGVyRXZlbnRzKSB8fCBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5oYXNQcm9qZWN0ZWQgJiYgIWhhc1RyYW5zZm9ybSh0aGlzLmxhdGVzdFZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgZW1wdHlTdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgID8gdHJhbnNmb3JtVGVtcGxhdGUoe30sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFwibm9uZVwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhc1Byb2plY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZW1wdHlTdHlsZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXNUb1JlbmRlciA9IGxlYWQuYW5pbWF0aW9uVmFsdWVzIHx8IGxlYWQubGF0ZXN0VmFsdWVzO1xuICAgICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXNUb1RhcmdldCgpO1xuICAgICAgICAgICAgc3R5bGVzLnRyYW5zZm9ybSA9IGJ1aWxkUHJvamVjdGlvblRyYW5zZm9ybSh0aGlzLnByb2plY3Rpb25EZWx0YVdpdGhUcmFuc2Zvcm0sIHRoaXMudHJlZVNjYWxlLCB2YWx1ZXNUb1JlbmRlcik7XG4gICAgICAgICAgICBpZiAodHJhbnNmb3JtVGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMudHJhbnNmb3JtID0gdHJhbnNmb3JtVGVtcGxhdGUodmFsdWVzVG9SZW5kZXIsIHN0eWxlcy50cmFuc2Zvcm0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB4LCB5IH0gPSB0aGlzLnByb2plY3Rpb25EZWx0YTtcbiAgICAgICAgICAgIHN0eWxlcy50cmFuc2Zvcm1PcmlnaW4gPSBgJHt4Lm9yaWdpbiAqIDEwMH0lICR7eS5vcmlnaW4gKiAxMDB9JSAwYDtcbiAgICAgICAgICAgIGlmIChsZWFkLmFuaW1hdGlvblZhbHVlcykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBsZWFkIGNvbXBvbmVudCBpcyBhbmltYXRpbmcsIGFzc2lnbiB0aGlzIGVpdGhlciB0aGUgZW50ZXJpbmcvbGVhdmluZ1xuICAgICAgICAgICAgICAgICAqIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBzdHlsZXMub3BhY2l0eSA9XG4gICAgICAgICAgICAgICAgICAgIGxlYWQgPT09IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gKF9iID0gKF9hID0gdmFsdWVzVG9SZW5kZXIub3BhY2l0eSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogMVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnByZXNlcnZlT3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdGhpcy5sYXRlc3RWYWx1ZXMub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVzVG9SZW5kZXIub3BhY2l0eUV4aXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBPciB3ZSdyZSBub3QgYW5pbWF0aW5nIGF0IGFsbCwgc2V0IHRoZSBsZWFkIGNvbXBvbmVudCB0byBpdHMgbGF5b3V0XG4gICAgICAgICAgICAgICAgICogb3BhY2l0eSBhbmQgb3RoZXIgY29tcG9uZW50cyB0byBoaWRkZW4uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc3R5bGVzLm9wYWNpdHkgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyLm9wYWNpdHkgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmFsdWVzVG9SZW5kZXIub3BhY2l0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB2YWx1ZXNUb1JlbmRlci5vcGFjaXR5RXhpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQXBwbHkgc2NhbGUgY29ycmVjdGlvblxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzY2FsZUNvcnJlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzVG9SZW5kZXJba2V5XSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGNvcnJlY3QsIGFwcGx5VG8gfSA9IHNjYWxlQ29ycmVjdG9yc1trZXldO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIE9ubHkgYXBwbHkgc2NhbGUgY29ycmVjdGlvbiB0byB0aGUgdmFsdWUgaWYgd2UgaGF2ZSBhblxuICAgICAgICAgICAgICAgICAqIGFjdGl2ZSBwcm9qZWN0aW9uIHRyYW5zZm9ybS4gT3RoZXJ3aXNlIHRoZXNlIHZhbHVlcyBiZWNvbWVcbiAgICAgICAgICAgICAgICAgKiB2dWxuZXJhYmxlIHRvIGRpc3RvcnRpb24gaWYgdGhlIGVsZW1lbnQgY2hhbmdlcyBzaXplIHdpdGhvdXRcbiAgICAgICAgICAgICAgICAgKiBhIGNvcnJlc3BvbmRpbmcgbGF5b3V0IGFuaW1hdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjb3JyZWN0ZWQgPSBzdHlsZXMudHJhbnNmb3JtID09PSBcIm5vbmVcIlxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlc1RvUmVuZGVyW2tleV1cbiAgICAgICAgICAgICAgICAgICAgOiBjb3JyZWN0KHZhbHVlc1RvUmVuZGVyW2tleV0sIGxlYWQpO1xuICAgICAgICAgICAgICAgIGlmIChhcHBseVRvKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IGFwcGx5VG8ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNbYXBwbHlUb1tpXV0gPSBjb3JyZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlc1trZXldID0gY29ycmVjdGVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGlzYWJsZSBwb2ludGVyIGV2ZW50cyBvbiBmb2xsb3cgY29tcG9uZW50cy4gVGhpcyBpcyB0byBlbnN1cmVcbiAgICAgICAgICAgICAqIHRoYXQgaWYgYSBmb2xsb3cgY29tcG9uZW50IGNvdmVycyBhIGxlYWQgY29tcG9uZW50IGl0IGRvZXNuJ3QgYmxvY2tcbiAgICAgICAgICAgICAqIHBvaW50ZXIgZXZlbnRzIG9uIHRoZSBsZWFkLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxheW91dElkKSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzLnBvaW50ZXJFdmVudHMgPVxuICAgICAgICAgICAgICAgICAgICBsZWFkID09PSB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHJlc29sdmVNb3Rpb25WYWx1ZShzdHlsZVByb3AgPT09IG51bGwgfHwgc3R5bGVQcm9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdHlsZVByb3AucG9pbnRlckV2ZW50cykgfHwgXCJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgOiBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzdHlsZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJTbmFwc2hvdCgpIHtcbiAgICAgICAgICAgIHRoaXMucmVzdW1lRnJvbSA9IHRoaXMuc25hcHNob3QgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT25seSBydW4gb24gcm9vdFxuICAgICAgICByZXNldFRyZWUoKSB7XG4gICAgICAgICAgICB0aGlzLnJvb3Qubm9kZXMuZm9yRWFjaCgobm9kZSkgPT4geyB2YXIgX2E7IHJldHVybiAoX2EgPSBub2RlLmN1cnJlbnRBbmltYXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdG9wKCk7IH0pO1xuICAgICAgICAgICAgdGhpcy5yb290Lm5vZGVzLmZvckVhY2goY2xlYXJNZWFzdXJlbWVudHMpO1xuICAgICAgICAgICAgdGhpcy5yb290LnNoYXJlZE5vZGVzLmNsZWFyKCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gdXBkYXRlTGF5b3V0KG5vZGUpIHtcbiAgICBub2RlLnVwZGF0ZUxheW91dCgpO1xufVxuZnVuY3Rpb24gbm90aWZ5TGF5b3V0VXBkYXRlKG5vZGUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc25hcHNob3QgPSAoKF9hID0gbm9kZS5yZXN1bWVGcm9tKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc25hcHNob3QpIHx8IG5vZGUuc25hcHNob3Q7XG4gICAgaWYgKG5vZGUuaXNMZWFkKCkgJiZcbiAgICAgICAgbm9kZS5sYXlvdXQgJiZcbiAgICAgICAgc25hcHNob3QgJiZcbiAgICAgICAgbm9kZS5oYXNMaXN0ZW5lcnMoXCJkaWRVcGRhdGVcIikpIHtcbiAgICAgICAgY29uc3QgeyBsYXlvdXRCb3g6IGxheW91dCwgbWVhc3VyZWRCb3g6IG1lYXN1cmVkTGF5b3V0IH0gPSBub2RlLmxheW91dDtcbiAgICAgICAgY29uc3QgeyBhbmltYXRpb25UeXBlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGlzU2hhcmVkID0gc25hcHNob3Quc291cmNlICE9PSBub2RlLmxheW91dC5zb3VyY2U7XG4gICAgICAgIC8vIFRPRE8gTWF5YmUgd2Ugd2FudCB0byBhbHNvIHJlc2l6ZSB0aGUgbGF5b3V0IHNuYXBzaG90IHNvIHdlIGRvbid0IHRyaWdnZXJcbiAgICAgICAgLy8gYW5pbWF0aW9ucyBmb3IgaW5zdGFuY2UgaWYgbGF5b3V0PVwic2l6ZVwiIGFuZCBhbiBlbGVtZW50IGhhcyBvbmx5IGNoYW5nZWQgcG9zaXRpb25cbiAgICAgICAgaWYgKGFuaW1hdGlvblR5cGUgPT09IFwic2l6ZVwiKSB7XG4gICAgICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGF4aXNTbmFwc2hvdCA9IGlzU2hhcmVkXG4gICAgICAgICAgICAgICAgICAgID8gc25hcHNob3QubWVhc3VyZWRCb3hbYXhpc11cbiAgICAgICAgICAgICAgICAgICAgOiBzbmFwc2hvdC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChheGlzU25hcHNob3QpO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5taW4gPSBsYXlvdXRbYXhpc10ubWluO1xuICAgICAgICAgICAgICAgIGF4aXNTbmFwc2hvdC5tYXggPSBheGlzU25hcHNob3QubWluICsgbGVuZ3RoO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc2hvdWxkQW5pbWF0ZVBvc2l0aW9uT25seShhbmltYXRpb25UeXBlLCBzbmFwc2hvdC5sYXlvdXRCb3gsIGxheW91dCkpIHtcbiAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXhpc1NuYXBzaG90ID0gaXNTaGFyZWRcbiAgICAgICAgICAgICAgICAgICAgPyBzbmFwc2hvdC5tZWFzdXJlZEJveFtheGlzXVxuICAgICAgICAgICAgICAgICAgICA6IHNuYXBzaG90LmxheW91dEJveFtheGlzXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBjYWxjTGVuZ3RoKGxheW91dFtheGlzXSk7XG4gICAgICAgICAgICAgICAgYXhpc1NuYXBzaG90Lm1heCA9IGF4aXNTbmFwc2hvdC5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogRW5zdXJlIHJlbGF0aXZlIHRhcmdldCBnZXRzIHJlc2l6ZWQgYW5kIHJlcmVuZGVyZXJkXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUucmVsYXRpdmVUYXJnZXQgJiYgIW5vZGUuY3VycmVudEFuaW1hdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBub2RlLmlzUHJvamVjdGlvbkRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldFtheGlzXS5tYXggPVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVRhcmdldFtheGlzXS5taW4gKyBsZW5ndGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGF5b3V0RGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBjYWxjQm94RGVsdGEobGF5b3V0RGVsdGEsIGxheW91dCwgc25hcHNob3QubGF5b3V0Qm94KTtcbiAgICAgICAgY29uc3QgdmlzdWFsRGVsdGEgPSBjcmVhdGVEZWx0YSgpO1xuICAgICAgICBpZiAoaXNTaGFyZWQpIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbm9kZS5hcHBseVRyYW5zZm9ybShtZWFzdXJlZExheW91dCwgdHJ1ZSksIHNuYXBzaG90Lm1lYXN1cmVkQm94KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGNCb3hEZWx0YSh2aXN1YWxEZWx0YSwgbGF5b3V0LCBzbmFwc2hvdC5sYXlvdXRCb3gpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhhc0xheW91dENoYW5nZWQgPSAhaXNEZWx0YVplcm8obGF5b3V0RGVsdGEpO1xuICAgICAgICBsZXQgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkID0gZmFsc2U7XG4gICAgICAgIGlmICghbm9kZS5yZXN1bWVGcm9tKSB7XG4gICAgICAgICAgICBjb25zdCByZWxhdGl2ZVBhcmVudCA9IG5vZGUuZ2V0Q2xvc2VzdFByb2plY3RpbmdQYXJlbnQoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlIHJlbGF0aXZlUGFyZW50IGlzIGl0c2VsZiByZXN1bWluZyBmcm9tIGEgZGlmZmVyZW50IGVsZW1lbnQgdGhlblxuICAgICAgICAgICAgICogdGhlIHJlbGF0aXZlIHNuYXBzaG90IGlzIG5vdCByZWxhdmVudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAocmVsYXRpdmVQYXJlbnQgJiYgIXJlbGF0aXZlUGFyZW50LnJlc3VtZUZyb20pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHNuYXBzaG90OiBwYXJlbnRTbmFwc2hvdCwgbGF5b3V0OiBwYXJlbnRMYXlvdXQgfSA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgICAgICAgIGlmIChwYXJlbnRTbmFwc2hvdCAmJiBwYXJlbnRMYXlvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVsYXRpdmVTbmFwc2hvdCA9IGNyZWF0ZUJveCgpO1xuICAgICAgICAgICAgICAgICAgICBjYWxjUmVsYXRpdmVQb3NpdGlvbihyZWxhdGl2ZVNuYXBzaG90LCBzbmFwc2hvdC5sYXlvdXRCb3gsIHBhcmVudFNuYXBzaG90LmxheW91dEJveCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlbGF0aXZlTGF5b3V0ID0gY3JlYXRlQm94KCk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGNSZWxhdGl2ZVBvc2l0aW9uKHJlbGF0aXZlTGF5b3V0LCBsYXlvdXQsIHBhcmVudExheW91dC5sYXlvdXRCb3gpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJveEVxdWFsc1JvdW5kZWQocmVsYXRpdmVTbmFwc2hvdCwgcmVsYXRpdmVMYXlvdXQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNSZWxhdGl2ZVRhcmdldENoYW5nZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWxhdGl2ZVBhcmVudC5vcHRpb25zLmxheW91dFJvb3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVUYXJnZXQgPSByZWxhdGl2ZUxheW91dDtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVsYXRpdmVUYXJnZXRPcmlnaW4gPSByZWxhdGl2ZVNuYXBzaG90O1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWxhdGl2ZVBhcmVudCA9IHJlbGF0aXZlUGFyZW50O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG5vZGUubm90aWZ5TGlzdGVuZXJzKFwiZGlkVXBkYXRlXCIsIHtcbiAgICAgICAgICAgIGxheW91dCxcbiAgICAgICAgICAgIHNuYXBzaG90LFxuICAgICAgICAgICAgZGVsdGE6IHZpc3VhbERlbHRhLFxuICAgICAgICAgICAgbGF5b3V0RGVsdGEsXG4gICAgICAgICAgICBoYXNMYXlvdXRDaGFuZ2VkLFxuICAgICAgICAgICAgaGFzUmVsYXRpdmVUYXJnZXRDaGFuZ2VkLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAobm9kZS5pc0xlYWQoKSkge1xuICAgICAgICBjb25zdCB7IG9uRXhpdENvbXBsZXRlIH0gPSBub2RlLm9wdGlvbnM7XG4gICAgICAgIG9uRXhpdENvbXBsZXRlICYmIG9uRXhpdENvbXBsZXRlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFyaW5nIHRyYW5zaXRpb25cbiAgICAgKiBUT0RPOiBJbnZlc3RpZ2F0ZSB3aHkgdGhpcyB0cmFuc2l0aW9uIGlzIGJlaW5nIHBhc3NlZCBpbiBhcyB7dHlwZTogZmFsc2UgfSBmcm9tIEZyYW1lclxuICAgICAqIGFuZCB3aHkgd2UgbmVlZCBpdCBhdCBhbGxcbiAgICAgKi9cbiAgICBub2RlLm9wdGlvbnMudHJhbnNpdGlvbiA9IHVuZGVmaW5lZDtcbn1cbmZ1bmN0aW9uIHByb3BhZ2F0ZURpcnR5Tm9kZXMobm9kZSkge1xuICAgIC8qKlxuICAgICAqIEluY3JlYXNlIGRlYnVnIGNvdW50ZXIgZm9yIG5vZGVzIGVuY291bnRlcmVkIHRoaXMgZnJhbWVcbiAgICAgKi9cbiAgICBpZiAoaXNEZWJ1Zykge1xuICAgICAgICBtZXRyaWNzLnRvdGFsTm9kZXMrKztcbiAgICB9XG4gICAgaWYgKCFub2RlLnBhcmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIC8qKlxuICAgICAqIElmIHRoaXMgbm9kZSBpc24ndCBwcm9qZWN0aW5nLCBwcm9wYWdhdGUgaXNQcm9qZWN0aW9uRGlydHkuIEl0IHdpbGwgaGF2ZVxuICAgICAqIG5vIHBlcmZvcm1hbmNlIGltcGFjdCBidXQgaXQgd2lsbCBhbGxvdyB0aGUgbmV4dCBjaGlsZCB0aGF0ICppcyogcHJvamVjdGluZ1xuICAgICAqIGJ1dCAqaXNuJ3QqIGRpcnR5IHRvIGp1c3QgY2hlY2sgaXRzIHBhcmVudCB0byBzZWUgaWYgKmFueSogYW5jZXN0b3IgbmVlZHNcbiAgICAgKiBjb3JyZWN0aW5nLlxuICAgICAqL1xuICAgIGlmICghbm9kZS5pc1Byb2plY3RpbmcoKSkge1xuICAgICAgICBub2RlLmlzUHJvamVjdGlvbkRpcnR5ID0gbm9kZS5wYXJlbnQuaXNQcm9qZWN0aW9uRGlydHk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3BhZ2F0ZSBpc1NoYXJlZFByb2plY3Rpb25EaXJ0eSBhbmQgaXNUcmFuc2Zvcm1EaXJ0eVxuICAgICAqIHRocm91Z2hvdXQgdGhlIHdob2xlIHRyZWUuIEEgZnV0dXJlIHJldmlzaW9uIGNhbiB0YWtlIGFub3RoZXIgbG9vayBhdFxuICAgICAqIHRoaXMgYnV0IGZvciBzYWZldHkgd2Ugc3RpbGwgcmVjYWxjdWFsdGUgc2hhcmVkIG5vZGVzLlxuICAgICAqL1xuICAgIG5vZGUuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgfHwgKG5vZGUuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkgPSBCb29sZWFuKG5vZGUuaXNQcm9qZWN0aW9uRGlydHkgfHxcbiAgICAgICAgbm9kZS5wYXJlbnQuaXNQcm9qZWN0aW9uRGlydHkgfHxcbiAgICAgICAgbm9kZS5wYXJlbnQuaXNTaGFyZWRQcm9qZWN0aW9uRGlydHkpKTtcbiAgICBub2RlLmlzVHJhbnNmb3JtRGlydHkgfHwgKG5vZGUuaXNUcmFuc2Zvcm1EaXJ0eSA9IG5vZGUucGFyZW50LmlzVHJhbnNmb3JtRGlydHkpO1xufVxuZnVuY3Rpb24gY2xlYW5EaXJ0eU5vZGVzKG5vZGUpIHtcbiAgICBub2RlLmlzUHJvamVjdGlvbkRpcnR5ID1cbiAgICAgICAgbm9kZS5pc1NoYXJlZFByb2plY3Rpb25EaXJ0eSA9XG4gICAgICAgICAgICBub2RlLmlzVHJhbnNmb3JtRGlydHkgPVxuICAgICAgICAgICAgICAgIGZhbHNlO1xufVxuZnVuY3Rpb24gY2xlYXJTbmFwc2hvdChub2RlKSB7XG4gICAgbm9kZS5jbGVhclNuYXBzaG90KCk7XG59XG5mdW5jdGlvbiBjbGVhck1lYXN1cmVtZW50cyhub2RlKSB7XG4gICAgbm9kZS5jbGVhck1lYXN1cmVtZW50cygpO1xufVxuZnVuY3Rpb24gY2xlYXJJc0xheW91dERpcnR5KG5vZGUpIHtcbiAgICBub2RlLmlzTGF5b3V0RGlydHkgPSBmYWxzZTtcbn1cbmZ1bmN0aW9uIHJlc2V0VHJhbnNmb3JtU3R5bGUobm9kZSkge1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gbm9kZS5vcHRpb25zO1xuICAgIGlmICh2aXN1YWxFbGVtZW50ICYmIHZpc3VhbEVsZW1lbnQuZ2V0UHJvcHMoKS5vbkJlZm9yZUxheW91dE1lYXN1cmUpIHtcbiAgICAgICAgdmlzdWFsRWxlbWVudC5ub3RpZnkoXCJCZWZvcmVMYXlvdXRNZWFzdXJlXCIpO1xuICAgIH1cbiAgICBub2RlLnJlc2V0VHJhbnNmb3JtKCk7XG59XG5mdW5jdGlvbiBmaW5pc2hBbmltYXRpb24obm9kZSkge1xuICAgIG5vZGUuZmluaXNoQW5pbWF0aW9uKCk7XG4gICAgbm9kZS50YXJnZXREZWx0YSA9IG5vZGUucmVsYXRpdmVUYXJnZXQgPSBub2RlLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICBub2RlLmlzUHJvamVjdGlvbkRpcnR5ID0gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHJlc29sdmVUYXJnZXREZWx0YShub2RlKSB7XG4gICAgbm9kZS5yZXNvbHZlVGFyZ2V0RGVsdGEoKTtcbn1cbmZ1bmN0aW9uIGNhbGNQcm9qZWN0aW9uKG5vZGUpIHtcbiAgICBub2RlLmNhbGNQcm9qZWN0aW9uKCk7XG59XG5mdW5jdGlvbiByZXNldFNrZXdBbmRSb3RhdGlvbihub2RlKSB7XG4gICAgbm9kZS5yZXNldFNrZXdBbmRSb3RhdGlvbigpO1xufVxuZnVuY3Rpb24gcmVtb3ZlTGVhZFNuYXBzaG90cyhzdGFjaykge1xuICAgIHN0YWNrLnJlbW92ZUxlYWRTbmFwc2hvdCgpO1xufVxuZnVuY3Rpb24gbWl4QXhpc0RlbHRhKG91dHB1dCwgZGVsdGEsIHApIHtcbiAgICBvdXRwdXQudHJhbnNsYXRlID0gbWl4TnVtYmVyJDEoZGVsdGEudHJhbnNsYXRlLCAwLCBwKTtcbiAgICBvdXRwdXQuc2NhbGUgPSBtaXhOdW1iZXIkMShkZWx0YS5zY2FsZSwgMSwgcCk7XG4gICAgb3V0cHV0Lm9yaWdpbiA9IGRlbHRhLm9yaWdpbjtcbiAgICBvdXRwdXQub3JpZ2luUG9pbnQgPSBkZWx0YS5vcmlnaW5Qb2ludDtcbn1cbmZ1bmN0aW9uIG1peEF4aXMob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG91dHB1dC5taW4gPSBtaXhOdW1iZXIkMShmcm9tLm1pbiwgdG8ubWluLCBwKTtcbiAgICBvdXRwdXQubWF4ID0gbWl4TnVtYmVyJDEoZnJvbS5tYXgsIHRvLm1heCwgcCk7XG59XG5mdW5jdGlvbiBtaXhCb3gob3V0cHV0LCBmcm9tLCB0bywgcCkge1xuICAgIG1peEF4aXMob3V0cHV0LngsIGZyb20ueCwgdG8ueCwgcCk7XG4gICAgbWl4QXhpcyhvdXRwdXQueSwgZnJvbS55LCB0by55LCBwKTtcbn1cbmZ1bmN0aW9uIGhhc09wYWNpdHlDcm9zc2ZhZGUobm9kZSkge1xuICAgIHJldHVybiAobm9kZS5hbmltYXRpb25WYWx1ZXMgJiYgbm9kZS5hbmltYXRpb25WYWx1ZXMub3BhY2l0eUV4aXQgIT09IHVuZGVmaW5lZCk7XG59XG5jb25zdCBkZWZhdWx0TGF5b3V0VHJhbnNpdGlvbiA9IHtcbiAgICBkdXJhdGlvbjogMC40NSxcbiAgICBlYXNlOiBbMC40LCAwLCAwLjEsIDFdLFxufTtcbmNvbnN0IHVzZXJBZ2VudENvbnRhaW5zID0gKHN0cmluZykgPT4gdHlwZW9mIG5hdmlnYXRvciAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgIG5hdmlnYXRvci51c2VyQWdlbnQgJiZcbiAgICBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoc3RyaW5nKTtcbi8qKlxuICogTWVhc3VyZWQgYm91bmRpbmcgYm94ZXMgbXVzdCBiZSByb3VuZGVkIGluIFNhZmFyaSBhbmRcbiAqIGxlZnQgdW50b3VjaGVkIGluIENocm9tZSwgb3RoZXJ3aXNlIG5vbi1pbnRlZ2VyIGxheW91dHMgd2l0aGluIHNjYWxlZC11cCBlbGVtZW50c1xuICogY2FuIGFwcGVhciB0byBqdW1wLlxuICovXG5jb25zdCByb3VuZFBvaW50ID0gdXNlckFnZW50Q29udGFpbnMoXCJhcHBsZXdlYmtpdC9cIikgJiYgIXVzZXJBZ2VudENvbnRhaW5zKFwiY2hyb21lL1wiKVxuICAgID8gTWF0aC5yb3VuZFxuICAgIDogbW90aW9uVXRpbHMubm9vcDtcbmZ1bmN0aW9uIHJvdW5kQXhpcyhheGlzKSB7XG4gICAgLy8gUm91bmQgdG8gdGhlIG5lYXJlc3QgLjUgcGl4ZWxzIHRvIHN1cHBvcnQgc3VicGl4ZWwgbGF5b3V0c1xuICAgIGF4aXMubWluID0gcm91bmRQb2ludChheGlzLm1pbik7XG4gICAgYXhpcy5tYXggPSByb3VuZFBvaW50KGF4aXMubWF4KTtcbn1cbmZ1bmN0aW9uIHJvdW5kQm94KGJveCkge1xuICAgIHJvdW5kQXhpcyhib3gueCk7XG4gICAgcm91bmRBeGlzKGJveC55KTtcbn1cbmZ1bmN0aW9uIHNob3VsZEFuaW1hdGVQb3NpdGlvbk9ubHkoYW5pbWF0aW9uVHlwZSwgc25hcHNob3QsIGxheW91dCkge1xuICAgIHJldHVybiAoYW5pbWF0aW9uVHlwZSA9PT0gXCJwb3NpdGlvblwiIHx8XG4gICAgICAgIChhbmltYXRpb25UeXBlID09PSBcInByZXNlcnZlLWFzcGVjdFwiICYmXG4gICAgICAgICAgICAhaXNOZWFyKGFzcGVjdFJhdGlvKHNuYXBzaG90KSwgYXNwZWN0UmF0aW8obGF5b3V0KSwgMC4yKSkpO1xufVxuZnVuY3Rpb24gY2hlY2tOb2RlV2FzU2Nyb2xsUm9vdChub2RlKSB7XG4gICAgdmFyIF9hO1xuICAgIHJldHVybiBub2RlICE9PSBub2RlLnJvb3QgJiYgKChfYSA9IG5vZGUuc2Nyb2xsKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eud2FzUm9vdCk7XG59XG5cbmNvbnN0IERvY3VtZW50UHJvamVjdGlvbk5vZGUgPSBjcmVhdGVQcm9qZWN0aW9uTm9kZSQxKHtcbiAgICBhdHRhY2hSZXNpemVMaXN0ZW5lcjogKHJlZiwgbm90aWZ5KSA9PiBhZGREb21FdmVudChyZWYsIFwicmVzaXplXCIsIG5vdGlmeSksXG4gICAgbWVhc3VyZVNjcm9sbDogKCkgPT4gKHtcbiAgICAgICAgeDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQgfHwgZG9jdW1lbnQuYm9keS5zY3JvbGxMZWZ0LFxuICAgICAgICB5OiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wLFxuICAgIH0pLFxuICAgIGNoZWNrSXNTY3JvbGxSb290OiAoKSA9PiB0cnVlLFxufSk7XG5cbmNvbnN0IHJvb3RQcm9qZWN0aW9uTm9kZSA9IHtcbiAgICBjdXJyZW50OiB1bmRlZmluZWQsXG59O1xuY29uc3QgSFRNTFByb2plY3Rpb25Ob2RlID0gY3JlYXRlUHJvamVjdGlvbk5vZGUkMSh7XG4gICAgbWVhc3VyZVNjcm9sbDogKGluc3RhbmNlKSA9PiAoe1xuICAgICAgICB4OiBpbnN0YW5jZS5zY3JvbGxMZWZ0LFxuICAgICAgICB5OiBpbnN0YW5jZS5zY3JvbGxUb3AsXG4gICAgfSksXG4gICAgZGVmYXVsdFBhcmVudDogKCkgPT4ge1xuICAgICAgICBpZiAoIXJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBkb2N1bWVudE5vZGUgPSBuZXcgRG9jdW1lbnRQcm9qZWN0aW9uTm9kZSh7fSk7XG4gICAgICAgICAgICBkb2N1bWVudE5vZGUubW91bnQod2luZG93KTtcbiAgICAgICAgICAgIGRvY3VtZW50Tm9kZS5zZXRPcHRpb25zKHsgbGF5b3V0U2Nyb2xsOiB0cnVlIH0pO1xuICAgICAgICAgICAgcm9vdFByb2plY3Rpb25Ob2RlLmN1cnJlbnQgPSBkb2N1bWVudE5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgIH0sXG4gICAgcmVzZXRUcmFuc2Zvcm06IChpbnN0YW5jZSwgdmFsdWUpID0+IHtcbiAgICAgICAgaW5zdGFuY2Uuc3R5bGUudHJhbnNmb3JtID0gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHZhbHVlIDogXCJub25lXCI7XG4gICAgfSxcbiAgICBjaGVja0lzU2Nyb2xsUm9vdDogKGluc3RhbmNlKSA9PiBCb29sZWFuKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGluc3RhbmNlKS5wb3NpdGlvbiA9PT0gXCJmaXhlZFwiKSxcbn0pO1xuXG5jb25zdCBub3RpZnkgPSAobm9kZSkgPT4gIW5vZGUuaXNMYXlvdXREaXJ0eSAmJiBub2RlLndpbGxVcGRhdGUoZmFsc2UpO1xuZnVuY3Rpb24gbm9kZUdyb3VwKCkge1xuICAgIGNvbnN0IG5vZGVzID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IHN1YnNjcmlwdGlvbnMgPSBuZXcgV2Vha01hcCgpO1xuICAgIGNvbnN0IGRpcnR5QWxsID0gKCkgPT4gbm9kZXMuZm9yRWFjaChub3RpZnkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgIG5vZGVzLmFkZChub2RlKTtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuc2V0KG5vZGUsIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihcIndpbGxVcGRhdGVcIiwgZGlydHlBbGwpKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAobm9kZSkgPT4ge1xuICAgICAgICAgICAgbm9kZXMuZGVsZXRlKG5vZGUpO1xuICAgICAgICAgICAgY29uc3QgdW5zdWJzY3JpYmUgPSBzdWJzY3JpcHRpb25zLmdldChub2RlKTtcbiAgICAgICAgICAgIGlmICh1bnN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIHVuc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAgICAgc3Vic2NyaXB0aW9ucy5kZWxldGUobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXJ0eUFsbCgpO1xuICAgICAgICB9LFxuICAgICAgICBkaXJ0eTogZGlydHlBbGwsXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gcGl4ZWxzVG9QZXJjZW50KHBpeGVscywgYXhpcykge1xuICAgIGlmIChheGlzLm1heCA9PT0gYXhpcy5taW4pXG4gICAgICAgIHJldHVybiAwO1xuICAgIHJldHVybiAocGl4ZWxzIC8gKGF4aXMubWF4IC0gYXhpcy5taW4pKSAqIDEwMDtcbn1cbi8qKlxuICogV2UgYWx3YXlzIGNvcnJlY3QgYm9yZGVyUmFkaXVzIGFzIGEgcGVyY2VudGFnZSByYXRoZXIgdGhhbiBwaXhlbHMgdG8gcmVkdWNlIHBhaW50cy5cbiAqIEZvciBleGFtcGxlLCBpZiB5b3UgYXJlIHByb2plY3RpbmcgYSBib3ggdGhhdCBpcyAxMDBweCB3aWRlIHdpdGggYSAxMHB4IGJvcmRlclJhZGl1c1xuICogaW50byBhIGJveCB0aGF0IGlzIDIwMHB4IHdpZGUgd2l0aCBhIDIwcHggYm9yZGVyUmFkaXVzLCB0aGF0IGlzIGFjdHVhbGx5IGEgMTAlXG4gKiBib3JkZXJSYWRpdXMgaW4gYm90aCBzdGF0ZXMuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBpeGVscyB0aGF0IHdpbGwgdHJpZ2dlclxuICogYSBwYWludCBlYWNoIHRpbWUuIElmIHdlIGFuaW1hdGUgYmV0d2VlbiB0aGUgdHdvIGluIHBlcmNlbnRhZ2Ugd2UnbGwgYXZvaWQgYSBwYWludC5cbiAqL1xuY29uc3QgY29ycmVjdEJvcmRlclJhZGl1cyA9IHtcbiAgICBjb3JyZWN0OiAobGF0ZXN0LCBub2RlKSA9PiB7XG4gICAgICAgIGlmICghbm9kZS50YXJnZXQpXG4gICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgbGF0ZXN0IGlzIGEgc3RyaW5nLCBpZiBpdCdzIGEgcGVyY2VudGFnZSB3ZSBjYW4gcmV0dXJuIGltbWVkaWF0ZWx5IGFzIGl0J3NcbiAgICAgICAgICogZ29pbmcgdG8gYmUgc3RyZXRjaGVkIGFwcHJvcHJpYXRlbHkuIE90aGVyd2lzZSwgaWYgaXQncyBhIHBpeGVsLCBjb252ZXJ0IGl0IHRvIGEgbnVtYmVyLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHR5cGVvZiBsYXRlc3QgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmIChweC50ZXN0KGxhdGVzdCkpIHtcbiAgICAgICAgICAgICAgICBsYXRlc3QgPSBwYXJzZUZsb2F0KGxhdGVzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGF0ZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBsYXRlc3QgaXMgYSBudW1iZXIsIGl0J3MgYSBwaXhlbCB2YWx1ZS4gV2UgdXNlIHRoZSBjdXJyZW50IHZpZXdwb3J0Qm94IHRvIGNhbGN1bGF0ZSB0aGF0XG4gICAgICAgICAqIHBpeGVsIHZhbHVlIGFzIGEgcGVyY2VudGFnZSBvZiBlYWNoIGF4aXNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHggPSBwaXhlbHNUb1BlcmNlbnQobGF0ZXN0LCBub2RlLnRhcmdldC54KTtcbiAgICAgICAgY29uc3QgeSA9IHBpeGVsc1RvUGVyY2VudChsYXRlc3QsIG5vZGUudGFyZ2V0LnkpO1xuICAgICAgICByZXR1cm4gYCR7eH0lICR7eX0lYDtcbiAgICB9LFxufTtcblxuY29uc3QgY29ycmVjdEJveFNoYWRvdyA9IHtcbiAgICBjb3JyZWN0OiAobGF0ZXN0LCB7IHRyZWVTY2FsZSwgcHJvamVjdGlvbkRlbHRhIH0pID0+IHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYWwgPSBsYXRlc3Q7XG4gICAgICAgIGNvbnN0IHNoYWRvdyA9IGNvbXBsZXgucGFyc2UobGF0ZXN0KTtcbiAgICAgICAgLy8gVE9ETzogRG9lc24ndCBzdXBwb3J0IG11bHRpcGxlIHNoYWRvd3NcbiAgICAgICAgaWYgKHNoYWRvdy5sZW5ndGggPiA1KVxuICAgICAgICAgICAgcmV0dXJuIG9yaWdpbmFsO1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZSA9IGNvbXBsZXguY3JlYXRlVHJhbnNmb3JtZXIobGF0ZXN0KTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdHlwZW9mIHNoYWRvd1swXSAhPT0gXCJudW1iZXJcIiA/IDEgOiAwO1xuICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJhbGwgY29udGV4dCBzY2FsZVxuICAgICAgICBjb25zdCB4U2NhbGUgPSBwcm9qZWN0aW9uRGVsdGEueC5zY2FsZSAqIHRyZWVTY2FsZS54O1xuICAgICAgICBjb25zdCB5U2NhbGUgPSBwcm9qZWN0aW9uRGVsdGEueS5zY2FsZSAqIHRyZWVTY2FsZS55O1xuICAgICAgICBzaGFkb3dbMCArIG9mZnNldF0gLz0geFNjYWxlO1xuICAgICAgICBzaGFkb3dbMSArIG9mZnNldF0gLz0geVNjYWxlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWRlYWxseSB3ZSdkIGNvcnJlY3QgeCBhbmQgeSBzY2FsZXMgaW5kaXZpZHVhbGx5LCBidXQgYmVjYXVzZSBibHVyIGFuZFxuICAgICAgICAgKiBzcHJlYWQgYXBwbHkgdG8gYm90aCB3ZSBoYXZlIHRvIHRha2UgYSBzY2FsZSBhdmVyYWdlIGFuZCBhcHBseSB0aGF0IGluc3RlYWQuXG4gICAgICAgICAqIFdlIGNvdWxkIHBvdGVudGlhbGx5IGltcHJvdmUgdGhlIG91dGNvbWUgb2YgdGhpcyBieSBpbmNvcnBvcmF0aW5nIHRoZSByYXRpbyBiZXR3ZWVuXG4gICAgICAgICAqIHRoZSB0d28gc2NhbGVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYXZlcmFnZVNjYWxlID0gbWl4TnVtYmVyJDEoeFNjYWxlLCB5U2NhbGUsIDAuNSk7XG4gICAgICAgIC8vIEJsdXJcbiAgICAgICAgaWYgKHR5cGVvZiBzaGFkb3dbMiArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzaGFkb3dbMiArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgICAgICAvLyBTcHJlYWRcbiAgICAgICAgaWYgKHR5cGVvZiBzaGFkb3dbMyArIG9mZnNldF0gPT09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICBzaGFkb3dbMyArIG9mZnNldF0gLz0gYXZlcmFnZVNjYWxlO1xuICAgICAgICByZXR1cm4gdGVtcGxhdGUoc2hhZG93KTtcbiAgICB9LFxufTtcblxuY29uc3Qgc2hvdWxkSW5oZXJpdEdyb3VwID0gKGluaGVyaXQpID0+IGluaGVyaXQgPT09IHRydWU7XG5jb25zdCBzaG91bGRJbmhlcml0SWQgPSAoaW5oZXJpdCkgPT4gc2hvdWxkSW5oZXJpdEdyb3VwKGluaGVyaXQgPT09IHRydWUpIHx8IGluaGVyaXQgPT09IFwiaWRcIjtcbmNvbnN0IExheW91dEdyb3VwID0gKHsgY2hpbGRyZW4sIGlkLCBpbmhlcml0ID0gdHJ1ZSB9KSA9PiB7XG4gICAgY29uc3QgbGF5b3V0R3JvdXBDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIGNvbnN0IGRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KERlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIGNvbnN0IFtmb3JjZVJlbmRlciwga2V5XSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgY29uc3QgY29udGV4dCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICBjb25zdCB1cHN0cmVhbUlkID0gbGF5b3V0R3JvdXBDb250ZXh0LmlkIHx8IGRlcHJlY2F0ZWRMYXlvdXRHcm91cENvbnRleHQ7XG4gICAgaWYgKGNvbnRleHQuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc2hvdWxkSW5oZXJpdElkKGluaGVyaXQpICYmIHVwc3RyZWFtSWQpIHtcbiAgICAgICAgICAgIGlkID0gaWQgPyB1cHN0cmVhbUlkICsgXCItXCIgKyBpZCA6IHVwc3RyZWFtSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBncm91cDogc2hvdWxkSW5oZXJpdEdyb3VwKGluaGVyaXQpXG4gICAgICAgICAgICAgICAgPyBsYXlvdXRHcm91cENvbnRleHQuZ3JvdXAgfHwgbm9kZUdyb3VwKClcbiAgICAgICAgICAgICAgICA6IG5vZGVHcm91cCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBtZW1vaXplZENvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+ICh7IC4uLmNvbnRleHQuY3VycmVudCwgZm9yY2VSZW5kZXIgfSksIFtrZXldKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KExheW91dEdyb3VwQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogbWVtb2l6ZWRDb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufTtcblxuY29uc3QgTGF6eUNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHsgc3RyaWN0OiBmYWxzZSB9KTtcblxuZnVuY3Rpb24gbG9hZEZlYXR1cmVzKGZlYXR1cmVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZmVhdHVyZXMpIHtcbiAgICAgICAgZmVhdHVyZURlZmluaXRpb25zW2tleV0gPSB7XG4gICAgICAgICAgICAuLi5mZWF0dXJlRGVmaW5pdGlvbnNba2V5XSxcbiAgICAgICAgICAgIC4uLmZlYXR1cmVzW2tleV0sXG4gICAgICAgIH07XG4gICAgfVxufVxuXG4vKipcbiAqIFVzZWQgaW4gY29uanVuY3Rpb24gd2l0aCB0aGUgYG1gIGNvbXBvbmVudCB0byByZWR1Y2UgYnVuZGxlIHNpemUuXG4gKlxuICogYG1gIGlzIGEgdmVyc2lvbiBvZiB0aGUgYG1vdGlvbmAgY29tcG9uZW50IHRoYXQgb25seSBsb2FkcyBmdW5jdGlvbmFsaXR5XG4gKiBjcml0aWNhbCBmb3IgdGhlIGluaXRpYWwgcmVuZGVyLlxuICpcbiAqIGBMYXp5TW90aW9uYCBjYW4gdGhlbiBiZSB1c2VkIHRvIGVpdGhlciBzeW5jaHJvbm91c2x5IG9yIGFzeW5jaHJvbm91c2x5XG4gKiBsb2FkIGFuaW1hdGlvbiBhbmQgZ2VzdHVyZSBzdXBwb3J0LlxuICpcbiAqIGBgYGpzeFxuICogLy8gU3luY2hyb25vdXMgbG9hZGluZ1xuICogaW1wb3J0IHsgTGF6eU1vdGlvbiwgbSwgZG9tQW5pbWF0aW9uIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgcmV0dXJuIChcbiAqICAgICA8TGF6eU1vdGlvbiBmZWF0dXJlcz17ZG9tQW5pbWF0aW9ufT5cbiAqICAgICAgIDxtLmRpdiBhbmltYXRlPXt7IHNjYWxlOiAyIH19IC8+XG4gKiAgICAgPC9MYXp5TW90aW9uPlxuICogICApXG4gKiB9XG4gKlxuICogLy8gQXN5bmNocm9ub3VzIGxvYWRpbmdcbiAqIGltcG9ydCB7IExhenlNb3Rpb24sIG0gfSBmcm9tIFwiZnJhbWVyLW1vdGlvblwiXG4gKlxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxMYXp5TW90aW9uIGZlYXR1cmVzPXsoKSA9PiBpbXBvcnQoJy4vcGF0aC90by9kb21BbmltYXRpb24nKX0+XG4gKiAgICAgICA8bS5kaXYgYW5pbWF0ZT17eyBzY2FsZTogMiB9fSAvPlxuICogICAgIDwvTGF6eU1vdGlvbj5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBMYXp5TW90aW9uKHsgY2hpbGRyZW4sIGZlYXR1cmVzLCBzdHJpY3QgPSBmYWxzZSB9KSB7XG4gICAgY29uc3QgWywgc2V0SXNMb2FkZWRdID0gUmVhY3QudXNlU3RhdGUoIWlzTGF6eUJ1bmRsZShmZWF0dXJlcykpO1xuICAgIGNvbnN0IGxvYWRlZFJlbmRlcmVyID0gUmVhY3QudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgLyoqXG4gICAgICogSWYgdGhpcyBpcyBhIHN5bmNocm9ub3VzIGxvYWQsIGxvYWQgZmVhdHVyZXMgaW1tZWRpYXRlbHlcbiAgICAgKi9cbiAgICBpZiAoIWlzTGF6eUJ1bmRsZShmZWF0dXJlcykpIHtcbiAgICAgICAgY29uc3QgeyByZW5kZXJlciwgLi4ubG9hZGVkRmVhdHVyZXMgfSA9IGZlYXR1cmVzO1xuICAgICAgICBsb2FkZWRSZW5kZXJlci5jdXJyZW50ID0gcmVuZGVyZXI7XG4gICAgICAgIGxvYWRGZWF0dXJlcyhsb2FkZWRGZWF0dXJlcyk7XG4gICAgfVxuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc0xhenlCdW5kbGUoZmVhdHVyZXMpKSB7XG4gICAgICAgICAgICBmZWF0dXJlcygpLnRoZW4oKHsgcmVuZGVyZXIsIC4uLmxvYWRlZEZlYXR1cmVzIH0pID0+IHtcbiAgICAgICAgICAgICAgICBsb2FkRmVhdHVyZXMobG9hZGVkRmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQgPSByZW5kZXJlcjtcbiAgICAgICAgICAgICAgICBzZXRJc0xvYWRlZCh0cnVlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSwgW10pO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goTGF6eUNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IHsgcmVuZGVyZXI6IGxvYWRlZFJlbmRlcmVyLmN1cnJlbnQsIHN0cmljdCB9LCBjaGlsZHJlbjogY2hpbGRyZW4gfSkpO1xufVxuZnVuY3Rpb24gaXNMYXp5QnVuZGxlKGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBmZWF0dXJlcyA9PT0gXCJmdW5jdGlvblwiO1xufVxuXG4vKipcbiAqIGBNb3Rpb25Db25maWdgIGlzIHVzZWQgdG8gc2V0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgYWxsIGNoaWxkcmVuIGBtb3Rpb25gIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQgeyBtb3Rpb24sIE1vdGlvbkNvbmZpZyB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBleHBvcnQgZnVuY3Rpb24gQXBwKCkge1xuICogICByZXR1cm4gKFxuICogICAgIDxNb3Rpb25Db25maWcgdHJhbnNpdGlvbj17eyB0eXBlOiBcInNwcmluZ1wiIH19PlxuICogICAgICAgPG1vdGlvbi5kaXYgYW5pbWF0ZT17eyB4OiAxMDAgfX0gLz5cbiAqICAgICA8L01vdGlvbkNvbmZpZz5cbiAqICAgKVxuICogfVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBNb3Rpb25Db25maWcoeyBjaGlsZHJlbiwgaXNWYWxpZFByb3AsIC4uLmNvbmZpZyB9KSB7XG4gICAgaXNWYWxpZFByb3AgJiYgbG9hZEV4dGVybmFsSXNWYWxpZFByb3AoaXNWYWxpZFByb3ApO1xuICAgIC8qKlxuICAgICAqIEluaGVyaXQgcHJvcHMgZnJvbSBhbnkgcGFyZW50IE1vdGlvbkNvbmZpZyBjb21wb25lbnRzXG4gICAgICovXG4gICAgY29uZmlnID0geyAuLi5SZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLCAuLi5jb25maWcgfTtcbiAgICAvKipcbiAgICAgKiBEb24ndCBhbGxvdyBpc1N0YXRpYyB0byBjaGFuZ2UgYmV0d2VlbiByZW5kZXJzIGFzIGl0IGFmZmVjdHMgaG93IG1hbnkgaG9va3NcbiAgICAgKiBtb3Rpb24gY29tcG9uZW50cyBmaXJlLlxuICAgICAqL1xuICAgIGNvbmZpZy5pc1N0YXRpYyA9IHVzZUNvbnN0YW50KCgpID0+IGNvbmZpZy5pc1N0YXRpYyk7XG4gICAgLyoqXG4gICAgICogQ3JlYXRpbmcgYSBuZXcgY29uZmlnIGNvbnRleHQgb2JqZWN0IHdpbGwgcmUtcmVuZGVyIGV2ZXJ5IGBtb3Rpb25gIGNvbXBvbmVudFxuICAgICAqIGV2ZXJ5IHRpbWUgaXQgcmVuZGVycy4gU28gd2Ugb25seSB3YW50IHRvIGNyZWF0ZSBhIG5ldyBvbmUgc3BhcmluZ2x5LlxuICAgICAqL1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VNZW1vKCgpID0+IGNvbmZpZywgW1xuICAgICAgICBKU09OLnN0cmluZ2lmeShjb25maWcudHJhbnNpdGlvbiksXG4gICAgICAgIGNvbmZpZy50cmFuc2Zvcm1QYWdlUG9pbnQsXG4gICAgICAgIGNvbmZpZy5yZWR1Y2VkTW90aW9uLFxuICAgIF0pO1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goTW90aW9uQ29uZmlnQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn1cblxuY29uc3QgUmVvcmRlckNvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuXG5mdW5jdGlvbiBjcmVhdGVET01Nb3Rpb25Db21wb25lbnRQcm94eShjb21wb25lbnRGYWN0b3J5KSB7XG4gICAgaWYgKHR5cGVvZiBQcm94eSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSBjYWNoZSBvZiBnZW5lcmF0ZWQgYG1vdGlvbmAgY29tcG9uZW50cywgZS5nIGBtb3Rpb24uZGl2YCwgYG1vdGlvbi5pbnB1dGAgZXRjLlxuICAgICAqIFJhdGhlciB0aGFuIGdlbmVyYXRpbmcgdGhlbSBhbmV3IGV2ZXJ5IHJlbmRlci5cbiAgICAgKi9cbiAgICBjb25zdCBjb21wb25lbnRDYWNoZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZXByZWNhdGVkRmFjdG9yeUZ1bmN0aW9uID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAgICAgICAgICAgd2Fybk9uY2UoZmFsc2UsIFwibW90aW9uKCkgaXMgZGVwcmVjYXRlZC4gVXNlIG1vdGlvbi5jcmVhdGUoKSBpbnN0ZWFkLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29tcG9uZW50RmFjdG9yeSguLi5hcmdzKTtcbiAgICB9O1xuICAgIHJldHVybiBuZXcgUHJveHkoZGVwcmVjYXRlZEZhY3RvcnlGdW5jdGlvbiwge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gYG1vdGlvbmAgaXMgcmVmZXJlbmNlZCB3aXRoIGEgcHJvcDogYG1vdGlvbi5kaXZgLCBgbW90aW9uLmlucHV0YCBldGMuXG4gICAgICAgICAqIFRoZSBwcm9wIG5hbWUgaXMgcGFzc2VkIHRocm91Z2ggYXMgYGtleWAgYW5kIHdlIGNhbiB1c2UgdGhhdCB0byBnZW5lcmF0ZSBhIGBtb3Rpb25gXG4gICAgICAgICAqIERPTSBjb21wb25lbnQgd2l0aCB0aGF0IG5hbWUuXG4gICAgICAgICAqL1xuICAgICAgICBnZXQ6IChfdGFyZ2V0LCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmIChrZXkgPT09IFwiY3JlYXRlXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudEZhY3Rvcnk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoaXMgZWxlbWVudCBkb2Vzbid0IGV4aXN0IGluIHRoZSBjb21wb25lbnQgY2FjaGUsIGNyZWF0ZSBpdCBhbmQgY2FjaGUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmICghY29tcG9uZW50Q2FjaGUuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRDYWNoZS5zZXQoa2V5LCBjb21wb25lbnRGYWN0b3J5KGtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudENhY2hlLmdldChrZXkpO1xuICAgICAgICB9LFxuICAgIH0pO1xufVxuXG4vKipcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQYW5TZXNzaW9uIHtcbiAgICBjb25zdHJ1Y3RvcihldmVudCwgaGFuZGxlcnMsIHsgdHJhbnNmb3JtUGFnZVBvaW50LCBjb250ZXh0V2luZG93LCBkcmFnU25hcFRvT3JpZ2luID0gZmFsc2UsIH0gPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnN0YXJ0RXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnQgPSBudWxsO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpbnRlcm5hbFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGludGVybmFsXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSB3aW5kb3c7XG4gICAgICAgIHRoaXMudXBkYXRlUG9pbnQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgaW5mbyA9IGdldFBhbkluZm8odGhpcy5sYXN0TW92ZUV2ZW50SW5mbywgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGNvbnN0IGlzUGFuU3RhcnRlZCA9IHRoaXMuc3RhcnRFdmVudCAhPT0gbnVsbDtcbiAgICAgICAgICAgIC8vIE9ubHkgc3RhcnQgcGFubmluZyBpZiB0aGUgb2Zmc2V0IGlzIGxhcmdlciB0aGFuIDMgcGl4ZWxzLiBJZiB3ZSBtYWtlIGl0XG4gICAgICAgICAgICAvLyBhbnkgbGFyZ2VyIHRoYW4gdGhpcyB3ZSdsbCB3YW50IHRvIHJlc2V0IHRoZSBwb2ludGVyIGhpc3RvcnlcbiAgICAgICAgICAgIC8vIG9uIHRoZSBmaXJzdCB1cGRhdGUgdG8gYXZvaWQgdmlzdWFsIHNuYXBwaW5nIHRvIHRoZSBjdXJzb2UuXG4gICAgICAgICAgICBjb25zdCBpc0Rpc3RhbmNlUGFzdFRocmVzaG9sZCA9IGRpc3RhbmNlMkQoaW5mby5vZmZzZXQsIHsgeDogMCwgeTogMCB9KSA+PSAzO1xuICAgICAgICAgICAgaWYgKCFpc1BhblN0YXJ0ZWQgJiYgIWlzRGlzdGFuY2VQYXN0VGhyZXNob2xkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgcG9pbnQgfSA9IGluZm87XG4gICAgICAgICAgICBjb25zdCB7IHRpbWVzdGFtcCB9ID0gZnJhbWVEYXRhO1xuICAgICAgICAgICAgdGhpcy5oaXN0b3J5LnB1c2goeyAuLi5wb2ludCwgdGltZXN0YW1wIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBvblN0YXJ0LCBvbk1vdmUgfSA9IHRoaXMuaGFuZGxlcnM7XG4gICAgICAgICAgICBpZiAoIWlzUGFuU3RhcnRlZCkge1xuICAgICAgICAgICAgICAgIG9uU3RhcnQgJiYgb25TdGFydCh0aGlzLmxhc3RNb3ZlRXZlbnQsIGluZm8pO1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRFdmVudCA9IHRoaXMubGFzdE1vdmVFdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG9uTW92ZSAmJiBvbk1vdmUodGhpcy5sYXN0TW92ZUV2ZW50LCBpbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5oYW5kbGVQb2ludGVyTW92ZSA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5sYXN0TW92ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgICAgICB0aGlzLmxhc3RNb3ZlRXZlbnRJbmZvID0gdHJhbnNmb3JtUG9pbnQoaW5mbywgdGhpcy50cmFuc2Zvcm1QYWdlUG9pbnQpO1xuICAgICAgICAgICAgLy8gVGhyb3R0bGUgbW91c2UgbW92ZSBldmVudCB0byBvbmNlIHBlciBmcmFtZVxuICAgICAgICAgICAgZnJhbWUudXBkYXRlKHRoaXMudXBkYXRlUG9pbnQsIHRydWUpO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhhbmRsZVBvaW50ZXJVcCA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbmQoKTtcbiAgICAgICAgICAgIGNvbnN0IHsgb25FbmQsIG9uU2Vzc2lvbkVuZCwgcmVzdW1lQW5pbWF0aW9uIH0gPSB0aGlzLmhhbmRsZXJzO1xuICAgICAgICAgICAgaWYgKHRoaXMuZHJhZ1NuYXBUb09yaWdpbilcbiAgICAgICAgICAgICAgICByZXN1bWVBbmltYXRpb24gJiYgcmVzdW1lQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoISh0aGlzLmxhc3RNb3ZlRXZlbnQgJiYgdGhpcy5sYXN0TW92ZUV2ZW50SW5mbykpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcGFuSW5mbyA9IGdldFBhbkluZm8oZXZlbnQudHlwZSA9PT0gXCJwb2ludGVyY2FuY2VsXCJcbiAgICAgICAgICAgICAgICA/IHRoaXMubGFzdE1vdmVFdmVudEluZm9cbiAgICAgICAgICAgICAgICA6IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KSwgdGhpcy5oaXN0b3J5KTtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXJ0RXZlbnQgJiYgb25FbmQpIHtcbiAgICAgICAgICAgICAgICBvbkVuZChldmVudCwgcGFuSW5mbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvblNlc3Npb25FbmQgJiYgb25TZXNzaW9uRW5kKGV2ZW50LCBwYW5JbmZvKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgd2UgaGF2ZSBtb3JlIHRoYW4gb25lIHRvdWNoLCBkb24ndCBzdGFydCBkZXRlY3RpbmcgdGhpcyBnZXN0dXJlXG4gICAgICAgIGlmICghbW90aW9uRG9tLmlzUHJpbWFyeVBvaW50ZXIoZXZlbnQpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLmRyYWdTbmFwVG9PcmlnaW4gPSBkcmFnU25hcFRvT3JpZ2luO1xuICAgICAgICB0aGlzLmhhbmRsZXJzID0gaGFuZGxlcnM7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50ID0gdHJhbnNmb3JtUGFnZVBvaW50O1xuICAgICAgICB0aGlzLmNvbnRleHRXaW5kb3cgPSBjb250ZXh0V2luZG93IHx8IHdpbmRvdztcbiAgICAgICAgY29uc3QgaW5mbyA9IGV4dHJhY3RFdmVudEluZm8oZXZlbnQpO1xuICAgICAgICBjb25zdCBpbml0aWFsSW5mbyA9IHRyYW5zZm9ybVBvaW50KGluZm8sIHRoaXMudHJhbnNmb3JtUGFnZVBvaW50KTtcbiAgICAgICAgY29uc3QgeyBwb2ludCB9ID0gaW5pdGlhbEluZm87XG4gICAgICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSBmcmFtZURhdGE7XG4gICAgICAgIHRoaXMuaGlzdG9yeSA9IFt7IC4uLnBvaW50LCB0aW1lc3RhbXAgfV07XG4gICAgICAgIGNvbnN0IHsgb25TZXNzaW9uU3RhcnQgfSA9IGhhbmRsZXJzO1xuICAgICAgICBvblNlc3Npb25TdGFydCAmJlxuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQoZXZlbnQsIGdldFBhbkluZm8oaW5pdGlhbEluZm8sIHRoaXMuaGlzdG9yeSkpO1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVycyA9IHBpcGUoYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVybW92ZVwiLCB0aGlzLmhhbmRsZVBvaW50ZXJNb3ZlKSwgYWRkUG9pbnRlckV2ZW50KHRoaXMuY29udGV4dFdpbmRvdywgXCJwb2ludGVydXBcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApLCBhZGRQb2ludGVyRXZlbnQodGhpcy5jb250ZXh0V2luZG93LCBcInBvaW50ZXJjYW5jZWxcIiwgdGhpcy5oYW5kbGVQb2ludGVyVXApKTtcbiAgICB9XG4gICAgdXBkYXRlSGFuZGxlcnMoaGFuZGxlcnMpIHtcbiAgICAgICAgdGhpcy5oYW5kbGVycyA9IGhhbmRsZXJzO1xuICAgIH1cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzICYmIHRoaXMucmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIGNhbmNlbEZyYW1lKHRoaXMudXBkYXRlUG9pbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybVBvaW50KGluZm8sIHRyYW5zZm9ybVBhZ2VQb2ludCkge1xuICAgIHJldHVybiB0cmFuc2Zvcm1QYWdlUG9pbnQgPyB7IHBvaW50OiB0cmFuc2Zvcm1QYWdlUG9pbnQoaW5mby5wb2ludCkgfSA6IGluZm87XG59XG5mdW5jdGlvbiBzdWJ0cmFjdFBvaW50KGEsIGIpIHtcbiAgICByZXR1cm4geyB4OiBhLnggLSBiLngsIHk6IGEueSAtIGIueSB9O1xufVxuZnVuY3Rpb24gZ2V0UGFuSW5mbyh7IHBvaW50IH0sIGhpc3RvcnkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb2ludCxcbiAgICAgICAgZGVsdGE6IHN1YnRyYWN0UG9pbnQocG9pbnQsIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIG9mZnNldDogc3VidHJhY3RQb2ludChwb2ludCwgc3RhcnREZXZpY2VQb2ludChoaXN0b3J5KSksXG4gICAgICAgIHZlbG9jaXR5OiBnZXRWZWxvY2l0eShoaXN0b3J5LCAwLjEpLFxuICAgIH07XG59XG5mdW5jdGlvbiBzdGFydERldmljZVBvaW50KGhpc3RvcnkpIHtcbiAgICByZXR1cm4gaGlzdG9yeVswXTtcbn1cbmZ1bmN0aW9uIGxhc3REZXZpY2VQb2ludChoaXN0b3J5KSB7XG4gICAgcmV0dXJuIGhpc3RvcnlbaGlzdG9yeS5sZW5ndGggLSAxXTtcbn1cbmZ1bmN0aW9uIGdldFZlbG9jaXR5KGhpc3RvcnksIHRpbWVEZWx0YSkge1xuICAgIGlmIChoaXN0b3J5Lmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIHsgeDogMCwgeTogMCB9O1xuICAgIH1cbiAgICBsZXQgaSA9IGhpc3RvcnkubGVuZ3RoIC0gMTtcbiAgICBsZXQgdGltZXN0YW1wZWRQb2ludCA9IG51bGw7XG4gICAgY29uc3QgbGFzdFBvaW50ID0gbGFzdERldmljZVBvaW50KGhpc3RvcnkpO1xuICAgIHdoaWxlIChpID49IDApIHtcbiAgICAgICAgdGltZXN0YW1wZWRQb2ludCA9IGhpc3RvcnlbaV07XG4gICAgICAgIGlmIChsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXAgPlxuICAgICAgICAgICAgbW90aW9uVXRpbHMuc2Vjb25kc1RvTWlsbGlzZWNvbmRzKHRpbWVEZWx0YSkpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGktLTtcbiAgICB9XG4gICAgaWYgKCF0aW1lc3RhbXBlZFBvaW50KSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgdGltZSA9IG1vdGlvblV0aWxzLm1pbGxpc2Vjb25kc1RvU2Vjb25kcyhsYXN0UG9pbnQudGltZXN0YW1wIC0gdGltZXN0YW1wZWRQb2ludC50aW1lc3RhbXApO1xuICAgIGlmICh0aW1lID09PSAwKSB7XG4gICAgICAgIHJldHVybiB7IHg6IDAsIHk6IDAgfTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudFZlbG9jaXR5ID0ge1xuICAgICAgICB4OiAobGFzdFBvaW50LnggLSB0aW1lc3RhbXBlZFBvaW50LngpIC8gdGltZSxcbiAgICAgICAgeTogKGxhc3RQb2ludC55IC0gdGltZXN0YW1wZWRQb2ludC55KSAvIHRpbWUsXG4gICAgfTtcbiAgICBpZiAoY3VycmVudFZlbG9jaXR5LnggPT09IEluZmluaXR5KSB7XG4gICAgICAgIGN1cnJlbnRWZWxvY2l0eS54ID0gMDtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRWZWxvY2l0eS55ID09PSBJbmZpbml0eSkge1xuICAgICAgICBjdXJyZW50VmVsb2NpdHkueSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50VmVsb2NpdHk7XG59XG5cbmZ1bmN0aW9uIGlzUmVmT2JqZWN0KHJlZikge1xuICAgIHJldHVybiAocmVmICYmXG4gICAgICAgIHR5cGVvZiByZWYgPT09IFwib2JqZWN0XCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlZiwgXCJjdXJyZW50XCIpKTtcbn1cblxuLyoqXG4gKiBBcHBseSBjb25zdHJhaW50cyB0byBhIHBvaW50LiBUaGVzZSBjb25zdHJhaW50cyBhcmUgYm90aCBwaHlzaWNhbCBhbG9uZyBhblxuICogYXhpcywgYW5kIGFuIGVsYXN0aWMgZmFjdG9yIHRoYXQgZGV0ZXJtaW5lcyBob3cgbXVjaCB0byBjb25zdHJhaW4gdGhlIHBvaW50XG4gKiBieSBpZiBpdCBkb2VzIGxpZSBvdXRzaWRlIHRoZSBkZWZpbmVkIHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5Q29uc3RyYWludHMocG9pbnQsIHsgbWluLCBtYXggfSwgZWxhc3RpYykge1xuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiBwb2ludCA8IG1pbikge1xuICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgbWluIHBvaW50IGRlZmluZWQsIGFuZCB0aGlzIGlzIG91dHNpZGUgb2YgdGhhdCwgY29uc3RyYWluXG4gICAgICAgIHBvaW50ID0gZWxhc3RpY1xuICAgICAgICAgICAgPyBtaXhOdW1iZXIkMShtaW4sIHBvaW50LCBlbGFzdGljLm1pbilcbiAgICAgICAgICAgIDogTWF0aC5tYXgocG9pbnQsIG1pbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIHBvaW50ID4gbWF4KSB7XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtYXggcG9pbnQgZGVmaW5lZCwgYW5kIHRoaXMgaXMgb3V0c2lkZSBvZiB0aGF0LCBjb25zdHJhaW5cbiAgICAgICAgcG9pbnQgPSBlbGFzdGljXG4gICAgICAgICAgICA/IG1peE51bWJlciQxKG1heCwgcG9pbnQsIGVsYXN0aWMubWF4KVxuICAgICAgICAgICAgOiBNYXRoLm1pbihwb2ludCwgbWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgY29uc3RyYWludHMgaW4gdGVybXMgb2YgdGhlIHZpZXdwb3J0IHdoZW4gZGVmaW5lZCByZWxhdGl2ZWx5IHRvIHRoZVxuICogbWVhc3VyZWQgYXhpcy4gVGhpcyBpcyBtZWFzdXJlZCBmcm9tIHRoZSBuZWFyZXN0IGVkZ2UsIHNvIGEgbWF4IGNvbnN0cmFpbnQgb2YgMjAwXG4gKiBvbiBhbiBheGlzIHdpdGggYSBtYXggdmFsdWUgb2YgMzAwIHdvdWxkIHJldHVybiBhIGNvbnN0cmFpbnQgb2YgNTAwIC0gYXhpcyBsZW5ndGhcbiAqL1xuZnVuY3Rpb24gY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGF4aXMsIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbWluOiBtaW4gIT09IHVuZGVmaW5lZCA/IGF4aXMubWluICsgbWluIDogdW5kZWZpbmVkLFxuICAgICAgICBtYXg6IG1heCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgICA/IGF4aXMubWF4ICsgbWF4IC0gKGF4aXMubWF4IC0gYXhpcy5taW4pXG4gICAgICAgICAgICA6IHVuZGVmaW5lZCxcbiAgICB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgY29uc3RyYWludHMgaW4gdGVybXMgb2YgdGhlIHZpZXdwb3J0IHdoZW5cbiAqIGRlZmluZWQgcmVsYXRpdmVseSB0byB0aGUgbWVhc3VyZWQgYm91bmRpbmcgYm94LlxuICovXG5mdW5jdGlvbiBjYWxjUmVsYXRpdmVDb25zdHJhaW50cyhsYXlvdXRCb3gsIHsgdG9wLCBsZWZ0LCBib3R0b20sIHJpZ2h0IH0pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBjYWxjUmVsYXRpdmVBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LngsIGxlZnQsIHJpZ2h0KSxcbiAgICAgICAgeTogY2FsY1JlbGF0aXZlQXhpc0NvbnN0cmFpbnRzKGxheW91dEJveC55LCB0b3AsIGJvdHRvbSksXG4gICAgfTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlIHZpZXdwb3J0IGNvbnN0cmFpbnRzIHdoZW4gZGVmaW5lZCBhcyBhbm90aGVyIHZpZXdwb3J0LXJlbGF0aXZlIGF4aXNcbiAqL1xuZnVuY3Rpb24gY2FsY1ZpZXdwb3J0QXhpc0NvbnN0cmFpbnRzKGxheW91dEF4aXMsIGNvbnN0cmFpbnRzQXhpcykge1xuICAgIGxldCBtaW4gPSBjb25zdHJhaW50c0F4aXMubWluIC0gbGF5b3V0QXhpcy5taW47XG4gICAgbGV0IG1heCA9IGNvbnN0cmFpbnRzQXhpcy5tYXggLSBsYXlvdXRBeGlzLm1heDtcbiAgICAvLyBJZiB0aGUgY29uc3RyYWludHMgYXhpcyBpcyBhY3R1YWxseSBzbWFsbGVyIHRoYW4gdGhlIGxheW91dCBheGlzIHRoZW4gd2UgY2FuXG4gICAgLy8gZmxpcCB0aGUgY29uc3RyYWludHNcbiAgICBpZiAoY29uc3RyYWludHNBeGlzLm1heCAtIGNvbnN0cmFpbnRzQXhpcy5taW4gPFxuICAgICAgICBsYXlvdXRBeGlzLm1heCAtIGxheW91dEF4aXMubWluKSB7XG4gICAgICAgIFttaW4sIG1heF0gPSBbbWF4LCBtaW5dO1xuICAgIH1cbiAgICByZXR1cm4geyBtaW4sIG1heCB9O1xufVxuLyoqXG4gKiBDYWxjdWxhdGUgdmlld3BvcnQgY29uc3RyYWludHMgd2hlbiBkZWZpbmVkIGFzIGFub3RoZXIgdmlld3BvcnQtcmVsYXRpdmUgYm94XG4gKi9cbmZ1bmN0aW9uIGNhbGNWaWV3cG9ydENvbnN0cmFpbnRzKGxheW91dEJveCwgY29uc3RyYWludHNCb3gpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB4OiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LngsIGNvbnN0cmFpbnRzQm94LngpLFxuICAgICAgICB5OiBjYWxjVmlld3BvcnRBeGlzQ29uc3RyYWludHMobGF5b3V0Qm94LnksIGNvbnN0cmFpbnRzQm94LnkpLFxuICAgIH07XG59XG4vKipcbiAqIENhbGN1bGF0ZSBhIHRyYW5zZm9ybSBvcmlnaW4gcmVsYXRpdmUgdG8gdGhlIHNvdXJjZSBheGlzLCBiZXR3ZWVuIDAtMSwgdGhhdCByZXN1bHRzXG4gKiBpbiBhbiBhc3RoZXRpY2FsbHkgcGxlYXNpbmcgc2NhbGUvdHJhbnNmb3JtIG5lZWRlZCB0byBwcm9qZWN0IGZyb20gc291cmNlIHRvIHRhcmdldC5cbiAqL1xuZnVuY3Rpb24gY2FsY09yaWdpbihzb3VyY2UsIHRhcmdldCkge1xuICAgIGxldCBvcmlnaW4gPSAwLjU7XG4gICAgY29uc3Qgc291cmNlTGVuZ3RoID0gY2FsY0xlbmd0aChzb3VyY2UpO1xuICAgIGNvbnN0IHRhcmdldExlbmd0aCA9IGNhbGNMZW5ndGgodGFyZ2V0KTtcbiAgICBpZiAodGFyZ2V0TGVuZ3RoID4gc291cmNlTGVuZ3RoKSB7XG4gICAgICAgIG9yaWdpbiA9IG1vdGlvblV0aWxzLnByb2dyZXNzKHRhcmdldC5taW4sIHRhcmdldC5tYXggLSBzb3VyY2VMZW5ndGgsIHNvdXJjZS5taW4pO1xuICAgIH1cbiAgICBlbHNlIGlmIChzb3VyY2VMZW5ndGggPiB0YXJnZXRMZW5ndGgpIHtcbiAgICAgICAgb3JpZ2luID0gbW90aW9uVXRpbHMucHJvZ3Jlc3Moc291cmNlLm1pbiwgc291cmNlLm1heCAtIHRhcmdldExlbmd0aCwgdGFyZ2V0Lm1pbik7XG4gICAgfVxuICAgIHJldHVybiBjbGFtcCgwLCAxLCBvcmlnaW4pO1xufVxuLyoqXG4gKiBSZWJhc2UgdGhlIGNhbGN1bGF0ZWQgdmlld3BvcnQgY29uc3RyYWludHMgcmVsYXRpdmUgdG8gdGhlIGxheW91dC5taW4gcG9pbnQuXG4gKi9cbmZ1bmN0aW9uIHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQsIGNvbnN0cmFpbnRzKSB7XG4gICAgY29uc3QgcmVsYXRpdmVDb25zdHJhaW50cyA9IHt9O1xuICAgIGlmIChjb25zdHJhaW50cy5taW4gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLm1pbiA9IGNvbnN0cmFpbnRzLm1pbiAtIGxheW91dC5taW47XG4gICAgfVxuICAgIGlmIChjb25zdHJhaW50cy5tYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZWxhdGl2ZUNvbnN0cmFpbnRzLm1heCA9IGNvbnN0cmFpbnRzLm1heCAtIGxheW91dC5taW47XG4gICAgfVxuICAgIHJldHVybiByZWxhdGl2ZUNvbnN0cmFpbnRzO1xufVxuY29uc3QgZGVmYXVsdEVsYXN0aWMgPSAwLjM1O1xuLyoqXG4gKiBBY2NlcHRzIGEgZHJhZ0VsYXN0aWMgcHJvcCBhbmQgcmV0dXJucyByZXNvbHZlZCBlbGFzdGljIHZhbHVlcyBmb3IgZWFjaCBheGlzLlxuICovXG5mdW5jdGlvbiByZXNvbHZlRHJhZ0VsYXN0aWMoZHJhZ0VsYXN0aWMgPSBkZWZhdWx0RWxhc3RpYykge1xuICAgIGlmIChkcmFnRWxhc3RpYyA9PT0gZmFsc2UpIHtcbiAgICAgICAgZHJhZ0VsYXN0aWMgPSAwO1xuICAgIH1cbiAgICBlbHNlIGlmIChkcmFnRWxhc3RpYyA9PT0gdHJ1ZSkge1xuICAgICAgICBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB4OiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIFwibGVmdFwiLCBcInJpZ2h0XCIpLFxuICAgICAgICB5OiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIFwidG9wXCIsIFwiYm90dG9tXCIpLFxuICAgIH07XG59XG5mdW5jdGlvbiByZXNvbHZlQXhpc0VsYXN0aWMoZHJhZ0VsYXN0aWMsIG1pbkxhYmVsLCBtYXhMYWJlbCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIG1pbjogcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbWluTGFiZWwpLFxuICAgICAgICBtYXg6IHJlc29sdmVQb2ludEVsYXN0aWMoZHJhZ0VsYXN0aWMsIG1heExhYmVsKSxcbiAgICB9O1xufVxuZnVuY3Rpb24gcmVzb2x2ZVBvaW50RWxhc3RpYyhkcmFnRWxhc3RpYywgbGFiZWwpIHtcbiAgICByZXR1cm4gdHlwZW9mIGRyYWdFbGFzdGljID09PSBcIm51bWJlclwiXG4gICAgICAgID8gZHJhZ0VsYXN0aWNcbiAgICAgICAgOiBkcmFnRWxhc3RpY1tsYWJlbF0gfHwgMDtcbn1cblxuLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL21vdGlvbmRpdmlzaW9uL21vdGlvbi9pc3N1ZXMvMjI3MFxuY29uc3QgZ2V0Q29udGV4dFdpbmRvdyA9ICh7IGN1cnJlbnQgfSkgPT4ge1xuICAgIHJldHVybiBjdXJyZW50ID8gY3VycmVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDogbnVsbDtcbn07XG5cbmNvbnN0IGVsZW1lbnREcmFnQ29udHJvbHMgPSBuZXcgV2Vha01hcCgpO1xuLyoqXG4gKlxuICovXG4vLyBsZXQgbGF0ZXN0UG9pbnRlckV2ZW50OiBQb2ludGVyRXZlbnRcbmNsYXNzIFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMge1xuICAgIGNvbnN0cnVjdG9yKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgdGhpcy5vcmlnaW5Qb2ludCA9IHsgeDogMCwgeTogMCB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlcm1pdHRlZCBib3VuZGFyaWVzIG9mIHRyYXZlbCwgaW4gcGl4ZWxzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cyA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHBlci1heGlzIHJlc29sdmVkIGVsYXN0aWMgdmFsdWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5lbGFzdGljID0gY3JlYXRlQm94KCk7XG4gICAgICAgIHRoaXMudmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgfVxuICAgIHN0YXJ0KG9yaWdpbkV2ZW50LCB7IHNuYXBUb0N1cnNvciA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogRG9uJ3Qgc3RhcnQgZHJhZ2dpbmcgaWYgdGhpcyBjb21wb25lbnQgaXMgZXhpdGluZ1xuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBwcmVzZW5jZUNvbnRleHQgfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByZXNlbmNlQ29udGV4dCAmJiBwcmVzZW5jZUNvbnRleHQuaXNQcmVzZW50ID09PSBmYWxzZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3Qgb25TZXNzaW9uU3RhcnQgPSAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ1NuYXBUb09yaWdpbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgLy8gU3RvcCBvciBwYXVzZSBhbnkgYW5pbWF0aW9ucyBvbiBib3RoIGF4aXMgdmFsdWVzIGltbWVkaWF0ZWx5LiBUaGlzIGFsbG93cyB0aGUgdXNlciB0byB0aHJvdyBhbmQgY2F0Y2hcbiAgICAgICAgICAgIC8vIHRoZSBjb21wb25lbnQuXG4gICAgICAgICAgICBkcmFnU25hcFRvT3JpZ2luID8gdGhpcy5wYXVzZUFuaW1hdGlvbigpIDogdGhpcy5zdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBpZiAoc25hcFRvQ3Vyc29yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zbmFwVG9DdXJzb3IoZXh0cmFjdEV2ZW50SW5mbyhldmVudCkucG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvblN0YXJ0ID0gKGV2ZW50LCBpbmZvKSA9PiB7XG4gICAgICAgICAgICAvLyBBdHRlbXB0IHRvIGdyYWIgdGhlIGdsb2JhbCBkcmFnIGdlc3R1cmUgbG9jayAtIG1heWJlIG1ha2UgdGhpcyBwYXJ0IG9mIFBhblNlc3Npb25cbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZywgZHJhZ1Byb3BhZ2F0aW9uLCBvbkRyYWdTdGFydCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAgICAgaWYgKGRyYWcgJiYgIWRyYWdQcm9wYWdhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wZW5EcmFnTG9jaylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2soKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9wZW5EcmFnTG9jayA9IG1vdGlvbkRvbS5zZXREcmFnTG9jayhkcmFnKTtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBkb24gJ3QgaGF2ZSB0aGUgbG9jaywgZG9uJ3Qgc3RhcnQgZHJhZ2dpbmdcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMub3BlbkRyYWdMb2NrKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmlzRHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgICAgICBpZiAodGhpcy52aXN1YWxFbGVtZW50LnByb2plY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5pc0FuaW1hdGlvbkJsb2NrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnRhcmdldCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVjb3JkIGdlc3R1cmUgb3JpZ2luXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGN1cnJlbnQgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKS5nZXQoKSB8fCAwO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIElmIHRoZSBNb3Rpb25WYWx1ZSBpcyBhIHBlcmNlbnRhZ2UgdmFsdWUgY29udmVydCB0byBweFxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGlmIChwZXJjZW50LnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9qZWN0aW9uICYmIHByb2plY3Rpb24ubGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtZWFzdXJlZEF4aXMgPSBwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobWVhc3VyZWRBeGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gY2FsY0xlbmd0aChtZWFzdXJlZEF4aXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnQgPSBsZW5ndGggKiAocGFyc2VGbG9hdChjdXJyZW50KSAvIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5vcmlnaW5Qb2ludFtheGlzXSA9IGN1cnJlbnQ7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIEZpcmUgb25EcmFnU3RhcnQgZXZlbnRcbiAgICAgICAgICAgIGlmIChvbkRyYWdTdGFydCkge1xuICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gb25EcmFnU3RhcnQoZXZlbnQsIGluZm8pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFkZFZhbHVlVG9XaWxsQ2hhbmdlKHRoaXMudmlzdWFsRWxlbWVudCwgXCJ0cmFuc2Zvcm1cIik7XG4gICAgICAgICAgICBjb25zdCB7IGFuaW1hdGlvblN0YXRlIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgICAgICBhbmltYXRpb25TdGF0ZSAmJiBhbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZURyYWdcIiwgdHJ1ZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uTW92ZSA9IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgLy8gbGF0ZXN0UG9pbnRlckV2ZW50ID0gZXZlbnRcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ1Byb3BhZ2F0aW9uLCBkcmFnRGlyZWN0aW9uTG9jaywgb25EaXJlY3Rpb25Mb2NrLCBvbkRyYWcsIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkaWRuJ3Qgc3VjY2Vzc2Z1bGx5IHJlY2VpdmUgdGhlIGdlc3R1cmUgbG9jaywgZWFybHkgcmV0dXJuLlxuICAgICAgICAgICAgaWYgKCFkcmFnUHJvcGFnYXRpb24gJiYgIXRoaXMub3BlbkRyYWdMb2NrKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IHsgb2Zmc2V0IH0gPSBpbmZvO1xuICAgICAgICAgICAgLy8gQXR0ZW1wdCB0byBkZXRlY3QgZHJhZyBkaXJlY3Rpb24gaWYgZGlyZWN0aW9uTG9jayBpcyB0cnVlXG4gICAgICAgICAgICBpZiAoZHJhZ0RpcmVjdGlvbkxvY2sgJiYgdGhpcy5jdXJyZW50RGlyZWN0aW9uID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50RGlyZWN0aW9uID0gZ2V0Q3VycmVudERpcmVjdGlvbihvZmZzZXQpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3ZlIHN1Y2Nlc3NmdWxseSBzZXQgYSBkaXJlY3Rpb24sIG5vdGlmeSBsaXN0ZW5lclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnREaXJlY3Rpb24gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgb25EaXJlY3Rpb25Mb2NrICYmIG9uRGlyZWN0aW9uTG9jayh0aGlzLmN1cnJlbnREaXJlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBVcGRhdGUgZWFjaCBwb2ludCB3aXRoIHRoZSBsYXRlc3QgcG9zaXRpb25cbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXhpcyhcInhcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlQXhpcyhcInlcIiwgaW5mby5wb2ludCwgb2Zmc2V0KTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWRlYWxseSB3ZSB3b3VsZCBsZWF2ZSB0aGUgcmVuZGVyZXIgdG8gZmlyZSBuYXR1cmFsbHkgYXQgdGhlIGVuZCBvZlxuICAgICAgICAgICAgICogdGhpcyBmcmFtZSBidXQgaWYgdGhlIGVsZW1lbnQgaXMgYWJvdXQgdG8gY2hhbmdlIGxheW91dCBhcyB0aGUgcmVzdWx0XG4gICAgICAgICAgICAgKiBvZiBhIHJlLXJlbmRlciB3ZSB3YW50IHRvIGVuc3VyZSB0aGUgYnJvd3NlciBjYW4gcmVhZCB0aGUgbGF0ZXN0XG4gICAgICAgICAgICAgKiBib3VuZGluZyBib3ggdG8gZW5zdXJlIHRoZSBwb2ludGVyIGFuZCBlbGVtZW50IGRvbid0IGZhbGwgb3V0IG9mIHN5bmMuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhpcyBtdXN0IGZpcmUgYWZ0ZXIgdGhlIHJlbmRlciBjYWxsIGFzIGl0IG1pZ2h0IHRyaWdnZXIgYSBzdGF0ZVxuICAgICAgICAgICAgICogY2hhbmdlIHdoaWNoIGl0c2VsZiBtaWdodCB0cmlnZ2VyIGEgbGF5b3V0IHVwZGF0ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25EcmFnICYmIG9uRHJhZyhldmVudCwgaW5mbyk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uU2Vzc2lvbkVuZCA9IChldmVudCwgaW5mbykgPT4gdGhpcy5zdG9wKGV2ZW50LCBpbmZvKTtcbiAgICAgICAgY29uc3QgcmVzdW1lQW5pbWF0aW9uID0gKCkgPT4gZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldEFuaW1hdGlvblN0YXRlKGF4aXMpID09PSBcInBhdXNlZFwiICYmXG4gICAgICAgICAgICAgICAgKChfYSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBsYXkoKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB7IGRyYWdTbmFwVG9PcmlnaW4gfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgdGhpcy5wYW5TZXNzaW9uID0gbmV3IFBhblNlc3Npb24ob3JpZ2luRXZlbnQsIHtcbiAgICAgICAgICAgIG9uU2Vzc2lvblN0YXJ0LFxuICAgICAgICAgICAgb25TdGFydCxcbiAgICAgICAgICAgIG9uTW92ZSxcbiAgICAgICAgICAgIG9uU2Vzc2lvbkVuZCxcbiAgICAgICAgICAgIHJlc3VtZUFuaW1hdGlvbixcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgdHJhbnNmb3JtUGFnZVBvaW50OiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VHJhbnNmb3JtUGFnZVBvaW50KCksXG4gICAgICAgICAgICBkcmFnU25hcFRvT3JpZ2luLFxuICAgICAgICAgICAgY29udGV4dFdpbmRvdzogZ2V0Q29udGV4dFdpbmRvdyh0aGlzLnZpc3VhbEVsZW1lbnQpLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RvcChldmVudCwgaW5mbykge1xuICAgICAgICBjb25zdCBpc0RyYWdnaW5nID0gdGhpcy5pc0RyYWdnaW5nO1xuICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICBpZiAoIWlzRHJhZ2dpbmcpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHsgdmVsb2NpdHkgfSA9IGluZm87XG4gICAgICAgIHRoaXMuc3RhcnRBbmltYXRpb24odmVsb2NpdHkpO1xuICAgICAgICBjb25zdCB7IG9uRHJhZ0VuZCB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBpZiAob25EcmFnRW5kKSB7XG4gICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IG9uRHJhZ0VuZChldmVudCwgaW5mbykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbmNlbCgpIHtcbiAgICAgICAgdGhpcy5pc0RyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiwgYW5pbWF0aW9uU3RhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgaWYgKHByb2plY3Rpb24pIHtcbiAgICAgICAgICAgIHByb2plY3Rpb24uaXNBbmltYXRpb25CbG9ja2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYW5TZXNzaW9uICYmIHRoaXMucGFuU2Vzc2lvbi5lbmQoKTtcbiAgICAgICAgdGhpcy5wYW5TZXNzaW9uID0gdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCB7IGRyYWdQcm9wYWdhdGlvbiB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBpZiAoIWRyYWdQcm9wYWdhdGlvbiAmJiB0aGlzLm9wZW5EcmFnTG9jaykge1xuICAgICAgICAgICAgdGhpcy5vcGVuRHJhZ0xvY2soKTtcbiAgICAgICAgICAgIHRoaXMub3BlbkRyYWdMb2NrID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBhbmltYXRpb25TdGF0ZSAmJiBhbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZURyYWdcIiwgZmFsc2UpO1xuICAgIH1cbiAgICB1cGRhdGVBeGlzKGF4aXMsIF9wb2ludCwgb2Zmc2V0KSB7XG4gICAgICAgIGNvbnN0IHsgZHJhZyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgICAgIGlmICghb2Zmc2V0IHx8ICFzaG91bGREcmFnKGF4aXMsIGRyYWcsIHRoaXMuY3VycmVudERpcmVjdGlvbikpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICBsZXQgbmV4dCA9IHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKyBvZmZzZXRbYXhpc107XG4gICAgICAgIC8vIEFwcGx5IGNvbnN0cmFpbnRzXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cmFpbnRzICYmIHRoaXMuY29uc3RyYWludHNbYXhpc10pIHtcbiAgICAgICAgICAgIG5leHQgPSBhcHBseUNvbnN0cmFpbnRzKG5leHQsIHRoaXMuY29uc3RyYWludHNbYXhpc10sIHRoaXMuZWxhc3RpY1theGlzXSk7XG4gICAgICAgIH1cbiAgICAgICAgYXhpc1ZhbHVlLnNldChuZXh0KTtcbiAgICB9XG4gICAgcmVzb2x2ZUNvbnN0cmFpbnRzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzLCBkcmFnRWxhc3RpYyB9ID0gdGhpcy5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCBsYXlvdXQgPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbiAmJlxuICAgICAgICAgICAgIXRoaXMudmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLmxheW91dFxuICAgICAgICAgICAgPyB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbi5tZWFzdXJlKGZhbHNlKVxuICAgICAgICAgICAgOiAoX2EgPSB0aGlzLnZpc3VhbEVsZW1lbnQucHJvamVjdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxheW91dDtcbiAgICAgICAgY29uc3QgcHJldkNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cztcbiAgICAgICAgaWYgKGRyYWdDb25zdHJhaW50cyAmJiBpc1JlZk9iamVjdChkcmFnQ29uc3RyYWludHMpKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY29uc3RyYWludHMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gdGhpcy5yZXNvbHZlUmVmQ29uc3RyYWludHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChkcmFnQ29uc3RyYWludHMgJiYgbGF5b3V0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50cyA9IGNhbGNSZWxhdGl2ZUNvbnN0cmFpbnRzKGxheW91dC5sYXlvdXRCb3gsIGRyYWdDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnN0cmFpbnRzID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGFzdGljID0gcmVzb2x2ZURyYWdFbGFzdGljKGRyYWdFbGFzdGljKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIHdlJ3JlIG91dHB1dHRpbmcgdG8gZXh0ZXJuYWwgTW90aW9uVmFsdWVzLCB3ZSB3YW50IHRvIHJlYmFzZSB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgICAgICogZnJvbSB2aWV3cG9ydC1yZWxhdGl2ZSB0byBjb21wb25lbnQtcmVsYXRpdmUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAocHJldkNvbnN0cmFpbnRzICE9PSB0aGlzLmNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgICBsYXlvdXQgJiZcbiAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgJiZcbiAgICAgICAgICAgICF0aGlzLmhhc011dGF0ZWRDb25zdHJhaW50cykge1xuICAgICAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25zdHJhaW50cyAhPT0gZmFsc2UgJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25zdHJhaW50c1theGlzXSA9IHJlYmFzZUF4aXNDb25zdHJhaW50cyhsYXlvdXQubGF5b3V0Qm94W2F4aXNdLCB0aGlzLmNvbnN0cmFpbnRzW2F4aXNdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXNvbHZlUmVmQ29uc3RyYWludHMoKSB7XG4gICAgICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzOiBjb25zdHJhaW50cywgb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGlmICghY29uc3RyYWludHMgfHwgIWlzUmVmT2JqZWN0KGNvbnN0cmFpbnRzKSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgY29uc3RyYWludHNFbGVtZW50ID0gY29uc3RyYWludHMuY3VycmVudDtcbiAgICAgICAgbW90aW9uVXRpbHMuaW52YXJpYW50KGNvbnN0cmFpbnRzRWxlbWVudCAhPT0gbnVsbCwgXCJJZiBgZHJhZ0NvbnN0cmFpbnRzYCBpcyBzZXQgYXMgYSBSZWFjdCByZWYsIHRoYXQgcmVmIG11c3QgYmUgcGFzc2VkIHRvIGFub3RoZXIgY29tcG9uZW50J3MgYHJlZmAgcHJvcC5cIik7XG4gICAgICAgIGNvbnN0IHsgcHJvamVjdGlvbiB9ID0gdGhpcy52aXN1YWxFbGVtZW50O1xuICAgICAgICAvLyBUT0RPXG4gICAgICAgIGlmICghcHJvamVjdGlvbiB8fCAhcHJvamVjdGlvbi5sYXlvdXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzQm94ID0gbWVhc3VyZVBhZ2VCb3goY29uc3RyYWludHNFbGVtZW50LCBwcm9qZWN0aW9uLnJvb3QsIHRoaXMudmlzdWFsRWxlbWVudC5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSk7XG4gICAgICAgIGxldCBtZWFzdXJlZENvbnN0cmFpbnRzID0gY2FsY1ZpZXdwb3J0Q29uc3RyYWludHMocHJvamVjdGlvbi5sYXlvdXQubGF5b3V0Qm94LCBjb25zdHJhaW50c0JveCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSdzIGFuIG9uTWVhc3VyZURyYWdDb25zdHJhaW50cyBsaXN0ZW5lciB3ZSBjYWxsIGl0IGFuZFxuICAgICAgICAgKiBpZiBkaWZmZXJlbnQgY29uc3RyYWludHMgYXJlIHJldHVybmVkLCBzZXQgY29uc3RyYWludHMgdG8gdGhhdFxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKG9uTWVhc3VyZURyYWdDb25zdHJhaW50cykge1xuICAgICAgICAgICAgY29uc3QgdXNlckNvbnN0cmFpbnRzID0gb25NZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKGNvbnZlcnRCb3hUb0JvdW5kaW5nQm94KG1lYXN1cmVkQ29uc3RyYWludHMpKTtcbiAgICAgICAgICAgIHRoaXMuaGFzTXV0YXRlZENvbnN0cmFpbnRzID0gISF1c2VyQ29uc3RyYWludHM7XG4gICAgICAgICAgICBpZiAodXNlckNvbnN0cmFpbnRzKSB7XG4gICAgICAgICAgICAgICAgbWVhc3VyZWRDb25zdHJhaW50cyA9IGNvbnZlcnRCb3VuZGluZ0JveFRvQm94KHVzZXJDb25zdHJhaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lYXN1cmVkQ29uc3RyYWludHM7XG4gICAgfVxuICAgIHN0YXJ0QW5pbWF0aW9uKHZlbG9jaXR5KSB7XG4gICAgICAgIGNvbnN0IHsgZHJhZywgZHJhZ01vbWVudHVtLCBkcmFnRWxhc3RpYywgZHJhZ1RyYW5zaXRpb24sIGRyYWdTbmFwVG9PcmlnaW4sIG9uRHJhZ1RyYW5zaXRpb25FbmQsIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IGNvbnN0cmFpbnRzID0gdGhpcy5jb25zdHJhaW50cyB8fCB7fTtcbiAgICAgICAgY29uc3QgbW9tZW50dW1BbmltYXRpb25zID0gZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCB0aGlzLmN1cnJlbnREaXJlY3Rpb24pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHRyYW5zaXRpb24gPSAoY29uc3RyYWludHMgJiYgY29uc3RyYWludHNbYXhpc10pIHx8IHt9O1xuICAgICAgICAgICAgaWYgKGRyYWdTbmFwVG9PcmlnaW4pXG4gICAgICAgICAgICAgICAgdHJhbnNpdGlvbiA9IHsgbWluOiAwLCBtYXg6IDAgfTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcmRhbXAgdGhlIGJvdW5kYXJ5IHNwcmluZyBpZiBgZHJhZ0VsYXN0aWNgIGlzIGRpc2FibGVkLiBUaGVyZSdzIHN0aWxsIGEgZnJhbWVcbiAgICAgICAgICAgICAqIG9mIHNwcmluZyBhbmltYXRpb25zIHNvIHdlIHNob3VsZCBsb29rIGludG8gYWRkaW5nIGEgZGlzYWJsZSBzcHJpbmcgb3B0aW9uIHRvIGBpbmVydGlhYC5cbiAgICAgICAgICAgICAqIFdlIGNvdWxkIGRvIHNvbWV0aGluZyBoZXJlIHdoZXJlIHdlIGFmZmVjdCB0aGUgYGJvdW5jZVN0aWZmbmVzc2AgYW5kIGBib3VuY2VEYW1waW5nYFxuICAgICAgICAgICAgICogdXNpbmcgdGhlIHZhbHVlIG9mIGBkcmFnRWxhc3RpY2AuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNvbnN0IGJvdW5jZVN0aWZmbmVzcyA9IGRyYWdFbGFzdGljID8gMjAwIDogMTAwMDAwMDtcbiAgICAgICAgICAgIGNvbnN0IGJvdW5jZURhbXBpbmcgPSBkcmFnRWxhc3RpYyA/IDQwIDogMTAwMDAwMDA7XG4gICAgICAgICAgICBjb25zdCBpbmVydGlhID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiaW5lcnRpYVwiLFxuICAgICAgICAgICAgICAgIHZlbG9jaXR5OiBkcmFnTW9tZW50dW0gPyB2ZWxvY2l0eVtheGlzXSA6IDAsXG4gICAgICAgICAgICAgICAgYm91bmNlU3RpZmZuZXNzLFxuICAgICAgICAgICAgICAgIGJvdW5jZURhbXBpbmcsXG4gICAgICAgICAgICAgICAgdGltZUNvbnN0YW50OiA3NTAsXG4gICAgICAgICAgICAgICAgcmVzdERlbHRhOiAxLFxuICAgICAgICAgICAgICAgIHJlc3RTcGVlZDogMTAsXG4gICAgICAgICAgICAgICAgLi4uZHJhZ1RyYW5zaXRpb24sXG4gICAgICAgICAgICAgICAgLi4udHJhbnNpdGlvbixcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYW5pbWF0aW5nIG9uIGFuIGV4dGVybmFsbHktcHJvdmlkZWQgYE1vdGlvblZhbHVlYCB3ZSBjYW4gdXNlIHRoZVxuICAgICAgICAgICAgLy8gY29tcG9uZW50J3MgYW5pbWF0aW9uIGNvbnRyb2xzIHdoaWNoIHdpbGwgaGFuZGxlIGludGVyYWN0aW9ucyB3aXRoIHdoaWxlSG92ZXIgKGV0YyksXG4gICAgICAgICAgICAvLyBvdGhlcndpc2Ugd2UganVzdCBoYXZlIHRvIGFuaW1hdGUgdGhlIGBNb3Rpb25WYWx1ZWAgaXRzZWxmLlxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RhcnRBeGlzVmFsdWVBbmltYXRpb24oYXhpcywgaW5lcnRpYSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBSdW4gYWxsIGFuaW1hdGlvbnMgYW5kIHRoZW4gcmVzb2x2ZSB0aGUgbmV3IGRyYWcgY29uc3RyYWludHMuXG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChtb21lbnR1bUFuaW1hdGlvbnMpLnRoZW4ob25EcmFnVHJhbnNpdGlvbkVuZCk7XG4gICAgfVxuICAgIHN0YXJ0QXhpc1ZhbHVlQW5pbWF0aW9uKGF4aXMsIHRyYW5zaXRpb24pIHtcbiAgICAgICAgY29uc3QgYXhpc1ZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgIGFkZFZhbHVlVG9XaWxsQ2hhbmdlKHRoaXMudmlzdWFsRWxlbWVudCwgYXhpcyk7XG4gICAgICAgIHJldHVybiBheGlzVmFsdWUuc3RhcnQoYW5pbWF0ZU1vdGlvblZhbHVlKGF4aXMsIGF4aXNWYWx1ZSwgMCwgdHJhbnNpdGlvbiwgdGhpcy52aXN1YWxFbGVtZW50LCBmYWxzZSkpO1xuICAgIH1cbiAgICBzdG9wQW5pbWF0aW9uKCkge1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcykuc3RvcCgpKTtcbiAgICB9XG4gICAgcGF1c2VBbmltYXRpb24oKSB7XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7IHZhciBfYTsgcmV0dXJuIChfYSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnBhdXNlKCk7IH0pO1xuICAgIH1cbiAgICBnZXRBbmltYXRpb25TdGF0ZShheGlzKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpLmFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEcmFnIHdvcmtzIGRpZmZlcmVudGx5IGRlcGVuZGluZyBvbiB3aGljaCBwcm9wcyBhcmUgcHJvdmlkZWQuXG4gICAgICpcbiAgICAgKiAtIElmIF9kcmFnWCBhbmQgX2RyYWdZIGFyZSBwcm92aWRlZCwgd2Ugb3V0cHV0IHRoZSBnZXN0dXJlIGRlbHRhIGRpcmVjdGx5IHRvIHRob3NlIG1vdGlvbiB2YWx1ZXMuXG4gICAgICogLSBPdGhlcndpc2UsIHdlIGFwcGx5IHRoZSBkZWx0YSB0byB0aGUgeC95IG1vdGlvbiB2YWx1ZXMuXG4gICAgICovXG4gICAgZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpIHtcbiAgICAgICAgY29uc3QgZHJhZ0tleSA9IGBfZHJhZyR7YXhpcy50b1VwcGVyQ2FzZSgpfWA7XG4gICAgICAgIGNvbnN0IHByb3BzID0gdGhpcy52aXN1YWxFbGVtZW50LmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IGV4dGVybmFsTW90aW9uVmFsdWUgPSBwcm9wc1tkcmFnS2V5XTtcbiAgICAgICAgcmV0dXJuIGV4dGVybmFsTW90aW9uVmFsdWVcbiAgICAgICAgICAgID8gZXh0ZXJuYWxNb3Rpb25WYWx1ZVxuICAgICAgICAgICAgOiB0aGlzLnZpc3VhbEVsZW1lbnQuZ2V0VmFsdWUoYXhpcywgKHByb3BzLmluaXRpYWxcbiAgICAgICAgICAgICAgICA/IHByb3BzLmluaXRpYWxbYXhpc11cbiAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCkgfHwgMCk7XG4gICAgfVxuICAgIHNuYXBUb0N1cnNvcihwb2ludCkge1xuICAgICAgICBlYWNoQXhpcygoYXhpcykgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBkcmFnIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgZHJhZ2dpbmcgdGhpcyBheGlzLCBkbyBhbiBlYXJseSByZXR1cm4uXG4gICAgICAgICAgICBpZiAoIXNob3VsZERyYWcoYXhpcywgZHJhZywgdGhpcy5jdXJyZW50RGlyZWN0aW9uKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgICAgIGNvbnN0IGF4aXNWYWx1ZSA9IHRoaXMuZ2V0QXhpc01vdGlvblZhbHVlKGF4aXMpO1xuICAgICAgICAgICAgaWYgKHByb2plY3Rpb24gJiYgcHJvamVjdGlvbi5sYXlvdXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IG1pbiwgbWF4IH0gPSBwcm9qZWN0aW9uLmxheW91dC5sYXlvdXRCb3hbYXhpc107XG4gICAgICAgICAgICAgICAgYXhpc1ZhbHVlLnNldChwb2ludFtheGlzXSAtIG1peE51bWJlciQxKG1pbiwgbWF4LCAwLjUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZW4gdGhlIHZpZXdwb3J0IHJlc2l6ZXMgd2Ugd2FudCB0byBjaGVjayBpZiB0aGUgbWVhc3VyZWQgY29uc3RyYWludHNcbiAgICAgKiBoYXZlIGNoYW5nZWQgYW5kLCBpZiBzbywgcmVwb3NpdGlvbiB0aGUgZWxlbWVudCB3aXRoaW4gdGhvc2UgbmV3IGNvbnN0cmFpbnRzXG4gICAgICogcmVsYXRpdmUgdG8gd2hlcmUgaXQgd2FzIGJlZm9yZSB0aGUgcmVzaXplLlxuICAgICAqL1xuICAgIHNjYWxlUG9zaXRpb25XaXRoaW5Db25zdHJhaW50cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBkcmFnLCBkcmFnQ29uc3RyYWludHMgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGlmICghaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSB8fCAhcHJvamVjdGlvbiB8fCAhdGhpcy5jb25zdHJhaW50cylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFN0b3AgY3VycmVudCBhbmltYXRpb25zIGFzIHRoZXJlIGNhbiBiZSB2aXN1YWwgZ2xpdGNoaW5nIGlmIHdlIHRyeSB0byBkb1xuICAgICAgICAgKiB0aGlzIG1pZC1hbmltYXRpb25cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkIHRoZSByZWxhdGl2ZSBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZVxuICAgICAgICAgKiBjb25zdHJhaW50cyBib3ggYW5kIHNhdmUgYXMgYSBwcm9ncmVzcyB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IGJveFByb2dyZXNzID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGlmIChheGlzVmFsdWUgJiYgdGhpcy5jb25zdHJhaW50cyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsYXRlc3QgPSBheGlzVmFsdWUuZ2V0KCk7XG4gICAgICAgICAgICAgICAgYm94UHJvZ3Jlc3NbYXhpc10gPSBjYWxjT3JpZ2luKHsgbWluOiBsYXRlc3QsIG1heDogbGF0ZXN0IH0sIHRoaXMuY29uc3RyYWludHNbYXhpc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgbGF5b3V0IG9mIHRoaXMgZWxlbWVudCBhbmQgcmVzb2x2ZSB0aGUgbGF0ZXN0IGRyYWcgY29uc3RyYWludHNcbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHsgdHJhbnNmb3JtVGVtcGxhdGUgfSA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICB0aGlzLnZpc3VhbEVsZW1lbnQuY3VycmVudC5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm1UZW1wbGF0ZVxuICAgICAgICAgICAgPyB0cmFuc2Zvcm1UZW1wbGF0ZSh7fSwgXCJcIilcbiAgICAgICAgICAgIDogXCJub25lXCI7XG4gICAgICAgIHByb2plY3Rpb24ucm9vdCAmJiBwcm9qZWN0aW9uLnJvb3QudXBkYXRlU2Nyb2xsKCk7XG4gICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIHRoaXMucmVzb2x2ZUNvbnN0cmFpbnRzKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgZWFjaCBheGlzLCBjYWxjdWxhdGUgdGhlIGN1cnJlbnQgcHJvZ3Jlc3Mgb2YgdGhlIGxheW91dCBheGlzXG4gICAgICAgICAqIHdpdGhpbiB0aGUgbmV3IGNvbnN0cmFpbnRzLlxuICAgICAgICAgKi9cbiAgICAgICAgZWFjaEF4aXMoKGF4aXMpID0+IHtcbiAgICAgICAgICAgIGlmICghc2hvdWxkRHJhZyhheGlzLCBkcmFnLCBudWxsKSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENhbGN1bGF0ZSBhIG5ldyB0cmFuc2Zvcm0gYmFzZWQgb24gdGhlIHByZXZpb3VzIGJveCBwcm9ncmVzc1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBjb25zdCBheGlzVmFsdWUgPSB0aGlzLmdldEF4aXNNb3Rpb25WYWx1ZShheGlzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbWluLCBtYXggfSA9IHRoaXMuY29uc3RyYWludHNbYXhpc107XG4gICAgICAgICAgICBheGlzVmFsdWUuc2V0KG1peE51bWJlciQxKG1pbiwgbWF4LCBib3hQcm9ncmVzc1theGlzXSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkTGlzdGVuZXJzKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlzdWFsRWxlbWVudC5jdXJyZW50KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBlbGVtZW50RHJhZ0NvbnRyb2xzLnNldCh0aGlzLnZpc3VhbEVsZW1lbnQsIHRoaXMpO1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy52aXN1YWxFbGVtZW50LmN1cnJlbnQ7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBdHRhY2ggYSBwb2ludGVyZG93biBldmVudCBsaXN0ZW5lciBvbiB0aGlzIERPTSBlbGVtZW50IHRvIGluaXRpYXRlIGRyYWcgdHJhY2tpbmcuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wUG9pbnRlckxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KGVsZW1lbnQsIFwicG9pbnRlcmRvd25cIiwgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRyYWcsIGRyYWdMaXN0ZW5lciA9IHRydWUgfSA9IHRoaXMuZ2V0UHJvcHMoKTtcbiAgICAgICAgICAgIGRyYWcgJiYgZHJhZ0xpc3RlbmVyICYmIHRoaXMuc3RhcnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgbWVhc3VyZURyYWdDb25zdHJhaW50cyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZHJhZ0NvbnN0cmFpbnRzIH0gPSB0aGlzLmdldFByb3BzKCk7XG4gICAgICAgICAgICBpZiAoaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSAmJiBkcmFnQ29uc3RyYWludHMuY3VycmVudCkge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uc3RyYWludHMgPSB0aGlzLnJlc29sdmVSZWZDb25zdHJhaW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHRoaXMudmlzdWFsRWxlbWVudDtcbiAgICAgICAgY29uc3Qgc3RvcE1lYXN1cmVMYXlvdXRMaXN0ZW5lciA9IHByb2plY3Rpb24uYWRkRXZlbnRMaXN0ZW5lcihcIm1lYXN1cmVcIiwgbWVhc3VyZURyYWdDb25zdHJhaW50cyk7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uICYmICFwcm9qZWN0aW9uLmxheW91dCkge1xuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290ICYmIHByb2plY3Rpb24ucm9vdC51cGRhdGVTY3JvbGwoKTtcbiAgICAgICAgICAgIHByb2plY3Rpb24udXBkYXRlTGF5b3V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZnJhbWUucmVhZChtZWFzdXJlRHJhZ0NvbnN0cmFpbnRzKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dGFjaCBhIHdpbmRvdyByZXNpemUgbGlzdGVuZXIgdG8gc2NhbGUgdGhlIGRyYWdnYWJsZSB0YXJnZXQgd2l0aGluIGl0cyBkZWZpbmVkXG4gICAgICAgICAqIGNvbnN0cmFpbnRzIGFzIHRoZSB3aW5kb3cgcmVzaXplcy5cbiAgICAgICAgICovXG4gICAgICAgIGNvbnN0IHN0b3BSZXNpemVMaXN0ZW5lciA9IGFkZERvbUV2ZW50KHdpbmRvdywgXCJyZXNpemVcIiwgKCkgPT4gdGhpcy5zY2FsZVBvc2l0aW9uV2l0aGluQ29uc3RyYWludHMoKSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgZWxlbWVudCdzIGxheW91dCBjaGFuZ2VzLCBjYWxjdWxhdGUgdGhlIGRlbHRhIGFuZCBhcHBseSB0aGF0IHRvXG4gICAgICAgICAqIHRoZSBkcmFnIGdlc3R1cmUncyBvcmlnaW4gcG9pbnQuXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdCBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgPSBwcm9qZWN0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXCJkaWRVcGRhdGVcIiwgKCh7IGRlbHRhLCBoYXNMYXlvdXRDaGFuZ2VkIH0pID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcgJiYgaGFzTGF5b3V0Q2hhbmdlZCkge1xuICAgICAgICAgICAgICAgIGVhY2hBeGlzKChheGlzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1vdGlvblZhbHVlID0gdGhpcy5nZXRBeGlzTW90aW9uVmFsdWUoYXhpcyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghbW90aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3JpZ2luUG9pbnRbYXhpc10gKz0gZGVsdGFbYXhpc10udHJhbnNsYXRlO1xuICAgICAgICAgICAgICAgICAgICBtb3Rpb25WYWx1ZS5zZXQobW90aW9uVmFsdWUuZ2V0KCkgKyBkZWx0YVtheGlzXS50cmFuc2xhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMudmlzdWFsRWxlbWVudC5yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgc3RvcFJlc2l6ZUxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wUG9pbnRlckxpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wTWVhc3VyZUxheW91dExpc3RlbmVyKCk7XG4gICAgICAgICAgICBzdG9wTGF5b3V0VXBkYXRlTGlzdGVuZXIgJiYgc3RvcExheW91dFVwZGF0ZUxpc3RlbmVyKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGdldFByb3BzKCkge1xuICAgICAgICBjb25zdCBwcm9wcyA9IHRoaXMudmlzdWFsRWxlbWVudC5nZXRQcm9wcygpO1xuICAgICAgICBjb25zdCB7IGRyYWcgPSBmYWxzZSwgZHJhZ0RpcmVjdGlvbkxvY2sgPSBmYWxzZSwgZHJhZ1Byb3BhZ2F0aW9uID0gZmFsc2UsIGRyYWdDb25zdHJhaW50cyA9IGZhbHNlLCBkcmFnRWxhc3RpYyA9IGRlZmF1bHRFbGFzdGljLCBkcmFnTW9tZW50dW0gPSB0cnVlLCB9ID0gcHJvcHM7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGRyYWcsXG4gICAgICAgICAgICBkcmFnRGlyZWN0aW9uTG9jayxcbiAgICAgICAgICAgIGRyYWdQcm9wYWdhdGlvbixcbiAgICAgICAgICAgIGRyYWdDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGRyYWdFbGFzdGljLFxuICAgICAgICAgICAgZHJhZ01vbWVudHVtLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNob3VsZERyYWcoZGlyZWN0aW9uLCBkcmFnLCBjdXJyZW50RGlyZWN0aW9uKSB7XG4gICAgcmV0dXJuICgoZHJhZyA9PT0gdHJ1ZSB8fCBkcmFnID09PSBkaXJlY3Rpb24pICYmXG4gICAgICAgIChjdXJyZW50RGlyZWN0aW9uID09PSBudWxsIHx8IGN1cnJlbnREaXJlY3Rpb24gPT09IGRpcmVjdGlvbikpO1xufVxuLyoqXG4gKiBCYXNlZCBvbiBhbiB4L3kgb2Zmc2V0IGRldGVybWluZSB0aGUgY3VycmVudCBkcmFnIGRpcmVjdGlvbi4gSWYgYm90aCBheGlzJyBvZmZzZXRzIGFyZSBsb3dlclxuICogdGhhbiB0aGUgcHJvdmlkZWQgdGhyZXNob2xkLCByZXR1cm4gYG51bGxgLlxuICpcbiAqIEBwYXJhbSBvZmZzZXQgLSBUaGUgeC95IG9mZnNldCBmcm9tIG9yaWdpbi5cbiAqIEBwYXJhbSBsb2NrVGhyZXNob2xkIC0gKE9wdGlvbmFsKSAtIHRoZSBtaW5pbXVtIGFic29sdXRlIG9mZnNldCBiZWZvcmUgd2UgY2FuIGRldGVybWluZSBhIGRyYWcgZGlyZWN0aW9uLlxuICovXG5mdW5jdGlvbiBnZXRDdXJyZW50RGlyZWN0aW9uKG9mZnNldCwgbG9ja1RocmVzaG9sZCA9IDEwKSB7XG4gICAgbGV0IGRpcmVjdGlvbiA9IG51bGw7XG4gICAgaWYgKE1hdGguYWJzKG9mZnNldC55KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ5XCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKE1hdGguYWJzKG9mZnNldC54KSA+IGxvY2tUaHJlc2hvbGQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gXCJ4XCI7XG4gICAgfVxuICAgIHJldHVybiBkaXJlY3Rpb247XG59XG5cbmNsYXNzIERyYWdHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3Iobm9kZSkge1xuICAgICAgICBzdXBlcihub2RlKTtcbiAgICAgICAgdGhpcy5yZW1vdmVHcm91cENvbnRyb2xzID0gbW90aW9uVXRpbHMubm9vcDtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMgPSBtb3Rpb25VdGlscy5ub29wO1xuICAgICAgICB0aGlzLmNvbnRyb2xzID0gbmV3IFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHMobm9kZSk7XG4gICAgfVxuICAgIG1vdW50KCkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBiZWVuIHByb3ZpZGVkIGEgRHJhZ0NvbnRyb2xzIGZvciBtYW51YWwgY29udHJvbCBvdmVyIHRoZSBkcmFnIGdlc3R1cmUsXG4gICAgICAgIC8vIHN1YnNjcmliZSB0aGlzIGNvbXBvbmVudCB0byBpdCBvbiBtb3VudC5cbiAgICAgICAgY29uc3QgeyBkcmFnQ29udHJvbHMgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICBpZiAoZHJhZ0NvbnRyb2xzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUdyb3VwQ29udHJvbHMgPSBkcmFnQ29udHJvbHMuc3Vic2NyaWJlKHRoaXMuY29udHJvbHMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXJzID0gdGhpcy5jb250cm9scy5hZGRMaXN0ZW5lcnMoKSB8fCBtb3Rpb25VdGlscy5ub29wO1xuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB0aGlzLnJlbW92ZUdyb3VwQ29udHJvbHMoKTtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcnMoKTtcbiAgICB9XG59XG5cbmNvbnN0IGFzeW5jSGFuZGxlciA9IChoYW5kbGVyKSA9PiAoZXZlbnQsIGluZm8pID0+IHtcbiAgICBpZiAoaGFuZGxlcikge1xuICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IGhhbmRsZXIoZXZlbnQsIGluZm8pKTtcbiAgICB9XG59O1xuY2xhc3MgUGFuR2VzdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLnJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXIgPSBtb3Rpb25VdGlscy5ub29wO1xuICAgIH1cbiAgICBvblBvaW50ZXJEb3duKHBvaW50ZXJEb3duRXZlbnQpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uID0gbmV3IFBhblNlc3Npb24ocG9pbnRlckRvd25FdmVudCwgdGhpcy5jcmVhdGVQYW5IYW5kbGVycygpLCB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1QYWdlUG9pbnQ6IHRoaXMubm9kZS5nZXRUcmFuc2Zvcm1QYWdlUG9pbnQoKSxcbiAgICAgICAgICAgIGNvbnRleHRXaW5kb3c6IGdldENvbnRleHRXaW5kb3codGhpcy5ub2RlKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVBhbkhhbmRsZXJzKCkge1xuICAgICAgICBjb25zdCB7IG9uUGFuU2Vzc2lvblN0YXJ0LCBvblBhblN0YXJ0LCBvblBhbiwgb25QYW5FbmQgfSA9IHRoaXMubm9kZS5nZXRQcm9wcygpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgb25TZXNzaW9uU3RhcnQ6IGFzeW5jSGFuZGxlcihvblBhblNlc3Npb25TdGFydCksXG4gICAgICAgICAgICBvblN0YXJ0OiBhc3luY0hhbmRsZXIob25QYW5TdGFydCksXG4gICAgICAgICAgICBvbk1vdmU6IG9uUGFuLFxuICAgICAgICAgICAgb25FbmQ6IChldmVudCwgaW5mbykgPT4ge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlc3Npb247XG4gICAgICAgICAgICAgICAgaWYgKG9uUGFuRW5kKSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gb25QYW5FbmQoZXZlbnQsIGluZm8pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVQb2ludGVyRG93bkxpc3RlbmVyID0gYWRkUG9pbnRlckV2ZW50KHRoaXMubm9kZS5jdXJyZW50LCBcInBvaW50ZXJkb3duXCIsIChldmVudCkgPT4gdGhpcy5vblBvaW50ZXJEb3duKGV2ZW50KSk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi51cGRhdGVIYW5kbGVycyh0aGlzLmNyZWF0ZVBhbkhhbmRsZXJzKCkpO1xuICAgIH1cbiAgICB1bm1vdW50KCkge1xuICAgICAgICB0aGlzLnJlbW92ZVBvaW50ZXJEb3duTGlzdGVuZXIoKTtcbiAgICAgICAgdGhpcy5zZXNzaW9uICYmIHRoaXMuc2Vzc2lvbi5lbmQoKTtcbiAgICB9XG59XG5cbi8qKlxuICogSW50ZXJuYWwsIGV4cG9ydGVkIG9ubHkgZm9yIHVzYWdlIGluIEZyYW1lclxuICovXG5jb25zdCBTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQgPSBSZWFjdC5jcmVhdGVDb250ZXh0KHt9KTtcblxuY2xhc3MgTWVhc3VyZUxheW91dFdpdGhDb250ZXh0IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgICAvKipcbiAgICAgKiBUaGlzIG9ubHkgbW91bnRzIHByb2plY3Rpb24gbm9kZXMgZm9yIGNvbXBvbmVudHMgdGhhdFxuICAgICAqIG5lZWQgbWVhc3VyaW5nLCB3ZSBtaWdodCB3YW50IHRvIGRvIGl0IGZvciBhbGwgY29tcG9uZW50c1xuICAgICAqIGluIG9yZGVyIHRvIGluY29ycG9yYXRlIHRyYW5zZm9ybXNcbiAgICAgKi9cbiAgICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyB2aXN1YWxFbGVtZW50LCBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXAsIGxheW91dElkIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGFkZFNjYWxlQ29ycmVjdG9yKGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMpO1xuICAgICAgICBpZiAocHJvamVjdGlvbikge1xuICAgICAgICAgICAgaWYgKGxheW91dEdyb3VwLmdyb3VwKVxuICAgICAgICAgICAgICAgIGxheW91dEdyb3VwLmdyb3VwLmFkZChwcm9qZWN0aW9uKTtcbiAgICAgICAgICAgIGlmIChzd2l0Y2hMYXlvdXRHcm91cCAmJiBzd2l0Y2hMYXlvdXRHcm91cC5yZWdpc3RlciAmJiBsYXlvdXRJZCkge1xuICAgICAgICAgICAgICAgIHN3aXRjaExheW91dEdyb3VwLnJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvamVjdGlvbi5yb290LmRpZFVwZGF0ZSgpO1xuICAgICAgICAgICAgcHJvamVjdGlvbi5hZGRFdmVudExpc3RlbmVyKFwiYW5pbWF0aW9uQ29tcGxldGVcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuc2FmZVRvUmVtb3ZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb2plY3Rpb24uc2V0T3B0aW9ucyh7XG4gICAgICAgICAgICAgICAgLi4ucHJvamVjdGlvbi5vcHRpb25zLFxuICAgICAgICAgICAgICAgIG9uRXhpdENvbXBsZXRlOiAoKSA9PiB0aGlzLnNhZmVUb1JlbW92ZSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZ2xvYmFsUHJvamVjdGlvblN0YXRlLmhhc0V2ZXJVcGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUocHJldlByb3BzKSB7XG4gICAgICAgIGNvbnN0IHsgbGF5b3V0RGVwZW5kZW5jeSwgdmlzdWFsRWxlbWVudCwgZHJhZywgaXNQcmVzZW50IH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCBwcm9qZWN0aW9uID0gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uO1xuICAgICAgICBpZiAoIXByb2plY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRPRE86IFdlIHVzZSB0aGlzIGRhdGEgaW4gcmVsZWdhdGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdG9cbiAgICAgICAgICogcHJvbW90ZSBhIHByZXZpb3VzIGVsZW1lbnQuIFRoZXJlJ3Mgbm8gZ3VhcmFudGVlIGl0cyBwcmVzZW5jZSBkYXRhXG4gICAgICAgICAqIHdpbGwgaGF2ZSB1cGRhdGVkIGJ5IHRoaXMgcG9pbnQgLSBpZiBhIGJ1ZyBsaWtlIHRoaXMgYXJpc2VzIGl0IHdpbGxcbiAgICAgICAgICogaGF2ZSB0byBiZSB0aGF0IHdlIG1hcmtGb3JSZWxlZ2F0aW9uIGFuZCB0aGVuIGZpbmQgYSBuZXcgbGVhZCBzb21lIG90aGVyIHdheSxcbiAgICAgICAgICogcGVyaGFwcyBpbiBkaWRVcGRhdGVcbiAgICAgICAgICovXG4gICAgICAgIHByb2plY3Rpb24uaXNQcmVzZW50ID0gaXNQcmVzZW50O1xuICAgICAgICBpZiAoZHJhZyB8fFxuICAgICAgICAgICAgcHJldlByb3BzLmxheW91dERlcGVuZGVuY3kgIT09IGxheW91dERlcGVuZGVuY3kgfHxcbiAgICAgICAgICAgIGxheW91dERlcGVuZGVuY3kgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcHJvamVjdGlvbi53aWxsVXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcmV2UHJvcHMuaXNQcmVzZW50ICE9PSBpc1ByZXNlbnQpIHtcbiAgICAgICAgICAgIGlmIChpc1ByZXNlbnQpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0aW9uLnByb21vdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCFwcm9qZWN0aW9uLnJlbGVnYXRlKCkpIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVyZSdzIGFub3RoZXIgc3RhY2sgbWVtYmVyIHRha2luZyBvdmVyIGZyb20gdGhpcyBvbmUsXG4gICAgICAgICAgICAgICAgICogaXQncyBpbiBjaGFyZ2Ugb2YgdGhlIGV4aXQgYW5pbWF0aW9uIGFuZCB0aGVyZWZvcmUgc2hvdWxkXG4gICAgICAgICAgICAgICAgICogYmUgaW4gY2hhcmdlIG9mIHRoZSBzYWZlIHRvIHJlbW92ZS4gT3RoZXJ3aXNlIHdlIGNhbGwgaXQgaGVyZS5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBmcmFtZS5wb3N0UmVuZGVyKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RhY2sgPSBwcm9qZWN0aW9uLmdldFN0YWNrKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghc3RhY2sgfHwgIXN0YWNrLm1lbWJlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbXBvbmVudERpZFVwZGF0ZSgpIHtcbiAgICAgICAgY29uc3QgeyBwcm9qZWN0aW9uIH0gPSB0aGlzLnByb3BzLnZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnJvb3QuZGlkVXBkYXRlKCk7XG4gICAgICAgICAgICBtaWNyb3Rhc2sucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFwcm9qZWN0aW9uLmN1cnJlbnRBbmltYXRpb24gJiYgcHJvamVjdGlvbi5pc0xlYWQoKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNhZmVUb1JlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgICAgICBjb25zdCB7IHZpc3VhbEVsZW1lbnQsIGxheW91dEdyb3VwLCBzd2l0Y2hMYXlvdXRHcm91cDogcHJvbW90ZUNvbnRleHQsIH0gPSB0aGlzLnByb3BzO1xuICAgICAgICBjb25zdCB7IHByb2plY3Rpb24gfSA9IHZpc3VhbEVsZW1lbnQ7XG4gICAgICAgIGlmIChwcm9qZWN0aW9uKSB7XG4gICAgICAgICAgICBwcm9qZWN0aW9uLnNjaGVkdWxlQ2hlY2tBZnRlclVubW91bnQoKTtcbiAgICAgICAgICAgIGlmIChsYXlvdXRHcm91cCAmJiBsYXlvdXRHcm91cC5ncm91cClcbiAgICAgICAgICAgICAgICBsYXlvdXRHcm91cC5ncm91cC5yZW1vdmUocHJvamVjdGlvbik7XG4gICAgICAgICAgICBpZiAocHJvbW90ZUNvbnRleHQgJiYgcHJvbW90ZUNvbnRleHQuZGVyZWdpc3RlcilcbiAgICAgICAgICAgICAgICBwcm9tb3RlQ29udGV4dC5kZXJlZ2lzdGVyKHByb2plY3Rpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNhZmVUb1JlbW92ZSgpIHtcbiAgICAgICAgY29uc3QgeyBzYWZlVG9SZW1vdmUgfSA9IHRoaXMucHJvcHM7XG4gICAgICAgIHNhZmVUb1JlbW92ZSAmJiBzYWZlVG9SZW1vdmUoKTtcbiAgICB9XG4gICAgcmVuZGVyKCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBNZWFzdXJlTGF5b3V0KHByb3BzKSB7XG4gICAgY29uc3QgW2lzUHJlc2VudCwgc2FmZVRvUmVtb3ZlXSA9IHVzZVByZXNlbmNlKCk7XG4gICAgY29uc3QgbGF5b3V0R3JvdXAgPSBSZWFjdC51c2VDb250ZXh0KExheW91dEdyb3VwQ29udGV4dCk7XG4gICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeChNZWFzdXJlTGF5b3V0V2l0aENvbnRleHQsIHsgLi4ucHJvcHMsIGxheW91dEdyb3VwOiBsYXlvdXRHcm91cCwgc3dpdGNoTGF5b3V0R3JvdXA6IFJlYWN0LnVzZUNvbnRleHQoU3dpdGNoTGF5b3V0R3JvdXBDb250ZXh0KSwgaXNQcmVzZW50OiBpc1ByZXNlbnQsIHNhZmVUb1JlbW92ZTogc2FmZVRvUmVtb3ZlIH0pKTtcbn1cbmNvbnN0IGRlZmF1bHRTY2FsZUNvcnJlY3RvcnMgPSB7XG4gICAgYm9yZGVyUmFkaXVzOiB7XG4gICAgICAgIC4uLmNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgICAgIGFwcGx5VG86IFtcbiAgICAgICAgICAgIFwiYm9yZGVyVG9wTGVmdFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJUb3BSaWdodFJhZGl1c1wiLFxuICAgICAgICAgICAgXCJib3JkZXJCb3R0b21MZWZ0UmFkaXVzXCIsXG4gICAgICAgICAgICBcImJvcmRlckJvdHRvbVJpZ2h0UmFkaXVzXCIsXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICBib3JkZXJUb3BMZWZ0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlclRvcFJpZ2h0UmFkaXVzOiBjb3JyZWN0Qm9yZGVyUmFkaXVzLFxuICAgIGJvcmRlckJvdHRvbUxlZnRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm9yZGVyQm90dG9tUmlnaHRSYWRpdXM6IGNvcnJlY3RCb3JkZXJSYWRpdXMsXG4gICAgYm94U2hhZG93OiBjb3JyZWN0Qm94U2hhZG93LFxufTtcblxuY29uc3QgZHJhZyA9IHtcbiAgICBwYW46IHtcbiAgICAgICAgRmVhdHVyZTogUGFuR2VzdHVyZSxcbiAgICB9LFxuICAgIGRyYWc6IHtcbiAgICAgICAgRmVhdHVyZTogRHJhZ0dlc3R1cmUsXG4gICAgICAgIFByb2plY3Rpb25Ob2RlOiBIVE1MUHJvamVjdGlvbk5vZGUsXG4gICAgICAgIE1lYXN1cmVMYXlvdXQsXG4gICAgfSxcbn07XG5cbmZ1bmN0aW9uIGhhbmRsZUhvdmVyRXZlbnQobm9kZSwgZXZlbnQsIGxpZmVjeWNsZSkge1xuICAgIGNvbnN0IHsgcHJvcHMgfSA9IG5vZGU7XG4gICAgaWYgKG5vZGUuYW5pbWF0aW9uU3RhdGUgJiYgcHJvcHMud2hpbGVIb3Zlcikge1xuICAgICAgICBub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlSG92ZXJcIiwgbGlmZWN5Y2xlID09PSBcIlN0YXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE5hbWUgPSAoXCJvbkhvdmVyXCIgKyBsaWZlY3ljbGUpO1xuICAgIGNvbnN0IGNhbGxiYWNrID0gcHJvcHNbZXZlbnROYW1lXTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiBjYWxsYmFjayhldmVudCwgZXh0cmFjdEV2ZW50SW5mbyhldmVudCkpKTtcbiAgICB9XG59XG5jbGFzcyBIb3Zlckdlc3R1cmUgZXh0ZW5kcyBGZWF0dXJlIHtcbiAgICBtb3VudCgpIHtcbiAgICAgICAgY29uc3QgeyBjdXJyZW50IH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGlmICghY3VycmVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy51bm1vdW50ID0gbW90aW9uRG9tLmhvdmVyKGN1cnJlbnQsIChzdGFydEV2ZW50KSA9PiB7XG4gICAgICAgICAgICBoYW5kbGVIb3ZlckV2ZW50KHRoaXMubm9kZSwgc3RhcnRFdmVudCwgXCJTdGFydFwiKTtcbiAgICAgICAgICAgIHJldHVybiAoZW5kRXZlbnQpID0+IGhhbmRsZUhvdmVyRXZlbnQodGhpcy5ub2RlLCBlbmRFdmVudCwgXCJFbmRcIik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB1bm1vdW50KCkgeyB9XG59XG5cbmNsYXNzIEZvY3VzR2VzdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgfVxuICAgIG9uRm9jdXMoKSB7XG4gICAgICAgIGxldCBpc0ZvY3VzVmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhpcyBlbGVtZW50IGRvZXNuJ3QgbWF0Y2ggZm9jdXMtdmlzaWJsZSB0aGVuIGRvbid0XG4gICAgICAgICAqIGFwcGx5IHdoaWxlSG92ZXIuIEJ1dCwgaWYgbWF0Y2hlcyB0aHJvd3MgdGhhdCBmb2N1cy12aXNpYmxlXG4gICAgICAgICAqIGlzIG5vdCBhIHZhbGlkIHNlbGVjdG9yIHRoZW4gaW4gdGhhdCBicm93c2VyIG91dGxpbmUgc3R5bGVzIHdpbGwgYmUgYXBwbGllZFxuICAgICAgICAgKiB0byB0aGUgZWxlbWVudCBieSBkZWZhdWx0IGFuZCB3ZSB3YW50IHRvIG1hdGNoIHRoYXQgYmVoYXZpb3VyIHdpdGggd2hpbGVGb2N1cy5cbiAgICAgICAgICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpc0ZvY3VzVmlzaWJsZSA9IHRoaXMubm9kZS5jdXJyZW50Lm1hdGNoZXMoXCI6Zm9jdXMtdmlzaWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaXNGb2N1c1Zpc2libGUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghaXNGb2N1c1Zpc2libGUgfHwgIXRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlLnNldEFjdGl2ZShcIndoaWxlRm9jdXNcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuICAgIH1cbiAgICBvbkJsdXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5pc0FjdGl2ZSB8fCAhdGhpcy5ub2RlLmFuaW1hdGlvblN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLm5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVGb2N1c1wiLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICB9XG4gICAgbW91bnQoKSB7XG4gICAgICAgIHRoaXMudW5tb3VudCA9IHBpcGUoYWRkRG9tRXZlbnQodGhpcy5ub2RlLmN1cnJlbnQsIFwiZm9jdXNcIiwgKCkgPT4gdGhpcy5vbkZvY3VzKCkpLCBhZGREb21FdmVudCh0aGlzLm5vZGUuY3VycmVudCwgXCJibHVyXCIsICgpID0+IHRoaXMub25CbHVyKCkpKTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuXG5mdW5jdGlvbiBoYW5kbGVQcmVzc0V2ZW50KG5vZGUsIGV2ZW50LCBsaWZlY3ljbGUpIHtcbiAgICBjb25zdCB7IHByb3BzIH0gPSBub2RlO1xuICAgIGlmIChub2RlLmFuaW1hdGlvblN0YXRlICYmIHByb3BzLndoaWxlVGFwKSB7XG4gICAgICAgIG5vZGUuYW5pbWF0aW9uU3RhdGUuc2V0QWN0aXZlKFwid2hpbGVUYXBcIiwgbGlmZWN5Y2xlID09PSBcIlN0YXJ0XCIpO1xuICAgIH1cbiAgICBjb25zdCBldmVudE5hbWUgPSAoXCJvblRhcFwiICsgKGxpZmVjeWNsZSA9PT0gXCJFbmRcIiA/IFwiXCIgOiBsaWZlY3ljbGUpKTtcbiAgICBjb25zdCBjYWxsYmFjayA9IHByb3BzW2V2ZW50TmFtZV07XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gY2FsbGJhY2soZXZlbnQsIGV4dHJhY3RFdmVudEluZm8oZXZlbnQpKSk7XG4gICAgfVxufVxuY2xhc3MgUHJlc3NHZXN0dXJlIGV4dGVuZHMgRmVhdHVyZSB7XG4gICAgbW91bnQoKSB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudCB9ID0gdGhpcy5ub2RlO1xuICAgICAgICBpZiAoIWN1cnJlbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMudW5tb3VudCA9IG1vdGlvbkRvbS5wcmVzcyhjdXJyZW50LCAoc3RhcnRFdmVudCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlUHJlc3NFdmVudCh0aGlzLm5vZGUsIHN0YXJ0RXZlbnQsIFwiU3RhcnRcIik7XG4gICAgICAgICAgICByZXR1cm4gKGVuZEV2ZW50LCB7IHN1Y2Nlc3MgfSkgPT4gaGFuZGxlUHJlc3NFdmVudCh0aGlzLm5vZGUsIGVuZEV2ZW50LCBzdWNjZXNzID8gXCJFbmRcIiA6IFwiQ2FuY2VsXCIpO1xuICAgICAgICB9LCB7IHVzZUdsb2JhbFRhcmdldDogdGhpcy5ub2RlLnByb3BzLmdsb2JhbFRhcFRhcmdldCB9KTtcbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuXG4vKipcbiAqIE1hcCBhbiBJbnRlcnNlY3Rpb25IYW5kbGVyIGNhbGxiYWNrIHRvIGFuIGVsZW1lbnQuIFdlIG9ubHkgZXZlciBtYWtlIG9uZSBoYW5kbGVyIGZvciBvbmVcbiAqIGVsZW1lbnQsIHNvIGV2ZW4gdGhvdWdoIHRoZXNlIGhhbmRsZXJzIG1pZ2h0IGFsbCBiZSB0cmlnZ2VyZWQgYnkgZGlmZmVyZW50XG4gKiBvYnNlcnZlcnMsIHdlIGNhbiBrZWVwIHRoZW0gaW4gdGhlIHNhbWUgbWFwLlxuICovXG5jb25zdCBvYnNlcnZlckNhbGxiYWNrcyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcbiAqIE11bHRpcGxlIG9ic2VydmVycyBjYW4gYmUgY3JlYXRlZCBmb3IgbXVsdGlwbGUgZWxlbWVudC9kb2N1bWVudCByb290cy4gRWFjaCB3aXRoXG4gKiBkaWZmZXJlbnQgc2V0dGluZ3MuIFNvIGhlcmUgd2Ugc3RvcmUgZGljdGlvbmFyaWVzIG9mIG9ic2VydmVycyB0byBlYWNoIHJvb3QsXG4gKiB1c2luZyBzZXJpYWxpc2VkIHNldHRpbmdzICh0aHJlc2hvbGQvbWFyZ2luKSBhcyBsb29rdXAga2V5cy5cbiAqL1xuY29uc3Qgb2JzZXJ2ZXJzID0gbmV3IFdlYWtNYXAoKTtcbmNvbnN0IGZpcmVPYnNlcnZlckNhbGxiYWNrID0gKGVudHJ5KSA9PiB7XG4gICAgY29uc3QgY2FsbGJhY2sgPSBvYnNlcnZlckNhbGxiYWNrcy5nZXQoZW50cnkudGFyZ2V0KTtcbiAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlbnRyeSk7XG59O1xuY29uc3QgZmlyZUFsbE9ic2VydmVyQ2FsbGJhY2tzID0gKGVudHJpZXMpID0+IHtcbiAgICBlbnRyaWVzLmZvckVhY2goZmlyZU9ic2VydmVyQ2FsbGJhY2spO1xufTtcbmZ1bmN0aW9uIGluaXRJbnRlcnNlY3Rpb25PYnNlcnZlcih7IHJvb3QsIC4uLm9wdGlvbnMgfSkge1xuICAgIGNvbnN0IGxvb2t1cFJvb3QgPSByb290IHx8IGRvY3VtZW50O1xuICAgIC8qKlxuICAgICAqIElmIHdlIGRvbid0IGhhdmUgYW4gb2JzZXJ2ZXIgbG9va3VwIG1hcCBmb3IgdGhpcyByb290LCBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghb2JzZXJ2ZXJzLmhhcyhsb29rdXBSb290KSkge1xuICAgICAgICBvYnNlcnZlcnMuc2V0KGxvb2t1cFJvb3QsIHt9KTtcbiAgICB9XG4gICAgY29uc3Qgcm9vdE9ic2VydmVycyA9IG9ic2VydmVycy5nZXQobG9va3VwUm9vdCk7XG4gICAgY29uc3Qga2V5ID0gSlNPTi5zdHJpbmdpZnkob3B0aW9ucyk7XG4gICAgLyoqXG4gICAgICogSWYgd2UgZG9uJ3QgaGF2ZSBhbiBvYnNlcnZlciBmb3IgdGhpcyBjb21iaW5hdGlvbiBvZiByb290IGFuZCBzZXR0aW5ncyxcbiAgICAgKiBjcmVhdGUgb25lLlxuICAgICAqL1xuICAgIGlmICghcm9vdE9ic2VydmVyc1trZXldKSB7XG4gICAgICAgIHJvb3RPYnNlcnZlcnNba2V5XSA9IG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihmaXJlQWxsT2JzZXJ2ZXJDYWxsYmFja3MsIHsgcm9vdCwgLi4ub3B0aW9ucyB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJvb3RPYnNlcnZlcnNba2V5XTtcbn1cbmZ1bmN0aW9uIG9ic2VydmVJbnRlcnNlY3Rpb24oZWxlbWVudCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBjb25zdCByb290SW50ZXJlc2VjdGlvbk9ic2VydmVyID0gaW5pdEludGVyc2VjdGlvbk9ic2VydmVyKG9wdGlvbnMpO1xuICAgIG9ic2VydmVyQ2FsbGJhY2tzLnNldChlbGVtZW50LCBjYWxsYmFjayk7XG4gICAgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlci5vYnNlcnZlKGVsZW1lbnQpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIG9ic2VydmVyQ2FsbGJhY2tzLmRlbGV0ZShlbGVtZW50KTtcbiAgICAgICAgcm9vdEludGVyZXNlY3Rpb25PYnNlcnZlci51bm9ic2VydmUoZWxlbWVudCk7XG4gICAgfTtcbn1cblxuY29uc3QgdGhyZXNob2xkTmFtZXMgPSB7XG4gICAgc29tZTogMCxcbiAgICBhbGw6IDEsXG59O1xuY2xhc3MgSW5WaWV3RmVhdHVyZSBleHRlbmRzIEZlYXR1cmUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmhhc0VudGVyZWRWaWV3ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNJblZpZXcgPSBmYWxzZTtcbiAgICB9XG4gICAgc3RhcnRPYnNlcnZlcigpIHtcbiAgICAgICAgdGhpcy51bm1vdW50KCk7XG4gICAgICAgIGNvbnN0IHsgdmlld3BvcnQgPSB7fSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgIGNvbnN0IHsgcm9vdCwgbWFyZ2luOiByb290TWFyZ2luLCBhbW91bnQgPSBcInNvbWVcIiwgb25jZSB9ID0gdmlld3BvcnQ7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICByb290OiByb290ID8gcm9vdC5jdXJyZW50IDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcm9vdE1hcmdpbixcbiAgICAgICAgICAgIHRocmVzaG9sZDogdHlwZW9mIGFtb3VudCA9PT0gXCJudW1iZXJcIiA/IGFtb3VudCA6IHRocmVzaG9sZE5hbWVzW2Ftb3VudF0sXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uSW50ZXJzZWN0aW9uVXBkYXRlID0gKGVudHJ5KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGlzSW50ZXJzZWN0aW5nIH0gPSBlbnRyeTtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSWYgdGhlcmUncyBiZWVuIG5vIGNoYW5nZSBpbiB0aGUgdmlld3BvcnQgc3RhdGUsIGVhcmx5IHJldHVybi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNJblZpZXcgPT09IGlzSW50ZXJzZWN0aW5nKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuaXNJblZpZXcgPSBpc0ludGVyc2VjdGluZztcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSGFuZGxlIGhhc0VudGVyZWRWaWV3LiBJZiB0aGlzIGlzIG9ubHkgbWVhbnQgdG8gcnVuIG9uY2UsIGFuZFxuICAgICAgICAgICAgICogZWxlbWVudCBpc24ndCB2aXNpYmxlLCBlYXJseSByZXR1cm4uIE90aGVyd2lzZSBzZXQgaGFzRW50ZXJlZFZpZXcgdG8gdHJ1ZS5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKG9uY2UgJiYgIWlzSW50ZXJzZWN0aW5nICYmIHRoaXMuaGFzRW50ZXJlZFZpZXcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc0ludGVyc2VjdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFzRW50ZXJlZFZpZXcgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9kZS5hbmltYXRpb25TdGF0ZS5zZXRBY3RpdmUoXCJ3aGlsZUluVmlld1wiLCBpc0ludGVyc2VjdGluZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFVzZSB0aGUgbGF0ZXN0IGNvbW1pdHRlZCBwcm9wcyByYXRoZXIgdGhhbiB0aGUgb25lcyBpbiBzY29wZVxuICAgICAgICAgICAgICogd2hlbiB0aGlzIG9ic2VydmVyIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29uc3QgeyBvblZpZXdwb3J0RW50ZXIsIG9uVmlld3BvcnRMZWF2ZSB9ID0gdGhpcy5ub2RlLmdldFByb3BzKCk7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IGlzSW50ZXJzZWN0aW5nID8gb25WaWV3cG9ydEVudGVyIDogb25WaWV3cG9ydExlYXZlO1xuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZW50cnkpO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gb2JzZXJ2ZUludGVyc2VjdGlvbih0aGlzLm5vZGUuY3VycmVudCwgb3B0aW9ucywgb25JbnRlcnNlY3Rpb25VcGRhdGUpO1xuICAgIH1cbiAgICBtb3VudCgpIHtcbiAgICAgICAgdGhpcy5zdGFydE9ic2VydmVyKCk7XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBJbnRlcnNlY3Rpb25PYnNlcnZlciA9PT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgeyBwcm9wcywgcHJldlByb3BzIH0gPSB0aGlzLm5vZGU7XG4gICAgICAgIGNvbnN0IGhhc09wdGlvbnNDaGFuZ2VkID0gW1wiYW1vdW50XCIsIFwibWFyZ2luXCIsIFwicm9vdFwiXS5zb21lKGhhc1ZpZXdwb3J0T3B0aW9uQ2hhbmdlZChwcm9wcywgcHJldlByb3BzKSk7XG4gICAgICAgIGlmIChoYXNPcHRpb25zQ2hhbmdlZCkge1xuICAgICAgICAgICAgdGhpcy5zdGFydE9ic2VydmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdW5tb3VudCgpIHsgfVxufVxuZnVuY3Rpb24gaGFzVmlld3BvcnRPcHRpb25DaGFuZ2VkKHsgdmlld3BvcnQgPSB7fSB9LCB7IHZpZXdwb3J0OiBwcmV2Vmlld3BvcnQgPSB7fSB9ID0ge30pIHtcbiAgICByZXR1cm4gKG5hbWUpID0+IHZpZXdwb3J0W25hbWVdICE9PSBwcmV2Vmlld3BvcnRbbmFtZV07XG59XG5cbmNvbnN0IGdlc3R1cmVBbmltYXRpb25zID0ge1xuICAgIGluVmlldzoge1xuICAgICAgICBGZWF0dXJlOiBJblZpZXdGZWF0dXJlLFxuICAgIH0sXG4gICAgdGFwOiB7XG4gICAgICAgIEZlYXR1cmU6IFByZXNzR2VzdHVyZSxcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICAgIEZlYXR1cmU6IEZvY3VzR2VzdHVyZSxcbiAgICB9LFxuICAgIGhvdmVyOiB7XG4gICAgICAgIEZlYXR1cmU6IEhvdmVyR2VzdHVyZSxcbiAgICB9LFxufTtcblxuY29uc3QgbGF5b3V0ID0ge1xuICAgIGxheW91dDoge1xuICAgICAgICBQcm9qZWN0aW9uTm9kZTogSFRNTFByb2plY3Rpb25Ob2RlLFxuICAgICAgICBNZWFzdXJlTGF5b3V0LFxuICAgIH0sXG59O1xuXG5mdW5jdGlvbiBnZXRDdXJyZW50VHJlZVZhcmlhbnRzKHByb3BzLCBjb250ZXh0KSB7XG4gICAgaWYgKGlzQ29udHJvbGxpbmdWYXJpYW50cyhwcm9wcykpIHtcbiAgICAgICAgY29uc3QgeyBpbml0aWFsLCBhbmltYXRlIH0gPSBwcm9wcztcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluaXRpYWw6IGluaXRpYWwgPT09IGZhbHNlIHx8IGlzVmFyaWFudExhYmVsKGluaXRpYWwpXG4gICAgICAgICAgICAgICAgPyBpbml0aWFsXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBhbmltYXRlOiBpc1ZhcmlhbnRMYWJlbChhbmltYXRlKSA/IGFuaW1hdGUgOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBwcm9wcy5pbmhlcml0ICE9PSBmYWxzZSA/IGNvbnRleHQgOiB7fTtcbn1cblxuZnVuY3Rpb24gdXNlQ3JlYXRlTW90aW9uQ29udGV4dChwcm9wcykge1xuICAgIGNvbnN0IHsgaW5pdGlhbCwgYW5pbWF0ZSB9ID0gZ2V0Q3VycmVudFRyZWVWYXJpYW50cyhwcm9wcywgUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KSk7XG4gICAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gKHsgaW5pdGlhbCwgYW5pbWF0ZSB9KSwgW3ZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koaW5pdGlhbCksIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3koYW5pbWF0ZSldKTtcbn1cbmZ1bmN0aW9uIHZhcmlhbnRMYWJlbHNBc0RlcGVuZGVuY3kocHJvcCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHByb3ApID8gcHJvcC5qb2luKFwiIFwiKSA6IHByb3A7XG59XG5cbmNvbnN0IG1vdGlvbkNvbXBvbmVudFN5bWJvbCA9IFN5bWJvbC5mb3IoXCJtb3Rpb25Db21wb25lbnRTeW1ib2xcIik7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlZiBmdW5jdGlvbiB0aGF0LCB3aGVuIGNhbGxlZCwgaHlkcmF0ZXMgdGhlIHByb3ZpZGVkXG4gKiBleHRlcm5hbCByZWYgYW5kIFZpc3VhbEVsZW1lbnQuXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgdmlzdWFsRWxlbWVudCwgZXh0ZXJuYWxSZWYpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soKGluc3RhbmNlKSA9PiB7XG4gICAgICAgIGlmIChpbnN0YW5jZSkge1xuICAgICAgICAgICAgdmlzdWFsU3RhdGUub25Nb3VudCAmJiB2aXN1YWxTdGF0ZS5vbk1vdW50KGluc3RhbmNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgdmlzdWFsRWxlbWVudC5tb3VudChpbnN0YW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2aXN1YWxFbGVtZW50LnVubW91bnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXh0ZXJuYWxSZWYpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZXh0ZXJuYWxSZWYgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmKGluc3RhbmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzUmVmT2JqZWN0KGV4dGVybmFsUmVmKSkge1xuICAgICAgICAgICAgICAgIGV4dGVybmFsUmVmLmN1cnJlbnQgPSBpbnN0YW5jZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFxuICAgIC8qKlxuICAgICAqIE9ubHkgcGFzcyBhIG5ldyByZWYgY2FsbGJhY2sgdG8gUmVhY3QgaWYgd2UndmUgcmVjZWl2ZWQgYSB2aXN1YWwgZWxlbWVudFxuICAgICAqIGZhY3RvcnkuIE90aGVyd2lzZSB3ZSdsbCBiZSBtb3VudGluZy9yZW1vdW50aW5nIGV2ZXJ5IHRpbWUgZXh0ZXJuYWxSZWZcbiAgICAgKiBvciBvdGhlciBkZXBlbmRlbmNpZXMgY2hhbmdlLlxuICAgICAqL1xuICAgIFt2aXN1YWxFbGVtZW50XSk7XG59XG5cbmZ1bmN0aW9uIHVzZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB2aXN1YWxTdGF0ZSwgcHJvcHMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudDogcGFyZW50IH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbnRleHQpO1xuICAgIGNvbnN0IGxhenlDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChMYXp5Q29udGV4dCk7XG4gICAgY29uc3QgcHJlc2VuY2VDb250ZXh0ID0gUmVhY3QudXNlQ29udGV4dChQcmVzZW5jZUNvbnRleHQpO1xuICAgIGNvbnN0IHJlZHVjZWRNb3Rpb25Db25maWcgPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLnJlZHVjZWRNb3Rpb247XG4gICAgY29uc3QgdmlzdWFsRWxlbWVudFJlZiA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSBoYXZlbid0IHByZWxvYWRlZCBhIHJlbmRlcmVyLCBjaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBvbmUgbGF6eS1sb2FkZWRcbiAgICAgKi9cbiAgICBjcmVhdGVWaXN1YWxFbGVtZW50ID0gY3JlYXRlVmlzdWFsRWxlbWVudCB8fCBsYXp5Q29udGV4dC5yZW5kZXJlcjtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCAmJiBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgICAgIHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCA9IGNyZWF0ZVZpc3VhbEVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICB2aXN1YWxTdGF0ZSxcbiAgICAgICAgICAgIHBhcmVudCxcbiAgICAgICAgICAgIHByb3BzLFxuICAgICAgICAgICAgcHJlc2VuY2VDb250ZXh0LFxuICAgICAgICAgICAgYmxvY2tJbml0aWFsQW5pbWF0aW9uOiBwcmVzZW5jZUNvbnRleHRcbiAgICAgICAgICAgICAgICA/IHByZXNlbmNlQ29udGV4dC5pbml0aWFsID09PSBmYWxzZVxuICAgICAgICAgICAgICAgIDogZmFsc2UsXG4gICAgICAgICAgICByZWR1Y2VkTW90aW9uQ29uZmlnLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgdmlzdWFsRWxlbWVudCA9IHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudDtcbiAgICAvKipcbiAgICAgKiBMb2FkIE1vdGlvbiBnZXN0dXJlIGFuZCBhbmltYXRpb24gZmVhdHVyZXMuIFRoZXNlIGFyZSByZW5kZXJlZCBhcyByZW5kZXJsZXNzXG4gICAgICogY29tcG9uZW50cyBzbyBlYWNoIGZlYXR1cmUgY2FuIG9wdGlvbmFsbHkgbWFrZSB1c2Ugb2YgUmVhY3QgbGlmZWN5Y2xlIG1ldGhvZHMuXG4gICAgICovXG4gICAgY29uc3QgaW5pdGlhbExheW91dEdyb3VwQ29uZmlnID0gUmVhY3QudXNlQ29udGV4dChTd2l0Y2hMYXlvdXRHcm91cENvbnRleHQpO1xuICAgIGlmICh2aXN1YWxFbGVtZW50ICYmXG4gICAgICAgICF2aXN1YWxFbGVtZW50LnByb2plY3Rpb24gJiZcbiAgICAgICAgUHJvamVjdGlvbk5vZGVDb25zdHJ1Y3RvciAmJlxuICAgICAgICAodmlzdWFsRWxlbWVudC50eXBlID09PSBcImh0bWxcIiB8fCB2aXN1YWxFbGVtZW50LnR5cGUgPT09IFwic3ZnXCIpKSB7XG4gICAgICAgIGNyZWF0ZVByb2plY3Rpb25Ob2RlKHZpc3VhbEVsZW1lbnRSZWYuY3VycmVudCwgcHJvcHMsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxMYXlvdXRHcm91cENvbmZpZyk7XG4gICAgfVxuICAgIGNvbnN0IGlzTW91bnRlZCA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgUmVhY3QudXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENoZWNrIHRoZSBjb21wb25lbnQgaGFzIGFscmVhZHkgbW91bnRlZCBiZWZvcmUgY2FsbGluZ1xuICAgICAgICAgKiBgdXBkYXRlYCB1bm5lY2Vzc2FyaWx5LiBUaGlzIGVuc3VyZXMgd2Ugc2tpcCB0aGUgaW5pdGlhbCB1cGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAodmlzdWFsRWxlbWVudCAmJiBpc01vdW50ZWQuY3VycmVudCkge1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC51cGRhdGUocHJvcHMsIHByZXNlbmNlQ29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvKipcbiAgICAgKiBDYWNoZSB0aGlzIHZhbHVlIGFzIHdlIHdhbnQgdG8ga25vdyB3aGV0aGVyIEhhbmRvZmZBcHBlYXJBbmltYXRpb25zXG4gICAgICogd2FzIHByZXNlbnQgb24gaW5pdGlhbCByZW5kZXIgLSBpdCB3aWxsIGJlIGRlbGV0ZWQgYWZ0ZXIgdGhpcy5cbiAgICAgKi9cbiAgICBjb25zdCBvcHRpbWlzZWRBcHBlYXJJZCA9IHByb3BzW29wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGVdO1xuICAgIGNvbnN0IHdhbnRzSGFuZG9mZiA9IFJlYWN0LnVzZVJlZihCb29sZWFuKG9wdGltaXNlZEFwcGVhcklkKSAmJlxuICAgICAgICAhKChfYSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmSXNDb21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBvcHRpbWlzZWRBcHBlYXJJZCkpICYmXG4gICAgICAgICgoX2IgPSB3aW5kb3cuTW90aW9uSGFzT3B0aW1pc2VkQW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbCh3aW5kb3csIG9wdGltaXNlZEFwcGVhcklkKSkpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlzTW91bnRlZC5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgd2luZG93Lk1vdGlvbklzTW91bnRlZCA9IHRydWU7XG4gICAgICAgIHZpc3VhbEVsZW1lbnQudXBkYXRlRmVhdHVyZXMoKTtcbiAgICAgICAgbWljcm90YXNrLnJlbmRlcih2aXN1YWxFbGVtZW50LnJlbmRlcik7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZGVhbGx5IHRoaXMgZnVuY3Rpb24gd291bGQgYWx3YXlzIHJ1biBpbiBhIHVzZUVmZmVjdC5cbiAgICAgICAgICpcbiAgICAgICAgICogSG93ZXZlciwgaWYgd2UgaGF2ZSBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnMgdG8gaGFuZG9mZiBmcm9tLFxuICAgICAgICAgKiBpdCBuZWVkcyB0byBoYXBwZW4gc3luY2hyb25vdXNseSB0byBlbnN1cmUgdGhlcmUncyBubyBmbGFzaCBvZlxuICAgICAgICAgKiBpbmNvcnJlY3Qgc3R5bGVzIGluIHRoZSBldmVudCBvZiBhIGh5ZHJhdGlvbiBlcnJvci5cbiAgICAgICAgICpcbiAgICAgICAgICogU28gaWYgd2UgZGV0ZWN0IGEgc2l0dXRhdGlvbiB3aGVyZSBvcHRpbWlzZWQgYXBwZWFyIGFuaW1hdGlvbnNcbiAgICAgICAgICogYXJlIHJ1bm5pbmcsIHdlIHVzZSB1c2VMYXlvdXRFZmZlY3QgdG8gdHJpZ2dlciBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKHdhbnRzSGFuZG9mZi5jdXJyZW50ICYmIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgIHZpc3VhbEVsZW1lbnQuYW5pbWF0aW9uU3RhdGUuYW5pbWF0ZUNoYW5nZXMoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghdmlzdWFsRWxlbWVudClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF3YW50c0hhbmRvZmYuY3VycmVudCAmJiB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlKSB7XG4gICAgICAgICAgICB2aXN1YWxFbGVtZW50LmFuaW1hdGlvblN0YXRlLmFuaW1hdGVDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhbnRzSGFuZG9mZi5jdXJyZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGVuc3VyZXMgYWxsIGZ1dHVyZSBjYWxscyB0byBhbmltYXRlQ2hhbmdlcygpIGluIHRoaXMgY29tcG9uZW50IHdpbGwgcnVuIGluIHVzZUVmZmVjdFxuICAgICAgICAgICAgcXVldWVNaWNyb3Rhc2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICAoX2EgPSB3aW5kb3cuTW90aW9uSGFuZG9mZk1hcmtBc0NvbXBsZXRlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIG9wdGltaXNlZEFwcGVhcklkKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgd2FudHNIYW5kb2ZmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB2aXN1YWxFbGVtZW50O1xufVxuZnVuY3Rpb24gY3JlYXRlUHJvamVjdGlvbk5vZGUodmlzdWFsRWxlbWVudCwgcHJvcHMsIFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IsIGluaXRpYWxQcm9tb3Rpb25Db25maWcpIHtcbiAgICBjb25zdCB7IGxheW91dElkLCBsYXlvdXQsIGRyYWcsIGRyYWdDb25zdHJhaW50cywgbGF5b3V0U2Nyb2xsLCBsYXlvdXRSb290LCB9ID0gcHJvcHM7XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uID0gbmV3IFByb2plY3Rpb25Ob2RlQ29uc3RydWN0b3IodmlzdWFsRWxlbWVudC5sYXRlc3RWYWx1ZXMsIHByb3BzW1wiZGF0YS1mcmFtZXItcG9ydGFsLWlkXCJdXG4gICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgIDogZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQucGFyZW50KSk7XG4gICAgdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uLnNldE9wdGlvbnMoe1xuICAgICAgICBsYXlvdXRJZCxcbiAgICAgICAgbGF5b3V0LFxuICAgICAgICBhbHdheXNNZWFzdXJlTGF5b3V0OiBCb29sZWFuKGRyYWcpIHx8IChkcmFnQ29uc3RyYWludHMgJiYgaXNSZWZPYmplY3QoZHJhZ0NvbnN0cmFpbnRzKSksXG4gICAgICAgIHZpc3VhbEVsZW1lbnQsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPOiBVcGRhdGUgb3B0aW9ucyBpbiBhbiBlZmZlY3QuIFRoaXMgY291bGQgYmUgdHJpY2t5IGFzIGl0J2xsIGJlIHRvbyBsYXRlXG4gICAgICAgICAqIHRvIHVwZGF0ZSBieSB0aGUgdGltZSBsYXlvdXQgYW5pbWF0aW9ucyBydW4uXG4gICAgICAgICAqIFdlIGFsc28gbmVlZCB0byBmaXggdGhpcyBzYWZlVG9SZW1vdmUgYnkgbGlua2luZyBpdCB1cCB0byB0aGUgb25lIHJldHVybmVkIGJ5IHVzZVByZXNlbmNlLFxuICAgICAgICAgKiBlbnN1cmluZyBpdCBnZXRzIGNhbGxlZCBpZiB0aGVyZSdzIG5vIHBvdGVudGlhbCBsYXlvdXQgYW5pbWF0aW9ucy5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIGFuaW1hdGlvblR5cGU6IHR5cGVvZiBsYXlvdXQgPT09IFwic3RyaW5nXCIgPyBsYXlvdXQgOiBcImJvdGhcIixcbiAgICAgICAgaW5pdGlhbFByb21vdGlvbkNvbmZpZyxcbiAgICAgICAgbGF5b3V0U2Nyb2xsLFxuICAgICAgICBsYXlvdXRSb290LFxuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICBpZiAoIXZpc3VhbEVsZW1lbnQpXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHZpc3VhbEVsZW1lbnQub3B0aW9ucy5hbGxvd1Byb2plY3Rpb24gIT09IGZhbHNlXG4gICAgICAgID8gdmlzdWFsRWxlbWVudC5wcm9qZWN0aW9uXG4gICAgICAgIDogZ2V0Q2xvc2VzdFByb2plY3RpbmdOb2RlKHZpc3VhbEVsZW1lbnQucGFyZW50KTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgbW90aW9uYCBjb21wb25lbnQuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBhY2NlcHRzIGEgQ29tcG9uZW50IGFyZ3VtZW50LCB3aGljaCBjYW4gYmUgZWl0aGVyIGEgc3RyaW5nIChpZSBcImRpdlwiXG4gKiBmb3IgYG1vdGlvbi5kaXZgKSwgb3IgYW4gYWN0dWFsIFJlYWN0IGNvbXBvbmVudC5cbiAqXG4gKiBBbG9uZ3NpZGUgdGhpcyBpcyBhIGNvbmZpZyBvcHRpb24gd2hpY2ggcHJvdmlkZXMgYSB3YXkgb2YgcmVuZGVyaW5nIHRoZSBwcm92aWRlZFxuICogY29tcG9uZW50IFwib2ZmbGluZVwiLCBvciBvdXRzaWRlIHRoZSBSZWFjdCByZW5kZXIgY3ljbGUuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50KHsgcHJlbG9hZGVkRmVhdHVyZXMsIGNyZWF0ZVZpc3VhbEVsZW1lbnQsIHVzZVJlbmRlciwgdXNlVmlzdWFsU3RhdGUsIENvbXBvbmVudCwgfSkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgcHJlbG9hZGVkRmVhdHVyZXMgJiYgbG9hZEZlYXR1cmVzKHByZWxvYWRlZEZlYXR1cmVzKTtcbiAgICBmdW5jdGlvbiBNb3Rpb25Db21wb25lbnQocHJvcHMsIGV4dGVybmFsUmVmKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB3ZSBuZWVkIHRvIG1lYXN1cmUgdGhlIGVsZW1lbnQgd2UgbG9hZCB0aGlzIGZ1bmN0aW9uYWxpdHkgaW4gYVxuICAgICAgICAgKiBzZXBhcmF0ZSBjbGFzcyBjb21wb25lbnQgaW4gb3JkZXIgdG8gZ2FpbiBhY2Nlc3MgdG8gZ2V0U25hcHNob3RCZWZvcmVVcGRhdGUuXG4gICAgICAgICAqL1xuICAgICAgICBsZXQgTWVhc3VyZUxheW91dDtcbiAgICAgICAgY29uc3QgY29uZmlnQW5kUHJvcHMgPSB7XG4gICAgICAgICAgICAuLi5SZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpLFxuICAgICAgICAgICAgLi4ucHJvcHMsXG4gICAgICAgICAgICBsYXlvdXRJZDogdXNlTGF5b3V0SWQocHJvcHMpLFxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBjb25maWdBbmRQcm9wcztcbiAgICAgICAgY29uc3QgY29udGV4dCA9IHVzZUNyZWF0ZU1vdGlvbkNvbnRleHQocHJvcHMpO1xuICAgICAgICBjb25zdCB2aXN1YWxTdGF0ZSA9IHVzZVZpc3VhbFN0YXRlKHByb3BzLCBpc1N0YXRpYyk7XG4gICAgICAgIGlmICghaXNTdGF0aWMgJiYgaXNCcm93c2VyKSB7XG4gICAgICAgICAgICB1c2VTdHJpY3RNb2RlKGNvbmZpZ0FuZFByb3BzLCBwcmVsb2FkZWRGZWF0dXJlcyk7XG4gICAgICAgICAgICBjb25zdCBsYXlvdXRQcm9qZWN0aW9uID0gZ2V0UHJvamVjdGlvbkZ1bmN0aW9uYWxpdHkoY29uZmlnQW5kUHJvcHMpO1xuICAgICAgICAgICAgTWVhc3VyZUxheW91dCA9IGxheW91dFByb2plY3Rpb24uTWVhc3VyZUxheW91dDtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgVmlzdWFsRWxlbWVudCBmb3IgdGhpcyBjb21wb25lbnQuIEEgVmlzdWFsRWxlbWVudCBwcm92aWRlcyBhIGNvbW1vblxuICAgICAgICAgICAgICogaW50ZXJmYWNlIHRvIHJlbmRlcmVyLXNwZWNpZmljIEFQSXMgKGllIERPTS9UaHJlZS5qcyBldGMpIGFzIHdlbGwgYXNcbiAgICAgICAgICAgICAqIHByb3ZpZGluZyBhIHdheSBvZiByZW5kZXJpbmcgdG8gdGhlc2UgQVBJcyBvdXRzaWRlIG9mIHRoZSBSZWFjdCByZW5kZXIgbG9vcFxuICAgICAgICAgICAgICogZm9yIG1vcmUgcGVyZm9ybWFudCBhbmltYXRpb25zIGFuZCBpbnRlcmFjdGlvbnNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgY29udGV4dC52aXN1YWxFbGVtZW50ID0gdXNlVmlzdWFsRWxlbWVudChDb21wb25lbnQsIHZpc3VhbFN0YXRlLCBjb25maWdBbmRQcm9wcywgY3JlYXRlVmlzdWFsRWxlbWVudCwgbGF5b3V0UHJvamVjdGlvbi5Qcm9qZWN0aW9uTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRoZSBtb3VudCBvcmRlciBhbmQgaGllcmFyY2h5IGlzIHNwZWNpZmljIHRvIGVuc3VyZSBvdXIgZWxlbWVudCByZWZcbiAgICAgICAgICogaXMgaHlkcmF0ZWQgYnkgdGhlIHRpbWUgZmVhdHVyZXMgZmlyZSB0aGVpciBlZmZlY3RzLlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIChqc3hSdW50aW1lLmpzeHMoTW90aW9uQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogY29udGV4dCwgY2hpbGRyZW46IFtNZWFzdXJlTGF5b3V0ICYmIGNvbnRleHQudmlzdWFsRWxlbWVudCA/IChqc3hSdW50aW1lLmpzeChNZWFzdXJlTGF5b3V0LCB7IHZpc3VhbEVsZW1lbnQ6IGNvbnRleHQudmlzdWFsRWxlbWVudCwgLi4uY29uZmlnQW5kUHJvcHMgfSkpIDogbnVsbCwgdXNlUmVuZGVyKENvbXBvbmVudCwgcHJvcHMsIHVzZU1vdGlvblJlZih2aXN1YWxTdGF0ZSwgY29udGV4dC52aXN1YWxFbGVtZW50LCBleHRlcm5hbFJlZiksIHZpc3VhbFN0YXRlLCBpc1N0YXRpYywgY29udGV4dC52aXN1YWxFbGVtZW50KV0gfSkpO1xuICAgIH1cbiAgICBNb3Rpb25Db21wb25lbnQuZGlzcGxheU5hbWUgPSBgbW90aW9uLiR7dHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIlxuICAgICAgICA/IENvbXBvbmVudFxuICAgICAgICA6IGBjcmVhdGUoJHsoX2IgPSAoX2EgPSBDb21wb25lbnQuZGlzcGxheU5hbWUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IENvbXBvbmVudC5uYW1lKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBcIlwifSlgfWA7XG4gICAgY29uc3QgRm9yd2FyZFJlZk1vdGlvbkNvbXBvbmVudCA9IFJlYWN0LmZvcndhcmRSZWYoTW90aW9uQ29tcG9uZW50KTtcbiAgICBGb3J3YXJkUmVmTW90aW9uQ29tcG9uZW50W21vdGlvbkNvbXBvbmVudFN5bWJvbF0gPSBDb21wb25lbnQ7XG4gICAgcmV0dXJuIEZvcndhcmRSZWZNb3Rpb25Db21wb25lbnQ7XG59XG5mdW5jdGlvbiB1c2VMYXlvdXRJZCh7IGxheW91dElkIH0pIHtcbiAgICBjb25zdCBsYXlvdXRHcm91cElkID0gUmVhY3QudXNlQ29udGV4dChMYXlvdXRHcm91cENvbnRleHQpLmlkO1xuICAgIHJldHVybiBsYXlvdXRHcm91cElkICYmIGxheW91dElkICE9PSB1bmRlZmluZWRcbiAgICAgICAgPyBsYXlvdXRHcm91cElkICsgXCItXCIgKyBsYXlvdXRJZFxuICAgICAgICA6IGxheW91dElkO1xufVxuZnVuY3Rpb24gdXNlU3RyaWN0TW9kZShjb25maWdBbmRQcm9wcywgcHJlbG9hZGVkRmVhdHVyZXMpIHtcbiAgICBjb25zdCBpc1N0cmljdCA9IFJlYWN0LnVzZUNvbnRleHQoTGF6eUNvbnRleHQpLnN0cmljdDtcbiAgICAvKipcbiAgICAgKiBJZiB3ZSdyZSBpbiBkZXZlbG9wbWVudCBtb2RlLCBjaGVjayB0byBtYWtlIHN1cmUgd2UncmUgbm90IHJlbmRlcmluZyBhIG1vdGlvbiBjb21wb25lbnRcbiAgICAgKiBhcyBhIGNoaWxkIG9mIExhenlNb3Rpb24sIGFzIHRoaXMgd2lsbCBicmVhayB0aGUgZmlsZS1zaXplIGJlbmVmaXRzIG9mIHVzaW5nIGl0LlxuICAgICAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIgJiZcbiAgICAgICAgcHJlbG9hZGVkRmVhdHVyZXMgJiZcbiAgICAgICAgaXNTdHJpY3QpIHtcbiAgICAgICAgY29uc3Qgc3RyaWN0TWVzc2FnZSA9IFwiWW91IGhhdmUgcmVuZGVyZWQgYSBgbW90aW9uYCBjb21wb25lbnQgd2l0aGluIGEgYExhenlNb3Rpb25gIGNvbXBvbmVudC4gVGhpcyB3aWxsIGJyZWFrIHRyZWUgc2hha2luZy4gSW1wb3J0IGFuZCByZW5kZXIgYSBgbWAgY29tcG9uZW50IGluc3RlYWQuXCI7XG4gICAgICAgIGNvbmZpZ0FuZFByb3BzLmlnbm9yZVN0cmljdFxuICAgICAgICAgICAgPyBtb3Rpb25VdGlscy53YXJuaW5nKGZhbHNlLCBzdHJpY3RNZXNzYWdlKVxuICAgICAgICAgICAgOiBtb3Rpb25VdGlscy5pbnZhcmlhbnQoZmFsc2UsIHN0cmljdE1lc3NhZ2UpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFByb2plY3Rpb25GdW5jdGlvbmFsaXR5KHByb3BzKSB7XG4gICAgY29uc3QgeyBkcmFnLCBsYXlvdXQgfSA9IGZlYXR1cmVEZWZpbml0aW9ucztcbiAgICBpZiAoIWRyYWcgJiYgIWxheW91dClcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgIGNvbnN0IGNvbWJpbmVkID0geyAuLi5kcmFnLCAuLi5sYXlvdXQgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBNZWFzdXJlTGF5b3V0OiAoZHJhZyA9PT0gbnVsbCB8fCBkcmFnID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkcmFnLmlzRW5hYmxlZChwcm9wcykpIHx8IChsYXlvdXQgPT09IG51bGwgfHwgbGF5b3V0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBsYXlvdXQuaXNFbmFibGVkKHByb3BzKSlcbiAgICAgICAgICAgID8gY29tYmluZWQuTWVhc3VyZUxheW91dFxuICAgICAgICAgICAgOiB1bmRlZmluZWQsXG4gICAgICAgIFByb2plY3Rpb25Ob2RlOiBjb21iaW5lZC5Qcm9qZWN0aW9uTm9kZSxcbiAgICB9O1xufVxuXG4vKipcbiAqIFdlIGtlZXAgdGhlc2UgbGlzdGVkIHNlcGFyYXRlbHkgYXMgd2UgdXNlIHRoZSBsb3dlcmNhc2UgdGFnIG5hbWVzIGFzIHBhcnRcbiAqIG9mIHRoZSBydW50aW1lIGJ1bmRsZSB0byBkZXRlY3QgU1ZHIGNvbXBvbmVudHNcbiAqL1xuY29uc3QgbG93ZXJjYXNlU1ZHRWxlbWVudHMgPSBbXG4gICAgXCJhbmltYXRlXCIsXG4gICAgXCJjaXJjbGVcIixcbiAgICBcImRlZnNcIixcbiAgICBcImRlc2NcIixcbiAgICBcImVsbGlwc2VcIixcbiAgICBcImdcIixcbiAgICBcImltYWdlXCIsXG4gICAgXCJsaW5lXCIsXG4gICAgXCJmaWx0ZXJcIixcbiAgICBcIm1hcmtlclwiLFxuICAgIFwibWFza1wiLFxuICAgIFwibWV0YWRhdGFcIixcbiAgICBcInBhdGhcIixcbiAgICBcInBhdHRlcm5cIixcbiAgICBcInBvbHlnb25cIixcbiAgICBcInBvbHlsaW5lXCIsXG4gICAgXCJyZWN0XCIsXG4gICAgXCJzdG9wXCIsXG4gICAgXCJzd2l0Y2hcIixcbiAgICBcInN5bWJvbFwiLFxuICAgIFwic3ZnXCIsXG4gICAgXCJ0ZXh0XCIsXG4gICAgXCJ0c3BhblwiLFxuICAgIFwidXNlXCIsXG4gICAgXCJ2aWV3XCIsXG5dO1xuXG5mdW5jdGlvbiBpc1NWR0NvbXBvbmVudChDb21wb25lbnQpIHtcbiAgICBpZiAoXG4gICAgLyoqXG4gICAgICogSWYgaXQncyBub3QgYSBzdHJpbmcsIGl0J3MgYSBjdXN0b20gUmVhY3QgY29tcG9uZW50LiBDdXJyZW50bHkgd2Ugb25seSBzdXBwb3J0XG4gICAgICogSFRNTCBjdXN0b20gUmVhY3QgY29tcG9uZW50cy5cbiAgICAgKi9cbiAgICB0eXBlb2YgQ29tcG9uZW50ICE9PSBcInN0cmluZ1wiIHx8XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiBpdCBjb250YWlucyBhIGRhc2gsIHRoZSBlbGVtZW50IGlzIGEgY3VzdG9tIEhUTUwgd2ViY29tcG9uZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgQ29tcG9uZW50LmluY2x1ZGVzKFwiLVwiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKFxuICAgIC8qKlxuICAgICAqIElmIGl0J3MgaW4gb3VyIGxpc3Qgb2YgbG93ZXJjYXNlIFNWRyB0YWdzLCBpdCdzIGFuIFNWRyBjb21wb25lbnRcbiAgICAgKi9cbiAgICBsb3dlcmNhc2VTVkdFbGVtZW50cy5pbmRleE9mKENvbXBvbmVudCkgPiAtMSB8fFxuICAgICAgICAvKipcbiAgICAgICAgICogSWYgaXQgY29udGFpbnMgYSBjYXBpdGFsIGxldHRlciwgaXQncyBhbiBTVkcgY29tcG9uZW50XG4gICAgICAgICAqL1xuICAgICAgICAvW0EtWl0vdS50ZXN0KENvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgY3JlYXRlSHRtbFJlbmRlclN0YXRlID0gKCkgPT4gKHtcbiAgICBzdHlsZToge30sXG4gICAgdHJhbnNmb3JtOiB7fSxcbiAgICB0cmFuc2Zvcm1PcmlnaW46IHt9LFxuICAgIHZhcnM6IHt9LFxufSk7XG5cbmNvbnN0IGNyZWF0ZVN2Z1JlbmRlclN0YXRlID0gKCkgPT4gKHtcbiAgICAuLi5jcmVhdGVIdG1sUmVuZGVyU3RhdGUoKSxcbiAgICBhdHRyczoge30sXG59KTtcblxuZnVuY3Rpb24gdXBkYXRlU1ZHRGltZW5zaW9ucyhpbnN0YW5jZSwgcmVuZGVyU3RhdGUpIHtcbiAgICB0cnkge1xuICAgICAgICByZW5kZXJTdGF0ZS5kaW1lbnNpb25zID1cbiAgICAgICAgICAgIHR5cGVvZiBpbnN0YW5jZS5nZXRCQm94ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICA/IGluc3RhbmNlLmdldEJCb3goKVxuICAgICAgICAgICAgICAgIDogaW5zdGFuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIC8vIE1vc3QgbGlrZWx5IHRyeWluZyB0byBtZWFzdXJlIGFuIHVucmVuZGVyZWQgZWxlbWVudCB1bmRlciBGaXJlZm94XG4gICAgICAgIHJlbmRlclN0YXRlLmRpbWVuc2lvbnMgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMCxcbiAgICAgICAgICAgIHdpZHRoOiAwLFxuICAgICAgICAgICAgaGVpZ2h0OiAwLFxuICAgICAgICB9O1xuICAgIH1cbn1cbmNvbnN0IGxheW91dFByb3BzID0gW1wieFwiLCBcInlcIiwgXCJ3aWR0aFwiLCBcImhlaWdodFwiLCBcImN4XCIsIFwiY3lcIiwgXCJyXCJdO1xuY29uc3Qgc3ZnTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyxcbiAgICAgICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZVN2Z1JlbmRlclN0YXRlLFxuICAgICAgICBvblVwZGF0ZTogKHsgcHJvcHMsIHByZXZQcm9wcywgY3VycmVudCwgcmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjdXJyZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBoYXNUcmFuc2Zvcm0gPSAhIXByb3BzLmRyYWc7XG4gICAgICAgICAgICBpZiAoIWhhc1RyYW5zZm9ybSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIGxhdGVzdFZhbHVlcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNmb3JtUHJvcHMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1RyYW5zZm9ybSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaGFzVHJhbnNmb3JtKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGxldCBuZWVkc01lYXN1cmUgPSAhcHJldlByb3BzO1xuICAgICAgICAgICAgaWYgKHByZXZQcm9wcykge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIENoZWNrIHRoZSBsYXlvdXQgcHJvcHMgZm9yIGNoYW5nZXMsIGlmIGFueSBhcmUgZm91bmQgd2UgbmVlZCB0b1xuICAgICAgICAgICAgICAgICAqIG1lYXN1cmUgdGhlIGVsZW1lbnQgYWdhaW4uXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXlvdXRQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBsYXlvdXRQcm9wc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BzW2tleV0gIT09XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmV2UHJvcHNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbmVlZHNNZWFzdXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbmVlZHNNZWFzdXJlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGZyYW1lLnJlYWQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNWR0RpbWVuc2lvbnMoY3VycmVudCwgcmVuZGVyU3RhdGUpO1xuICAgICAgICAgICAgICAgIGZyYW1lLnJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1aWxkU1ZHQXR0cnMocmVuZGVyU3RhdGUsIGxhdGVzdFZhbHVlcywgaXNTVkdUYWcoY3VycmVudC50YWdOYW1lKSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZW5kZXJTVkcoY3VycmVudCwgcmVuZGVyU3RhdGUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgfSksXG59O1xuXG5jb25zdCBodG1sTW90aW9uQ29uZmlnID0ge1xuICAgIHVzZVZpc3VhbFN0YXRlOiBtYWtlVXNlVmlzdWFsU3RhdGUoe1xuICAgICAgICBzY3JhcGVNb3Rpb25WYWx1ZXNGcm9tUHJvcHM6IHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcyQxLFxuICAgICAgICBjcmVhdGVSZW5kZXJTdGF0ZTogY3JlYXRlSHRtbFJlbmRlclN0YXRlLFxuICAgIH0pLFxufTtcblxuZnVuY3Rpb24gY29weVJhd1ZhbHVlc09ubHkodGFyZ2V0LCBzb3VyY2UsIHByb3BzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgIGlmICghaXNNb3Rpb25WYWx1ZShzb3VyY2Vba2V5XSkgJiYgIWlzRm9yY2VkTW90aW9uVmFsdWUoa2V5LCBwcm9wcykpIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1c2VJbml0aWFsTW90aW9uVmFsdWVzKHsgdHJhbnNmb3JtVGVtcGxhdGUgfSwgdmlzdWFsU3RhdGUpIHtcbiAgICByZXR1cm4gUmVhY3QudXNlTWVtbygoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN0YXRlID0gY3JlYXRlSHRtbFJlbmRlclN0YXRlKCk7XG4gICAgICAgIGJ1aWxkSFRNTFN0eWxlcyhzdGF0ZSwgdmlzdWFsU3RhdGUsIHRyYW5zZm9ybVRlbXBsYXRlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnZhcnMsIHN0YXRlLnN0eWxlKTtcbiAgICB9LCBbdmlzdWFsU3RhdGVdKTtcbn1cbmZ1bmN0aW9uIHVzZVN0eWxlKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIGNvbnN0IHN0eWxlUHJvcCA9IHByb3BzLnN0eWxlIHx8IHt9O1xuICAgIGNvbnN0IHN0eWxlID0ge307XG4gICAgLyoqXG4gICAgICogQ29weSBub24tTW90aW9uIFZhbHVlcyBzdHJhaWdodCBpbnRvIHN0eWxlXG4gICAgICovXG4gICAgY29weVJhd1ZhbHVlc09ubHkoc3R5bGUsIHN0eWxlUHJvcCwgcHJvcHMpO1xuICAgIE9iamVjdC5hc3NpZ24oc3R5bGUsIHVzZUluaXRpYWxNb3Rpb25WYWx1ZXMocHJvcHMsIHZpc3VhbFN0YXRlKSk7XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gdXNlSFRNTFByb3BzKHByb3BzLCB2aXN1YWxTdGF0ZSkge1xuICAgIC8vIFRoZSBgYW55YCBpc24ndCBpZGVhbCBidXQgaXQgaXMgdGhlIHR5cGUgb2YgY3JlYXRlRWxlbWVudCBwcm9wcyBhcmd1bWVudFxuICAgIGNvbnN0IGh0bWxQcm9wcyA9IHt9O1xuICAgIGNvbnN0IHN0eWxlID0gdXNlU3R5bGUocHJvcHMsIHZpc3VhbFN0YXRlKTtcbiAgICBpZiAocHJvcHMuZHJhZyAmJiBwcm9wcy5kcmFnTGlzdGVuZXIgIT09IGZhbHNlKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGhlIGdob3N0IGVsZW1lbnQgd2hlbiBhIHVzZXIgZHJhZ3NcbiAgICAgICAgaHRtbFByb3BzLmRyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBEaXNhYmxlIHRleHQgc2VsZWN0aW9uXG4gICAgICAgIHN0eWxlLnVzZXJTZWxlY3QgPVxuICAgICAgICAgICAgc3R5bGUuV2Via2l0VXNlclNlbGVjdCA9XG4gICAgICAgICAgICAgICAgc3R5bGUuV2Via2l0VG91Y2hDYWxsb3V0ID1cbiAgICAgICAgICAgICAgICAgICAgXCJub25lXCI7XG4gICAgICAgIC8vIERpc2FibGUgc2Nyb2xsaW5nIG9uIHRoZSBkcmFnZ2FibGUgZGlyZWN0aW9uXG4gICAgICAgIHN0eWxlLnRvdWNoQWN0aW9uID1cbiAgICAgICAgICAgIHByb3BzLmRyYWcgPT09IHRydWVcbiAgICAgICAgICAgICAgICA/IFwibm9uZVwiXG4gICAgICAgICAgICAgICAgOiBgcGFuLSR7cHJvcHMuZHJhZyA9PT0gXCJ4XCIgPyBcInlcIiA6IFwieFwifWA7XG4gICAgfVxuICAgIGlmIChwcm9wcy50YWJJbmRleCA9PT0gdW5kZWZpbmVkICYmXG4gICAgICAgIChwcm9wcy5vblRhcCB8fCBwcm9wcy5vblRhcFN0YXJ0IHx8IHByb3BzLndoaWxlVGFwKSkge1xuICAgICAgICBodG1sUHJvcHMudGFiSW5kZXggPSAwO1xuICAgIH1cbiAgICBodG1sUHJvcHMuc3R5bGUgPSBzdHlsZTtcbiAgICByZXR1cm4gaHRtbFByb3BzO1xufVxuXG5mdW5jdGlvbiB1c2VTVkdQcm9wcyhwcm9wcywgdmlzdWFsU3RhdGUsIF9pc1N0YXRpYywgQ29tcG9uZW50KSB7XG4gICAgY29uc3QgdmlzdWFsUHJvcHMgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBjcmVhdGVTdmdSZW5kZXJTdGF0ZSgpO1xuICAgICAgICBidWlsZFNWR0F0dHJzKHN0YXRlLCB2aXN1YWxTdGF0ZSwgaXNTVkdUYWcoQ29tcG9uZW50KSwgcHJvcHMudHJhbnNmb3JtVGVtcGxhdGUpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLi4uc3RhdGUuYXR0cnMsXG4gICAgICAgICAgICBzdHlsZTogeyAuLi5zdGF0ZS5zdHlsZSB9LFxuICAgICAgICB9O1xuICAgIH0sIFt2aXN1YWxTdGF0ZV0pO1xuICAgIGlmIChwcm9wcy5zdHlsZSkge1xuICAgICAgICBjb25zdCByYXdTdHlsZXMgPSB7fTtcbiAgICAgICAgY29weVJhd1ZhbHVlc09ubHkocmF3U3R5bGVzLCBwcm9wcy5zdHlsZSwgcHJvcHMpO1xuICAgICAgICB2aXN1YWxQcm9wcy5zdHlsZSA9IHsgLi4ucmF3U3R5bGVzLCAuLi52aXN1YWxQcm9wcy5zdHlsZSB9O1xuICAgIH1cbiAgICByZXR1cm4gdmlzdWFsUHJvcHM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVVzZVJlbmRlcihmb3J3YXJkTW90aW9uUHJvcHMgPSBmYWxzZSkge1xuICAgIGNvbnN0IHVzZVJlbmRlciA9IChDb21wb25lbnQsIHByb3BzLCByZWYsIHsgbGF0ZXN0VmFsdWVzIH0sIGlzU3RhdGljKSA9PiB7XG4gICAgICAgIGNvbnN0IHVzZVZpc3VhbFByb3BzID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICAgICAgPyB1c2VTVkdQcm9wc1xuICAgICAgICAgICAgOiB1c2VIVE1MUHJvcHM7XG4gICAgICAgIGNvbnN0IHZpc3VhbFByb3BzID0gdXNlVmlzdWFsUHJvcHMocHJvcHMsIGxhdGVzdFZhbHVlcywgaXNTdGF0aWMsIENvbXBvbmVudCk7XG4gICAgICAgIGNvbnN0IGZpbHRlcmVkUHJvcHMgPSBmaWx0ZXJQcm9wcyhwcm9wcywgdHlwZW9mIENvbXBvbmVudCA9PT0gXCJzdHJpbmdcIiwgZm9yd2FyZE1vdGlvblByb3BzKTtcbiAgICAgICAgY29uc3QgZWxlbWVudFByb3BzID0gQ29tcG9uZW50ICE9PSBSZWFjdC5GcmFnbWVudFxuICAgICAgICAgICAgPyB7IC4uLmZpbHRlcmVkUHJvcHMsIC4uLnZpc3VhbFByb3BzLCByZWYgfVxuICAgICAgICAgICAgOiB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIElmIGNvbXBvbmVudCBoYXMgYmVlbiBoYW5kZWQgYSBtb3Rpb24gdmFsdWUgYXMgaXRzIGNoaWxkLFxuICAgICAgICAgKiBtZW1vaXNlIGl0cyBpbml0aWFsIHZhbHVlIGFuZCByZW5kZXIgdGhhdC4gU3Vic2VxdWVudCB1cGRhdGVzXG4gICAgICAgICAqIHdpbGwgYmUgaGFuZGxlZCBieSB0aGUgb25DaGFuZ2UgaGFuZGxlclxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgeyBjaGlsZHJlbiB9ID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHJlbmRlcmVkQ2hpbGRyZW4gPSBSZWFjdC51c2VNZW1vKCgpID0+IChpc01vdGlvblZhbHVlKGNoaWxkcmVuKSA/IGNoaWxkcmVuLmdldCgpIDogY2hpbGRyZW4pLCBbY2hpbGRyZW5dKTtcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB7XG4gICAgICAgICAgICAuLi5lbGVtZW50UHJvcHMsXG4gICAgICAgICAgICBjaGlsZHJlbjogcmVuZGVyZWRDaGlsZHJlbixcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gdXNlUmVuZGVyO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVNb3Rpb25Db21wb25lbnRGYWN0b3J5KHByZWxvYWRlZEZlYXR1cmVzLCBjcmVhdGVWaXN1YWxFbGVtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZU1vdGlvbkNvbXBvbmVudChDb21wb25lbnQsIHsgZm9yd2FyZE1vdGlvblByb3BzIH0gPSB7IGZvcndhcmRNb3Rpb25Qcm9wczogZmFsc2UgfSkge1xuICAgICAgICBjb25zdCBiYXNlQ29uZmlnID0gaXNTVkdDb21wb25lbnQoQ29tcG9uZW50KVxuICAgICAgICAgICAgPyBzdmdNb3Rpb25Db25maWdcbiAgICAgICAgICAgIDogaHRtbE1vdGlvbkNvbmZpZztcbiAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgLi4uYmFzZUNvbmZpZyxcbiAgICAgICAgICAgIHByZWxvYWRlZEZlYXR1cmVzLFxuICAgICAgICAgICAgdXNlUmVuZGVyOiBjcmVhdGVVc2VSZW5kZXIoZm9yd2FyZE1vdGlvblByb3BzKSxcbiAgICAgICAgICAgIGNyZWF0ZVZpc3VhbEVsZW1lbnQsXG4gICAgICAgICAgICBDb21wb25lbnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudChjb25maWcpO1xuICAgIH07XG59XG5cbmNvbnN0IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQgPSAoQ29tcG9uZW50LCBvcHRpb25zKSA9PiB7XG4gICAgcmV0dXJuIGlzU1ZHQ29tcG9uZW50KENvbXBvbmVudClcbiAgICAgICAgPyBuZXcgU1ZHVmlzdWFsRWxlbWVudChvcHRpb25zKVxuICAgICAgICA6IG5ldyBIVE1MVmlzdWFsRWxlbWVudChvcHRpb25zLCB7XG4gICAgICAgICAgICBhbGxvd1Byb2plY3Rpb246IENvbXBvbmVudCAhPT0gUmVhY3QuRnJhZ21lbnQsXG4gICAgICAgIH0pO1xufTtcblxuY29uc3QgY3JlYXRlTW90aW9uQ29tcG9uZW50ID0gLypAX19QVVJFX18qLyBjcmVhdGVNb3Rpb25Db21wb25lbnRGYWN0b3J5KHtcbiAgICAuLi5hbmltYXRpb25zLFxuICAgIC4uLmdlc3R1cmVBbmltYXRpb25zLFxuICAgIC4uLmRyYWcsXG4gICAgLi4ubGF5b3V0LFxufSwgY3JlYXRlRG9tVmlzdWFsRWxlbWVudCk7XG5cbmNvbnN0IG1vdGlvbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkoY3JlYXRlTW90aW9uQ29tcG9uZW50KTtcblxuZnVuY3Rpb24gY2hlY2tSZW9yZGVyKG9yZGVyLCB2YWx1ZSwgb2Zmc2V0LCB2ZWxvY2l0eSkge1xuICAgIGlmICghdmVsb2NpdHkpXG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICBjb25zdCBpbmRleCA9IG9yZGVyLmZpbmRJbmRleCgoaXRlbSkgPT4gaXRlbS52YWx1ZSA9PT0gdmFsdWUpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpXG4gICAgICAgIHJldHVybiBvcmRlcjtcbiAgICBjb25zdCBuZXh0T2Zmc2V0ID0gdmVsb2NpdHkgPiAwID8gMSA6IC0xO1xuICAgIGNvbnN0IG5leHRJdGVtID0gb3JkZXJbaW5kZXggKyBuZXh0T2Zmc2V0XTtcbiAgICBpZiAoIW5leHRJdGVtKVxuICAgICAgICByZXR1cm4gb3JkZXI7XG4gICAgY29uc3QgaXRlbSA9IG9yZGVyW2luZGV4XTtcbiAgICBjb25zdCBuZXh0TGF5b3V0ID0gbmV4dEl0ZW0ubGF5b3V0O1xuICAgIGNvbnN0IG5leHRJdGVtQ2VudGVyID0gbWl4TnVtYmVyJDEobmV4dExheW91dC5taW4sIG5leHRMYXlvdXQubWF4LCAwLjUpO1xuICAgIGlmICgobmV4dE9mZnNldCA9PT0gMSAmJiBpdGVtLmxheW91dC5tYXggKyBvZmZzZXQgPiBuZXh0SXRlbUNlbnRlcikgfHxcbiAgICAgICAgKG5leHRPZmZzZXQgPT09IC0xICYmIGl0ZW0ubGF5b3V0Lm1pbiArIG9mZnNldCA8IG5leHRJdGVtQ2VudGVyKSkge1xuICAgICAgICByZXR1cm4gbW92ZUl0ZW0ob3JkZXIsIGluZGV4LCBpbmRleCArIG5leHRPZmZzZXQpO1xuICAgIH1cbiAgICByZXR1cm4gb3JkZXI7XG59XG5cbmZ1bmN0aW9uIFJlb3JkZXJHcm91cENvbXBvbmVudCh7IGNoaWxkcmVuLCBhcyA9IFwidWxcIiwgYXhpcyA9IFwieVwiLCBvblJlb3JkZXIsIHZhbHVlcywgLi4ucHJvcHMgfSwgZXh0ZXJuYWxSZWYpIHtcbiAgICBjb25zdCBDb21wb25lbnQgPSB1c2VDb25zdGFudCgoKSA9PiBtb3Rpb25bYXNdKTtcbiAgICBjb25zdCBvcmRlciA9IFtdO1xuICAgIGNvbnN0IGlzUmVvcmRlcmluZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gICAgbW90aW9uVXRpbHMuaW52YXJpYW50KEJvb2xlYW4odmFsdWVzKSwgXCJSZW9yZGVyLkdyb3VwIG11c3QgYmUgcHJvdmlkZWQgYSB2YWx1ZXMgcHJvcFwiKTtcbiAgICBjb25zdCBjb250ZXh0ID0ge1xuICAgICAgICBheGlzLFxuICAgICAgICByZWdpc3Rlckl0ZW06ICh2YWx1ZSwgbGF5b3V0KSA9PiB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgZW50cnkgd2FzIGFscmVhZHkgYWRkZWQsIHVwZGF0ZSBpdCByYXRoZXIgdGhhbiBhZGRpbmcgaXQgYWdhaW5cbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IG9yZGVyLmZpbmRJbmRleCgoZW50cnkpID0+IHZhbHVlID09PSBlbnRyeS52YWx1ZSk7XG4gICAgICAgICAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIG9yZGVyW2lkeF0ubGF5b3V0ID0gbGF5b3V0W2F4aXNdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3JkZXIucHVzaCh7IHZhbHVlOiB2YWx1ZSwgbGF5b3V0OiBsYXlvdXRbYXhpc10gfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvcmRlci5zb3J0KGNvbXBhcmVNaW4pO1xuICAgICAgICB9LFxuICAgICAgICB1cGRhdGVPcmRlcjogKGl0ZW0sIG9mZnNldCwgdmVsb2NpdHkpID0+IHtcbiAgICAgICAgICAgIGlmIChpc1Jlb3JkZXJpbmcuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCBuZXdPcmRlciA9IGNoZWNrUmVvcmRlcihvcmRlciwgaXRlbSwgb2Zmc2V0LCB2ZWxvY2l0eSk7XG4gICAgICAgICAgICBpZiAob3JkZXIgIT09IG5ld09yZGVyKSB7XG4gICAgICAgICAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG9uUmVvcmRlcihuZXdPcmRlclxuICAgICAgICAgICAgICAgICAgICAubWFwKGdldFZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKCh2YWx1ZSkgPT4gdmFsdWVzLmluZGV4T2YodmFsdWUpICE9PSAtMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgIH07XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaXNSZW9yZGVyaW5nLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KENvbXBvbmVudCwgeyAuLi5wcm9wcywgcmVmOiBleHRlcm5hbFJlZiwgaWdub3JlU3RyaWN0OiB0cnVlLCBjaGlsZHJlbjoganN4UnVudGltZS5qc3goUmVvcmRlckNvbnRleHQuUHJvdmlkZXIsIHsgdmFsdWU6IGNvbnRleHQsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSB9KSk7XG59XG5jb25zdCBSZW9yZGVyR3JvdXAgPSAvKkBfX1BVUkVfXyovIFJlYWN0LmZvcndhcmRSZWYoUmVvcmRlckdyb3VwQ29tcG9uZW50KTtcbmZ1bmN0aW9uIGdldFZhbHVlKGl0ZW0pIHtcbiAgICByZXR1cm4gaXRlbS52YWx1ZTtcbn1cbmZ1bmN0aW9uIGNvbXBhcmVNaW4oYSwgYikge1xuICAgIHJldHVybiBhLmxheW91dC5taW4gLSBiLmxheW91dC5taW47XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdG8gdHJhY2sgdGhlIHN0YXRlIGFuZCB2ZWxvY2l0eSBvZiBhIHZhbHVlLlxuICpcbiAqIFVzdWFsbHksIHRoZXNlIGFyZSBjcmVhdGVkIGF1dG9tYXRpY2FsbHkuIEZvciBhZHZhbmNlZCB1c2UtY2FzZXMsIGxpa2UgdXNlIHdpdGggYHVzZVRyYW5zZm9ybWAsIHlvdSBjYW4gY3JlYXRlIGBNb3Rpb25WYWx1ZWBzIGV4dGVybmFsbHkgYW5kIHBhc3MgdGhlbSBpbnRvIHRoZSBhbmltYXRlZCBjb21wb25lbnQgdmlhIHRoZSBgc3R5bGVgIHByb3AuXG4gKlxuICogYGBganN4XG4gKiBleHBvcnQgY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHNjYWxlID0gdXNlTW90aW9uVmFsdWUoMSlcbiAqXG4gKiAgIHJldHVybiA8bW90aW9uLmRpdiBzdHlsZT17eyBzY2FsZSB9fSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHBhcmFtIGluaXRpYWwgLSBUaGUgaW5pdGlhbCBzdGF0ZS5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblZhbHVlKGluaXRpYWwpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZUNvbnN0YW50KCgpID0+IG1vdGlvblZhbHVlKGluaXRpYWwpKTtcbiAgICAvKipcbiAgICAgKiBJZiB0aGlzIG1vdGlvbiB2YWx1ZSBpcyBiZWluZyB1c2VkIGluIHN0YXRpYyBtb2RlLCBsaWtlIG9uXG4gICAgICogdGhlIEZyYW1lciBjYW52YXMsIGZvcmNlIGNvbXBvbmVudHMgdG8gcmVyZW5kZXIgd2hlbiB0aGUgbW90aW9uXG4gICAgICogdmFsdWUgaXMgdXBkYXRlZC5cbiAgICAgKi9cbiAgICBjb25zdCB7IGlzU3RhdGljIH0gPSBSZWFjdC51c2VDb250ZXh0KE1vdGlvbkNvbmZpZ0NvbnRleHQpO1xuICAgIGlmIChpc1N0YXRpYykge1xuICAgICAgICBjb25zdCBbLCBzZXRMYXRlc3RdID0gUmVhY3QudXNlU3RhdGUoaW5pdGlhbCk7XG4gICAgICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB2YWx1ZS5vbihcImNoYW5nZVwiLCBzZXRMYXRlc3QpLCBbXSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tYmluZU1vdGlvblZhbHVlcyh2YWx1ZXMsIGNvbWJpbmVWYWx1ZXMpIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXNlIHRoZSByZXR1cm5lZCBtb3Rpb24gdmFsdWUuIFRoaXMgcmVtYWlucyB0aGUgc2FtZSBiZXR3ZWVuIHJlbmRlcnMuXG4gICAgICovXG4gICAgY29uc3QgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShjb21iaW5lVmFsdWVzKCkpO1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgd2lsbCB1cGRhdGUgdGhlIHRlbXBsYXRlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgcHJlLWJvdW5kIHNvIHdoZW5ldmVyIGEgbW90aW9uIHZhbHVlIHVwZGF0ZXMgaXQgY2FuIHNjaGVkdWxlIGl0c1xuICAgICAqIGV4ZWN1dGlvbiBpbiBGcmFtZXN5bmMuIElmIGl0J3MgYWxyZWFkeSBiZWVuIHNjaGVkdWxlZCBpdCB3b24ndCBiZSBmaXJlZCB0d2ljZVxuICAgICAqIGluIGEgc2luZ2xlIGZyYW1lLlxuICAgICAqL1xuICAgIGNvbnN0IHVwZGF0ZVZhbHVlID0gKCkgPT4gdmFsdWUuc2V0KGNvbWJpbmVWYWx1ZXMoKSk7XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXNseSB1cGRhdGUgdGhlIG1vdGlvbiB2YWx1ZSB3aXRoIHRoZSBsYXRlc3QgdmFsdWVzIGR1cmluZyB0aGUgcmVuZGVyLlxuICAgICAqIFRoaXMgZW5zdXJlcyB0aGF0IHdpdGhpbiBhIFJlYWN0IHJlbmRlciwgdGhlIHN0eWxlcyBhcHBsaWVkIHRvIHRoZSBET00gYXJlIHVwLXRvLWRhdGUuXG4gICAgICovXG4gICAgdXBkYXRlVmFsdWUoKTtcbiAgICAvKipcbiAgICAgKiBTdWJzY3JpYmUgdG8gYWxsIG1vdGlvbiB2YWx1ZXMgZm91bmQgd2l0aGluIHRoZSB0ZW1wbGF0ZS4gV2hlbmV2ZXIgYW55IG9mIHRoZW0gY2hhbmdlLFxuICAgICAqIHNjaGVkdWxlIGFuIHVwZGF0ZS5cbiAgICAgKi9cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3Qgc2NoZWR1bGVVcGRhdGUgPSAoKSA9PiBmcmFtZS5wcmVSZW5kZXIodXBkYXRlVmFsdWUsIGZhbHNlLCB0cnVlKTtcbiAgICAgICAgY29uc3Qgc3Vic2NyaXB0aW9ucyA9IHZhbHVlcy5tYXAoKHYpID0+IHYub24oXCJjaGFuZ2VcIiwgc2NoZWR1bGVVcGRhdGUpKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmlwdGlvbnMuZm9yRWFjaCgodW5zdWJzY3JpYmUpID0+IHVuc3Vic2NyaWJlKCkpO1xuICAgICAgICAgICAgY2FuY2VsRnJhbWUodXBkYXRlVmFsdWUpO1xuICAgICAgICB9O1xuICAgIH0pO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gdXNlQ29tcHV0ZWQoY29tcHV0ZSkge1xuICAgIC8qKlxuICAgICAqIE9wZW4gc2Vzc2lvbiBvZiBjb2xsZWN0TW90aW9uVmFsdWVzLiBBbnkgTW90aW9uVmFsdWUgdGhhdCBjYWxscyBnZXQoKVxuICAgICAqIHdpbGwgYmUgc2F2ZWQgaW50byB0aGlzIGFycmF5LlxuICAgICAqL1xuICAgIGNvbGxlY3RNb3Rpb25WYWx1ZXMuY3VycmVudCA9IFtdO1xuICAgIGNvbXB1dGUoKTtcbiAgICBjb25zdCB2YWx1ZSA9IHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXMoY29sbGVjdE1vdGlvblZhbHVlcy5jdXJyZW50LCBjb21wdXRlKTtcbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91c2x5IGNsb3NlIHNlc3Npb24gb2YgY29sbGVjdE1vdGlvblZhbHVlcy5cbiAgICAgKi9cbiAgICBjb2xsZWN0TW90aW9uVmFsdWVzLmN1cnJlbnQgPSB1bmRlZmluZWQ7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VUcmFuc2Zvcm0oaW5wdXQsIGlucHV0UmFuZ2VPclRyYW5zZm9ybWVyLCBvdXRwdXRSYW5nZSwgb3B0aW9ucykge1xuICAgIGlmICh0eXBlb2YgaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gdXNlQ29tcHV0ZWQoaW5wdXQpO1xuICAgIH1cbiAgICBjb25zdCB0cmFuc2Zvcm1lciA9IHR5cGVvZiBpbnB1dFJhbmdlT3JUcmFuc2Zvcm1lciA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXJcbiAgICAgICAgOiB0cmFuc2Zvcm0oaW5wdXRSYW5nZU9yVHJhbnNmb3JtZXIsIG91dHB1dFJhbmdlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShpbnB1dClcbiAgICAgICAgPyB1c2VMaXN0VHJhbnNmb3JtKGlucHV0LCB0cmFuc2Zvcm1lcilcbiAgICAgICAgOiB1c2VMaXN0VHJhbnNmb3JtKFtpbnB1dF0sIChbbGF0ZXN0XSkgPT4gdHJhbnNmb3JtZXIobGF0ZXN0KSk7XG59XG5mdW5jdGlvbiB1c2VMaXN0VHJhbnNmb3JtKHZhbHVlcywgdHJhbnNmb3JtZXIpIHtcbiAgICBjb25zdCBsYXRlc3QgPSB1c2VDb25zdGFudCgoKSA9PiBbXSk7XG4gICAgcmV0dXJuIHVzZUNvbWJpbmVNb3Rpb25WYWx1ZXModmFsdWVzLCAoKSA9PiB7XG4gICAgICAgIGxhdGVzdC5sZW5ndGggPSAwO1xuICAgICAgICBjb25zdCBudW1WYWx1ZXMgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bVZhbHVlczsgaSsrKSB7XG4gICAgICAgICAgICBsYXRlc3RbaV0gPSB2YWx1ZXNbaV0uZ2V0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybWVyKGxhdGVzdCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHVzZURlZmF1bHRNb3Rpb25WYWx1ZSh2YWx1ZSwgZGVmYXVsdFZhbHVlID0gMCkge1xuICAgIHJldHVybiBpc01vdGlvblZhbHVlKHZhbHVlKSA/IHZhbHVlIDogdXNlTW90aW9uVmFsdWUoZGVmYXVsdFZhbHVlKTtcbn1cbmZ1bmN0aW9uIFJlb3JkZXJJdGVtQ29tcG9uZW50KHsgY2hpbGRyZW4sIHN0eWxlID0ge30sIHZhbHVlLCBhcyA9IFwibGlcIiwgb25EcmFnLCBsYXlvdXQgPSB0cnVlLCAuLi5wcm9wcyB9LCBleHRlcm5hbFJlZikge1xuICAgIGNvbnN0IENvbXBvbmVudCA9IHVzZUNvbnN0YW50KCgpID0+IG1vdGlvblthc10pO1xuICAgIGNvbnN0IGNvbnRleHQgPSBSZWFjdC51c2VDb250ZXh0KFJlb3JkZXJDb250ZXh0KTtcbiAgICBjb25zdCBwb2ludCA9IHtcbiAgICAgICAgeDogdXNlRGVmYXVsdE1vdGlvblZhbHVlKHN0eWxlLngpLFxuICAgICAgICB5OiB1c2VEZWZhdWx0TW90aW9uVmFsdWUoc3R5bGUueSksXG4gICAgfTtcbiAgICBjb25zdCB6SW5kZXggPSB1c2VUcmFuc2Zvcm0oW3BvaW50LngsIHBvaW50LnldLCAoW2xhdGVzdFgsIGxhdGVzdFldKSA9PiBsYXRlc3RYIHx8IGxhdGVzdFkgPyAxIDogXCJ1bnNldFwiKTtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoQm9vbGVhbihjb250ZXh0KSwgXCJSZW9yZGVyLkl0ZW0gbXVzdCBiZSBhIGNoaWxkIG9mIFJlb3JkZXIuR3JvdXBcIik7XG4gICAgY29uc3QgeyBheGlzLCByZWdpc3Rlckl0ZW0sIHVwZGF0ZU9yZGVyIH0gPSBjb250ZXh0O1xuICAgIHJldHVybiAoanN4UnVudGltZS5qc3goQ29tcG9uZW50LCB7IGRyYWc6IGF4aXMsIC4uLnByb3BzLCBkcmFnU25hcFRvT3JpZ2luOiB0cnVlLCBzdHlsZTogeyAuLi5zdHlsZSwgeDogcG9pbnQueCwgeTogcG9pbnQueSwgekluZGV4IH0sIGxheW91dDogbGF5b3V0LCBvbkRyYWc6IChldmVudCwgZ2VzdHVyZVBvaW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IHZlbG9jaXR5IH0gPSBnZXN0dXJlUG9pbnQ7XG4gICAgICAgICAgICB2ZWxvY2l0eVtheGlzXSAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZU9yZGVyKHZhbHVlLCBwb2ludFtheGlzXS5nZXQoKSwgdmVsb2NpdHlbYXhpc10pO1xuICAgICAgICAgICAgb25EcmFnICYmIG9uRHJhZyhldmVudCwgZ2VzdHVyZVBvaW50KTtcbiAgICAgICAgfSwgb25MYXlvdXRNZWFzdXJlOiAobWVhc3VyZWQpID0+IHJlZ2lzdGVySXRlbSh2YWx1ZSwgbWVhc3VyZWQpLCByZWY6IGV4dGVybmFsUmVmLCBpZ25vcmVTdHJpY3Q6IHRydWUsIGNoaWxkcmVuOiBjaGlsZHJlbiB9KSk7XG59XG5jb25zdCBSZW9yZGVySXRlbSA9IC8qQF9fUFVSRV9fKi8gUmVhY3QuZm9yd2FyZFJlZihSZW9yZGVySXRlbUNvbXBvbmVudCk7XG5cbnZhciBuYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSh7XG4gICAgX19wcm90b19fOiBudWxsLFxuICAgIEdyb3VwOiBSZW9yZGVyR3JvdXAsXG4gICAgSXRlbTogUmVvcmRlckl0ZW1cbn0pO1xuXG5jb25zdCBjcmVhdGVNaW5pbWFsTW90aW9uQ29tcG9uZW50ID0gXG4vKkBfX1BVUkVfXyovIGNyZWF0ZU1vdGlvbkNvbXBvbmVudEZhY3RvcnkoKTtcblxuY29uc3QgbSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlRE9NTW90aW9uQ29tcG9uZW50UHJveHkoY3JlYXRlTWluaW1hbE1vdGlvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBkb21BbmltYXRpb24gPSB7XG4gICAgcmVuZGVyZXI6IGNyZWF0ZURvbVZpc3VhbEVsZW1lbnQsXG4gICAgLi4uYW5pbWF0aW9ucyxcbiAgICAuLi5nZXN0dXJlQW5pbWF0aW9ucyxcbn07XG5cbi8qKlxuICogQHB1YmxpY1xuICovXG5jb25zdCBkb21NYXggPSB7XG4gICAgLi4uZG9tQW5pbWF0aW9uLFxuICAgIC4uLmRyYWcsXG4gICAgLi4ubGF5b3V0LFxufTtcblxuLyoqXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IGRvbU1pbiA9IHtcbiAgICByZW5kZXJlcjogY3JlYXRlRG9tVmlzdWFsRWxlbWVudCxcbiAgICAuLi5hbmltYXRpb25zLFxufTtcblxuZnVuY3Rpb24gdXNlTW90aW9uVmFsdWVFdmVudCh2YWx1ZSwgZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgLyoqXG4gICAgICogdXNlSW5zZXJ0aW9uRWZmZWN0IHdpbGwgY3JlYXRlIHN1YnNjcmlwdGlvbnMgYmVmb3JlIGFueSBvdGhlclxuICAgICAqIGVmZmVjdHMgd2lsbCBydW4uIEVmZmVjdHMgcnVuIHVwd2FyZHMgdGhyb3VnaCB0aGUgdHJlZSBzbyBpdFxuICAgICAqIGNhbiBiZSB0aGF0IGJpbmRpbmcgYSB1c2VMYXlvdXRFZmZlY3QgaGlnaGVyIHVwIHRoZSB0cmVlIGNhblxuICAgICAqIG1pc3MgY2hhbmdlcyBmcm9tIGxvd2VyIGRvd24gdGhlIHRyZWUuXG4gICAgICovXG4gICAgUmVhY3QudXNlSW5zZXJ0aW9uRWZmZWN0KCgpID0+IHZhbHVlLm9uKGV2ZW50LCBjYWxsYmFjayksIFt2YWx1ZSwgZXZlbnQsIGNhbGxiYWNrXSk7XG59XG5cbmZ1bmN0aW9uIHJlZldhcm5pbmcobmFtZSwgcmVmKSB7XG4gICAgbW90aW9uVXRpbHMud2FybmluZyhCb29sZWFuKCFyZWYgfHwgcmVmLmN1cnJlbnQpLCBgWW91IGhhdmUgZGVmaW5lZCBhICR7bmFtZX0gb3B0aW9ucyBidXQgdGhlIHByb3ZpZGVkIHJlZiBpcyBub3QgeWV0IGh5ZHJhdGVkLCBwcm9iYWJseSBiZWNhdXNlIGl0J3MgZGVmaW5lZCBoaWdoZXIgdXAgdGhlIHRyZWUuIFRyeSBjYWxsaW5nIHVzZVNjcm9sbCgpIGluIHRoZSBzYW1lIGNvbXBvbmVudCBhcyB0aGUgcmVmLCBvciBzZXR0aW5nIGl0cyBcXGBsYXlvdXRFZmZlY3Q6IGZhbHNlXFxgIG9wdGlvbi5gKTtcbn1cbmNvbnN0IGNyZWF0ZVNjcm9sbE1vdGlvblZhbHVlcyA9ICgpID0+ICh7XG4gICAgc2Nyb2xsWDogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWTogbW90aW9uVmFsdWUoMCksXG4gICAgc2Nyb2xsWFByb2dyZXNzOiBtb3Rpb25WYWx1ZSgwKSxcbiAgICBzY3JvbGxZUHJvZ3Jlc3M6IG1vdGlvblZhbHVlKDApLFxufSk7XG5mdW5jdGlvbiB1c2VTY3JvbGwoeyBjb250YWluZXIsIHRhcmdldCwgbGF5b3V0RWZmZWN0ID0gdHJ1ZSwgLi4ub3B0aW9ucyB9ID0ge30pIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB1c2VDb25zdGFudChjcmVhdGVTY3JvbGxNb3Rpb25WYWx1ZXMpO1xuICAgIGNvbnN0IHVzZUxpZmVjeWNsZUVmZmVjdCA9IGxheW91dEVmZmVjdFxuICAgICAgICA/IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3RcbiAgICAgICAgOiBSZWFjdC51c2VFZmZlY3Q7XG4gICAgdXNlTGlmZWN5Y2xlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcmVmV2FybmluZyhcInRhcmdldFwiLCB0YXJnZXQpO1xuICAgICAgICByZWZXYXJuaW5nKFwiY29udGFpbmVyXCIsIGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiBzY3JvbGwoKF9wcm9ncmVzcywgeyB4LCB5IH0pID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxYLnNldCh4LmN1cnJlbnQpO1xuICAgICAgICAgICAgdmFsdWVzLnNjcm9sbFhQcm9ncmVzcy5zZXQoeC5wcm9ncmVzcyk7XG4gICAgICAgICAgICB2YWx1ZXMuc2Nyb2xsWS5zZXQoeS5jdXJyZW50KTtcbiAgICAgICAgICAgIHZhbHVlcy5zY3JvbGxZUHJvZ3Jlc3Muc2V0KHkucHJvZ3Jlc3MpO1xuICAgICAgICB9LCB7XG4gICAgICAgICAgICAuLi5vcHRpb25zLFxuICAgICAgICAgICAgY29udGFpbmVyOiAoY29udGFpbmVyID09PSBudWxsIHx8IGNvbnRhaW5lciA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29udGFpbmVyLmN1cnJlbnQpIHx8IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHRhcmdldDogKHRhcmdldCA9PT0gbnVsbCB8fCB0YXJnZXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRhcmdldC5jdXJyZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgIH0sIFtjb250YWluZXIsIHRhcmdldCwgSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5vZmZzZXQpXSk7XG4gICAgcmV0dXJuIHZhbHVlcztcbn1cblxuLyoqXG4gKiBAZGVwcmVjYXRlZCB1c2VFbGVtZW50U2Nyb2xsIGlzIGRlcHJlY2F0ZWQuIENvbnZlcnQgdG8gdXNlU2Nyb2xsKHsgY29udGFpbmVyOiByZWYgfSlcbiAqL1xuZnVuY3Rpb24gdXNlRWxlbWVudFNjcm9sbChyZWYpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09IFwiZGV2ZWxvcG1lbnRcIikge1xuICAgICAgICB3YXJuT25jZShmYWxzZSwgXCJ1c2VFbGVtZW50U2Nyb2xsIGlzIGRlcHJlY2F0ZWQuIENvbnZlcnQgdG8gdXNlU2Nyb2xsKHsgY29udGFpbmVyOiByZWYgfSkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU2Nyb2xsKHsgY29udGFpbmVyOiByZWYgfSk7XG59XG5cbi8qKlxuICogQGRlcHJlY2F0ZWQgdXNlVmlld3BvcnRTY3JvbGwgaXMgZGVwcmVjYXRlZC4gQ29udmVydCB0byB1c2VTY3JvbGwoKVxuICovXG5mdW5jdGlvbiB1c2VWaWV3cG9ydFNjcm9sbCgpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09IFwicHJvZHVjdGlvblwiKSB7XG4gICAgICAgIHdhcm5PbmNlKGZhbHNlLCBcInVzZVZpZXdwb3J0U2Nyb2xsIGlzIGRlcHJlY2F0ZWQuIENvbnZlcnQgdG8gdXNlU2Nyb2xsKCkuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gdXNlU2Nyb2xsKCk7XG59XG5cbi8qKlxuICogQ29tYmluZSBtdWx0aXBsZSBtb3Rpb24gdmFsdWVzIGludG8gYSBuZXcgb25lIHVzaW5nIGEgc3RyaW5nIHRlbXBsYXRlIGxpdGVyYWwuXG4gKlxuICogYGBganN4XG4gKiBpbXBvcnQge1xuICogICBtb3Rpb24sXG4gKiAgIHVzZVNwcmluZyxcbiAqICAgdXNlTW90aW9uVmFsdWUsXG4gKiAgIHVzZU1vdGlvblRlbXBsYXRlXG4gKiB9IGZyb20gXCJmcmFtZXItbW90aW9uXCJcbiAqXG4gKiBmdW5jdGlvbiBDb21wb25lbnQoKSB7XG4gKiAgIGNvbnN0IHNoYWRvd1ggPSB1c2VTcHJpbmcoMClcbiAqICAgY29uc3Qgc2hhZG93WSA9IHVzZU1vdGlvblZhbHVlKDApXG4gKiAgIGNvbnN0IHNoYWRvdyA9IHVzZU1vdGlvblRlbXBsYXRlYGRyb3Atc2hhZG93KCR7c2hhZG93WH1weCAke3NoYWRvd1l9cHggMjBweCByZ2JhKDAsMCwwLDAuMykpYFxuICpcbiAqICAgcmV0dXJuIDxtb3Rpb24uZGl2IHN0eWxlPXt7IGZpbHRlcjogc2hhZG93IH19IC8+XG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZU1vdGlvblRlbXBsYXRlKGZyYWdtZW50cywgLi4udmFsdWVzKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJ1aWxkIGEgc3RyaW5nIGZyb20gdGhlIGxhdGVzdCBtb3Rpb24gdmFsdWVzLlxuICAgICAqL1xuICAgIGNvbnN0IG51bUZyYWdtZW50cyA9IGZyYWdtZW50cy5sZW5ndGg7XG4gICAgZnVuY3Rpb24gYnVpbGRWYWx1ZSgpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IGBgO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUZyYWdtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBvdXRwdXQgKz0gZnJhZ21lbnRzW2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB2YWx1ZXNbaV07XG4gICAgICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgKz0gaXNNb3Rpb25WYWx1ZSh2YWx1ZSkgPyB2YWx1ZS5nZXQoKSA6IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxuICAgIHJldHVybiB1c2VDb21iaW5lTW90aW9uVmFsdWVzKHZhbHVlcy5maWx0ZXIoaXNNb3Rpb25WYWx1ZSksIGJ1aWxkVmFsdWUpO1xufVxuXG5mdW5jdGlvbiB0b051bWJlcih2KSB7XG4gICAgaWYgKHR5cGVvZiB2ID09PSBcIm51bWJlclwiKVxuICAgICAgICByZXR1cm4gdjtcbiAgICByZXR1cm4gcGFyc2VGbG9hdCh2KTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhIGBNb3Rpb25WYWx1ZWAgdGhhdCwgd2hlbiBgc2V0YCwgd2lsbCB1c2UgYSBzcHJpbmcgYW5pbWF0aW9uIHRvIGFuaW1hdGUgdG8gaXRzIG5ldyBzdGF0ZS5cbiAqXG4gKiBJdCBjYW4gZWl0aGVyIHdvcmsgYXMgYSBzdGFuZC1hbG9uZSBgTW90aW9uVmFsdWVgIGJ5IGluaXRpYWxpc2luZyBpdCB3aXRoIGEgdmFsdWUsIG9yIGFzIGEgc3Vic2NyaWJlclxuICogdG8gYW5vdGhlciBgTW90aW9uVmFsdWVgLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogYGBganN4XG4gKiBjb25zdCB4ID0gdXNlU3ByaW5nKDAsIHsgc3RpZmZuZXNzOiAzMDAgfSlcbiAqIGNvbnN0IHkgPSB1c2VTcHJpbmcoeCwgeyBkYW1waW5nOiAxMCB9KVxuICogYGBgXG4gKlxuICogQHBhcmFtIGlucHV0VmFsdWUgLSBgTW90aW9uVmFsdWVgIG9yIG51bWJlci4gSWYgcHJvdmlkZWQgYSBgTW90aW9uVmFsdWVgLCB3aGVuIHRoZSBpbnB1dCBgTW90aW9uVmFsdWVgIGNoYW5nZXMsIHRoZSBjcmVhdGVkIGBNb3Rpb25WYWx1ZWAgd2lsbCBzcHJpbmcgdG93YXJkcyB0aGF0IHZhbHVlLlxuICogQHBhcmFtIHNwcmluZ0NvbmZpZyAtIENvbmZpZ3VyYXRpb24gb3B0aW9ucyBmb3IgdGhlIHNwcmluZy5cbiAqIEByZXR1cm5zIGBNb3Rpb25WYWx1ZWBcbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVNwcmluZyhzb3VyY2UsIGNvbmZpZyA9IHt9KSB7XG4gICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgICBjb25zdCBhY3RpdmVTcHJpbmdBbmltYXRpb24gPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VNb3Rpb25WYWx1ZShpc01vdGlvblZhbHVlKHNvdXJjZSkgPyB0b051bWJlcihzb3VyY2UuZ2V0KCkpIDogc291cmNlKTtcbiAgICBjb25zdCBsYXRlc3RWYWx1ZSA9IFJlYWN0LnVzZVJlZih2YWx1ZS5nZXQoKSk7XG4gICAgY29uc3QgbGF0ZXN0U2V0dGVyID0gUmVhY3QudXNlUmVmKCgpID0+IHsgfSk7XG4gICAgY29uc3Qgc3RhcnRBbmltYXRpb24gPSAoKSA9PiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGUgcHJldmlvdXMgYW5pbWF0aW9uIGhhc24ndCBoYWQgdGhlIGNoYW5jZSB0byBldmVuIHJlbmRlciBhIGZyYW1lLCByZW5kZXIgaXQgbm93LlxuICAgICAgICAgKi9cbiAgICAgICAgY29uc3QgYW5pbWF0aW9uID0gYWN0aXZlU3ByaW5nQW5pbWF0aW9uLmN1cnJlbnQ7XG4gICAgICAgIGlmIChhbmltYXRpb24gJiYgYW5pbWF0aW9uLnRpbWUgPT09IDApIHtcbiAgICAgICAgICAgIGFuaW1hdGlvbi5zYW1wbGUoZnJhbWVEYXRhLmRlbHRhKTtcbiAgICAgICAgfVxuICAgICAgICBzdG9wQW5pbWF0aW9uKCk7XG4gICAgICAgIGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50ID0gYW5pbWF0ZVZhbHVlKHtcbiAgICAgICAgICAgIGtleWZyYW1lczogW3ZhbHVlLmdldCgpLCBsYXRlc3RWYWx1ZS5jdXJyZW50XSxcbiAgICAgICAgICAgIHZlbG9jaXR5OiB2YWx1ZS5nZXRWZWxvY2l0eSgpLFxuICAgICAgICAgICAgdHlwZTogXCJzcHJpbmdcIixcbiAgICAgICAgICAgIHJlc3REZWx0YTogMC4wMDEsXG4gICAgICAgICAgICByZXN0U3BlZWQ6IDAuMDEsXG4gICAgICAgICAgICAuLi5jb25maWcsXG4gICAgICAgICAgICBvblVwZGF0ZTogbGF0ZXN0U2V0dGVyLmN1cnJlbnQsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3Qgc3RvcEFuaW1hdGlvbiA9ICgpID0+IHtcbiAgICAgICAgaWYgKGFjdGl2ZVNwcmluZ0FuaW1hdGlvbi5jdXJyZW50KSB7XG4gICAgICAgICAgICBhY3RpdmVTcHJpbmdBbmltYXRpb24uY3VycmVudC5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWN0LnVzZUluc2VydGlvbkVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5hdHRhY2goKHYsIHNldCkgPT4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIG1vcmUgaG9sbGlzdGljIGFwcHJvYWNoIHRvIHRoaXMgbWlnaHQgYmUgdG8gdXNlIGlzU3RhdGljIHRvIGZpeCBWaXN1YWxFbGVtZW50IGFuaW1hdGlvbnNcbiAgICAgICAgICAgICAqIGF0IHRoYXQgbGV2ZWwsIGJ1dCB0aGlzIHdpbGwgd29yayBmb3Igbm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChpc1N0YXRpYylcbiAgICAgICAgICAgICAgICByZXR1cm4gc2V0KHYpO1xuICAgICAgICAgICAgbGF0ZXN0VmFsdWUuY3VycmVudCA9IHY7XG4gICAgICAgICAgICBsYXRlc3RTZXR0ZXIuY3VycmVudCA9IHNldDtcbiAgICAgICAgICAgIGZyYW1lLnVwZGF0ZShzdGFydEFuaW1hdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuZ2V0KCk7XG4gICAgICAgIH0sIHN0b3BBbmltYXRpb24pO1xuICAgIH0sIFtKU09OLnN0cmluZ2lmeShjb25maWcpXSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChpc01vdGlvblZhbHVlKHNvdXJjZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBzb3VyY2Uub24oXCJjaGFuZ2VcIiwgKHYpID0+IHZhbHVlLnNldCh0b051bWJlcih2KSkpO1xuICAgICAgICB9XG4gICAgfSwgW3ZhbHVlXSk7XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuXG5mdW5jdGlvbiB1c2VBbmltYXRpb25GcmFtZShjYWxsYmFjaykge1xuICAgIGNvbnN0IGluaXRpYWxUaW1lc3RhbXAgPSBSZWFjdC51c2VSZWYoMCk7XG4gICAgY29uc3QgeyBpc1N0YXRpYyB9ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db25maWdDb250ZXh0KTtcbiAgICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoaXNTdGF0aWMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHByb3ZpZGVUaW1lU2luY2VTdGFydCA9ICh7IHRpbWVzdGFtcCwgZGVsdGEgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpbml0aWFsVGltZXN0YW1wLmN1cnJlbnQpXG4gICAgICAgICAgICAgICAgaW5pdGlhbFRpbWVzdGFtcC5jdXJyZW50ID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgY2FsbGJhY2sodGltZXN0YW1wIC0gaW5pdGlhbFRpbWVzdGFtcC5jdXJyZW50LCBkZWx0YSk7XG4gICAgICAgIH07XG4gICAgICAgIGZyYW1lLnVwZGF0ZShwcm92aWRlVGltZVNpbmNlU3RhcnQsIHRydWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4gY2FuY2VsRnJhbWUocHJvdmlkZVRpbWVTaW5jZVN0YXJ0KTtcbiAgICB9LCBbY2FsbGJhY2tdKTtcbn1cblxuZnVuY3Rpb24gdXNlVGltZSgpIHtcbiAgICBjb25zdCB0aW1lID0gdXNlTW90aW9uVmFsdWUoMCk7XG4gICAgdXNlQW5pbWF0aW9uRnJhbWUoKHQpID0+IHRpbWUuc2V0KHQpKTtcbiAgICByZXR1cm4gdGltZTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgYE1vdGlvblZhbHVlYCB0aGF0IHVwZGF0ZXMgd2hlbiB0aGUgdmVsb2NpdHkgb2YgdGhlIHByb3ZpZGVkIGBNb3Rpb25WYWx1ZWAgY2hhbmdlcy5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBjb25zdCB4ID0gdXNlTW90aW9uVmFsdWUoMClcbiAqIGNvbnN0IHhWZWxvY2l0eSA9IHVzZVZlbG9jaXR5KHgpXG4gKiBjb25zdCB4QWNjZWxlcmF0aW9uID0gdXNlVmVsb2NpdHkoeFZlbG9jaXR5KVxuICogYGBgXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB1c2VWZWxvY2l0eSh2YWx1ZSkge1xuICAgIGNvbnN0IHZlbG9jaXR5ID0gdXNlTW90aW9uVmFsdWUodmFsdWUuZ2V0VmVsb2NpdHkoKSk7XG4gICAgY29uc3QgdXBkYXRlVmVsb2NpdHkgPSAoKSA9PiB7XG4gICAgICAgIGNvbnN0IGxhdGVzdCA9IHZhbHVlLmdldFZlbG9jaXR5KCk7XG4gICAgICAgIHZlbG9jaXR5LnNldChsYXRlc3QpO1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgd2Ugc3RpbGwgaGF2ZSB2ZWxvY2l0eSwgc2NoZWR1bGUgYW4gdXBkYXRlIGZvciB0aGUgbmV4dCBmcmFtZVxuICAgICAgICAgKiB0byBrZWVwIGNoZWNraW5nIHVudGlsIGl0IGlzIHplcm8uXG4gICAgICAgICAqL1xuICAgICAgICBpZiAobGF0ZXN0KVxuICAgICAgICAgICAgZnJhbWUudXBkYXRlKHVwZGF0ZVZlbG9jaXR5KTtcbiAgICB9O1xuICAgIHVzZU1vdGlvblZhbHVlRXZlbnQodmFsdWUsIFwiY2hhbmdlXCIsICgpID0+IHtcbiAgICAgICAgLy8gU2NoZWR1bGUgYW4gdXBkYXRlIHRvIHRoaXMgdmFsdWUgYXQgdGhlIGVuZCBvZiB0aGUgY3VycmVudCBmcmFtZS5cbiAgICAgICAgZnJhbWUudXBkYXRlKHVwZGF0ZVZlbG9jaXR5LCBmYWxzZSwgdHJ1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHZlbG9jaXR5O1xufVxuXG5mdW5jdGlvbiBnZXRXaWxsQ2hhbmdlTmFtZShuYW1lKSB7XG4gICAgaWYgKHRyYW5zZm9ybVByb3BzLmhhcyhuYW1lKSkge1xuICAgICAgICByZXR1cm4gXCJ0cmFuc2Zvcm1cIjtcbiAgICB9XG4gICAgZWxzZSBpZiAoYWNjZWxlcmF0ZWRWYWx1ZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBjYW1lbFRvRGFzaChuYW1lKTtcbiAgICB9XG59XG5cbmNsYXNzIFdpbGxDaGFuZ2VNb3Rpb25WYWx1ZSBleHRlbmRzIE1vdGlvblZhbHVlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy52YWx1ZXMgPSBbXTtcbiAgICB9XG4gICAgYWRkKG5hbWUpIHtcbiAgICAgICAgY29uc3Qgc3R5bGVOYW1lID0gZ2V0V2lsbENoYW5nZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChzdHlsZU5hbWUpIHtcbiAgICAgICAgICAgIGFkZFVuaXF1ZUl0ZW0odGhpcy52YWx1ZXMsIHN0eWxlTmFtZSk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZSgpIHtcbiAgICAgICAgdGhpcy5zZXQodGhpcy52YWx1ZXMubGVuZ3RoID8gdGhpcy52YWx1ZXMuam9pbihcIiwgXCIpIDogXCJhdXRvXCIpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdXNlV2lsbENoYW5nZSgpIHtcbiAgICByZXR1cm4gdXNlQ29uc3RhbnQoKCkgPT4gbmV3IFdpbGxDaGFuZ2VNb3Rpb25WYWx1ZShcImF1dG9cIikpO1xufVxuXG4vKipcbiAqIEEgaG9vayB0aGF0IHJldHVybnMgYHRydWVgIGlmIHdlIHNob3VsZCBiZSB1c2luZyByZWR1Y2VkIG1vdGlvbiBiYXNlZCBvbiB0aGUgY3VycmVudCBkZXZpY2UncyBSZWR1Y2VkIE1vdGlvbiBzZXR0aW5nLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWQgdG8gaW1wbGVtZW50IGNoYW5nZXMgdG8geW91ciBVSSBiYXNlZCBvbiBSZWR1Y2VkIE1vdGlvbi4gRm9yIGluc3RhbmNlLCByZXBsYWNpbmcgbW90aW9uLXNpY2tuZXNzIGluZHVjaW5nXG4gKiBgeGAvYHlgIGFuaW1hdGlvbnMgd2l0aCBgb3BhY2l0eWAsIGRpc2FibGluZyB0aGUgYXV0b3BsYXkgb2YgYmFja2dyb3VuZCB2aWRlb3MsIG9yIHR1cm5pbmcgb2ZmIHBhcmFsbGF4IG1vdGlvbi5cbiAqXG4gKiBJdCB3aWxsIGFjdGl2ZWx5IHJlc3BvbmQgdG8gY2hhbmdlcyBhbmQgcmUtcmVuZGVyIHlvdXIgY29tcG9uZW50cyB3aXRoIHRoZSBsYXRlc3Qgc2V0dGluZy5cbiAqXG4gKiBgYGBqc3hcbiAqIGV4cG9ydCBmdW5jdGlvbiBTaWRlYmFyKHsgaXNPcGVuIH0pIHtcbiAqICAgY29uc3Qgc2hvdWxkUmVkdWNlTW90aW9uID0gdXNlUmVkdWNlZE1vdGlvbigpXG4gKiAgIGNvbnN0IGNsb3NlZFggPSBzaG91bGRSZWR1Y2VNb3Rpb24gPyAwIDogXCItMTAwJVwiXG4gKlxuICogICByZXR1cm4gKFxuICogICAgIDxtb3Rpb24uZGl2IGFuaW1hdGU9e3tcbiAqICAgICAgIG9wYWNpdHk6IGlzT3BlbiA/IDEgOiAwLFxuICogICAgICAgeDogaXNPcGVuID8gMCA6IGNsb3NlZFhcbiAqICAgICB9fSAvPlxuICogICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcmV0dXJuIGJvb2xlYW5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZVJlZHVjZWRNb3Rpb24oKSB7XG4gICAgLyoqXG4gICAgICogTGF6eSBpbml0aWFsaXNhdGlvbiBvZiBwcmVmZXJzUmVkdWNlZE1vdGlvblxuICAgICAqL1xuICAgICFoYXNSZWR1Y2VkTW90aW9uTGlzdGVuZXIuY3VycmVudCAmJiBpbml0UHJlZmVyc1JlZHVjZWRNb3Rpb24oKTtcbiAgICBjb25zdCBbc2hvdWxkUmVkdWNlTW90aW9uXSA9IFJlYWN0LnVzZVN0YXRlKHByZWZlcnNSZWR1Y2VkTW90aW9uLmN1cnJlbnQpO1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgICAgICAgd2Fybk9uY2Uoc2hvdWxkUmVkdWNlTW90aW9uICE9PSB0cnVlLCBcIllvdSBoYXZlIFJlZHVjZWQgTW90aW9uIGVuYWJsZWQgb24geW91ciBkZXZpY2UuIEFuaW1hdGlvbnMgbWF5IG5vdCBhcHBlYXIgYXMgZXhwZWN0ZWQuXCIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUT0RPIFNlZSBpZiBwZW9wbGUgbWlzcyBhdXRvbWF0aWNhbGx5IHVwZGF0aW5nIHNob3VsZFJlZHVjZU1vdGlvbiBzZXR0aW5nXG4gICAgICovXG4gICAgcmV0dXJuIHNob3VsZFJlZHVjZU1vdGlvbjtcbn1cblxuZnVuY3Rpb24gdXNlUmVkdWNlZE1vdGlvbkNvbmZpZygpIHtcbiAgICBjb25zdCByZWR1Y2VkTW90aW9uUHJlZmVyZW5jZSA9IHVzZVJlZHVjZWRNb3Rpb24oKTtcbiAgICBjb25zdCB7IHJlZHVjZWRNb3Rpb24gfSA9IFJlYWN0LnVzZUNvbnRleHQoTW90aW9uQ29uZmlnQ29udGV4dCk7XG4gICAgaWYgKHJlZHVjZWRNb3Rpb24gPT09IFwibmV2ZXJcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlZHVjZWRNb3Rpb24gPT09IFwiYWx3YXlzXCIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcmVkdWNlZE1vdGlvblByZWZlcmVuY2U7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzdG9wQW5pbWF0aW9uKHZpc3VhbEVsZW1lbnQpIHtcbiAgICB2aXN1YWxFbGVtZW50LnZhbHVlcy5mb3JFYWNoKCh2YWx1ZSkgPT4gdmFsdWUuc3RvcCgpKTtcbn1cbmZ1bmN0aW9uIHNldFZhcmlhbnRzKHZpc3VhbEVsZW1lbnQsIHZhcmlhbnRMYWJlbHMpIHtcbiAgICBjb25zdCByZXZlcnNlZExhYmVscyA9IFsuLi52YXJpYW50TGFiZWxzXS5yZXZlcnNlKCk7XG4gICAgcmV2ZXJzZWRMYWJlbHMuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IHZhcmlhbnQgPSB2aXN1YWxFbGVtZW50LmdldFZhcmlhbnQoa2V5KTtcbiAgICAgICAgdmFyaWFudCAmJiBzZXRUYXJnZXQodmlzdWFsRWxlbWVudCwgdmFyaWFudCk7XG4gICAgICAgIGlmICh2aXN1YWxFbGVtZW50LnZhcmlhbnRDaGlsZHJlbikge1xuICAgICAgICAgICAgdmlzdWFsRWxlbWVudC52YXJpYW50Q2hpbGRyZW4uZm9yRWFjaCgoY2hpbGQpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRWYXJpYW50cyhjaGlsZCwgdmFyaWFudExhYmVscyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuZnVuY3Rpb24gc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShkZWZpbml0aW9uKSkge1xuICAgICAgICByZXR1cm4gc2V0VmFyaWFudHModmlzdWFsRWxlbWVudCwgZGVmaW5pdGlvbik7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkZWZpbml0aW9uID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBzZXRWYXJpYW50cyh2aXN1YWxFbGVtZW50LCBbZGVmaW5pdGlvbl0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0VGFyZ2V0KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgIH1cbn1cbi8qKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBhbmltYXRpb25Db250cm9scygpIHtcbiAgICAvKipcbiAgICAgKiBUcmFjayB3aGV0aGVyIHRoZSBob3N0IGNvbXBvbmVudCBoYXMgbW91bnRlZC5cbiAgICAgKi9cbiAgICBsZXQgaGFzTW91bnRlZCA9IGZhbHNlO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBsaW5rZWQgY29tcG9uZW50IGFuaW1hdGlvbiBjb250cm9scy5cbiAgICAgKi9cbiAgICBjb25zdCBzdWJzY3JpYmVycyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBjb250cm9scyA9IHtcbiAgICAgICAgc3Vic2NyaWJlKHZpc3VhbEVsZW1lbnQpIHtcbiAgICAgICAgICAgIHN1YnNjcmliZXJzLmFkZCh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIHJldHVybiAoKSA9PiB2b2lkIHN1YnNjcmliZXJzLmRlbGV0ZSh2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnQoZGVmaW5pdGlvbiwgdHJhbnNpdGlvbk92ZXJyaWRlKSB7XG4gICAgICAgICAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoaGFzTW91bnRlZCwgXCJjb250cm9scy5zdGFydCgpIHNob3VsZCBvbmx5IGJlIGNhbGxlZCBhZnRlciBhIGNvbXBvbmVudCBoYXMgbW91bnRlZC4gQ29uc2lkZXIgY2FsbGluZyB3aXRoaW4gYSB1c2VFZmZlY3QgaG9vay5cIik7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25zID0gW107XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKCh2aXN1YWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgYW5pbWF0aW9ucy5wdXNoKGFuaW1hdGVWaXN1YWxFbGVtZW50KHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNpdGlvbk92ZXJyaWRlLFxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIFByb21pc2UuYWxsKGFuaW1hdGlvbnMpO1xuICAgICAgICB9LFxuICAgICAgICBzZXQoZGVmaW5pdGlvbikge1xuICAgICAgICAgICAgbW90aW9uVXRpbHMuaW52YXJpYW50KGhhc01vdW50ZWQsIFwiY29udHJvbHMuc2V0KCkgc2hvdWxkIG9ubHkgYmUgY2FsbGVkIGFmdGVyIGEgY29tcG9uZW50IGhhcyBtb3VudGVkLiBDb25zaWRlciBjYWxsaW5nIHdpdGhpbiBhIHVzZUVmZmVjdCBob29rLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzY3JpYmVycy5mb3JFYWNoKCh2aXN1YWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWVzKHZpc3VhbEVsZW1lbnQsIGRlZmluaXRpb24pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3AoKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5mb3JFYWNoKCh2aXN1YWxFbGVtZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc3RvcEFuaW1hdGlvbih2aXN1YWxFbGVtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBtb3VudCgpIHtcbiAgICAgICAgICAgIGhhc01vdW50ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBoYXNNb3VudGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgY29udHJvbHMuc3RvcCgpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBjb250cm9scztcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZSgpIHtcbiAgICBjb25zdCBzY29wZSA9IHVzZUNvbnN0YW50KCgpID0+ICh7XG4gICAgICAgIGN1cnJlbnQ6IG51bGwsIC8vIFdpbGwgYmUgaHlkcmF0ZWQgYnkgUmVhY3RcbiAgICAgICAgYW5pbWF0aW9uczogW10sXG4gICAgfSkpO1xuICAgIGNvbnN0IGFuaW1hdGUgPSB1c2VDb25zdGFudCgoKSA9PiBjcmVhdGVTY29wZWRBbmltYXRlKHNjb3BlKSk7XG4gICAgdXNlVW5tb3VudEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNjb3BlLmFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiBhbmltYXRpb24uc3RvcCgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Njb3BlLCBhbmltYXRlXTtcbn1cblxuZnVuY3Rpb24gdXNlQW5pbWF0ZU1pbmkoKSB7XG4gICAgY29uc3Qgc2NvcGUgPSB1c2VDb25zdGFudCgoKSA9PiAoe1xuICAgICAgICBjdXJyZW50OiBudWxsLCAvLyBXaWxsIGJlIGh5ZHJhdGVkIGJ5IFJlYWN0XG4gICAgICAgIGFuaW1hdGlvbnM6IFtdLFxuICAgIH0pKTtcbiAgICBjb25zdCBhbmltYXRlID0gdXNlQ29uc3RhbnQoKCkgPT4gY3JlYXRlU2NvcGVkV2FhcGlBbmltYXRlKHNjb3BlKSk7XG4gICAgdXNlVW5tb3VudEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIHNjb3BlLmFuaW1hdGlvbnMuZm9yRWFjaCgoYW5pbWF0aW9uKSA9PiBhbmltYXRpb24uc3RvcCgpKTtcbiAgICB9KTtcbiAgICByZXR1cm4gW3Njb3BlLCBhbmltYXRlXTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGBBbmltYXRpb25Db250cm9sc2AsIHdoaWNoIGNhbiBiZSB1c2VkIHRvIG1hbnVhbGx5IHN0YXJ0LCBzdG9wXG4gKiBhbmQgc2VxdWVuY2UgYW5pbWF0aW9ucyBvbiBvbmUgb3IgbW9yZSBjb21wb25lbnRzLlxuICpcbiAqIFRoZSByZXR1cm5lZCBgQW5pbWF0aW9uQ29udHJvbHNgIHNob3VsZCBiZSBwYXNzZWQgdG8gdGhlIGBhbmltYXRlYCBwcm9wZXJ0eVxuICogb2YgdGhlIGNvbXBvbmVudHMgeW91IHdhbnQgdG8gYW5pbWF0ZS5cbiAqXG4gKiBUaGVzZSBjb21wb25lbnRzIGNhbiB0aGVuIGJlIGFuaW1hdGVkIHdpdGggdGhlIGBzdGFydGAgbWV0aG9kLlxuICpcbiAqIGBgYGpzeFxuICogaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnXG4gKiBpbXBvcnQgeyBtb3Rpb24sIHVzZUFuaW1hdGlvbiB9IGZyb20gJ2ZyYW1lci1tb3Rpb24nXG4gKlxuICogZXhwb3J0IGZ1bmN0aW9uIE15Q29tcG9uZW50KHByb3BzKSB7XG4gKiAgICBjb25zdCBjb250cm9scyA9IHVzZUFuaW1hdGlvbigpXG4gKlxuICogICAgY29udHJvbHMuc3RhcnQoe1xuICogICAgICAgIHg6IDEwMCxcbiAqICAgICAgICB0cmFuc2l0aW9uOiB7IGR1cmF0aW9uOiAwLjUgfSxcbiAqICAgIH0pXG4gKlxuICogICAgcmV0dXJuIDxtb3Rpb24uZGl2IGFuaW1hdGU9e2NvbnRyb2xzfSAvPlxuICogfVxuICogYGBgXG4gKlxuICogQHJldHVybnMgQW5pbWF0aW9uIGNvbnRyb2xsZXIgd2l0aCBgc3RhcnRgIGFuZCBgc3RvcGAgbWV0aG9kc1xuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlQW5pbWF0aW9uQ29udHJvbHMoKSB7XG4gICAgY29uc3QgY29udHJvbHMgPSB1c2VDb25zdGFudChhbmltYXRpb25Db250cm9scyk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdChjb250cm9scy5tb3VudCwgW10pO1xuICAgIHJldHVybiBjb250cm9scztcbn1cbmNvbnN0IHVzZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbkNvbnRyb2xzO1xuXG4vKipcbiAqIEF0dGFjaGVzIGFuIGV2ZW50IGxpc3RlbmVyIGRpcmVjdGx5IHRvIHRoZSBwcm92aWRlZCBET00gZWxlbWVudC5cbiAqXG4gKiBCeXBhc3NpbmcgUmVhY3QncyBldmVudCBzeXN0ZW0gY2FuIGJlIGRlc2lyYWJsZSwgZm9yIGluc3RhbmNlIHdoZW4gYXR0YWNoaW5nIG5vbi1wYXNzaXZlXG4gKiBldmVudCBoYW5kbGVycy5cbiAqXG4gKiBgYGBqc3hcbiAqIGNvbnN0IHJlZiA9IHVzZVJlZihudWxsKVxuICpcbiAqIHVzZURvbUV2ZW50KHJlZiwgJ3doZWVsJywgb25XaGVlbCwgeyBwYXNzaXZlOiBmYWxzZSB9KVxuICpcbiAqIHJldHVybiA8ZGl2IHJlZj17cmVmfSAvPlxuICogYGBgXG4gKlxuICogQHBhcmFtIHJlZiAtIFJlYWN0LlJlZk9iamVjdCB0aGF0J3MgYmVlbiBwcm92aWRlZCB0byB0aGUgZWxlbWVudCB5b3Ugd2FudCB0byBiaW5kIHRoZSBsaXN0ZW5lciB0by5cbiAqIEBwYXJhbSBldmVudE5hbWUgLSBOYW1lIG9mIHRoZSBldmVudCB5b3Ugd2FudCBsaXN0ZW4gZm9yLlxuICogQHBhcmFtIGhhbmRsZXIgLSBGdW5jdGlvbiB0byBmaXJlIHdoZW4gcmVjZWl2aW5nIHRoZSBldmVudC5cbiAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIGBFdmVudC5hZGRFdmVudExpc3RlbmVyYC5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHVzZURvbUV2ZW50KHJlZiwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHJlZi5jdXJyZW50O1xuICAgICAgICBpZiAoaGFuZGxlciAmJiBlbGVtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gYWRkRG9tRXZlbnQoZWxlbWVudCwgZXZlbnROYW1lLCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgIH0sIFtyZWYsIGV2ZW50TmFtZSwgaGFuZGxlciwgb3B0aW9uc10pO1xufVxuXG4vKipcbiAqIENhbiBtYW51YWxseSB0cmlnZ2VyIGEgZHJhZyBnZXN0dXJlIG9uIG9uZSBvciBtb3JlIGBkcmFnYC1lbmFibGVkIGBtb3Rpb25gIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuY2xhc3MgRHJhZ0NvbnRyb2xzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scyA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlIGEgY29tcG9uZW50J3MgaW50ZXJuYWwgYFZpc3VhbEVsZW1lbnREcmFnQ29udHJvbHNgIHRvIHRoZSB1c2VyLWZhY2luZyBBUEkuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY29udHJvbHMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5hZGQoY29udHJvbHMpO1xuICAgICAgICByZXR1cm4gKCkgPT4gdGhpcy5jb21wb25lbnRDb250cm9scy5kZWxldGUoY29udHJvbHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCBhIGRyYWcgZ2VzdHVyZSBvbiBldmVyeSBgbW90aW9uYCBjb21wb25lbnQgdGhhdCBoYXMgdGhpcyBzZXQgb2YgZHJhZyBjb250cm9sc1xuICAgICAqIHBhc3NlZCBpbnRvIGl0IHZpYSB0aGUgYGRyYWdDb250cm9sc2AgcHJvcC5cbiAgICAgKlxuICAgICAqIGBgYGpzeFxuICAgICAqIGRyYWdDb250cm9scy5zdGFydChlLCB7XG4gICAgICogICBzbmFwVG9DdXJzb3I6IHRydWVcbiAgICAgKiB9KVxuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IC0gUG9pbnRlckV2ZW50XG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc3RhcnQoZXZlbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnRDb250cm9scy5mb3JFYWNoKChjb250cm9scykgPT4ge1xuICAgICAgICAgICAgY29udHJvbHMuc3RhcnQoZXZlbnQubmF0aXZlRXZlbnQgfHwgZXZlbnQsIG9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCBjcmVhdGVEcmFnQ29udHJvbHMgPSAoKSA9PiBuZXcgRHJhZ0NvbnRyb2xzKCk7XG4vKipcbiAqIFVzdWFsbHksIGRyYWdnaW5nIGlzIGluaXRpYXRlZCBieSBwcmVzc2luZyBkb3duIG9uIGEgYG1vdGlvbmAgY29tcG9uZW50IHdpdGggYSBgZHJhZ2AgcHJvcFxuICogYW5kIG1vdmluZyBpdC4gRm9yIHNvbWUgdXNlLWNhc2VzLCBmb3IgaW5zdGFuY2UgY2xpY2tpbmcgYXQgYW4gYXJiaXRyYXJ5IHBvaW50IG9uIGEgdmlkZW8gc2NydWJiZXIsIHdlXG4gKiBtaWdodCB3YW50IHRvIGluaXRpYXRlIHRoYXQgZHJhZ2dpbmcgZnJvbSBhIGRpZmZlcmVudCBjb21wb25lbnQgdGhhbiB0aGUgZHJhZ2dhYmxlIG9uZS5cbiAqXG4gKiBCeSBjcmVhdGluZyBhIGBkcmFnQ29udHJvbHNgIHVzaW5nIHRoZSBgdXNlRHJhZ0NvbnRyb2xzYCBob29rLCB3ZSBjYW4gcGFzcyB0aGlzIGludG9cbiAqIHRoZSBkcmFnZ2FibGUgY29tcG9uZW50J3MgYGRyYWdDb250cm9sc2AgcHJvcC4gSXQgZXhwb3NlcyBhIGBzdGFydGAgbWV0aG9kXG4gKiB0aGF0IGNhbiBzdGFydCBkcmFnZ2luZyBmcm9tIHBvaW50ZXIgZXZlbnRzIG9uIG90aGVyIGNvbXBvbmVudHMuXG4gKlxuICogYGBganN4XG4gKiBjb25zdCBkcmFnQ29udHJvbHMgPSB1c2VEcmFnQ29udHJvbHMoKVxuICpcbiAqIGZ1bmN0aW9uIHN0YXJ0RHJhZyhldmVudCkge1xuICogICBkcmFnQ29udHJvbHMuc3RhcnQoZXZlbnQsIHsgc25hcFRvQ3Vyc29yOiB0cnVlIH0pXG4gKiB9XG4gKlxuICogcmV0dXJuIChcbiAqICAgPD5cbiAqICAgICA8ZGl2IG9uUG9pbnRlckRvd249e3N0YXJ0RHJhZ30gLz5cbiAqICAgICA8bW90aW9uLmRpdiBkcmFnPVwieFwiIGRyYWdDb250cm9scz17ZHJhZ0NvbnRyb2xzfSAvPlxuICogICA8Lz5cbiAqIClcbiAqIGBgYFxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlRHJhZ0NvbnRyb2xzKCkge1xuICAgIHJldHVybiB1c2VDb25zdGFudChjcmVhdGVEcmFnQ29udHJvbHMpO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGNvbXBvbmVudCBpcyBhIGBtb3Rpb25gIGNvbXBvbmVudC5cbiAqL1xuZnVuY3Rpb24gaXNNb3Rpb25Db21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgcmV0dXJuIChjb21wb25lbnQgIT09IG51bGwgJiZcbiAgICAgICAgdHlwZW9mIGNvbXBvbmVudCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICBtb3Rpb25Db21wb25lbnRTeW1ib2wgaW4gY29tcG9uZW50KTtcbn1cblxuLyoqXG4gKiBVbndyYXBzIGEgYG1vdGlvbmAgY29tcG9uZW50IGFuZCByZXR1cm5zIGVpdGhlciBhIHN0cmluZyBmb3IgYG1vdGlvbi5kaXZgIG9yXG4gKiB0aGUgUmVhY3QgY29tcG9uZW50IGZvciBgbW90aW9uKENvbXBvbmVudClgLlxuICpcbiAqIElmIHRoZSBjb21wb25lbnQgaXMgbm90IGEgYG1vdGlvbmAgY29tcG9uZW50IGl0IHJldHVybnMgdW5kZWZpbmVkLlxuICovXG5mdW5jdGlvbiB1bndyYXBNb3Rpb25Db21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgaWYgKGlzTW90aW9uQ29tcG9uZW50KGNvbXBvbmVudCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudFttb3Rpb25Db21wb25lbnRTeW1ib2xdO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbigpIHtcbiAgICByZXR1cm4gc3RhcnRUcmFuc2l0aW9uO1xufVxuZnVuY3Rpb24gc3RhcnRUcmFuc2l0aW9uKGNhbGxiYWNrKSB7XG4gICAgaWYgKCFyb290UHJvamVjdGlvbk5vZGUuY3VycmVudClcbiAgICAgICAgcmV0dXJuO1xuICAgIHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50LmlzVXBkYXRpbmcgPSBmYWxzZTtcbiAgICByb290UHJvamVjdGlvbk5vZGUuY3VycmVudC5ibG9ja1VwZGF0ZSgpO1xuICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKCk7XG59XG5cbmZ1bmN0aW9uIHVzZVJlc2V0UHJvamVjdGlvbigpIHtcbiAgICBjb25zdCByZXNldCA9IFJlYWN0LnVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICAgICAgY29uc3Qgcm9vdCA9IHJvb3RQcm9qZWN0aW9uTm9kZS5jdXJyZW50O1xuICAgICAgICBpZiAoIXJvb3QpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHJvb3QucmVzZXRUcmVlKCk7XG4gICAgfSwgW10pO1xuICAgIHJldHVybiByZXNldDtcbn1cblxuLyoqXG4gKiBDeWNsZXMgdGhyb3VnaCBhIHNlcmllcyBvZiB2aXN1YWwgcHJvcGVydGllcy4gQ2FuIGJlIHVzZWQgdG8gdG9nZ2xlIGJldHdlZW4gb3IgY3ljbGUgdGhyb3VnaCBhbmltYXRpb25zLiBJdCB3b3JrcyBzaW1pbGFyIHRvIGB1c2VTdGF0ZWAgaW4gUmVhY3QuIEl0IGlzIHByb3ZpZGVkIGFuIGluaXRpYWwgYXJyYXkgb2YgcG9zc2libGUgc3RhdGVzLCBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0d28gYXJndW1lbnRzLlxuICpcbiAqIEFuIGluZGV4IHZhbHVlIGNhbiBiZSBwYXNzZWQgdG8gdGhlIHJldHVybmVkIGBjeWNsZWAgZnVuY3Rpb24gdG8gY3ljbGUgdG8gYSBzcGVjaWZpYyBpbmRleC5cbiAqXG4gKiBgYGBqc3hcbiAqIGltcG9ydCAqIGFzIFJlYWN0IGZyb20gXCJyZWFjdFwiXG4gKiBpbXBvcnQgeyBtb3Rpb24sIHVzZUN5Y2xlIH0gZnJvbSBcImZyYW1lci1tb3Rpb25cIlxuICpcbiAqIGV4cG9ydCBjb25zdCBNeUNvbXBvbmVudCA9ICgpID0+IHtcbiAqICAgY29uc3QgW3gsIGN5Y2xlWF0gPSB1c2VDeWNsZSgwLCA1MCwgMTAwKVxuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8bW90aW9uLmRpdlxuICogICAgICAgYW5pbWF0ZT17eyB4OiB4IH19XG4gKiAgICAgICBvblRhcD17KCkgPT4gY3ljbGVYKCl9XG4gKiAgICAgIC8+XG4gKiAgICApXG4gKiB9XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gaXRlbXMgLSBpdGVtcyB0byBjeWNsZSB0aHJvdWdoXG4gKiBAcmV0dXJucyBbY3VycmVudFN0YXRlLCBjeWNsZVN0YXRlXVxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdXNlQ3ljbGUoLi4uaXRlbXMpIHtcbiAgICBjb25zdCBpbmRleCA9IFJlYWN0LnVzZVJlZigwKTtcbiAgICBjb25zdCBbaXRlbSwgc2V0SXRlbV0gPSBSZWFjdC51c2VTdGF0ZShpdGVtc1tpbmRleC5jdXJyZW50XSk7XG4gICAgY29uc3QgcnVuQ3ljbGUgPSBSZWFjdC51c2VDYWxsYmFjaygobmV4dCkgPT4ge1xuICAgICAgICBpbmRleC5jdXJyZW50ID1cbiAgICAgICAgICAgIHR5cGVvZiBuZXh0ICE9PSBcIm51bWJlclwiXG4gICAgICAgICAgICAgICAgPyB3cmFwKDAsIGl0ZW1zLmxlbmd0aCwgaW5kZXguY3VycmVudCArIDEpXG4gICAgICAgICAgICAgICAgOiBuZXh0O1xuICAgICAgICBzZXRJdGVtKGl0ZW1zW2luZGV4LmN1cnJlbnRdKTtcbiAgICB9LCBcbiAgICAvLyBUaGUgYXJyYXkgd2lsbCBjaGFuZ2Ugb24gZWFjaCBjYWxsLCBidXQgYnkgcHV0dGluZyBpdGVtcy5sZW5ndGggYXRcbiAgICAvLyB0aGUgZnJvbnQgb2YgdGhpcyBhcnJheSwgd2UgZ3VhcmFudGVlIHRoZSBkZXBlbmRlbmN5IGNvbXBhcmlzb24gd2lsbCBtYXRjaCB1cFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1ob29rcy9leGhhdXN0aXZlLWRlcHNcbiAgICBbaXRlbXMubGVuZ3RoLCAuLi5pdGVtc10pO1xuICAgIHJldHVybiBbaXRlbSwgcnVuQ3ljbGVdO1xufVxuXG5mdW5jdGlvbiB1c2VJblZpZXcocmVmLCB7IHJvb3QsIG1hcmdpbiwgYW1vdW50LCBvbmNlID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgW2lzSW5WaWV3LCBzZXRJblZpZXddID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuICAgIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmICghcmVmLmN1cnJlbnQgfHwgKG9uY2UgJiYgaXNJblZpZXcpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjb25zdCBvbkVudGVyID0gKCkgPT4ge1xuICAgICAgICAgICAgc2V0SW5WaWV3KHRydWUpO1xuICAgICAgICAgICAgcmV0dXJuIG9uY2UgPyB1bmRlZmluZWQgOiAoKSA9PiBzZXRJblZpZXcoZmFsc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgcm9vdDogKHJvb3QgJiYgcm9vdC5jdXJyZW50KSB8fCB1bmRlZmluZWQsXG4gICAgICAgICAgICBtYXJnaW4sXG4gICAgICAgICAgICBhbW91bnQsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBpblZpZXcocmVmLmN1cnJlbnQsIG9uRW50ZXIsIG9wdGlvbnMpO1xuICAgIH0sIFtyb290LCByZWYsIG1hcmdpbiwgb25jZSwgYW1vdW50XSk7XG4gICAgcmV0dXJuIGlzSW5WaWV3O1xufVxuXG5mdW5jdGlvbiB1c2VJbnN0YW50VHJhbnNpdGlvbigpIHtcbiAgICBjb25zdCBbZm9yY2VVcGRhdGUsIGZvcmNlZFJlbmRlckNvdW50XSA9IHVzZUZvcmNlVXBkYXRlKCk7XG4gICAgY29uc3Qgc3RhcnRJbnN0YW50TGF5b3V0VHJhbnNpdGlvbiA9IHVzZUluc3RhbnRMYXlvdXRUcmFuc2l0aW9uKCk7XG4gICAgY29uc3QgdW5sb2NrT25GcmFtZVJlZiA9IFJlYWN0LnVzZVJlZigtMSk7XG4gICAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuYmxvY2sgYWZ0ZXIgdHdvIGFuaW1hdGlvbiBmcmFtZXMsIG90aGVyd2lzZSB0aGlzIHdpbGwgdW5ibG9jayB0b28gc29vbi5cbiAgICAgICAgICovXG4gICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4gZnJhbWUucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIElmIHRoZSBjYWxsYmFjayBoYXMgYmVlbiBjYWxsZWQgYWdhaW4gYWZ0ZXIgdGhlIGVmZmVjdFxuICAgICAgICAgICAgICogdHJpZ2dlcmVkIHRoaXMgMiBmcmFtZSBkZWxheSwgZG9uJ3QgdW5ibG9jayBhbmltYXRpb25zLiBUaGlzXG4gICAgICAgICAgICAgKiBwcmV2ZW50cyB0aGUgcHJldmlvdXMgZWZmZWN0IGZyb20gdW5ibG9ja2luZyB0aGUgY3VycmVudFxuICAgICAgICAgICAgICogaW5zdGFudCB0cmFuc2l0aW9uIHRvbyBzb29uLiBUaGlzIGJlY29tZXMgbW9yZSBsaWtlbHkgd2hlblxuICAgICAgICAgICAgICogdXNlZCBpbiBjb25qdW5jdGlvbiB3aXRoIFJlYWN0LnN0YXJ0VHJhbnNpdGlvbigpLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZm9yY2VkUmVuZGVyQ291bnQgIT09IHVubG9ja09uRnJhbWVSZWYuY3VycmVudClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCA9IGZhbHNlO1xuICAgICAgICB9KSk7XG4gICAgfSwgW2ZvcmNlZFJlbmRlckNvdW50XSk7XG4gICAgcmV0dXJuIChjYWxsYmFjaykgPT4ge1xuICAgICAgICBzdGFydEluc3RhbnRMYXlvdXRUcmFuc2l0aW9uKCgpID0+IHtcbiAgICAgICAgICAgIGluc3RhbnRBbmltYXRpb25TdGF0ZS5jdXJyZW50ID0gdHJ1ZTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgdW5sb2NrT25GcmFtZVJlZi5jdXJyZW50ID0gZm9yY2VkUmVuZGVyQ291bnQgKyAxO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZGlzYWJsZUluc3RhbnRUcmFuc2l0aW9ucygpIHtcbiAgICBpbnN0YW50QW5pbWF0aW9uU3RhdGUuY3VycmVudCA9IGZhbHNlO1xufVxuXG5jb25zdCBhcHBlYXJTdG9yZUlkID0gKGVsZW1lbnRJZCwgdmFsdWVOYW1lKSA9PiB7XG4gICAgY29uc3Qga2V5ID0gdHJhbnNmb3JtUHJvcHMuaGFzKHZhbHVlTmFtZSkgPyBcInRyYW5zZm9ybVwiIDogdmFsdWVOYW1lO1xuICAgIHJldHVybiBgJHtlbGVtZW50SWR9OiAke2tleX1gO1xufTtcblxuY29uc3QgYXBwZWFyQW5pbWF0aW9uU3RvcmUgPSBuZXcgTWFwKCk7XG5jb25zdCBhcHBlYXJDb21wbGV0ZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gaGFuZG9mZk9wdGltaXplZEFwcGVhckFuaW1hdGlvbihlbGVtZW50SWQsIHZhbHVlTmFtZSwgZnJhbWUpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3Qgc3RvcmVJZCA9IGFwcGVhclN0b3JlSWQoZWxlbWVudElkLCB2YWx1ZU5hbWUpO1xuICAgIGNvbnN0IG9wdGltaXNlZEFuaW1hdGlvbiA9IGFwcGVhckFuaW1hdGlvblN0b3JlLmdldChzdG9yZUlkKTtcbiAgICBpZiAoIW9wdGltaXNlZEFuaW1hdGlvbikge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgeyBhbmltYXRpb24sIHN0YXJ0VGltZSB9ID0gb3B0aW1pc2VkQW5pbWF0aW9uO1xuICAgIGZ1bmN0aW9uIGNhbmNlbEFuaW1hdGlvbigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAoX2EgPSB3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIGVsZW1lbnRJZCwgdmFsdWVOYW1lLCBmcmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdlIGNhbiBjYW5jZWwgdGhlIGFuaW1hdGlvbiBvbmNlIGl0J3MgZmluaXNoZWQgbm93IHRoYXQgd2UndmUgc3luY2VkXG4gICAgICogd2l0aCBNb3Rpb24uXG4gICAgICpcbiAgICAgKiBQcmVmZXIgb25maW5pc2ggb3ZlciBmaW5pc2hlZCBhcyBvbmZpbmlzaCBpcyBiYWNrd2FyZHMgY29tcGF0aWJsZSB3aXRoXG4gICAgICogb2xkZXIgYnJvd3NlcnMuXG4gICAgICovXG4gICAgYW5pbWF0aW9uLm9uZmluaXNoID0gY2FuY2VsQW5pbWF0aW9uO1xuICAgIGlmIChzdGFydFRpbWUgPT09IG51bGwgfHwgKChfYSA9IHdpbmRvdy5Nb3Rpb25IYW5kb2ZmSXNDb21wbGV0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBlbGVtZW50SWQpKSkge1xuICAgICAgICAvKipcbiAgICAgICAgICogSWYgdGhlIHN0YXJ0VGltZSBpcyBudWxsLCB0aGlzIGFuaW1hdGlvbiBpcyB0aGUgUGFpbnQgUmVhZHkgZGV0ZWN0aW9uIGFuaW1hdGlvblxuICAgICAgICAgKiBhbmQgd2UgY2FuIGNhbmNlbCBpdCBpbW1lZGlhdGVseSB3aXRob3V0IGhhbmRvZmYuXG4gICAgICAgICAqXG4gICAgICAgICAqIE9yIGlmIHdlJ3ZlIGFscmVhZHkgaGFuZGVkIG9mZiB0aGUgYW5pbWF0aW9uIHRoZW4gd2UncmUgbm93IGludGVycnVwdGluZyBpdC5cbiAgICAgICAgICogSW4gd2hpY2ggY2FzZSB3ZSBuZWVkIHRvIGNhbmNlbCBpdC5cbiAgICAgICAgICovXG4gICAgICAgIGNhbmNlbEFuaW1hdGlvbigpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBzdGFydFRpbWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEEgc2luZ2xlIHRpbWUgdG8gdXNlIGFjcm9zcyBhbGwgYW5pbWF0aW9ucyB0byBtYW51YWxseSBzZXQgc3RhcnRUaW1lXG4gKiBhbmQgZW5zdXJlIHRoZXkncmUgYWxsIGluIHN5bmMuXG4gKi9cbmxldCBzdGFydEZyYW1lVGltZTtcbi8qKlxuICogQSBkdW1teSBhbmltYXRpb24gdG8gZGV0ZWN0IHdoZW4gQ2hyb21lIGlzIHJlYWR5IHRvIHN0YXJ0XG4gKiBwYWludGluZyB0aGUgcGFnZSBhbmQgaG9sZCBvZmYgZnJvbSB0cmlnZ2VyaW5nIHRoZSByZWFsIGFuaW1hdGlvblxuICogdW50aWwgdGhlbi4gV2Ugb25seSBuZWVkIG9uZSBhbmltYXRpb24gdG8gZGV0ZWN0IHBhaW50IHJlYWR5LlxuICpcbiAqIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTE0MDY4NTBcbiAqL1xubGV0IHJlYWR5QW5pbWF0aW9uO1xuLyoqXG4gKiBLZWVwIHRyYWNrIG9mIGFuaW1hdGlvbnMgdGhhdCB3ZXJlIHN1c3BlbmRlZCB2cyBjYW5jZWxsZWQgc28gd2VcbiAqIGNhbiBlYXNpbHkgcmVzdW1lIHRoZW0gd2hlbiB3ZSdyZSBkb25lIG1lYXN1cmluZyBsYXlvdXQuXG4gKi9cbmNvbnN0IHN1c3BlbmRlZEFuaW1hdGlvbnMgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiByZXN1bWVTdXNwZW5kZWRBbmltYXRpb25zKCkge1xuICAgIHN1c3BlbmRlZEFuaW1hdGlvbnMuZm9yRWFjaCgoZGF0YSkgPT4ge1xuICAgICAgICBkYXRhLmFuaW1hdGlvbi5wbGF5KCk7XG4gICAgICAgIGRhdGEuYW5pbWF0aW9uLnN0YXJ0VGltZSA9IGRhdGEuc3RhcnRUaW1lO1xuICAgIH0pO1xuICAgIHN1c3BlbmRlZEFuaW1hdGlvbnMuY2xlYXIoKTtcbn1cbmZ1bmN0aW9uIHN0YXJ0T3B0aW1pemVkQXBwZWFyQW5pbWF0aW9uKGVsZW1lbnQsIG5hbWUsIGtleWZyYW1lcywgb3B0aW9ucywgb25SZWFkeSkge1xuICAgIC8vIFByZXZlbnQgb3B0aW1pc2VkIGFwcGVhciBhbmltYXRpb25zIGlmIE1vdGlvbiBoYXMgYWxyZWFkeSBzdGFydGVkIGFuaW1hdGluZy5cbiAgICBpZiAod2luZG93Lk1vdGlvbklzTW91bnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlkID0gZWxlbWVudC5kYXRhc2V0W29wdGltaXplZEFwcGVhckRhdGFJZF07XG4gICAgaWYgKCFpZClcbiAgICAgICAgcmV0dXJuO1xuICAgIHdpbmRvdy5Nb3Rpb25IYW5kb2ZmQW5pbWF0aW9uID0gaGFuZG9mZk9wdGltaXplZEFwcGVhckFuaW1hdGlvbjtcbiAgICBjb25zdCBzdG9yZUlkID0gYXBwZWFyU3RvcmVJZChpZCwgbmFtZSk7XG4gICAgaWYgKCFyZWFkeUFuaW1hdGlvbikge1xuICAgICAgICByZWFkeUFuaW1hdGlvbiA9IHN0YXJ0V2FhcGlBbmltYXRpb24oZWxlbWVudCwgbmFtZSwgW2tleWZyYW1lc1swXSwga2V5ZnJhbWVzWzBdXSwgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiAxMCBzZWNzIGlzIGJhc2ljYWxseSBqdXN0IGEgc3VwZXItc2FmZSBkdXJhdGlvbiB0byBnaXZlIENocm9tZVxuICAgICAgICAgKiBsb25nIGVub3VnaCB0byBnZXQgdGhlIGFuaW1hdGlvbiByZWFkeS5cbiAgICAgICAgICovXG4gICAgICAgIHsgZHVyYXRpb246IDEwMDAwLCBlYXNlOiBcImxpbmVhclwiIH0pO1xuICAgICAgICBhcHBlYXJBbmltYXRpb25TdG9yZS5zZXQoc3RvcmVJZCwge1xuICAgICAgICAgICAgYW5pbWF0aW9uOiByZWFkeUFuaW1hdGlvbixcbiAgICAgICAgICAgIHN0YXJ0VGltZTogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJZiB0aGVyZSdzIG5vIHJlYWR5QW5pbWF0aW9uIHRoZW4gdGhlcmUncyBiZWVuIG5vIGluc3RhbnRpYXRpb25cbiAgICAgICAgICogb2YgaGFuZG9mZiBhbmltYXRpb25zLlxuICAgICAgICAgKi9cbiAgICAgICAgd2luZG93Lk1vdGlvbkhhbmRvZmZBbmltYXRpb24gPSBoYW5kb2ZmT3B0aW1pemVkQXBwZWFyQW5pbWF0aW9uO1xuICAgICAgICB3aW5kb3cuTW90aW9uSGFzT3B0aW1pc2VkQW5pbWF0aW9uID0gKGVsZW1lbnRJZCwgdmFsdWVOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoIWVsZW1lbnRJZClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEtlZXAgYSBtYXAgb2YgZWxlbWVudElkcyB0aGF0IGhhdmUgc3RhcnRlZCBhbmltYXRpbmcuIFdlIGNoZWNrXG4gICAgICAgICAgICAgKiB2aWEgSUQgaW5zdGVhZCBvZiBFbGVtZW50IGJlY2F1c2Ugb2YgaHlkcmF0aW9uIGVycm9ycyBhbmRcbiAgICAgICAgICAgICAqIHByZS1oeWRyYXRpb24gY2hlY2tzLiBXZSBhbHNvIGFjdGl2ZWx5IHJlY29yZCBJRHMgYXMgdGhleSBzdGFydFxuICAgICAgICAgICAgICogYW5pbWF0aW5nIHJhdGhlciB0aGFuIHNpbXBseSBjaGVja2luZyBmb3IgZGF0YS1hcHBlYXItaWQgYXNcbiAgICAgICAgICAgICAqIHRoaXMgYXR0cmJ1dGUgbWlnaHQgYmUgcHJlc2VudCBidXQgbm90IGxlYWQgdG8gYW4gYW5pbWF0aW9uLCBmb3JcbiAgICAgICAgICAgICAqIGluc3RhbmNlIGlmIHRoZSBlbGVtZW50J3MgYXBwZWFyIGFuaW1hdGlvbiBpcyBvbiBhIGRpZmZlcmVudFxuICAgICAgICAgICAgICogYnJlYWtwb2ludC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgaWYgKCF2YWx1ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXBwZWFyQ29tcGxldGUuaGFzKGVsZW1lbnRJZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25JZCA9IGFwcGVhclN0b3JlSWQoZWxlbWVudElkLCB2YWx1ZU5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIEJvb2xlYW4oYXBwZWFyQW5pbWF0aW9uU3RvcmUuZ2V0KGFuaW1hdGlvbklkKSk7XG4gICAgICAgIH07XG4gICAgICAgIHdpbmRvdy5Nb3Rpb25IYW5kb2ZmTWFya0FzQ29tcGxldGUgPSAoZWxlbWVudElkKSA9PiB7XG4gICAgICAgICAgICBpZiAoYXBwZWFyQ29tcGxldGUuaGFzKGVsZW1lbnRJZCkpIHtcbiAgICAgICAgICAgICAgICBhcHBlYXJDb21wbGV0ZS5zZXQoZWxlbWVudElkLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgd2luZG93Lk1vdGlvbkhhbmRvZmZJc0NvbXBsZXRlID0gKGVsZW1lbnRJZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFwcGVhckNvbXBsZXRlLmdldChlbGVtZW50SWQpID09PSB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICAvKipcbiAgICAgICAgICogV2Ugb25seSBuZWVkIHRvIGNhbmNlbCB0cmFuc2Zvcm0gYW5pbWF0aW9ucyBhc1xuICAgICAgICAgKiB0aGV5J3JlIHRoZSBvbmVzIHRoYXQgd2lsbCBpbnRlcmZlcmUgd2l0aCB0aGVcbiAgICAgICAgICogbGF5b3V0IGFuaW1hdGlvbiBtZWFzdXJlbWVudHMuXG4gICAgICAgICAqL1xuICAgICAgICB3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uID0gKGVsZW1lbnRJZCwgdmFsdWVOYW1lLCBmcmFtZSwgY2FuUmVzdW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhbmltYXRpb25JZCA9IGFwcGVhclN0b3JlSWQoZWxlbWVudElkLCB2YWx1ZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IGFwcGVhckFuaW1hdGlvblN0b3JlLmdldChhbmltYXRpb25JZCk7XG4gICAgICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKGZyYW1lICYmIGNhblJlc3VtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogV2FpdCB1bnRpbCB0aGUgZW5kIG9mIHRoZSBzdWJzZXF1ZW50IGZyYW1lIHRvIGNhbmNlbCB0aGUgYW5pbWF0aW9uXG4gICAgICAgICAgICAgICAgICogdG8gZW5zdXJlIHdlIGRvbid0IHJlbW92ZSB0aGUgYW5pbWF0aW9uIGJlZm9yZSB0aGUgbWFpbiB0aHJlYWQgaGFzXG4gICAgICAgICAgICAgICAgICogaGFkIGEgY2hhbmNlIHRvIHJlc29sdmUga2V5ZnJhbWVzIGFuZCByZW5kZXIuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgZnJhbWUucG9zdFJlbmRlcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGZyYW1lLnBvc3RSZW5kZXIoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGF0YS5hbmltYXRpb24uY2FuY2VsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZnJhbWUgJiYgY2FuUmVzdW1lKSB7XG4gICAgICAgICAgICAgICAgc3VzcGVuZGVkQW5pbWF0aW9ucy5hZGQoZGF0YSk7XG4gICAgICAgICAgICAgICAgZnJhbWUucmVuZGVyKHJlc3VtZVN1c3BlbmRlZEFuaW1hdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXBwZWFyQW5pbWF0aW9uU3RvcmUuZGVsZXRlKGFuaW1hdGlvbklkKTtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBJZiB0aGVyZSBhcmUgbm8gbW9yZSBhbmltYXRpb25zIGxlZnQsIHdlIGNhbiByZW1vdmUgdGhlIGNhbmNlbCBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICAgKiBUaGlzIHdpbGwgbGV0IHVzIGtub3cgd2hlbiB3ZSBjYW4gc3RvcCBjaGVja2luZyBmb3IgY29uZmxpY3RpbmcgbGF5b3V0IGFuaW1hdGlvbnMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFhcHBlYXJBbmltYXRpb25TdG9yZS5zaXplKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5Nb3Rpb25DYW5jZWxPcHRpbWlzZWRBbmltYXRpb24gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB3aW5kb3cuTW90aW9uQ2hlY2tBcHBlYXJTeW5jID0gKHZpc3VhbEVsZW1lbnQsIHZhbHVlTmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICBjb25zdCBhcHBlYXJJZCA9IGdldE9wdGltaXNlZEFwcGVhcklkKHZpc3VhbEVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFhcHBlYXJJZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjb25zdCB2YWx1ZUlzT3B0aW1pc2VkID0gKF9hID0gd2luZG93Lk1vdGlvbkhhc09wdGltaXNlZEFuaW1hdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNhbGwod2luZG93LCBhcHBlYXJJZCwgdmFsdWVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGV4dGVybmFsQW5pbWF0aW9uVmFsdWUgPSAoX2IgPSB2aXN1YWxFbGVtZW50LnByb3BzLnZhbHVlcykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW3ZhbHVlTmFtZV07XG4gICAgICAgICAgICBpZiAoIXZhbHVlSXNPcHRpbWlzZWQgfHwgIWV4dGVybmFsQW5pbWF0aW9uVmFsdWUpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgcmVtb3ZlU3luY0NoZWNrID0gdmFsdWUub24oXCJjaGFuZ2VcIiwgKGxhdGVzdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIGlmIChleHRlcm5hbEFuaW1hdGlvblZhbHVlLmdldCgpICE9PSBsYXRlc3RWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB3aW5kb3cuTW90aW9uQ2FuY2VsT3B0aW1pc2VkQW5pbWF0aW9uKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbCh3aW5kb3csIGFwcGVhcklkLCB2YWx1ZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVTeW5jQ2hlY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZW1vdmVTeW5jQ2hlY2s7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YXJ0QW5pbWF0aW9uID0gKCkgPT4ge1xuICAgICAgICByZWFkeUFuaW1hdGlvbi5jYW5jZWwoKTtcbiAgICAgICAgY29uc3QgYXBwZWFyQW5pbWF0aW9uID0gc3RhcnRXYWFwaUFuaW1hdGlvbihlbGVtZW50LCBuYW1lLCBrZXlmcmFtZXMsIG9wdGlvbnMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogUmVjb3JkIHRoZSB0aW1lIG9mIHRoZSBmaXJzdCBzdGFydGVkIGFuaW1hdGlvbi4gV2UgY2FsbCBwZXJmb3JtYW5jZS5ub3coKSBvbmNlXG4gICAgICAgICAqIGhlcmUgYW5kIG9uY2UgaW4gaGFuZG9mZiB0byBlbnN1cmUgd2UncmUgZ2V0dGluZ1xuICAgICAgICAgKiBjbG9zZSB0byBhIGZyYW1lLWxvY2tlZCB0aW1lLiBUaGlzIGtlZXBzIGFsbCBhbmltYXRpb25zIGluIHN5bmMuXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoc3RhcnRGcmFtZVRpbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgc3RhcnRGcmFtZVRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICBhcHBlYXJBbmltYXRpb24uc3RhcnRUaW1lID0gc3RhcnRGcmFtZVRpbWU7XG4gICAgICAgIGFwcGVhckFuaW1hdGlvblN0b3JlLnNldChzdG9yZUlkLCB7XG4gICAgICAgICAgICBhbmltYXRpb246IGFwcGVhckFuaW1hdGlvbixcbiAgICAgICAgICAgIHN0YXJ0VGltZTogc3RhcnRGcmFtZVRpbWUsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAob25SZWFkeSlcbiAgICAgICAgICAgIG9uUmVhZHkoYXBwZWFyQW5pbWF0aW9uKTtcbiAgICB9O1xuICAgIGFwcGVhckNvbXBsZXRlLnNldChpZCwgZmFsc2UpO1xuICAgIGlmIChyZWFkeUFuaW1hdGlvbi5yZWFkeSkge1xuICAgICAgICByZWFkeUFuaW1hdGlvbi5yZWFkeS50aGVuKHN0YXJ0QW5pbWF0aW9uKS5jYXRjaChtb3Rpb25VdGlscy5ub29wKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHN0YXJ0QW5pbWF0aW9uKCk7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVPYmplY3QgPSAoKSA9PiAoe30pO1xuY2xhc3MgU3RhdGVWaXN1YWxFbGVtZW50IGV4dGVuZHMgVmlzdWFsRWxlbWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgICAgIHRoaXMubWVhc3VyZUluc3RhbmNlVmlld3BvcnRCb3ggPSBjcmVhdGVCb3g7XG4gICAgfVxuICAgIGJ1aWxkKCkgeyB9XG4gICAgcmVzZXRUcmFuc2Zvcm0oKSB7IH1cbiAgICByZXN0b3JlVHJhbnNmb3JtKCkgeyB9XG4gICAgcmVtb3ZlVmFsdWVGcm9tUmVuZGVyU3RhdGUoKSB7IH1cbiAgICByZW5kZXJJbnN0YW5jZSgpIHsgfVxuICAgIHNjcmFwZU1vdGlvblZhbHVlc0Zyb21Qcm9wcygpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZU9iamVjdCgpO1xuICAgIH1cbiAgICBnZXRCYXNlVGFyZ2V0RnJvbVByb3BzKCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZWFkVmFsdWVGcm9tSW5zdGFuY2UoX3N0YXRlLCBrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuaW5pdGlhbFN0YXRlW2tleV0gfHwgMDtcbiAgICB9XG4gICAgc29ydEluc3RhbmNlTm9kZVBvc2l0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG59XG5jb25zdCB1c2VWaXN1YWxTdGF0ZSA9IG1ha2VVc2VWaXN1YWxTdGF0ZSh7XG4gICAgc2NyYXBlTW90aW9uVmFsdWVzRnJvbVByb3BzOiBjcmVhdGVPYmplY3QsXG4gICAgY3JlYXRlUmVuZGVyU3RhdGU6IGNyZWF0ZU9iamVjdCxcbn0pO1xuLyoqXG4gKiBUaGlzIGlzIG5vdCBhbiBvZmZpY2lhbGx5IHN1cHBvcnRlZCBBUEkgYW5kIG1heSBiZSByZW1vdmVkXG4gKiBvbiBhbnkgdmVyc2lvbi5cbiAqL1xuZnVuY3Rpb24gdXNlQW5pbWF0ZWRTdGF0ZShpbml0aWFsU3RhdGUpIHtcbiAgICBjb25zdCBbYW5pbWF0aW9uU3RhdGUsIHNldEFuaW1hdGlvblN0YXRlXSA9IFJlYWN0LnVzZVN0YXRlKGluaXRpYWxTdGF0ZSk7XG4gICAgY29uc3QgdmlzdWFsU3RhdGUgPSB1c2VWaXN1YWxTdGF0ZSh7fSwgZmFsc2UpO1xuICAgIGNvbnN0IGVsZW1lbnQgPSB1c2VDb25zdGFudCgoKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgU3RhdGVWaXN1YWxFbGVtZW50KHtcbiAgICAgICAgICAgIHByb3BzOiB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGU6ICh2KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNldEFuaW1hdGlvblN0YXRlKHsgLi4udiB9KTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHZpc3VhbFN0YXRlLFxuICAgICAgICAgICAgcHJlc2VuY2VDb250ZXh0OiBudWxsLFxuICAgICAgICB9LCB7IGluaXRpYWxTdGF0ZSB9KTtcbiAgICB9KTtcbiAgICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgICAgICBlbGVtZW50Lm1vdW50KHt9KTtcbiAgICAgICAgcmV0dXJuICgpID0+IGVsZW1lbnQudW5tb3VudCgpO1xuICAgIH0sIFtlbGVtZW50XSk7XG4gICAgY29uc3Qgc3RhcnRBbmltYXRpb24gPSB1c2VDb25zdGFudCgoKSA9PiAoYW5pbWF0aW9uRGVmaW5pdGlvbikgPT4ge1xuICAgICAgICByZXR1cm4gYW5pbWF0ZVZpc3VhbEVsZW1lbnQoZWxlbWVudCwgYW5pbWF0aW9uRGVmaW5pdGlvbik7XG4gICAgfSk7XG4gICAgcmV0dXJuIFthbmltYXRpb25TdGF0ZSwgc3RhcnRBbmltYXRpb25dO1xufVxuXG5sZXQgaWQgPSAwO1xuY29uc3QgQW5pbWF0ZVNoYXJlZExheW91dCA9ICh7IGNoaWxkcmVuIH0pID0+IHtcbiAgICBSZWFjdF9fbmFtZXNwYWNlLnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIG1vdGlvblV0aWxzLmludmFyaWFudChmYWxzZSwgXCJBbmltYXRlU2hhcmVkTGF5b3V0IGlzIGRlcHJlY2F0ZWQ6IGh0dHBzOi8vd3d3LmZyYW1lci5jb20vZG9jcy9ndWlkZS11cGdyYWRlLyMjc2hhcmVkLWxheW91dC1hbmltYXRpb25zXCIpO1xuICAgIH0sIFtdKTtcbiAgICByZXR1cm4gKGpzeFJ1bnRpbWUuanN4KExheW91dEdyb3VwLCB7IGlkOiB1c2VDb25zdGFudCgoKSA9PiBgYXNsLSR7aWQrK31gKSwgY2hpbGRyZW46IGNoaWxkcmVuIH0pKTtcbn07XG5cbi8vIEtlZXAgdGhpbmdzIHJlYXNvbmFibGUgYW5kIGF2b2lkIHNjYWxlOiBJbmZpbml0eS4gSW4gcHJhY3Rpc2Ugd2UgbWlnaHQgbmVlZFxuLy8gdG8gYWRkIGFub3RoZXIgdmFsdWUsIG9wYWNpdHksIHRoYXQgY291bGQgaW50ZXJwb2xhdGUgc2NhbGVYL1kgWzAsMC4wMV0gPT4gWzAsMV1cbi8vIHRvIHNpbXBseSBoaWRlIGNvbnRlbnQgYXQgdW5yZWFzb25hYmxlIHNjYWxlcy5cbmNvbnN0IG1heFNjYWxlID0gMTAwMDAwO1xuY29uc3QgaW52ZXJ0U2NhbGUgPSAoc2NhbGUpID0+IHNjYWxlID4gMC4wMDEgPyAxIC8gc2NhbGUgOiBtYXhTY2FsZTtcbmxldCBoYXNXYXJuZWQgPSBmYWxzZTtcbi8qKlxuICogUmV0dXJucyBhIGBNb3Rpb25WYWx1ZWAgZWFjaCBmb3IgYHNjYWxlWGAgYW5kIGBzY2FsZVlgIHRoYXQgdXBkYXRlIHdpdGggdGhlIGludmVyc2VcbiAqIG9mIHRoZWlyIHJlc3BlY3RpdmUgcGFyZW50IHNjYWxlcy5cbiAqXG4gKiBUaGlzIGlzIHVzZWZ1bCBmb3IgdW5kb2luZyB0aGUgZGlzdG9ydGlvbiBvZiBjb250ZW50IHdoZW4gc2NhbGluZyBhIHBhcmVudCBjb21wb25lbnQuXG4gKlxuICogQnkgZGVmYXVsdCwgYHVzZUludmVydGVkU2NhbGVgIHdpbGwgYXV0b21hdGljYWxseSBmZXRjaCBgc2NhbGVYYCBhbmQgYHNjYWxlWWAgZnJvbSB0aGUgbmVhcmVzdCBwYXJlbnQuXG4gKiBCeSBwYXNzaW5nIG90aGVyIGBNb3Rpb25WYWx1ZWBzIGluIGFzIGB1c2VJbnZlcnRlZFNjYWxlKHsgc2NhbGVYLCBzY2FsZVkgfSlgLCBpdCB3aWxsIGludmVydCB0aGUgb3V0cHV0XG4gKiBvZiB0aG9zZSBpbnN0ZWFkLlxuICpcbiAqIGBgYGpzeFxuICogY29uc3QgTXlDb21wb25lbnQgPSAoKSA9PiB7XG4gKiAgIGNvbnN0IHsgc2NhbGVYLCBzY2FsZVkgfSA9IHVzZUludmVydGVkU2NhbGUoKVxuICogICByZXR1cm4gPG1vdGlvbi5kaXYgc3R5bGU9e3sgc2NhbGVYLCBzY2FsZVkgfX0gLz5cbiAqIH1cbiAqIGBgYFxuICpcbiAqIEBkZXByZWNhdGVkXG4gKi9cbmZ1bmN0aW9uIHVzZUludmVydGVkU2NhbGUoc2NhbGUpIHtcbiAgICBsZXQgcGFyZW50U2NhbGVYID0gdXNlTW90aW9uVmFsdWUoMSk7XG4gICAgbGV0IHBhcmVudFNjYWxlWSA9IHVzZU1vdGlvblZhbHVlKDEpO1xuICAgIGNvbnN0IHsgdmlzdWFsRWxlbWVudCB9ID0gUmVhY3QudXNlQ29udGV4dChNb3Rpb25Db250ZXh0KTtcbiAgICBtb3Rpb25VdGlscy5pbnZhcmlhbnQoISEoc2NhbGUgfHwgdmlzdWFsRWxlbWVudCksIFwiSWYgbm8gc2NhbGUgdmFsdWVzIGFyZSBwcm92aWRlZCwgdXNlSW52ZXJ0ZWRTY2FsZSBtdXN0IGJlIHVzZWQgd2l0aGluIGEgY2hpbGQgb2YgYW5vdGhlciBtb3Rpb24gY29tcG9uZW50LlwiKTtcbiAgICBtb3Rpb25VdGlscy53YXJuaW5nKGhhc1dhcm5lZCwgXCJ1c2VJbnZlcnRlZFNjYWxlIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiAzLjAuIFVzZSB0aGUgbGF5b3V0IHByb3AgaW5zdGVhZC5cIik7XG4gICAgaGFzV2FybmVkID0gdHJ1ZTtcbiAgICBpZiAoc2NhbGUpIHtcbiAgICAgICAgcGFyZW50U2NhbGVYID0gc2NhbGUuc2NhbGVYIHx8IHBhcmVudFNjYWxlWDtcbiAgICAgICAgcGFyZW50U2NhbGVZID0gc2NhbGUuc2NhbGVZIHx8IHBhcmVudFNjYWxlWTtcbiAgICB9XG4gICAgZWxzZSBpZiAodmlzdWFsRWxlbWVudCkge1xuICAgICAgICBwYXJlbnRTY2FsZVggPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwic2NhbGVYXCIsIDEpO1xuICAgICAgICBwYXJlbnRTY2FsZVkgPSB2aXN1YWxFbGVtZW50LmdldFZhbHVlKFwic2NhbGVZXCIsIDEpO1xuICAgIH1cbiAgICBjb25zdCBzY2FsZVggPSB1c2VUcmFuc2Zvcm0ocGFyZW50U2NhbGVYLCBpbnZlcnRTY2FsZSk7XG4gICAgY29uc3Qgc2NhbGVZID0gdXNlVHJhbnNmb3JtKHBhcmVudFNjYWxlWSwgaW52ZXJ0U2NhbGUpO1xuICAgIHJldHVybiB7IHNjYWxlWCwgc2NhbGVZIH07XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImludmFyaWFudFwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblV0aWxzLmludmFyaWFudDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJub29wXCIsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbW90aW9uVXRpbHMubm9vcDsgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwcm9ncmVzc1wiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvblV0aWxzLnByb2dyZXNzOyB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImlzRHJhZ0FjdGl2ZVwiLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG1vdGlvbkRvbS5pc0RyYWdBY3RpdmU7IH1cbn0pO1xuZXhwb3J0cy5BY2NlbGVyYXRlZEFuaW1hdGlvbiA9IEFjY2VsZXJhdGVkQW5pbWF0aW9uO1xuZXhwb3J0cy5BbmltYXRlUHJlc2VuY2UgPSBBbmltYXRlUHJlc2VuY2U7XG5leHBvcnRzLkFuaW1hdGVTaGFyZWRMYXlvdXQgPSBBbmltYXRlU2hhcmVkTGF5b3V0O1xuZXhwb3J0cy5EZXByZWNhdGVkTGF5b3V0R3JvdXBDb250ZXh0ID0gRGVwcmVjYXRlZExheW91dEdyb3VwQ29udGV4dDtcbmV4cG9ydHMuRHJhZ0NvbnRyb2xzID0gRHJhZ0NvbnRyb2xzO1xuZXhwb3J0cy5GbGF0VHJlZSA9IEZsYXRUcmVlO1xuZXhwb3J0cy5MYXlvdXRHcm91cCA9IExheW91dEdyb3VwO1xuZXhwb3J0cy5MYXlvdXRHcm91cENvbnRleHQgPSBMYXlvdXRHcm91cENvbnRleHQ7XG5leHBvcnRzLkxhenlNb3Rpb24gPSBMYXp5TW90aW9uO1xuZXhwb3J0cy5Nb3Rpb25Db25maWcgPSBNb3Rpb25Db25maWc7XG5leHBvcnRzLk1vdGlvbkNvbmZpZ0NvbnRleHQgPSBNb3Rpb25Db25maWdDb250ZXh0O1xuZXhwb3J0cy5Nb3Rpb25Db250ZXh0ID0gTW90aW9uQ29udGV4dDtcbmV4cG9ydHMuTW90aW9uR2xvYmFsQ29uZmlnID0gTW90aW9uR2xvYmFsQ29uZmlnO1xuZXhwb3J0cy5Nb3Rpb25WYWx1ZSA9IE1vdGlvblZhbHVlO1xuZXhwb3J0cy5QcmVzZW5jZUNvbnRleHQgPSBQcmVzZW5jZUNvbnRleHQ7XG5leHBvcnRzLlJlb3JkZXIgPSBuYW1lc3BhY2U7XG5leHBvcnRzLlN3aXRjaExheW91dEdyb3VwQ29udGV4dCA9IFN3aXRjaExheW91dEdyb3VwQ29udGV4dDtcbmV4cG9ydHMuVmlzdWFsRWxlbWVudCA9IFZpc3VhbEVsZW1lbnQ7XG5leHBvcnRzLmFkZFBvaW50ZXJFdmVudCA9IGFkZFBvaW50ZXJFdmVudDtcbmV4cG9ydHMuYWRkUG9pbnRlckluZm8gPSBhZGRQb2ludGVySW5mbztcbmV4cG9ydHMuYWRkU2NhbGVDb3JyZWN0b3IgPSBhZGRTY2FsZUNvcnJlY3RvcjtcbmV4cG9ydHMuYW5pbWF0ZSA9IGFuaW1hdGU7XG5leHBvcnRzLmFuaW1hdGVNaW5pID0gYW5pbWF0ZU1pbmk7XG5leHBvcnRzLmFuaW1hdGVWYWx1ZSA9IGFuaW1hdGVWYWx1ZTtcbmV4cG9ydHMuYW5pbWF0ZVZpc3VhbEVsZW1lbnQgPSBhbmltYXRlVmlzdWFsRWxlbWVudDtcbmV4cG9ydHMuYW5pbWF0aW9uQ29udHJvbHMgPSBhbmltYXRpb25Db250cm9scztcbmV4cG9ydHMuYW5pbWF0aW9ucyA9IGFuaW1hdGlvbnM7XG5leHBvcnRzLmFudGljaXBhdGUgPSBhbnRpY2lwYXRlO1xuZXhwb3J0cy5iYWNrSW4gPSBiYWNrSW47XG5leHBvcnRzLmJhY2tJbk91dCA9IGJhY2tJbk91dDtcbmV4cG9ydHMuYmFja091dCA9IGJhY2tPdXQ7XG5leHBvcnRzLmJ1aWxkVHJhbnNmb3JtID0gYnVpbGRUcmFuc2Zvcm07XG5leHBvcnRzLmNhbGNMZW5ndGggPSBjYWxjTGVuZ3RoO1xuZXhwb3J0cy5jYW5jZWxGcmFtZSA9IGNhbmNlbEZyYW1lO1xuZXhwb3J0cy5jYW5jZWxTeW5jID0gY2FuY2VsU3luYztcbmV4cG9ydHMuY2lyY0luID0gY2lyY0luO1xuZXhwb3J0cy5jaXJjSW5PdXQgPSBjaXJjSW5PdXQ7XG5leHBvcnRzLmNpcmNPdXQgPSBjaXJjT3V0O1xuZXhwb3J0cy5jbGFtcCA9IGNsYW1wO1xuZXhwb3J0cy5jb2xvciA9IGNvbG9yO1xuZXhwb3J0cy5jb21wbGV4ID0gY29tcGxleDtcbmV4cG9ydHMuY3JlYXRlQm94ID0gY3JlYXRlQm94O1xuZXhwb3J0cy5jcmVhdGVSZW5kZXJlck1vdGlvbkNvbXBvbmVudCA9IGNyZWF0ZVJlbmRlcmVyTW90aW9uQ29tcG9uZW50O1xuZXhwb3J0cy5jcmVhdGVTY29wZWRBbmltYXRlID0gY3JlYXRlU2NvcGVkQW5pbWF0ZTtcbmV4cG9ydHMuY3ViaWNCZXppZXIgPSBjdWJpY0JlemllcjtcbmV4cG9ydHMuZGVsYXkgPSBkZWxheTtcbmV4cG9ydHMuZGlzYWJsZUluc3RhbnRUcmFuc2l0aW9ucyA9IGRpc2FibGVJbnN0YW50VHJhbnNpdGlvbnM7XG5leHBvcnRzLmRpc3RhbmNlID0gZGlzdGFuY2U7XG5leHBvcnRzLmRpc3RhbmNlMkQgPSBkaXN0YW5jZTJEO1xuZXhwb3J0cy5kb21BbmltYXRpb24gPSBkb21BbmltYXRpb247XG5leHBvcnRzLmRvbU1heCA9IGRvbU1heDtcbmV4cG9ydHMuZG9tTWluID0gZG9tTWluO1xuZXhwb3J0cy5lYXNlSW4gPSBlYXNlSW47XG5leHBvcnRzLmVhc2VJbk91dCA9IGVhc2VJbk91dDtcbmV4cG9ydHMuZWFzZU91dCA9IGVhc2VPdXQ7XG5leHBvcnRzLmZpbHRlclByb3BzID0gZmlsdGVyUHJvcHM7XG5leHBvcnRzLmZpbmRTcHJpbmcgPSBmaW5kU3ByaW5nO1xuZXhwb3J0cy5mcmFtZSA9IGZyYW1lO1xuZXhwb3J0cy5mcmFtZURhdGEgPSBmcmFtZURhdGE7XG5leHBvcnRzLmZyYW1lU3RlcHMgPSBmcmFtZVN0ZXBzO1xuZXhwb3J0cy5pblZpZXcgPSBpblZpZXc7XG5leHBvcnRzLmluZXJ0aWEgPSBpbmVydGlhO1xuZXhwb3J0cy5pbnRlcnBvbGF0ZSA9IGludGVycG9sYXRlO1xuZXhwb3J0cy5pc0Jyb3dzZXIgPSBpc0Jyb3dzZXI7XG5leHBvcnRzLmlzTW90aW9uQ29tcG9uZW50ID0gaXNNb3Rpb25Db21wb25lbnQ7XG5leHBvcnRzLmlzTW90aW9uVmFsdWUgPSBpc01vdGlvblZhbHVlO1xuZXhwb3J0cy5pc1ZhbGlkTW90aW9uUHJvcCA9IGlzVmFsaWRNb3Rpb25Qcm9wO1xuZXhwb3J0cy5rZXlmcmFtZXMgPSBrZXlmcmFtZXM7XG5leHBvcnRzLm0gPSBtO1xuZXhwb3J0cy5tYWtlVXNlVmlzdWFsU3RhdGUgPSBtYWtlVXNlVmlzdWFsU3RhdGU7XG5leHBvcnRzLm1pcnJvckVhc2luZyA9IG1pcnJvckVhc2luZztcbmV4cG9ydHMubWl4ID0gbWl4O1xuZXhwb3J0cy5tb3Rpb24gPSBtb3Rpb247XG5leHBvcnRzLm1vdGlvblZhbHVlID0gbW90aW9uVmFsdWU7XG5leHBvcnRzLm9wdGltaXplZEFwcGVhckRhdGFBdHRyaWJ1dGUgPSBvcHRpbWl6ZWRBcHBlYXJEYXRhQXR0cmlidXRlO1xuZXhwb3J0cy5waXBlID0gcGlwZTtcbmV4cG9ydHMucHggPSBweDtcbmV4cG9ydHMucmVzb2x2ZU1vdGlvblZhbHVlID0gcmVzb2x2ZU1vdGlvblZhbHVlO1xuZXhwb3J0cy5yZXZlcnNlRWFzaW5nID0gcmV2ZXJzZUVhc2luZztcbmV4cG9ydHMuc2Nyb2xsID0gc2Nyb2xsO1xuZXhwb3J0cy5zY3JvbGxJbmZvID0gc2Nyb2xsSW5mbztcbmV4cG9ydHMuc3ByaW5nID0gc3ByaW5nO1xuZXhwb3J0cy5zdGFnZ2VyID0gc3RhZ2dlcjtcbmV4cG9ydHMuc3RhcnRPcHRpbWl6ZWRBcHBlYXJBbmltYXRpb24gPSBzdGFydE9wdGltaXplZEFwcGVhckFuaW1hdGlvbjtcbmV4cG9ydHMuc3RlcHMgPSBzdGVwcztcbmV4cG9ydHMuc3luYyA9IHN5bmM7XG5leHBvcnRzLnRpbWUgPSB0aW1lO1xuZXhwb3J0cy50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG5leHBvcnRzLnVud3JhcE1vdGlvbkNvbXBvbmVudCA9IHVud3JhcE1vdGlvbkNvbXBvbmVudDtcbmV4cG9ydHMudXNlQW5pbWF0ZSA9IHVzZUFuaW1hdGU7XG5leHBvcnRzLnVzZUFuaW1hdGVNaW5pID0gdXNlQW5pbWF0ZU1pbmk7XG5leHBvcnRzLnVzZUFuaW1hdGlvbiA9IHVzZUFuaW1hdGlvbjtcbmV4cG9ydHMudXNlQW5pbWF0aW9uQ29udHJvbHMgPSB1c2VBbmltYXRpb25Db250cm9scztcbmV4cG9ydHMudXNlQW5pbWF0aW9uRnJhbWUgPSB1c2VBbmltYXRpb25GcmFtZTtcbmV4cG9ydHMudXNlQ3ljbGUgPSB1c2VDeWNsZTtcbmV4cG9ydHMudXNlRGVwcmVjYXRlZEFuaW1hdGVkU3RhdGUgPSB1c2VBbmltYXRlZFN0YXRlO1xuZXhwb3J0cy51c2VEZXByZWNhdGVkSW52ZXJ0ZWRTY2FsZSA9IHVzZUludmVydGVkU2NhbGU7XG5leHBvcnRzLnVzZURvbUV2ZW50ID0gdXNlRG9tRXZlbnQ7XG5leHBvcnRzLnVzZURyYWdDb250cm9scyA9IHVzZURyYWdDb250cm9scztcbmV4cG9ydHMudXNlRWxlbWVudFNjcm9sbCA9IHVzZUVsZW1lbnRTY3JvbGw7XG5leHBvcnRzLnVzZUZvcmNlVXBkYXRlID0gdXNlRm9yY2VVcGRhdGU7XG5leHBvcnRzLnVzZUluVmlldyA9IHVzZUluVmlldztcbmV4cG9ydHMudXNlSW5zdGFudExheW91dFRyYW5zaXRpb24gPSB1c2VJbnN0YW50TGF5b3V0VHJhbnNpdGlvbjtcbmV4cG9ydHMudXNlSW5zdGFudFRyYW5zaXRpb24gPSB1c2VJbnN0YW50VHJhbnNpdGlvbjtcbmV4cG9ydHMudXNlSXNQcmVzZW50ID0gdXNlSXNQcmVzZW50O1xuZXhwb3J0cy51c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdDtcbmV4cG9ydHMudXNlTW90aW9uVGVtcGxhdGUgPSB1c2VNb3Rpb25UZW1wbGF0ZTtcbmV4cG9ydHMudXNlTW90aW9uVmFsdWUgPSB1c2VNb3Rpb25WYWx1ZTtcbmV4cG9ydHMudXNlTW90aW9uVmFsdWVFdmVudCA9IHVzZU1vdGlvblZhbHVlRXZlbnQ7XG5leHBvcnRzLnVzZVByZXNlbmNlID0gdXNlUHJlc2VuY2U7XG5leHBvcnRzLnVzZVJlZHVjZWRNb3Rpb24gPSB1c2VSZWR1Y2VkTW90aW9uO1xuZXhwb3J0cy51c2VSZWR1Y2VkTW90aW9uQ29uZmlnID0gdXNlUmVkdWNlZE1vdGlvbkNvbmZpZztcbmV4cG9ydHMudXNlUmVzZXRQcm9qZWN0aW9uID0gdXNlUmVzZXRQcm9qZWN0aW9uO1xuZXhwb3J0cy51c2VTY3JvbGwgPSB1c2VTY3JvbGw7XG5leHBvcnRzLnVzZVNwcmluZyA9IHVzZVNwcmluZztcbmV4cG9ydHMudXNlVGltZSA9IHVzZVRpbWU7XG5leHBvcnRzLnVzZVRyYW5zZm9ybSA9IHVzZVRyYW5zZm9ybTtcbmV4cG9ydHMudXNlVW5tb3VudEVmZmVjdCA9IHVzZVVubW91bnRFZmZlY3Q7XG5leHBvcnRzLnVzZVZlbG9jaXR5ID0gdXNlVmVsb2NpdHk7XG5leHBvcnRzLnVzZVZpZXdwb3J0U2Nyb2xsID0gdXNlVmlld3BvcnRTY3JvbGw7XG5leHBvcnRzLnVzZVdpbGxDaGFuZ2UgPSB1c2VXaWxsQ2hhbmdlO1xuZXhwb3J0cy52aXN1YWxFbGVtZW50U3RvcmUgPSB2aXN1YWxFbGVtZW50U3RvcmU7XG5leHBvcnRzLndyYXAgPSB3cmFwO1xuIl0sIm1hcHBpbmdzIjoiQUFBQSxZQUFZOztBQUVaQSxNQUFNLENBQUNDLGNBQWMsQ0FBQ0MsT0FBTyxFQUFFLFlBQVksRUFBRTtFQUFFQyxLQUFLLEVBQUU7QUFBSyxDQUFDLENBQUM7QUFFN0QsSUFBSUMsVUFBVSxHQUFHQyxPQUFPLENBQUMsbUJBQW1CLENBQUM7QUFDN0MsSUFBSUMsS0FBSyxHQUFHRCxPQUFPLENBQUMsT0FBTyxDQUFDO0FBQzVCLElBQUlFLFdBQVcsR0FBR0YsT0FBTyxDQUFDLGNBQWMsQ0FBQztBQUN6QyxJQUFJRyxTQUFTLEdBQUdILE9BQU8sQ0FBQyxZQUFZLENBQUM7QUFFckMsU0FBU0ksd0JBQXdCQSxDQUFDQyxDQUFDLEVBQUU7RUFDakMsSUFBSUMsQ0FBQyxHQUFHWCxNQUFNLENBQUNZLE1BQU0sQ0FBQyxJQUFJLENBQUM7RUFDM0IsSUFBSUYsQ0FBQyxFQUFFO0lBQ0hWLE1BQU0sQ0FBQ2EsSUFBSSxDQUFDSCxDQUFDLENBQUMsQ0FBQ0ksT0FBTyxDQUFDLFVBQVVDLENBQUMsRUFBRTtNQUNoQyxJQUFJQSxDQUFDLEtBQUssU0FBUyxFQUFFO1FBQ2pCLElBQUlDLENBQUMsR0FBR2hCLE1BQU0sQ0FBQ2lCLHdCQUF3QixDQUFDUCxDQUFDLEVBQUVLLENBQUMsQ0FBQztRQUM3Q2YsTUFBTSxDQUFDQyxjQUFjLENBQUNVLENBQUMsRUFBRUksQ0FBQyxFQUFFQyxDQUFDLENBQUNFLEdBQUcsR0FBR0YsQ0FBQyxHQUFHO1VBQ3BDRyxVQUFVLEVBQUUsSUFBSTtVQUNo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